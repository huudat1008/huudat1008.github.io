var Pr = Object.defineProperty;
var Or = (C,S,E)=>S in C ? Pr(C, S, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: E
}) : C[S] = E;
var jt = (C,S,E)=>(Or(C, typeof S != "symbol" ? S + "" : S, E),
E);
import {r as reactExports, g as getDefaults, a as getI18n, R as React, B as Buffer, c as commonjsGlobal, b as getAugmentedNamespace, d as dist$5, e as getDefaultExportFromCjs$1, f as React$1, h as re$3, i as global, j as re$4, k as ee, l as jsxRuntimeExports, o as observer, m as ReactDOM, n as reactDomExports, p as action$1, q as makeAutoObservable, s as enableStaticRendering, t as ReactDOM$1, A as A$1, T as TitleImage, Q, P as Preloader} from "./index-vrWuPYGZ.js";
function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(C) {
        for (var S = 1; S < arguments.length; S++) {
            var E = arguments[S];
            for (var M in E)
                Object.prototype.hasOwnProperty.call(E, M) && (C[M] = E[M])
        }
        return C
    }
    ,
    _extends$3.apply(this, arguments)
}
const _extends$4 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: _extends$3
}, Symbol.toStringTag, {
    value: "Module"
}));
function warn() {
    if (console && console.warn) {
        for (var C = arguments.length, S = new Array(C), E = 0; E < C; E++)
            S[E] = arguments[E];
        typeof S[0] == "string" && (S[0] = `react-i18next:: ${S[0]}`),
        console.warn(...S)
    }
}
const alreadyWarned$1 = {};
function warnOnce() {
    for (var C = arguments.length, S = new Array(C), E = 0; E < C; E++)
        S[E] = arguments[E];
    typeof S[0] == "string" && alreadyWarned$1[S[0]] || (typeof S[0] == "string" && (alreadyWarned$1[S[0]] = new Date),
    warn(...S))
}
const loadedClb = (C,S)=>()=>{
    if (C.isInitialized)
        S();
    else {
        const E = ()=>{
            setTimeout(()=>{
                C.off("initialized", E)
            }
            , 0),
            S()
        }
        ;
        C.on("initialized", E)
    }
}
;
function loadNamespaces(C, S, E) {
    C.loadNamespaces(S, loadedClb(C, E))
}
function loadLanguages(C, S, E, M) {
    typeof E == "string" && (E = [E]),
    E.forEach(T=>{
        C.options.ns.indexOf(T) < 0 && C.options.ns.push(T)
    }
    ),
    C.loadLanguages(S, loadedClb(C, M))
}
function oldI18nextHasLoadedNamespace(C, S) {
    let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const M = S.languages[0]
      , T = S.options ? S.options.fallbackLng : !1
      , $ = S.languages[S.languages.length - 1];
    if (M.toLowerCase() === "cimode")
        return !0;
    const B = (O,F)=>{
        const N = S.services.backendConnector.state[`${O}|${F}`];
        return N === -1 || N === 2
    }
    ;
    return E.bindI18n && E.bindI18n.indexOf("languageChanging") > -1 && S.services.backendConnector.backend && S.isLanguageChangingTo && !B(S.isLanguageChangingTo, C) ? !1 : !!(S.hasResourceBundle(M, C) || !S.services.backendConnector.backend || S.options.resources && !S.options.partialBundledLanguages || B(M, C) && (!T || B($, C)))
}
function hasLoadedNamespace(C, S) {
    let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return !S.languages || !S.languages.length ? (warnOnce("i18n.languages were undefined or empty", S.languages),
    !0) : S.options.ignoreJSONStructure !== void 0 ? S.hasLoadedNamespace(C, {
        lng: E.lng,
        precheck: (T,$)=>{
            if (E.bindI18n && E.bindI18n.indexOf("languageChanging") > -1 && T.services.backendConnector.backend && T.isLanguageChangingTo && !$(T.isLanguageChangingTo, C))
                return !1
        }
    }) : oldI18nextHasLoadedNamespace(C, S, E)
}
const I18nContext$1 = reactExports.createContext();
class ReportNamespaces {
    constructor() {
        this.usedNamespaces = {}
    }
    addUsedNamespaces(S) {
        S.forEach(E=>{
            this.usedNamespaces[E] || (this.usedNamespaces[E] = !0)
        }
        )
    }
    getUsedNamespaces() {
        return Object.keys(this.usedNamespaces)
    }
}
const usePrevious = (C,S)=>{
    const E = reactExports.useRef();
    return reactExports.useEffect(()=>{
        E.current = S ? E.current : C
    }
    , [C, S]),
    E.current
}
;
function useTranslation(C) {
    let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {i18n: E} = S
      , {i18n: M, defaultNS: T} = reactExports.useContext(I18nContext$1) || {}
      , $ = E || M || getI18n();
    if ($ && !$.reportNamespaces && ($.reportNamespaces = new ReportNamespaces),
    !$) {
        warnOnce("You will need to pass in an i18next instance by using initReactI18next");
        const de = (pe,ge)=>typeof ge == "string" ? ge : ge && typeof ge == "object" && typeof ge.defaultValue == "string" ? ge.defaultValue : Array.isArray(pe) ? pe[pe.length - 1] : pe
          , fe = [de, {}, !1];
        return fe.t = de,
        fe.i18n = {},
        fe.ready = !1,
        fe
    }
    $.options.react && $.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const B = {
        ...getDefaults(),
        ...$.options.react,
        ...S
    }
      , {useSuspense: O, keyPrefix: F} = B;
    let N = C || T || $.options && $.options.defaultNS;
    N = typeof N == "string" ? [N] : N || ["translation"],
    $.reportNamespaces.addUsedNamespaces && $.reportNamespaces.addUsedNamespaces(N);
    const U = ($.isInitialized || $.initializedStoreOnce) && N.every(de=>hasLoadedNamespace(de, $, B));
    function H() {
        return $.getFixedT(S.lng || null, B.nsMode === "fallback" ? N : N[0], F)
    }
    const [Z,J] = reactExports.useState(H);
    let ie = N.join();
    S.lng && (ie = `${S.lng}${ie}`);
    const oe = usePrevious(ie)
      , ae = reactExports.useRef(!0);
    reactExports.useEffect(()=>{
        const {bindI18n: de, bindI18nStore: fe} = B;
        ae.current = !0,
        !U && !O && (S.lng ? loadLanguages($, S.lng, N, ()=>{
            ae.current && J(H)
        }
        ) : loadNamespaces($, N, ()=>{
            ae.current && J(H)
        }
        )),
        U && oe && oe !== ie && ae.current && J(H);
        function pe() {
            ae.current && J(H)
        }
        return de && $ && $.on(de, pe),
        fe && $ && $.store.on(fe, pe),
        ()=>{
            ae.current = !1,
            de && $ && de.split(" ").forEach(ge=>$.off(ge, pe)),
            fe && $ && fe.split(" ").forEach(ge=>$.store.off(ge, pe))
        }
    }
    , [$, ie]);
    const se = reactExports.useRef(!0);
    reactExports.useEffect(()=>{
        ae.current && !se.current && J(H),
        se.current = !1
    }
    , [$, F]);
    const le = [Z, $, U];
    if (le.t = Z,
    le.i18n = $,
    le.ready = U,
    U || !U && !O)
        return le;
    throw new Promise(de=>{
        S.lng ? loadLanguages($, S.lng, N, ()=>de()) : loadNamespaces($, N, ()=>de())
    }
    )
}
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(C) {
        for (var S = 1; S < arguments.length; S++) {
            var E = arguments[S];
            for (var M in E)
                Object.prototype.hasOwnProperty.call(E, M) && (C[M] = E[M])
        }
        return C
    }
    ,
    _extends$2.apply(this, arguments)
}
var Action$1;
(function(C) {
    C.Pop = "POP",
    C.Push = "PUSH",
    C.Replace = "REPLACE"
}
)(Action$1 || (Action$1 = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(C) {
    C === void 0 && (C = {});
    function S(M, T) {
        let {pathname: $, search: B, hash: O} = M.location;
        return createLocation("", {
            pathname: $,
            search: B,
            hash: O
        }, T.state && T.state.usr || null, T.state && T.state.key || "default")
    }
    function E(M, T) {
        return typeof T == "string" ? T : createPath(T)
    }
    return getUrlBasedHistory(S, E, null, C)
}
function invariant(C, S) {
    if (C === !1 || C === null || typeof C > "u")
        throw new Error(S)
}
function warning$2(C, S) {
    if (!C) {
        typeof console < "u" && console.warn(S);
        try {
            throw new Error(S)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(C, S) {
    return {
        usr: C.state,
        key: C.key,
        idx: S
    }
}
function createLocation(C, S, E, M) {
    return E === void 0 && (E = null),
    _extends$2({
        pathname: typeof C == "string" ? C : C.pathname,
        search: "",
        hash: ""
    }, typeof S == "string" ? parsePath(S) : S, {
        state: E,
        key: S && S.key || M || createKey()
    })
}
function createPath(C) {
    let {pathname: S="/", search: E="", hash: M=""} = C;
    return E && E !== "?" && (S += E.charAt(0) === "?" ? E : "?" + E),
    M && M !== "#" && (S += M.charAt(0) === "#" ? M : "#" + M),
    S
}
function parsePath(C) {
    let S = {};
    if (C) {
        let E = C.indexOf("#");
        E >= 0 && (S.hash = C.substr(E),
        C = C.substr(0, E));
        let M = C.indexOf("?");
        M >= 0 && (S.search = C.substr(M),
        C = C.substr(0, M)),
        C && (S.pathname = C)
    }
    return S
}
function getUrlBasedHistory(C, S, E, M) {
    M === void 0 && (M = {});
    let {window: T=document.defaultView, v5Compat: $=!1} = M
      , B = T.history
      , O = Action$1.Pop
      , F = null
      , N = U();
    N == null && (N = 0,
    B.replaceState(_extends$2({}, B.state, {
        idx: N
    }), ""));
    function U() {
        return (B.state || {
            idx: null
        }).idx
    }
    function H() {
        O = Action$1.Pop;
        let ae = U()
          , se = ae == null ? null : ae - N;
        N = ae,
        F && F({
            action: O,
            location: oe.location,
            delta: se
        })
    }
    function Z(ae, se) {
        O = Action$1.Push;
        let le = createLocation(oe.location, ae, se);
        E && E(le, ae),
        N = U() + 1;
        let de = getHistoryState(le, N)
          , fe = oe.createHref(le);
        try {
            B.pushState(de, "", fe)
        } catch (pe) {
            if (pe instanceof DOMException && pe.name === "DataCloneError")
                throw pe;
            T.location.assign(fe)
        }
        $ && F && F({
            action: O,
            location: oe.location,
            delta: 1
        })
    }
    function J(ae, se) {
        O = Action$1.Replace;
        let le = createLocation(oe.location, ae, se);
        E && E(le, ae),
        N = U();
        let de = getHistoryState(le, N)
          , fe = oe.createHref(le);
        B.replaceState(de, "", fe),
        $ && F && F({
            action: O,
            location: oe.location,
            delta: 0
        })
    }
    function ie(ae) {
        let se = T.location.origin !== "null" ? T.location.origin : T.location.href
          , le = typeof ae == "string" ? ae : createPath(ae);
        return le = le.replace(/ $/, "%20"),
        invariant(se, "No window.location.(origin|href) available to create URL for href: " + le),
        new URL(le,se)
    }
    let oe = {
        get action() {
            return O
        },
        get location() {
            return C(T, B)
        },
        listen(ae) {
            if (F)
                throw new Error("A history only accepts one active listener");
            return T.addEventListener(PopStateEventType, H),
            F = ae,
            ()=>{
                T.removeEventListener(PopStateEventType, H),
                F = null
            }
        },
        createHref(ae) {
            return S(T, ae)
        },
        createURL: ie,
        encodeLocation(ae) {
            let se = ie(ae);
            return {
                pathname: se.pathname,
                search: se.search,
                hash: se.hash
            }
        },
        push: Z,
        replace: J,
        go(ae) {
            return B.go(ae)
        }
    };
    return oe
}
var ResultType;
(function(C) {
    C.data = "data",
    C.deferred = "deferred",
    C.redirect = "redirect",
    C.error = "error"
}
)(ResultType || (ResultType = {}));
function matchRoutes(C, S, E) {
    E === void 0 && (E = "/");
    let M = typeof S == "string" ? parsePath(S) : S
      , T = stripBasename(M.pathname || "/", E);
    if (T == null)
        return null;
    let $ = flattenRoutes(C);
    rankRouteBranches($);
    let B = null;
    for (let O = 0; B == null && O < $.length; ++O) {
        let F = decodePath(T);
        B = matchRouteBranch($[O], F)
    }
    return B
}
function flattenRoutes(C, S, E, M) {
    S === void 0 && (S = []),
    E === void 0 && (E = []),
    M === void 0 && (M = "");
    let T = ($,B,O)=>{
        let F = {
            relativePath: O === void 0 ? $.path || "" : O,
            caseSensitive: $.caseSensitive === !0,
            childrenIndex: B,
            route: $
        };
        F.relativePath.startsWith("/") && (invariant(F.relativePath.startsWith(M), 'Absolute route path "' + F.relativePath + '" nested under path ' + ('"' + M + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        F.relativePath = F.relativePath.slice(M.length));
        let N = joinPaths([M, F.relativePath])
          , U = E.concat(F);
        $.children && $.children.length > 0 && (invariant($.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + N + '".')),
        flattenRoutes($.children, S, U, N)),
        !($.path == null && !$.index) && S.push({
            path: N,
            score: computeScore(N, $.index),
            routesMeta: U
        })
    }
    ;
    return C.forEach(($,B)=>{
        var O;
        if ($.path === "" || !((O = $.path) != null && O.includes("?")))
            T($, B);
        else
            for (let F of explodeOptionalSegments($.path))
                T($, B, F)
    }
    ),
    S
}
function explodeOptionalSegments(C) {
    let S = C.split("/");
    if (S.length === 0)
        return [];
    let[E,...M] = S
      , T = E.endsWith("?")
      , $ = E.replace(/\?$/, "");
    if (M.length === 0)
        return T ? [$, ""] : [$];
    let B = explodeOptionalSegments(M.join("/"))
      , O = [];
    return O.push(...B.map(F=>F === "" ? $ : [$, F].join("/"))),
    T && O.push(...B),
    O.map(F=>C.startsWith("/") && F === "" ? "/" : F)
}
function rankRouteBranches(C) {
    C.sort((S,E)=>S.score !== E.score ? E.score - S.score : compareIndexes(S.routesMeta.map(M=>M.childrenIndex), E.routesMeta.map(M=>M.childrenIndex)))
}
const paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = C=>C === "*";
function computeScore(C, S) {
    let E = C.split("/")
      , M = E.length;
    return E.some(isSplat) && (M += splatPenalty),
    S && (M += indexRouteValue),
    E.filter(T=>!isSplat(T)).reduce((T,$)=>T + (paramRe.test($) ? dynamicSegmentValue : $ === "" ? emptySegmentValue : staticSegmentValue), M)
}
function compareIndexes(C, S) {
    return C.length === S.length && C.slice(0, -1).every((M,T)=>M === S[T]) ? C[C.length - 1] - S[S.length - 1] : 0
}
function matchRouteBranch(C, S) {
    let {routesMeta: E} = C
      , M = {}
      , T = "/"
      , $ = [];
    for (let B = 0; B < E.length; ++B) {
        let O = E[B]
          , F = B === E.length - 1
          , N = T === "/" ? S : S.slice(T.length) || "/"
          , U = matchPath({
            path: O.relativePath,
            caseSensitive: O.caseSensitive,
            end: F
        }, N);
        if (!U)
            return null;
        Object.assign(M, U.params);
        let H = O.route;
        $.push({
            params: M,
            pathname: joinPaths([T, U.pathname]),
            pathnameBase: normalizePathname(joinPaths([T, U.pathnameBase])),
            route: H
        }),
        U.pathnameBase !== "/" && (T = joinPaths([T, U.pathnameBase]))
    }
    return $
}
function matchPath(C, S) {
    typeof C == "string" && (C = {
        path: C,
        caseSensitive: !1,
        end: !0
    });
    let[E,M] = compilePath(C.path, C.caseSensitive, C.end)
      , T = S.match(E);
    if (!T)
        return null;
    let $ = T[0]
      , B = $.replace(/(.)\/+$/, "$1")
      , O = T.slice(1);
    return {
        params: M.reduce((N,U,H)=>{
            let {paramName: Z, isOptional: J} = U;
            if (Z === "*") {
                let oe = O[H] || "";
                B = $.slice(0, $.length - oe.length).replace(/(.)\/+$/, "$1")
            }
            const ie = O[H];
            return J && !ie ? N[Z] = void 0 : N[Z] = (ie || "").replace(/%2F/g, "/"),
            N
        }
        , {}),
        pathname: $,
        pathnameBase: B,
        pattern: C
    }
}
function compilePath(C, S, E) {
    S === void 0 && (S = !1),
    E === void 0 && (E = !0),
    warning$2(C === "*" || !C.endsWith("*") || C.endsWith("/*"), 'Route path "' + C + '" will be treated as if it were ' + ('"' + C.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + C.replace(/\*$/, "/*") + '".'));
    let M = []
      , T = "^" + C.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (B,O,F)=>(M.push({
        paramName: O,
        isOptional: F != null
    }),
    F ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return C.endsWith("*") ? (M.push({
        paramName: "*"
    }),
    T += C === "*" || C === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : E ? T += "\\/*$" : C !== "" && C !== "/" && (T += "(?:(?=\\/|$))"),
    [new RegExp(T,S ? void 0 : "i"), M]
}
function decodePath(C) {
    try {
        return C.split("/").map(S=>decodeURIComponent(S).replace(/\//g, "%2F")).join("/")
    } catch (S) {
        return warning$2(!1, 'The URL path "' + C + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + S + ").")),
        C
    }
}
function stripBasename(C, S) {
    if (S === "/")
        return C;
    if (!C.toLowerCase().startsWith(S.toLowerCase()))
        return null;
    let E = S.endsWith("/") ? S.length - 1 : S.length
      , M = C.charAt(E);
    return M && M !== "/" ? null : C.slice(E) || "/"
}
function resolvePath(C, S) {
    S === void 0 && (S = "/");
    let {pathname: E, search: M="", hash: T=""} = typeof C == "string" ? parsePath(C) : C;
    return {
        pathname: E ? E.startsWith("/") ? E : resolvePathname(E, S) : S,
        search: normalizeSearch(M),
        hash: normalizeHash(T)
    }
}
function resolvePathname(C, S) {
    let E = S.replace(/\/+$/, "").split("/");
    return C.split("/").forEach(T=>{
        T === ".." ? E.length > 1 && E.pop() : T !== "." && E.push(T)
    }
    ),
    E.length > 1 ? E.join("/") : "/"
}
function getInvalidPathError(C, S, E, M) {
    return "Cannot include a '" + C + "' character in a manually specified " + ("`to." + S + "` field [" + JSON.stringify(M) + "].  Please separate it out to the ") + ("`to." + E + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function getPathContributingMatches(C) {
    return C.filter((S,E)=>E === 0 || S.route.path && S.route.path.length > 0)
}
function getResolveToMatches(C, S) {
    let E = getPathContributingMatches(C);
    return S ? E.map((M,T)=>T === C.length - 1 ? M.pathname : M.pathnameBase) : E.map(M=>M.pathnameBase)
}
function resolveTo(C, S, E, M) {
    M === void 0 && (M = !1);
    let T;
    typeof C == "string" ? T = parsePath(C) : (T = _extends$2({}, C),
    invariant(!T.pathname || !T.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", T)),
    invariant(!T.pathname || !T.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", T)),
    invariant(!T.search || !T.search.includes("#"), getInvalidPathError("#", "search", "hash", T)));
    let $ = C === "" || T.pathname === "", B = $ ? "/" : T.pathname, O;
    if (B == null)
        O = E;
    else {
        let H = S.length - 1;
        if (!M && B.startsWith("..")) {
            let Z = B.split("/");
            for (; Z[0] === ".."; )
                Z.shift(),
                H -= 1;
            T.pathname = Z.join("/")
        }
        O = H >= 0 ? S[H] : "/"
    }
    let F = resolvePath(T, O)
      , N = B && B !== "/" && B.endsWith("/")
      , U = ($ || B === ".") && E.endsWith("/");
    return !F.pathname.endsWith("/") && (N || U) && (F.pathname += "/"),
    F
}
const joinPaths = C=>C.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = C=>C.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = C=>!C || C === "?" ? "" : C.startsWith("?") ? C : "?" + C
  , normalizeHash = C=>!C || C === "#" ? "" : C.startsWith("#") ? C : "#" + C;
function isRouteErrorResponse(C) {
    return C != null && typeof C.status == "number" && typeof C.statusText == "string" && typeof C.internal == "boolean" && "data"in C
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(C) {
        for (var S = 1; S < arguments.length; S++) {
            var E = arguments[S];
            for (var M in E)
                Object.prototype.hasOwnProperty.call(E, M) && (C[M] = E[M])
        }
        return C
    }
    ,
    _extends$1.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null)
  , DataRouterStateContext = reactExports.createContext(null)
  , NavigationContext = reactExports.createContext(null)
  , LocationContext = reactExports.createContext(null)
  , RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , RouteErrorContext = reactExports.createContext(null);
function useHref(C, S) {
    let {relative: E} = S === void 0 ? {} : S;
    useInRouterContext() || invariant(!1);
    let {basename: M, navigator: T} = reactExports.useContext(NavigationContext)
      , {hash: $, pathname: B, search: O} = useResolvedPath(C, {
        relative: E
    })
      , F = B;
    return M !== "/" && (F = B === "/" ? M : joinPaths([M, B])),
    T.createHref({
        pathname: F,
        search: O,
        hash: $
    })
}
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return useInRouterContext() || invariant(!1),
    reactExports.useContext(LocationContext).location
}
function useIsomorphicLayoutEffect$1(C) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(C)
}
function useNavigate() {
    let {isDataRoute: C} = reactExports.useContext(RouteContext);
    return C ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    useInRouterContext() || invariant(!1);
    let C = reactExports.useContext(DataRouterContext)
      , {basename: S, future: E, navigator: M} = reactExports.useContext(NavigationContext)
      , {matches: T} = reactExports.useContext(RouteContext)
      , {pathname: $} = useLocation()
      , B = JSON.stringify(getResolveToMatches(T, E.v7_relativeSplatPath))
      , O = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$1(()=>{
        O.current = !0
    }
    ),
    reactExports.useCallback(function(N, U) {
        if (U === void 0 && (U = {}),
        !O.current)
            return;
        if (typeof N == "number") {
            M.go(N);
            return
        }
        let H = resolveTo(N, JSON.parse(B), $, U.relative === "path");
        C == null && S !== "/" && (H.pathname = H.pathname === "/" ? S : joinPaths([S, H.pathname])),
        (U.replace ? M.replace : M.push)(H, U.state, U)
    }, [S, M, B, $, C])
}
function useResolvedPath(C, S) {
    let {relative: E} = S === void 0 ? {} : S
      , {future: M} = reactExports.useContext(NavigationContext)
      , {matches: T} = reactExports.useContext(RouteContext)
      , {pathname: $} = useLocation()
      , B = JSON.stringify(getResolveToMatches(T, M.v7_relativeSplatPath));
    return reactExports.useMemo(()=>resolveTo(C, JSON.parse(B), $, E === "path"), [C, B, $, E])
}
function useRoutes(C, S) {
    return useRoutesImpl(C, S)
}
function useRoutesImpl(C, S, E, M) {
    useInRouterContext() || invariant(!1);
    let {navigator: T} = reactExports.useContext(NavigationContext)
      , {matches: $} = reactExports.useContext(RouteContext)
      , B = $[$.length - 1]
      , O = B ? B.params : {};
    B && B.pathname;
    let F = B ? B.pathnameBase : "/";
    B && B.route;
    let N = useLocation(), U;
    if (S) {
        var H;
        let ae = typeof S == "string" ? parsePath(S) : S;
        F === "/" || (H = ae.pathname) != null && H.startsWith(F) || invariant(!1),
        U = ae
    } else
        U = N;
    let Z = U.pathname || "/"
      , J = Z;
    if (F !== "/") {
        let ae = F.replace(/^\//, "").split("/");
        J = "/" + Z.replace(/^\//, "").split("/").slice(ae.length).join("/")
    }
    let ie = matchRoutes(C, {
        pathname: J
    })
      , oe = _renderMatches(ie && ie.map(ae=>Object.assign({}, ae, {
        params: Object.assign({}, O, ae.params),
        pathname: joinPaths([F, T.encodeLocation ? T.encodeLocation(ae.pathname).pathname : ae.pathname]),
        pathnameBase: ae.pathnameBase === "/" ? F : joinPaths([F, T.encodeLocation ? T.encodeLocation(ae.pathnameBase).pathname : ae.pathnameBase])
    })), $, E, M);
    return S && oe ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: _extends$1({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, U),
            navigationType: Action$1.Pop
        }
    }, oe) : oe
}
function DefaultErrorComponent() {
    let C = useRouteError()
      , S = isRouteErrorResponse(C) ? C.status + " " + C.statusText : C instanceof Error ? C.message : JSON.stringify(C)
      , E = C instanceof Error ? C.stack : null
      , T = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, S), E ? reactExports.createElement("pre", {
        style: T
    }, E) : null, null)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor(S) {
        super(S),
        this.state = {
            location: S.location,
            revalidation: S.revalidation,
            error: S.error
        }
    }
    static getDerivedStateFromError(S) {
        return {
            error: S
        }
    }
    static getDerivedStateFromProps(S, E) {
        return E.location !== S.location || E.revalidation !== "idle" && S.revalidation === "idle" ? {
            error: S.error,
            location: S.location,
            revalidation: S.revalidation
        } : {
            error: S.error !== void 0 ? S.error : E.error,
            location: E.location,
            revalidation: S.revalidation || E.revalidation
        }
    }
    componentDidCatch(S, E) {
        console.error("React Router caught the following error during render", S, E)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function RenderedRoute(C) {
    let {routeContext: S, match: E, children: M} = C
      , T = reactExports.useContext(DataRouterContext);
    return T && T.static && T.staticContext && (E.route.errorElement || E.route.ErrorBoundary) && (T.staticContext._deepestRenderedBoundaryId = E.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: S
    }, M)
}
function _renderMatches(C, S, E, M) {
    var T;
    if (S === void 0 && (S = []),
    E === void 0 && (E = null),
    M === void 0 && (M = null),
    C == null) {
        var $;
        if (($ = E) != null && $.errors)
            C = E.matches;
        else
            return null
    }
    let B = C
      , O = (T = E) == null ? void 0 : T.errors;
    if (O != null) {
        let U = B.findIndex(H=>H.route.id && (O == null ? void 0 : O[H.route.id]));
        U >= 0 || invariant(!1),
        B = B.slice(0, Math.min(B.length, U + 1))
    }
    let F = !1
      , N = -1;
    if (E && M && M.v7_partialHydration)
        for (let U = 0; U < B.length; U++) {
            let H = B[U];
            if ((H.route.HydrateFallback || H.route.hydrateFallbackElement) && (N = U),
            H.route.id) {
                let {loaderData: Z, errors: J} = E
                  , ie = H.route.loader && Z[H.route.id] === void 0 && (!J || J[H.route.id] === void 0);
                if (H.route.lazy || ie) {
                    F = !0,
                    N >= 0 ? B = B.slice(0, N + 1) : B = [B[0]];
                    break
                }
            }
        }
    return B.reduceRight((U,H,Z)=>{
        let J, ie = !1, oe = null, ae = null;
        E && (J = O && H.route.id ? O[H.route.id] : void 0,
        oe = H.route.errorElement || defaultErrorElement,
        F && (N < 0 && Z === 0 ? (warningOnce$1("route-fallback", !1),
        ie = !0,
        ae = null) : N === Z && (ie = !0,
        ae = H.route.hydrateFallbackElement || null)));
        let se = S.concat(B.slice(0, Z + 1))
          , le = ()=>{
            let de;
            return J ? de = oe : ie ? de = ae : H.route.Component ? de = reactExports.createElement(H.route.Component, null) : H.route.element ? de = H.route.element : de = U,
            reactExports.createElement(RenderedRoute, {
                match: H,
                routeContext: {
                    outlet: U,
                    matches: se,
                    isDataRoute: E != null
                },
                children: de
            })
        }
        ;
        return E && (H.route.ErrorBoundary || H.route.errorElement || Z === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: E.location,
            revalidation: E.revalidation,
            component: oe,
            error: J,
            children: le(),
            routeContext: {
                outlet: null,
                matches: se,
                isDataRoute: !0
            }
        }) : le()
    }
    , null)
}
var DataRouterHook$1 = function(C) {
    return C.UseBlocker = "useBlocker",
    C.UseRevalidator = "useRevalidator",
    C.UseNavigateStable = "useNavigate",
    C
}(DataRouterHook$1 || {})
  , DataRouterStateHook$1 = function(C) {
    return C.UseBlocker = "useBlocker",
    C.UseLoaderData = "useLoaderData",
    C.UseActionData = "useActionData",
    C.UseRouteError = "useRouteError",
    C.UseNavigation = "useNavigation",
    C.UseRouteLoaderData = "useRouteLoaderData",
    C.UseMatches = "useMatches",
    C.UseRevalidator = "useRevalidator",
    C.UseNavigateStable = "useNavigate",
    C.UseRouteId = "useRouteId",
    C
}(DataRouterStateHook$1 || {});
function useDataRouterContext(C) {
    let S = reactExports.useContext(DataRouterContext);
    return S || invariant(!1),
    S
}
function useDataRouterState(C) {
    let S = reactExports.useContext(DataRouterStateContext);
    return S || invariant(!1),
    S
}
function useRouteContext(C) {
    let S = reactExports.useContext(RouteContext);
    return S || invariant(!1),
    S
}
function useCurrentRouteId(C) {
    let S = useRouteContext()
      , E = S.matches[S.matches.length - 1];
    return E.route.id || invariant(!1),
    E.route.id
}
function useRouteError() {
    var C;
    let S = reactExports.useContext(RouteErrorContext)
      , E = useDataRouterState(DataRouterStateHook$1.UseRouteError)
      , M = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    return S !== void 0 ? S : (C = E.errors) == null ? void 0 : C[M]
}
function useNavigateStable() {
    let {router: C} = useDataRouterContext(DataRouterHook$1.UseNavigateStable)
      , S = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
      , E = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$1(()=>{
        E.current = !0
    }
    ),
    reactExports.useCallback(function(T, $) {
        $ === void 0 && ($ = {}),
        E.current && (typeof T == "number" ? C.navigate(T) : C.navigate(T, _extends$1({
            fromRouteId: S
        }, $)))
    }, [C, S])
}
const alreadyWarned = {};
function warningOnce$1(C, S, E) {
    !S && !alreadyWarned[C] && (alreadyWarned[C] = !0)
}
function Route(C) {
    invariant(!1)
}
function Router(C) {
    let {basename: S="/", children: E=null, location: M, navigationType: T=Action$1.Pop, navigator: $, static: B=!1, future: O} = C;
    useInRouterContext() && invariant(!1);
    let F = S.replace(/^\/*/, "/")
      , N = reactExports.useMemo(()=>({
        basename: F,
        navigator: $,
        static: B,
        future: _extends$1({
            v7_relativeSplatPath: !1
        }, O)
    }), [F, O, $, B]);
    typeof M == "string" && (M = parsePath(M));
    let {pathname: U="/", search: H="", hash: Z="", state: J=null, key: ie="default"} = M
      , oe = reactExports.useMemo(()=>{
        let ae = stripBasename(U, F);
        return ae == null ? null : {
            location: {
                pathname: ae,
                search: H,
                hash: Z,
                state: J,
                key: ie
            },
            navigationType: T
        }
    }
    , [F, U, H, Z, J, ie, T]);
    return oe == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: N
    }, reactExports.createElement(LocationContext.Provider, {
        children: E,
        value: oe
    }))
}
function Routes(C) {
    let {children: S, location: E} = C;
    return useRoutes(createRoutesFromChildren(S), E)
}
new Promise(()=>{}
);
function createRoutesFromChildren(C, S) {
    S === void 0 && (S = []);
    let E = [];
    return reactExports.Children.forEach(C, (M,T)=>{
        if (!reactExports.isValidElement(M))
            return;
        let $ = [...S, T];
        if (M.type === reactExports.Fragment) {
            E.push.apply(E, createRoutesFromChildren(M.props.children, $));
            return
        }
        M.type !== Route && invariant(!1),
        !M.props.index || !M.props.children || invariant(!1);
        let B = {
            id: M.props.id || $.join("-"),
            caseSensitive: M.props.caseSensitive,
            element: M.props.element,
            Component: M.props.Component,
            index: M.props.index,
            path: M.props.path,
            loader: M.props.loader,
            action: M.props.action,
            errorElement: M.props.errorElement,
            ErrorBoundary: M.props.ErrorBoundary,
            hasErrorBoundary: M.props.ErrorBoundary != null || M.props.errorElement != null,
            shouldRevalidate: M.props.shouldRevalidate,
            handle: M.props.handle,
            lazy: M.props.lazy
        };
        M.props.children && (B.children = createRoutesFromChildren(M.props.children, $)),
        E.push(B)
    }
    ),
    E
}
/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(C) {
        for (var S = 1; S < arguments.length; S++) {
            var E = arguments[S];
            for (var M in E)
                Object.prototype.hasOwnProperty.call(E, M) && (C[M] = E[M])
        }
        return C
    }
    ,
    _extends.apply(this, arguments)
}
function _objectWithoutPropertiesLoose$1(C, S) {
    if (C == null)
        return {};
    var E = {}, M = Object.keys(C), T, $;
    for ($ = 0; $ < M.length; $++)
        T = M[$],
        !(S.indexOf(T) >= 0) && (E[T] = C[T]);
    return E
}
function isModifiedEvent(C) {
    return !!(C.metaKey || C.altKey || C.ctrlKey || C.shiftKey)
}
function shouldProcessLinkClick(C, S) {
    return C.button === 0 && (!S || S === "_self") && !isModifiedEvent(C)
}
const _excluded$v = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
  , REACT_ROUTER_VERSION = "6";
try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION
} catch {}
const START_TRANSITION = "startTransition"
  , startTransitionImpl = React[START_TRANSITION];
function BrowserRouter(C) {
    let {basename: S, children: E, future: M, window: T} = C
      , $ = reactExports.useRef();
    $.current == null && ($.current = createBrowserHistory({
        window: T,
        v5Compat: !0
    }));
    let B = $.current
      , [O,F] = reactExports.useState({
        action: B.action,
        location: B.location
    })
      , {v7_startTransition: N} = M || {}
      , U = reactExports.useCallback(H=>{
        N && startTransitionImpl ? startTransitionImpl(()=>F(H)) : F(H)
    }
    , [F, N]);
    return reactExports.useLayoutEffect(()=>B.listen(U), [B, U]),
    reactExports.createElement(Router, {
        basename: S,
        children: E,
        location: O.location,
        navigationType: O.action,
        navigator: B,
        future: M
    })
}
const isBrowser$2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Link$1 = reactExports.forwardRef(function(S, E) {
    let {onClick: M, relative: T, reloadDocument: $, replace: B, state: O, target: F, to: N, preventScrollReset: U, unstable_viewTransition: H} = S, Z = _objectWithoutPropertiesLoose$1(S, _excluded$v), {basename: J} = reactExports.useContext(NavigationContext), ie, oe = !1;
    if (typeof N == "string" && ABSOLUTE_URL_REGEX.test(N) && (ie = N,
    isBrowser$2))
        try {
            let de = new URL(window.location.href)
              , fe = N.startsWith("//") ? new URL(de.protocol + N) : new URL(N)
              , pe = stripBasename(fe.pathname, J);
            fe.origin === de.origin && pe != null ? N = pe + fe.search + fe.hash : oe = !0
        } catch {}
    let ae = useHref(N, {
        relative: T
    })
      , se = useLinkClickHandler(N, {
        replace: B,
        state: O,
        target: F,
        preventScrollReset: U,
        relative: T,
        unstable_viewTransition: H
    });
    function le(de) {
        M && M(de),
        de.defaultPrevented || se(de)
    }
    return reactExports.createElement("a", _extends({}, Z, {
        href: ie || ae,
        onClick: oe || $ ? M : le,
        ref: E,
        target: F
    }))
});
var DataRouterHook;
(function(C) {
    C.UseScrollRestoration = "useScrollRestoration",
    C.UseSubmit = "useSubmit",
    C.UseSubmitFetcher = "useSubmitFetcher",
    C.UseFetcher = "useFetcher",
    C.useViewTransitionState = "useViewTransitionState"
}
)(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(C) {
    C.UseFetcher = "useFetcher",
    C.UseFetchers = "useFetchers",
    C.UseScrollRestoration = "useScrollRestoration"
}
)(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(C, S) {
    let {target: E, replace: M, state: T, preventScrollReset: $, relative: B, unstable_viewTransition: O} = S === void 0 ? {} : S
      , F = useNavigate()
      , N = useLocation()
      , U = useResolvedPath(C, {
        relative: B
    });
    return reactExports.useCallback(H=>{
        if (shouldProcessLinkClick(H, E)) {
            H.preventDefault();
            let Z = M !== void 0 ? M : createPath(N) === createPath(U);
            F(C, {
                replace: Z,
                state: T,
                preventScrollReset: $,
                relative: B,
                unstable_viewTransition: O
            })
        }
    }
    , [N, F, U, M, T, E, C, $, B, O])
}
var dist$4 = {}
  , Address$i = {};
const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
var symbol_inspect = SymbolInspect
  , crc16$6 = {};
Object.defineProperty(crc16$6, "__esModule", {
    value: !0
});
crc16$6.crc16 = void 0;
function crc16$5(C) {
    let E = 0;
    const M = Buffer.alloc(C.length + 2);
    M.set(C);
    for (let T of M) {
        let $ = 128;
        for (; $ > 0; )
            E <<= 1,
            T & $ && (E += 1),
            $ >>= 1,
            E > 65535 && (E &= 65535,
            E ^= 4129)
    }
    return Buffer.from([Math.floor(E / 256), E % 256])
}
crc16$6.crc16 = crc16$5;
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
, _a$3;
Object.defineProperty(Address$i, "__esModule", {
    value: !0
});
Address$i.address = Address$i.Address = void 0;
const symbol_inspect_1$2 = __importDefault$a(symbol_inspect)
  , crc16_1$1 = crc16$6
  , bounceable_tag$1 = 17
  , non_bounceable_tag$1 = 81
  , test_flag$1 = 128;
function parseFriendlyAddress$1(C) {
    if (typeof C == "string" && !Address$h.isFriendly(C))
        throw new Error("Unknown address type");
    const S = Buffer.isBuffer(C) ? C : Buffer.from(C, "base64");
    if (S.length !== 36)
        throw new Error("Unknown address type: byte length is not equal to 36");
    const E = S.subarray(0, 34)
      , M = S.subarray(34, 36)
      , T = (0,
    crc16_1$1.crc16)(E);
    if (!(T[0] === M[0] && T[1] === M[1]))
        throw new Error("Invalid checksum: " + C);
    let $ = E[0]
      , B = !1
      , O = !1;
    if ($ & test_flag$1 && (B = !0,
    $ = $ ^ test_flag$1),
    $ !== bounceable_tag$1 && $ !== non_bounceable_tag$1)
        throw "Unknown address tag";
    O = $ === bounceable_tag$1;
    let F = null;
    E[1] === 255 ? F = -1 : F = E[1];
    const N = E.subarray(2, 34);
    return {
        isTestOnly: B,
        isBounceable: O,
        workchain: F,
        hashPart: N
    }
}
let Address$h = class br {
    static isAddress(S) {
        return S instanceof br
    }
    static isFriendly(S) {
        return !(S.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(S))
    }
    static isRaw(S) {
        if (S.indexOf(":") === -1)
            return !1;
        let[E,M] = S.split(":");
        return !(!Number.isInteger(parseFloat(E)) || !/[a-f0-9]+/.test(M.toLowerCase()) || M.length !== 64)
    }
    static normalize(S) {
        return typeof S == "string" ? br.parse(S).toString() : S.toString()
    }
    static parse(S) {
        if (br.isFriendly(S))
            return this.parseFriendly(S).address;
        if (br.isRaw(S))
            return this.parseRaw(S);
        throw new Error("Unknown address type: " + S)
    }
    static parseRaw(S) {
        let E = parseInt(S.split(":")[0])
          , M = Buffer.from(S.split(":")[1], "hex");
        return new br(E,M)
    }
    static parseFriendly(S) {
        if (Buffer.isBuffer(S)) {
            let E = parseFriendlyAddress$1(S);
            return {
                isBounceable: E.isBounceable,
                isTestOnly: E.isTestOnly,
                address: new br(E.workchain,E.hashPart)
            }
        } else {
            let E = S.replace(/\-/g, "+").replace(/_/g, "/")
              , M = parseFriendlyAddress$1(E);
            return {
                isBounceable: M.isBounceable,
                isTestOnly: M.isTestOnly,
                address: new br(M.workchain,M.hashPart)
            }
        }
    }
    constructor(S, E) {
        if (this.toRawString = ()=>this.workChain + ":" + this.hash.toString("hex"),
        this.toRaw = ()=>{
            const M = Buffer.alloc(36);
            return M.set(this.hash),
            M.set([this.workChain, this.workChain, this.workChain, this.workChain], 32),
            M
        }
        ,
        this.toStringBuffer = M=>{
            let T = M && M.testOnly !== void 0 ? M.testOnly : !1
              , B = (M && M.bounceable !== void 0 ? M.bounceable : !0) ? bounceable_tag$1 : non_bounceable_tag$1;
            T && (B |= test_flag$1);
            const O = Buffer.alloc(34);
            O[0] = B,
            O[1] = this.workChain,
            O.set(this.hash, 2);
            const F = Buffer.alloc(36);
            return F.set(O),
            F.set((0,
            crc16_1$1.crc16)(O), 34),
            F
        }
        ,
        this.toString = M=>{
            let T = M && M.urlSafe !== void 0 ? M.urlSafe : !0
              , $ = this.toStringBuffer(M);
            return T ? $.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : $.toString("base64")
        }
        ,
        this[_a$3] = ()=>this.toString(),
        E.length !== 32)
            throw new Error("Invalid address hash length: " + E.length);
        this.workChain = S,
        this.hash = E,
        Object.freeze(this)
    }
    equals(S) {
        return S.workChain !== this.workChain ? !1 : S.hash.equals(this.hash)
    }
}
;
Address$i.Address = Address$h;
_a$3 = symbol_inspect_1$2.default;
function address(C) {
    return Address$h.parse(C)
}
Address$i.address = address;
var ExternalAddress$1 = {}, __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
, _a$2;
Object.defineProperty(ExternalAddress$1, "__esModule", {
    value: !0
});
ExternalAddress$1.ExternalAddress = void 0;
const symbol_inspect_1$1 = __importDefault$9(symbol_inspect);
class ExternalAddress {
    static isAddress(S) {
        return S instanceof ExternalAddress
    }
    constructor(S, E) {
        this[_a$2] = ()=>this.toString(),
        this.value = S,
        this.bits = E
    }
    toString() {
        return `External<${this.bits}:${this.value}>`
    }
}
ExternalAddress$1.ExternalAddress = ExternalAddress;
_a$2 = symbol_inspect_1$1.default;
var ADNLAddress$1 = {}
  , base32 = {};
Object.defineProperty(base32, "__esModule", {
    value: !0
});
base32.base32Decode = base32.base32Encode = void 0;
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
function base32Encode(C) {
    const S = C.byteLength;
    let E = 0
      , M = 0
      , T = "";
    for (let $ = 0; $ < S; $++)
        for (M = M << 8 | C[$],
        E += 8; E >= 5; )
            T += alphabet[M >>> E - 5 & 31],
            E -= 5;
    return E > 0 && (T += alphabet[M << 5 - E & 31]),
    T
}
base32.base32Encode = base32Encode;
function readChar(C, S) {
    const E = C.indexOf(S);
    if (E === -1)
        throw new Error("Invalid character found: " + S);
    return E
}
function base32Decode(C) {
    let S;
    S = C.toLowerCase();
    const {length: E} = S;
    let M = 0
      , T = 0
      , $ = 0;
    const B = Buffer.alloc(E * 5 / 8 | 0);
    for (let O = 0; O < E; O++)
        T = T << 5 | readChar(alphabet, S[O]),
        M += 5,
        M >= 8 && (B[$++] = T >>> M - 8 & 255,
        M -= 8);
    return B
}
base32.base32Decode = base32Decode;
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
, _a$1;
Object.defineProperty(ADNLAddress$1, "__esModule", {
    value: !0
});
ADNLAddress$1.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault$8(symbol_inspect)
  , base32_1 = base32
  , crc16_1 = crc16$6;
class ADNLAddress {
    static parseFriendly(S) {
        if (S.length !== 55)
            throw Error("Invalid address");
        S = "f" + S;
        let E = (0,
        base32_1.base32Decode)(S);
        if (E[0] !== 45)
            throw Error("Invalid address");
        let M = E.slice(33);
        if (!(0,
        crc16_1.crc16)(E.slice(0, 33)).equals(M))
            throw Error("Invalid address");
        return new ADNLAddress(E.slice(1, 33))
    }
    static parseRaw(S) {
        const E = Buffer.from(S, "base64");
        return new ADNLAddress(E)
    }
    constructor(S) {
        if (this.toRaw = ()=>this.address.toString("hex").toUpperCase(),
        this.toString = ()=>{
            let E = Buffer.concat([Buffer.from([45]), this.address])
              , M = (0,
            crc16_1.crc16)(E);
            return E = Buffer.concat([E, M]),
            (0,
            base32_1.base32Encode)(E).slice(1)
        }
        ,
        this[_a$1] = ()=>this.toString(),
        S.length !== 32)
            throw Error("Invalid address");
        this.address = S
    }
    equals(S) {
        return this.address.equals(S.address)
    }
}
ADNLAddress$1.ADNLAddress = ADNLAddress;
_a$1 = symbol_inspect_1.default;
var contractAddress$1 = {}, Builder = {}, BitBuilder = {}, BitString$4 = {}, paddedBits = {}, hasRequiredPaddedBits;
function requirePaddedBits() {
    if (hasRequiredPaddedBits)
        return paddedBits;
    hasRequiredPaddedBits = 1,
    Object.defineProperty(paddedBits, "__esModule", {
        value: !0
    }),
    paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
    const C = requireBitBuilder()
      , S = requireBitString();
    function E(T) {
        let $ = new C.BitBuilder(Math.ceil(T.length / 8) * 8);
        $.writeBits(T);
        let B = Math.ceil(T.length / 8) * 8 - T.length;
        for (let O = 0; O < B; O++)
            O === 0 ? $.writeBit(1) : $.writeBit(0);
        return $.buffer()
    }
    paddedBits.bitsToPaddedBuffer = E;
    function M(T) {
        let $ = 0;
        for (let B = T.length - 1; B >= 0; B--)
            if (T[B] !== 0) {
                const O = T[B];
                let F = O & -O;
                F & 1 || (F = Math.log2(F) + 1),
                B > 0 && ($ = B << 3),
                $ += 8 - F;
                break
            }
        return new S.BitString(T,0,$)
    }
    return paddedBits.paddedBufferToBits = M,
    paddedBits
}
var hasRequiredBitString;
function requireBitString() {
    if (hasRequiredBitString)
        return BitString$4;
    hasRequiredBitString = 1;
    var C = commonjsGlobal && commonjsGlobal.__importDefault || function($) {
        return $ && $.__esModule ? $ : {
            default: $
        }
    }
    , S;
    Object.defineProperty(BitString$4, "__esModule", {
        value: !0
    }),
    BitString$4.BitString = void 0;
    const E = requirePaddedBits()
      , M = C(symbol_inspect);
    class T {
        static isBitString(B) {
            return B instanceof T
        }
        constructor(B, O, F) {
            if (this[S] = ()=>this.toString(),
            F < 0)
                throw new Error(`Length ${F} is out of bounds`);
            this._length = F,
            this._data = B,
            this._offset = O
        }
        get length() {
            return this._length
        }
        at(B) {
            if (B >= this._length)
                throw new Error(`Index ${B} > ${this._length} is out of bounds`);
            if (B < 0)
                throw new Error(`Index ${B} < 0 is out of bounds`);
            let O = this._offset + B >> 3
              , F = 7 - (this._offset + B) % 8;
            return (this._data[O] & 1 << F) !== 0
        }
        substring(B, O) {
            if (B > this._length)
                throw new Error(`Offset(${B}) > ${this._length} is out of bounds`);
            if (B < 0)
                throw new Error(`Offset(${B}) < 0 is out of bounds`);
            if (O === 0)
                return T.EMPTY;
            if (B + O > this._length)
                throw new Error(`Offset ${B} + Length ${O} > ${this._length} is out of bounds`);
            return new T(this._data,this._offset + B,O)
        }
        subbuffer(B, O) {
            if (B > this._length)
                throw new Error(`Offset ${B} is out of bounds`);
            if (B < 0)
                throw new Error(`Offset ${B} is out of bounds`);
            if (B + O > this._length)
                throw new Error(`Offset + Lenght = ${B + O} is out of bounds`);
            if (O % 8 !== 0 || (this._offset + B) % 8 !== 0)
                return null;
            let F = this._offset + B >> 3
              , N = F + (O >> 3);
            return this._data.subarray(F, N)
        }
        equals(B) {
            if (this._length !== B._length)
                return !1;
            for (let O = 0; O < this._length; O++)
                if (this.at(O) !== B.at(O))
                    return !1;
            return !0
        }
        toString() {
            const B = (0,
            E.bitsToPaddedBuffer)(this);
            if (this._length % 4 === 0) {
                const O = B.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
                return this._length % 8 === 0 ? O : O.substring(0, O.length - 1)
            } else {
                const O = B.toString("hex").toUpperCase();
                return this._length % 8 <= 4 ? O.substring(0, O.length - 1) + "_" : O + "_"
            }
        }
    }
    return BitString$4.BitString = T,
    S = M.default,
    T.EMPTY = new T(Buffer.alloc(0),0,0),
    BitString$4
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
    if (hasRequiredBitBuilder)
        return BitBuilder;
    hasRequiredBitBuilder = 1,
    Object.defineProperty(BitBuilder, "__esModule", {
        value: !0
    }),
    BitBuilder.BitBuilder = void 0;
    const C = Address$i
      , S = ExternalAddress$1
      , E = requireBitString();
    let M = class {
        constructor($=1023) {
            this._buffer = Buffer.alloc(Math.ceil($ / 8)),
            this._length = 0
        }
        get length() {
            return this._length
        }
        writeBit($) {
            let B = this._length;
            if (B > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            ($ === !0 || $ > 0) && (this._buffer[B / 8 | 0] |= 1 << 7 - B % 8),
            this._length++
        }
        writeBits($) {
            for (let B = 0; B < $.length; B++)
                this.writeBit($.at(B))
        }
        writeBuffer($) {
            if (this._length % 8 === 0) {
                if (this._length + $.length * 8 > this._buffer.length * 8)
                    throw new Error("BitBuilder overflow");
                $.copy(this._buffer, this._length / 8),
                this._length += $.length * 8
            } else
                for (let B = 0; B < $.length; B++)
                    this.writeUint($[B], 8)
        }
        writeUint($, B) {
            if (B === 8 && this._length % 8 === 0) {
                let U = Number($);
                if (U < 0 || U > 255 || !Number.isSafeInteger(U))
                    throw Error(`value is out of range for ${B} bits. Got ${$}`);
                this._buffer[this._length / 8] = Number($),
                this._length += 8;
                return
            }
            if (B === 16 && this._length % 8 === 0) {
                let U = Number($);
                if (U < 0 || U > 65536 || !Number.isSafeInteger(U))
                    throw Error(`value is out of range for ${B} bits. Got ${$}`);
                this._buffer[this._length / 8] = U >> 8,
                this._buffer[this._length / 8 + 1] = U & 255,
                this._length += 16;
                return
            }
            let O = BigInt($);
            if (B < 0 || !Number.isSafeInteger(B))
                throw Error(`invalid bit length. Got ${B}`);
            if (B === 0) {
                if ($ !== 0n)
                    throw Error(`value is not zero for ${B} bits. Got ${$}`);
                return
            }
            let F = 1n << BigInt(B);
            if (O < 0 || O >= F)
                throw Error(`bitLength is too small for a value ${$}. Got ${B}`);
            let N = [];
            for (; O > 0; )
                N.push(O % 2n === 1n),
                O /= 2n;
            for (let U = 0; U < B; U++) {
                let H = B - U - 1;
                H < N.length ? this.writeBit(N[H]) : this.writeBit(!1)
            }
        }
        writeInt($, B) {
            let O = BigInt($);
            if (B < 0 || !Number.isSafeInteger(B))
                throw Error(`invalid bit length. Got ${B}`);
            if (B === 0) {
                if ($ !== 0n)
                    throw Error(`value is not zero for ${B} bits. Got ${$}`);
                return
            }
            if (B === 1) {
                if ($ !== -1n && $ !== 0n)
                    throw Error(`value is not zero or -1 for ${B} bits. Got ${$}`);
                this.writeBit($ === -1n);
                return
            }
            let F = 1n << BigInt(B) - 1n;
            if (O < -F || O >= F)
                throw Error(`value is out of range for ${B} bits. Got ${$}`);
            O < 0 ? (this.writeBit(!0),
            O = F + O) : this.writeBit(!1),
            this.writeUint(O, B - 1)
        }
        writeVarUint($, B) {
            let O = BigInt($);
            if (B < 0 || !Number.isSafeInteger(B))
                throw Error(`invalid bit length. Got ${B}`);
            if (O < 0)
                throw Error(`value is negative. Got ${$}`);
            if (O === 0n) {
                this.writeUint(0, B);
                return
            }
            const F = Math.ceil(O.toString(2).length / 8)
              , N = F * 8;
            this.writeUint(F, B),
            this.writeUint(O, N)
        }
        writeVarInt($, B) {
            let O = BigInt($);
            if (B < 0 || !Number.isSafeInteger(B))
                throw Error(`invalid bit length. Got ${B}`);
            if (O === 0n) {
                this.writeUint(0, B);
                return
            }
            let F = O > 0 ? O : -O;
            const N = 1 + Math.ceil(F.toString(2).length / 8)
              , U = N * 8;
            this.writeUint(N, B),
            this.writeInt(O, U)
        }
        writeCoins($) {
            this.writeVarUint($, 4)
        }
        writeAddress($) {
            if ($ == null) {
                this.writeUint(0, 2);
                return
            }
            if (C.Address.isAddress($)) {
                this.writeUint(2, 2),
                this.writeUint(0, 1),
                this.writeInt($.workChain, 8),
                this.writeBuffer($.hash);
                return
            }
            if (S.ExternalAddress.isAddress($)) {
                this.writeUint(1, 2),
                this.writeUint($.bits, 9),
                this.writeUint($.value, $.bits);
                return
            }
            throw Error(`Invalid address. Got ${$}`)
        }
        build() {
            return new E.BitString(this._buffer,0,this._length)
        }
        buffer() {
            if (this._length % 8 !== 0)
                throw new Error("BitBuilder buffer is not byte aligned");
            return this._buffer.subarray(0, this._length / 8)
        }
    }
    ;
    return BitBuilder.BitBuilder = M,
    BitBuilder
}
var Cell$r = {}
  , CellType = {};
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.CellType = void 0,
    function(S) {
        S[S.Ordinary = -1] = "Ordinary",
        S[S.PrunedBranch = 1] = "PrunedBranch",
        S[S.Library = 2] = "Library",
        S[S.MerkleProof = 3] = "MerkleProof",
        S[S.MerkleUpdate = 4] = "MerkleUpdate"
    }(C.CellType || (C.CellType = {}))
}
)(CellType);
var Slice$3 = {}
  , Dictionary = {}
  , generateMerkleProof = {}
  , readUnaryLength$2 = {};
Object.defineProperty(readUnaryLength$2, "__esModule", {
    value: !0
});
readUnaryLength$2.readUnaryLength = void 0;
function readUnaryLength$1(C) {
    let S = 0;
    for (; C.loadBit(); )
        S++;
    return S
}
readUnaryLength$2.readUnaryLength = readUnaryLength$1;
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
    if (hasRequiredGenerateMerkleProof)
        return generateMerkleProof;
    hasRequiredGenerateMerkleProof = 1,
    Object.defineProperty(generateMerkleProof, "__esModule", {
        value: !0
    }),
    generateMerkleProof.generateMerkleProof = void 0;
    const C = requireBuilder()
      , S = requireCell()
      , E = readUnaryLength$2;
    function M(O) {
        return new S.Cell({
            exotic: !0,
            bits: (0,
            C.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(O.hash(0)).storeUint(O.depth(0), 16).endCell().beginParse().loadBits(288)
        })
    }
    function T(O) {
        return new S.Cell({
            exotic: !0,
            bits: (0,
            C.beginCell)().storeUint(3, 8).storeBuffer(O.hash(0)).storeUint(O.depth(0), 16).endCell().beginParse().loadBits(280),
            refs: [O]
        })
    }
    function $(O, F, N, U) {
        const H = F.asCell();
        let Z = F.loadBit() ? 1 : 0
          , J = 0
          , ie = O;
        if (Z === 0) {
            J = (0,
            E.readUnaryLength)(F);
            for (let oe = 0; oe < J; oe++)
                ie += F.loadBit() ? "1" : "0"
        } else if ((F.loadBit() ? 1 : 0) === 0) {
            J = F.loadUint(Math.ceil(Math.log2(N + 1)));
            for (let ae = 0; ae < J; ae++)
                ie += F.loadBit() ? "1" : "0"
        } else {
            let ae = F.loadBit() ? "1" : "0";
            J = F.loadUint(Math.ceil(Math.log2(N + 1)));
            for (let se = 0; se < J; se++)
                ie += ae
        }
        if (N - J === 0)
            return H;
        {
            let oe = H.beginParse()
              , ae = oe.loadRef()
              , se = oe.loadRef();
            return ae.isExotic || (ie + "0" === U.slice(0, ie.length + 1) ? ae = $(ie + "0", ae.beginParse(), N - J - 1, U) : ae = M(ae)),
            se.isExotic || (ie + "1" === U.slice(0, ie.length + 1) ? se = $(ie + "1", se.beginParse(), N - J - 1, U) : se = M(se)),
            (0,
            C.beginCell)().storeSlice(oe).storeRef(ae).storeRef(se).endCell()
        }
    }
    function B(O, F, N) {
        const U = (0,
        C.beginCell)().storeDictDirect(O).endCell().beginParse();
        return T($("", U, N.bits, N.serialize(F).toString(2).padStart(N.bits, "0")))
    }
    return generateMerkleProof.generateMerkleProof = B,
    generateMerkleProof
}
var generateMerkleUpdate = {}, hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
    if (hasRequiredGenerateMerkleUpdate)
        return generateMerkleUpdate;
    hasRequiredGenerateMerkleUpdate = 1,
    Object.defineProperty(generateMerkleUpdate, "__esModule", {
        value: !0
    }),
    generateMerkleUpdate.generateMerkleUpdate = void 0;
    const C = requireBuilder()
      , S = requireCell()
      , E = requireGenerateMerkleProof();
    function M($, B) {
        return new S.Cell({
            exotic: !0,
            bits: (0,
            C.beginCell)().storeUint(4, 8).storeBuffer($.hash(0)).storeBuffer(B.hash(0)).storeUint($.depth(0), 16).storeUint(B.depth(0), 16).endCell().beginParse().loadBits(552),
            refs: [$, B]
        })
    }
    function T($, B, O, F) {
        const N = (0,
        E.generateMerkleProof)($, B, O).refs[0];
        $.set(B, F);
        const U = (0,
        E.generateMerkleProof)($, B, O).refs[0];
        return M(N, U)
    }
    return generateMerkleUpdate.generateMerkleUpdate = T,
    generateMerkleUpdate
}
var parseDict$1 = {};
Object.defineProperty(parseDict$1, "__esModule", {
    value: !0
});
parseDict$1.parseDict = void 0;
function readUnaryLength(C) {
    let S = 0;
    for (; C.loadBit(); )
        S++;
    return S
}
function doParse(C, S, E, M, T) {
    let $ = S.loadBit() ? 1 : 0
      , B = 0
      , O = C;
    if ($ === 0) {
        B = readUnaryLength(S);
        for (let F = 0; F < B; F++)
            O += S.loadBit() ? "1" : "0"
    } else if ((S.loadBit() ? 1 : 0) === 0) {
        B = S.loadUint(Math.ceil(Math.log2(E + 1)));
        for (let N = 0; N < B; N++)
            O += S.loadBit() ? "1" : "0"
    } else {
        let N = S.loadBit() ? "1" : "0";
        B = S.loadUint(Math.ceil(Math.log2(E + 1)));
        for (let U = 0; U < B; U++)
            O += N
    }
    if (E - B === 0)
        M.set(BigInt("0b" + O), T(S));
    else {
        let F = S.loadRef()
          , N = S.loadRef();
        F.isExotic || doParse(O + "0", F.beginParse(), E - B - 1, M, T),
        N.isExotic || doParse(O + "1", N.beginParse(), E - B - 1, M, T)
    }
}
function parseDict(C, S, E) {
    let M = new Map;
    return C && doParse("", C, S, M, E),
    M
}
parseDict$1.parseDict = parseDict;
var serializeDict = {}
  , findCommonPrefix$1 = {};
Object.defineProperty(findCommonPrefix$1, "__esModule", {
    value: !0
});
findCommonPrefix$1.findCommonPrefix = void 0;
function findCommonPrefix(C) {
    if (C.length === 0)
        return "";
    if (C.length === 1)
        return C[0];
    const S = [...C].sort();
    let E = 0;
    for (let M = 0; M < S[0].length && S[0][M] === S[S.length - 1][M]; M++)
        E++;
    return C[0].slice(0, E)
}
findCommonPrefix$1.findCommonPrefix = findCommonPrefix;
var hasRequiredSerializeDict;
function requireSerializeDict() {
    if (hasRequiredSerializeDict)
        return serializeDict;
    hasRequiredSerializeDict = 1,
    Object.defineProperty(serializeDict, "__esModule", {
        value: !0
    }),
    serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
    const C = requireBuilder()
      , S = findCommonPrefix$1;
    function E(fe, pe) {
        for (; fe.length < pe; )
            fe = "0" + fe;
        return fe
    }
    function M(fe, pe) {
        if (pe === 0)
            return fe;
        {
            let ge = new Map;
            for (let we of fe.keys()) {
                let Ae = fe.get(we);
                ge.set(we.slice(pe), Ae)
            }
            return ge
        }
    }
    function T(fe) {
        if (fe.size === 0)
            throw Error("Internal inconsistency");
        let pe = new Map
          , ge = new Map;
        for (let we of fe.keys()) {
            let Ae = fe.get(we);
            we.startsWith("0") ? pe.set(we.substr(1), Ae) : ge.set(we.substr(1), Ae)
        }
        if (pe.size === 0)
            throw Error("Internal inconsistency. Left emtpy.");
        if (ge.size === 0)
            throw Error("Internal inconsistency. Right emtpy.");
        return {
            left: pe,
            right: ge
        }
    }
    function $(fe) {
        if (fe.size === 0)
            throw Error("Internal inconsistency");
        if (fe.size === 1)
            return {
                type: "leaf",
                value: Array.from(fe.values())[0]
            };
        let {left: pe, right: ge} = T(fe);
        return {
            type: "fork",
            left: B(pe),
            right: B(ge)
        }
    }
    function B(fe) {
        if (fe.size === 0)
            throw Error("Internal inconsistency");
        const pe = (0,
        S.findCommonPrefix)(Array.from(fe.keys()));
        return {
            label: pe,
            node: $(M(fe, pe.length))
        }
    }
    function O(fe, pe) {
        let ge = new Map;
        for (let we of Array.from(fe.keys())) {
            const Ae = E(we.toString(2), pe);
            ge.set(Ae, fe.get(we))
        }
        return B(ge)
    }
    serializeDict.buildTree = O;
    function F(fe, pe) {
        pe.storeBit(0);
        for (let ge = 0; ge < fe.length; ge++)
            pe.storeBit(1);
        pe.storeBit(0);
        for (let ge = 0; ge < fe.length; ge++)
            pe.storeBit(fe[ge] === "1");
        return pe
    }
    serializeDict.writeLabelShort = F;
    function N(fe) {
        return 1 + fe.length + 1 + fe.length
    }
    function U(fe, pe, ge) {
        ge.storeBit(1),
        ge.storeBit(0);
        let we = Math.ceil(Math.log2(pe + 1));
        ge.storeUint(fe.length, we);
        for (let Ae = 0; Ae < fe.length; Ae++)
            ge.storeBit(fe[Ae] === "1");
        return ge
    }
    serializeDict.writeLabelLong = U;
    function H(fe, pe) {
        return 2 + Math.ceil(Math.log2(pe + 1)) + fe.length
    }
    function Z(fe, pe, ge, we) {
        we.storeBit(1),
        we.storeBit(1),
        we.storeBit(fe);
        let Ae = Math.ceil(Math.log2(ge + 1));
        we.storeUint(pe, Ae)
    }
    serializeDict.writeLabelSame = Z;
    function J(fe) {
        return 3 + Math.ceil(Math.log2(fe + 1))
    }
    function ie(fe) {
        if (fe.length === 0 || fe.length === 1)
            return !0;
        for (let pe = 1; pe < fe.length; pe++)
            if (fe[pe] !== fe[0])
                return !1;
        return !0
    }
    function oe(fe, pe) {
        let ge = "short"
          , we = N(fe)
          , Ae = H(fe, pe);
        if (Ae < we && (we = Ae,
        ge = "long"),
        ie(fe)) {
            let Se = J(pe);
            Se < we && (we = Se,
            ge = "same")
        }
        return ge
    }
    serializeDict.detectLabelType = oe;
    function ae(fe, pe, ge) {
        let we = oe(fe, pe);
        we === "short" && F(fe, ge),
        we === "long" && U(fe, pe, ge),
        we === "same" && Z(fe[0] === "1", fe.length, pe, ge)
    }
    function se(fe, pe, ge, we) {
        if (fe.type === "leaf" && ge(fe.value, we),
        fe.type === "fork") {
            const Ae = (0,
            C.beginCell)()
              , Se = (0,
            C.beginCell)();
            le(fe.left, pe - 1, ge, Ae),
            le(fe.right, pe - 1, ge, Se),
            we.storeRef(Ae),
            we.storeRef(Se)
        }
    }
    function le(fe, pe, ge, we) {
        ae(fe.label, pe, we),
        se(fe.node, pe - fe.label.length, ge, we)
    }
    function de(fe, pe, ge, we) {
        const Ae = O(fe, pe);
        le(Ae, pe, ge, we)
    }
    return serializeDict.serializeDict = de,
    serializeDict
}
var internalKeySerializer = {};
Object.defineProperty(internalKeySerializer, "__esModule", {
    value: !0
});
internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
const Address_1$4 = Address$i
  , BitString_1$2 = requireBitString()
  , paddedBits_1$1 = requirePaddedBits();
function serializeInternalKey(C) {
    if (typeof C == "number") {
        if (!Number.isSafeInteger(C))
            throw Error("Invalid key type: not a safe integer: " + C);
        return "n:" + C.toString(10)
    } else {
        if (typeof C == "bigint")
            return "b:" + C.toString(10);
        if (Address_1$4.Address.isAddress(C))
            return "a:" + C.toString();
        if (Buffer.isBuffer(C))
            return "f:" + C.toString("hex");
        if (BitString_1$2.BitString.isBitString(C))
            return "B:" + C.toString();
        throw Error("Invalid key type")
    }
}
internalKeySerializer.serializeInternalKey = serializeInternalKey;
function deserializeInternalKey(C) {
    let S = C.slice(0, 2)
      , E = C.slice(2);
    if (S === "n:")
        return parseInt(E, 10);
    if (S === "b:")
        return BigInt(E);
    if (S === "a:")
        return Address_1$4.Address.parse(E);
    if (S === "f:")
        return Buffer.from(E, "hex");
    if (S === "B:") {
        const M = E.slice(-1) == "_";
        if (M || E.length % 2 != 0) {
            let $ = M ? E.length - 1 : E.length;
            const B = E.substr(0, $) + "0";
            return !M && $ & 1 ? new BitString_1$2.BitString(Buffer.from(B, "hex"),0,$ << 2) : (0,
            paddedBits_1$1.paddedBufferToBits)(Buffer.from(B, "hex"))
        } else
            return new BitString_1$2.BitString(Buffer.from(E, "hex"),0,E.length << 2)
    }
    throw Error("Invalid key type: " + S)
}
internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
var hasRequiredDictionary;
function requireDictionary() {
    if (hasRequiredDictionary)
        return Dictionary;
    hasRequiredDictionary = 1,
    Object.defineProperty(Dictionary, "__esModule", {
        value: !0
    }),
    Dictionary.Dictionary = void 0;
    const C = Address$i
      , S = requireBuilder()
      , E = requireCell()
      , M = requireBitString()
      , T = requireGenerateMerkleProof()
      , $ = requireGenerateMerkleUpdate()
      , B = parseDict$1
      , O = requireSerializeDict()
      , F = internalKeySerializer;
    let N = class wr {
        static empty(I, L) {
            return I && L ? new wr(new Map,I,L) : new wr(new Map,null,null)
        }
        static load(I, L, K) {
            let X;
            if (K instanceof E.Cell) {
                if (K.isExotic)
                    return wr.empty(I, L);
                X = K.beginParse()
            } else
                X = K;
            let Y = X.loadMaybeRef();
            return Y && !Y.isExotic ? wr.loadDirect(I, L, Y.beginParse()) : wr.empty(I, L)
        }
        static loadDirect(I, L, K) {
            if (!K)
                return wr.empty(I, L);
            let X;
            K instanceof E.Cell ? X = K.beginParse() : X = K;
            let Y = (0,
            B.parseDict)(X, I.bits, L.parse)
              , j = new Map;
            for (let[G,ne] of Y)
                j.set((0,
                F.serializeInternalKey)(I.parse(G)), ne);
            return new wr(j,I,L)
        }
        constructor(I, L, K) {
            this._key = L,
            this._value = K,
            this._map = I
        }
        get size() {
            return this._map.size
        }
        get(I) {
            return this._map.get((0,
            F.serializeInternalKey)(I))
        }
        has(I) {
            return this._map.has((0,
            F.serializeInternalKey)(I))
        }
        set(I, L) {
            return this._map.set((0,
            F.serializeInternalKey)(I), L),
            this
        }
        delete(I) {
            const L = (0,
            F.serializeInternalKey)(I);
            return this._map.delete(L)
        }
        clear() {
            this._map.clear()
        }
        *[Symbol.iterator]() {
            for (const [I,L] of this._map)
                yield[(0,
                F.deserializeInternalKey)(I), L]
        }
        keys() {
            return Array.from(this._map.keys()).map(I=>(0,
            F.deserializeInternalKey)(I))
        }
        values() {
            return Array.from(this._map.values())
        }
        store(I, L, K) {
            if (this._map.size === 0)
                I.storeBit(0);
            else {
                let X = this._key;
                L != null && (X = L);
                let Y = this._value;
                if (K != null && (Y = K),
                !X)
                    throw Error("Key serializer is not defined");
                if (!Y)
                    throw Error("Value serializer is not defined");
                let j = new Map;
                for (const [ne,te] of this._map)
                    j.set(X.serialize((0,
                    F.deserializeInternalKey)(ne)), te);
                I.storeBit(1);
                let G = (0,
                S.beginCell)();
                (0,
                O.serializeDict)(j, X.bits, Y.serialize, G),
                I.storeRef(G.endCell())
            }
        }
        storeDirect(I, L, K) {
            if (this._map.size === 0)
                throw Error("Cannot store empty dictionary directly");
            let X = this._key;
            L != null && (X = L);
            let Y = this._value;
            if (K != null && (Y = K),
            !X)
                throw Error("Key serializer is not defined");
            if (!Y)
                throw Error("Value serializer is not defined");
            let j = new Map;
            for (const [G,ne] of this._map)
                j.set(X.serialize((0,
                F.deserializeInternalKey)(G)), ne);
            (0,
            O.serializeDict)(j, X.bits, Y.serialize, I)
        }
        generateMerkleProof(I) {
            return (0,
            T.generateMerkleProof)(this, I, this._key)
        }
        generateMerkleUpdate(I, L) {
            return (0,
            $.generateMerkleUpdate)(this, I, this._key, L)
        }
    }
    ;
    Dictionary.Dictionary = N,
    N.Keys = {
        Address: ()=>U(),
        BigInt: D=>H(D),
        Int: D=>Z(D),
        BigUint: D=>J(D),
        Uint: D=>ie(D),
        Buffer: D=>oe(D),
        BitString: D=>ae(D)
    },
    N.Values = {
        BigInt: D=>le(D),
        Int: D=>se(D),
        BigVarInt: D=>de(D),
        BigUint: D=>ge(D),
        Uint: D=>pe(D),
        BigVarUint: D=>fe(D),
        Bool: ()=>we(),
        Address: ()=>Ae(),
        Cell: ()=>Se(),
        Buffer: D=>V(D),
        BitString: D=>W(D),
        Dictionary: (D,I)=>ue(D, I)
    };
    function U() {
        return {
            bits: 267,
            serialize: D=>{
                if (!C.Address.isAddress(D))
                    throw Error("Key is not an address");
                return (0,
                S.beginCell)().storeAddress(D).endCell().beginParse().preloadUintBig(267)
            }
            ,
            parse: D=>(0,
            S.beginCell)().storeUint(D, 267).endCell().beginParse().loadAddress()
        }
    }
    function H(D) {
        return {
            bits: D,
            serialize: I=>{
                if (typeof I != "bigint")
                    throw Error("Key is not a bigint");
                return (0,
                S.beginCell)().storeInt(I, D).endCell().beginParse().loadUintBig(D)
            }
            ,
            parse: I=>(0,
            S.beginCell)().storeUint(I, D).endCell().beginParse().loadIntBig(D)
        }
    }
    function Z(D) {
        return {
            bits: D,
            serialize: I=>{
                if (typeof I != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(I))
                    throw Error("Key is not a safe integer: " + I);
                return (0,
                S.beginCell)().storeInt(I, D).endCell().beginParse().loadUintBig(D)
            }
            ,
            parse: I=>(0,
            S.beginCell)().storeUint(I, D).endCell().beginParse().loadInt(D)
        }
    }
    function J(D) {
        return {
            bits: D,
            serialize: I=>{
                if (typeof I != "bigint")
                    throw Error("Key is not a bigint");
                if (I < 0)
                    throw Error("Key is negative: " + I);
                return (0,
                S.beginCell)().storeUint(I, D).endCell().beginParse().loadUintBig(D)
            }
            ,
            parse: I=>(0,
            S.beginCell)().storeUint(I, D).endCell().beginParse().loadUintBig(D)
        }
    }
    function ie(D) {
        return {
            bits: D,
            serialize: I=>{
                if (typeof I != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(I))
                    throw Error("Key is not a safe integer: " + I);
                if (I < 0)
                    throw Error("Key is negative: " + I);
                return (0,
                S.beginCell)().storeUint(I, D).endCell().beginParse().loadUintBig(D)
            }
            ,
            parse: I=>Number((0,
            S.beginCell)().storeUint(I, D).endCell().beginParse().loadUint(D))
        }
    }
    function oe(D) {
        return {
            bits: D * 8,
            serialize: I=>{
                if (!Buffer.isBuffer(I))
                    throw Error("Key is not a buffer");
                return (0,
                S.beginCell)().storeBuffer(I).endCell().beginParse().loadUintBig(D * 8)
            }
            ,
            parse: I=>(0,
            S.beginCell)().storeUint(I, D * 8).endCell().beginParse().loadBuffer(D)
        }
    }
    function ae(D) {
        return {
            bits: D,
            serialize: I=>{
                if (!M.BitString.isBitString(I))
                    throw Error("Key is not a BitString");
                return (0,
                S.beginCell)().storeBits(I).endCell().beginParse().loadUintBig(D)
            }
            ,
            parse: I=>(0,
            S.beginCell)().storeUint(I, D).endCell().beginParse().loadBits(D)
        }
    }
    function se(D) {
        return {
            serialize: (I,L)=>{
                L.storeInt(I, D)
            }
            ,
            parse: I=>I.loadInt(D)
        }
    }
    function le(D) {
        return {
            serialize: (I,L)=>{
                L.storeInt(I, D)
            }
            ,
            parse: I=>I.loadIntBig(D)
        }
    }
    function de(D) {
        return {
            serialize: (I,L)=>{
                L.storeVarInt(I, D)
            }
            ,
            parse: I=>I.loadVarIntBig(D)
        }
    }
    function fe(D) {
        return {
            serialize: (I,L)=>{
                L.storeVarUint(I, D)
            }
            ,
            parse: I=>I.loadVarUintBig(D)
        }
    }
    function pe(D) {
        return {
            serialize: (I,L)=>{
                L.storeUint(I, D)
            }
            ,
            parse: I=>I.loadUint(D)
        }
    }
    function ge(D) {
        return {
            serialize: (I,L)=>{
                L.storeUint(I, D)
            }
            ,
            parse: I=>I.loadUintBig(D)
        }
    }
    function we() {
        return {
            serialize: (D,I)=>{
                I.storeBit(D)
            }
            ,
            parse: D=>D.loadBit()
        }
    }
    function Ae() {
        return {
            serialize: (D,I)=>{
                I.storeAddress(D)
            }
            ,
            parse: D=>D.loadAddress()
        }
    }
    function Se() {
        return {
            serialize: (D,I)=>{
                I.storeRef(D)
            }
            ,
            parse: D=>D.loadRef()
        }
    }
    function ue(D, I) {
        return {
            serialize: (L,K)=>{
                L.store(K)
            }
            ,
            parse: L=>N.load(D, I, L)
        }
    }
    function V(D) {
        return {
            serialize: (I,L)=>{
                if (I.length !== D)
                    throw Error("Invalid buffer size");
                L.storeBuffer(I)
            }
            ,
            parse: I=>I.loadBuffer(D)
        }
    }
    function W(D) {
        return {
            serialize: (I,L)=>{
                if (I.length !== D)
                    throw Error("Invalid BitString size");
                L.storeBits(I)
            }
            ,
            parse: I=>I.loadBits(D)
        }
    }
    return Dictionary
}
var strings = {}, hasRequiredStrings;
function requireStrings() {
    if (hasRequiredStrings)
        return strings;
    hasRequiredStrings = 1,
    Object.defineProperty(strings, "__esModule", {
        value: !0
    }),
    strings.writeString = strings.stringToCell = strings.readString = void 0;
    const C = requireBuilder();
    function S(B) {
        if (B.remainingBits % 8 !== 0)
            throw new Error(`Invalid string length: ${B.remainingBits}`);
        if (B.remainingRefs !== 0 && B.remainingRefs !== 1)
            throw new Error(`invalid number of refs: ${B.remainingRefs}`);
        let O;
        return B.remainingBits === 0 ? O = Buffer.alloc(0) : O = B.loadBuffer(B.remainingBits / 8),
        B.remainingRefs === 1 && (O = Buffer.concat([O, S(B.loadRef().beginParse())])),
        O
    }
    function E(B) {
        return S(B).toString()
    }
    strings.readString = E;
    function M(B, O) {
        if (B.length > 0) {
            let F = Math.floor(O.availableBits / 8);
            if (B.length > F) {
                let N = B.subarray(0, F)
                  , U = B.subarray(F);
                O = O.storeBuffer(N);
                let H = (0,
                C.beginCell)();
                M(U, H),
                O = O.storeRef(H.endCell())
            } else
                O = O.storeBuffer(B)
        }
    }
    function T(B) {
        let O = (0,
        C.beginCell)();
        return M(Buffer.from(B), O),
        O.endCell()
    }
    strings.stringToCell = T;
    function $(B, O) {
        M(Buffer.from(B), O)
    }
    return strings.writeString = $,
    strings
}
var hasRequiredSlice;
function requireSlice() {
    if (hasRequiredSlice)
        return Slice$3;
    hasRequiredSlice = 1;
    var C = commonjsGlobal && commonjsGlobal.__importDefault || function(O) {
        return O && O.__esModule ? O : {
            default: O
        }
    }
    , S;
    Object.defineProperty(Slice$3, "__esModule", {
        value: !0
    }),
    Slice$3.Slice = void 0;
    const E = C(symbol_inspect)
      , M = requireDictionary()
      , T = requireBuilder()
      , $ = requireStrings();
    class B {
        constructor(F, N) {
            this[S] = ()=>this.toString(),
            this._reader = F.clone(),
            this._refs = [...N],
            this._refsOffset = 0
        }
        get remainingBits() {
            return this._reader.remaining
        }
        get offsetBits() {
            return this._reader.offset
        }
        get remainingRefs() {
            return this._refs.length - this._refsOffset
        }
        get offsetRefs() {
            return this._refsOffset
        }
        skip(F) {
            return this._reader.skip(F),
            this
        }
        loadBit() {
            return this._reader.loadBit()
        }
        preloadBit() {
            return this._reader.preloadBit()
        }
        loadBoolean() {
            return this.loadBit()
        }
        loadMaybeBoolean() {
            return this.loadBit() ? this.loadBoolean() : null
        }
        loadBits(F) {
            return this._reader.loadBits(F)
        }
        preloadBits(F) {
            return this._reader.preloadBits(F)
        }
        loadUint(F) {
            return this._reader.loadUint(F)
        }
        loadUintBig(F) {
            return this._reader.loadUintBig(F)
        }
        preloadUint(F) {
            return this._reader.preloadUint(F)
        }
        preloadUintBig(F) {
            return this._reader.preloadUintBig(F)
        }
        loadMaybeUint(F) {
            return this.loadBit() ? this.loadUint(F) : null
        }
        loadMaybeUintBig(F) {
            return this.loadBit() ? this.loadUintBig(F) : null
        }
        loadInt(F) {
            return this._reader.loadInt(F)
        }
        loadIntBig(F) {
            return this._reader.loadIntBig(F)
        }
        preloadInt(F) {
            return this._reader.preloadInt(F)
        }
        preloadIntBig(F) {
            return this._reader.preloadIntBig(F)
        }
        loadMaybeInt(F) {
            return this.loadBit() ? this.loadInt(F) : null
        }
        loadMaybeIntBig(F) {
            return this.loadBit() ? this.loadIntBig(F) : null
        }
        loadVarUint(F) {
            return this._reader.loadVarUint(F)
        }
        loadVarUintBig(F) {
            return this._reader.loadVarUintBig(F)
        }
        preloadVarUint(F) {
            return this._reader.preloadVarUint(F)
        }
        preloadVarUintBig(F) {
            return this._reader.preloadVarUintBig(F)
        }
        loadVarInt(F) {
            return this._reader.loadVarInt(F)
        }
        loadVarIntBig(F) {
            return this._reader.loadVarIntBig(F)
        }
        preloadVarInt(F) {
            return this._reader.preloadVarInt(F)
        }
        preloadVarIntBig(F) {
            return this._reader.preloadVarIntBig(F)
        }
        loadCoins() {
            return this._reader.loadCoins()
        }
        preloadCoins() {
            return this._reader.preloadCoins()
        }
        loadMaybeCoins() {
            return this._reader.loadBit() ? this._reader.loadCoins() : null
        }
        loadAddress() {
            return this._reader.loadAddress()
        }
        loadMaybeAddress() {
            return this._reader.loadMaybeAddress()
        }
        loadExternalAddress() {
            return this._reader.loadExternalAddress()
        }
        loadMaybeExternalAddress() {
            return this._reader.loadMaybeExternalAddress()
        }
        loadAddressAny() {
            return this._reader.loadAddressAny()
        }
        loadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset++]
        }
        preloadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset]
        }
        loadMaybeRef() {
            return this.loadBit() ? this.loadRef() : null
        }
        preloadMaybeRef() {
            return this.preloadBit() ? this.preloadRef() : null
        }
        loadBuffer(F) {
            return this._reader.loadBuffer(F)
        }
        preloadBuffer(F) {
            return this._reader.preloadBuffer(F)
        }
        loadStringTail() {
            return (0,
            $.readString)(this)
        }
        loadMaybeStringTail() {
            return this.loadBit() ? (0,
            $.readString)(this) : null
        }
        loadStringRefTail() {
            return (0,
            $.readString)(this.loadRef().beginParse())
        }
        loadMaybeStringRefTail() {
            const F = this.loadMaybeRef();
            return F ? (0,
            $.readString)(F.beginParse()) : null
        }
        loadDict(F, N) {
            return M.Dictionary.load(F, N, this)
        }
        loadDictDirect(F, N) {
            return M.Dictionary.loadDirect(F, N, this)
        }
        endParse() {
            if (this.remainingBits > 0 || this.remainingRefs > 0)
                throw new Error("Slice is not empty")
        }
        asCell() {
            return (0,
            T.beginCell)().storeSlice(this).endCell()
        }
        asBuilder() {
            return (0,
            T.beginCell)().storeSlice(this)
        }
        clone(F=!1) {
            if (F) {
                let N = this._reader.clone();
                return N.reset(),
                new B(N,this._refs)
            } else {
                let N = new B(this._reader,this._refs);
                return N._refsOffset = this._refsOffset,
                N
            }
        }
        toString() {
            return this.asCell().toString()
        }
    }
    return Slice$3.Slice = B,
    S = E.default,
    Slice$3
}
var resolveExotic$1 = {}
  , BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", {
    value: !0
});
BitReader$1.BitReader = void 0;
const Address_1$3 = Address$i
  , ExternalAddress_1 = ExternalAddress$1;
class BitReader {
    constructor(S, E=0) {
        this._checkpoints = [],
        this._bits = S,
        this._offset = E
    }
    get offset() {
        return this._offset
    }
    get remaining() {
        return this._bits.length - this._offset
    }
    skip(S) {
        if (S < 0 || this._offset + S > this._bits.length)
            throw new Error(`Index ${this._offset + S} is out of bounds`);
        this._offset += S
    }
    reset() {
        this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0
    }
    save() {
        this._checkpoints.push(this._offset)
    }
    loadBit() {
        let S = this._bits.at(this._offset);
        return this._offset++,
        S
    }
    preloadBit() {
        return this._bits.at(this._offset)
    }
    loadBits(S) {
        let E = this._bits.substring(this._offset, S);
        return this._offset += S,
        E
    }
    preloadBits(S) {
        return this._bits.substring(this._offset, S)
    }
    loadBuffer(S) {
        let E = this._preloadBuffer(S, this._offset);
        return this._offset += S * 8,
        E
    }
    preloadBuffer(S) {
        return this._preloadBuffer(S, this._offset)
    }
    loadUint(S) {
        return Number(this.loadUintBig(S))
    }
    loadUintBig(S) {
        let E = this.preloadUintBig(S);
        return this._offset += S,
        E
    }
    preloadUint(S) {
        return Number(this._preloadUint(S, this._offset))
    }
    preloadUintBig(S) {
        return this._preloadUint(S, this._offset)
    }
    loadInt(S) {
        let E = this._preloadInt(S, this._offset);
        return this._offset += S,
        Number(E)
    }
    loadIntBig(S) {
        let E = this._preloadInt(S, this._offset);
        return this._offset += S,
        E
    }
    preloadInt(S) {
        return Number(this._preloadInt(S, this._offset))
    }
    preloadIntBig(S) {
        return this._preloadInt(S, this._offset)
    }
    loadVarUint(S) {
        let E = Number(this.loadUint(S));
        return Number(this.loadUintBig(E * 8))
    }
    loadVarUintBig(S) {
        let E = Number(this.loadUint(S));
        return this.loadUintBig(E * 8)
    }
    preloadVarUint(S) {
        let E = Number(this._preloadUint(S, this._offset));
        return Number(this._preloadUint(E * 8, this._offset + S))
    }
    preloadVarUintBig(S) {
        let E = Number(this._preloadUint(S, this._offset));
        return this._preloadUint(E * 8, this._offset + S)
    }
    loadVarInt(S) {
        let E = Number(this.loadUint(S));
        return Number(this.loadIntBig(E * 8))
    }
    loadVarIntBig(S) {
        let E = Number(this.loadUint(S));
        return this.loadIntBig(E * 8)
    }
    preloadVarInt(S) {
        let E = Number(this._preloadUint(S, this._offset));
        return Number(this._preloadInt(E * 8, this._offset + S))
    }
    preloadVarIntBig(S) {
        let E = Number(this._preloadUint(S, this._offset));
        return this._preloadInt(E * 8, this._offset + S)
    }
    loadCoins() {
        return this.loadVarUintBig(4)
    }
    preloadCoins() {
        return this.preloadVarUintBig(4)
    }
    loadAddress() {
        let S = Number(this._preloadUint(2, this._offset));
        if (S === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address: " + S)
    }
    loadMaybeAddress() {
        let S = Number(this._preloadUint(2, this._offset));
        if (S === 0)
            return this._offset += 2,
            null;
        if (S === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address")
    }
    loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadMaybeExternalAddress() {
        let S = Number(this._preloadUint(2, this._offset));
        if (S === 0)
            return this._offset += 2,
            null;
        if (S === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadAddressAny() {
        let S = Number(this._preloadUint(2, this._offset));
        if (S === 0)
            return this._offset += 2,
            null;
        if (S === 2)
            return this._loadInternalAddress();
        if (S === 1)
            return this._loadExternalAddress();
        throw Error(S === 3 ? "Unsupported" : "Unreachable")
    }
    loadPaddedBits(S) {
        if (S % 8 !== 0)
            throw new Error("Invalid number of bits");
        let E = S;
        for (; ; )
            if (this._bits.at(this._offset + E - 1)) {
                E--;
                break
            } else
                E--;
        let M = this._bits.substring(this._offset, E);
        return this._offset += S,
        M
    }
    clone() {
        return new BitReader(this._bits,this._offset)
    }
    _preloadInt(S, E) {
        if (S == 0)
            return 0n;
        let M = this._bits.at(E)
          , T = 0n;
        for (let $ = 0; $ < S - 1; $++)
            this._bits.at(E + 1 + $) && (T += 1n << BigInt(S - $ - 1 - 1));
        return M && (T = T - (1n << BigInt(S - 1))),
        T
    }
    _preloadUint(S, E) {
        if (S == 0)
            return 0n;
        let M = 0n;
        for (let T = 0; T < S; T++)
            this._bits.at(E + T) && (M += 1n << BigInt(S - T - 1));
        return M
    }
    _preloadBuffer(S, E) {
        let M = this._bits.subbuffer(E, S * 8);
        if (M)
            return M;
        let T = Buffer.alloc(S);
        for (let $ = 0; $ < S; $++)
            T[$] = Number(this._preloadUint(8, E + $ * 8));
        return T
    }
    _loadInternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n)
            throw Error("Invalid address");
        let E = Number(this._preloadInt(8, this._offset + 3))
          , M = this._preloadBuffer(32, this._offset + 11);
        return this._offset += 267,
        new Address_1$3.Address(E,M)
    }
    _loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 1)
            throw Error("Invalid address");
        let E = Number(this._preloadUint(9, this._offset + 2))
          , M = this._preloadUint(E, this._offset + 11);
        return this._offset += 11 + E,
        new ExternalAddress_1.ExternalAddress(M,E)
    }
}
BitReader$1.BitReader = BitReader;
var exoticLibrary$1 = {};
Object.defineProperty(exoticLibrary$1, "__esModule", {
    value: !0
});
exoticLibrary$1.exoticLibrary = void 0;
const BitReader_1$4 = BitReader$1;
function exoticLibrary(C, S) {
    const E = new BitReader_1$4.BitReader(C);
    if (C.length !== 264)
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${C.length}"`);
    let T = E.loadUint(8);
    if (T !== 2)
        throw new Error(`Library cell must have type 2, got "${T}"`);
    return {}
}
exoticLibrary$1.exoticLibrary = exoticLibrary;
var exoticMerkleProof$1 = {};
Object.defineProperty(exoticMerkleProof$1, "__esModule", {
    value: !0
});
exoticMerkleProof$1.exoticMerkleProof = void 0;
const BitReader_1$3 = BitReader$1;
function exoticMerkleProof(C, S) {
    const E = new BitReader_1$3.BitReader(C);
    if (C.length !== 280)
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${C.length}"`);
    if (S.length !== 1)
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${S.length}"`);
    let T = E.loadUint(8);
    if (T !== 3)
        throw new Error(`Merkle Proof cell must have type 3, got "${T}"`);
    const $ = E.loadBuffer(32)
      , B = E.loadUint(16)
      , O = S[0].hash(0)
      , F = S[0].depth(0);
    if (B !== F)
        throw new Error(`Merkle Proof cell ref depth must be exactly "${B}", got "${F}"`);
    if (!$.equals(O))
        throw new Error(`Merkle Proof cell ref hash must be exactly "${$.toString("hex")}", got "${O.toString("hex")}"`);
    return {
        proofDepth: B,
        proofHash: $
    }
}
exoticMerkleProof$1.exoticMerkleProof = exoticMerkleProof;
var exoticMerkleUpdate$1 = {};
Object.defineProperty(exoticMerkleUpdate$1, "__esModule", {
    value: !0
});
exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
const BitReader_1$2 = BitReader$1;
function exoticMerkleUpdate(C, S) {
    const E = new BitReader_1$2.BitReader(C)
      , M = 8 + 2 * 272;
    if (C.length !== M)
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${C.length}"`);
    if (S.length !== 2)
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${S.length}"`);
    let T = E.loadUint(8);
    if (T !== 4)
        throw new Error(`Merkle Update cell type must be exactly 4, got "${T}"`);
    const $ = E.loadBuffer(32)
      , B = E.loadBuffer(32)
      , O = E.loadUint(16)
      , F = E.loadUint(16);
    if (O !== S[0].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${O}", got "${S[0].depth(0)}"`);
    if (!$.equals(S[0].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${$.toString("hex")}", got "${S[0].hash(0).toString("hex")}"`);
    if (F !== S[1].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${F}", got "${S[1].depth(0)}"`);
    if (!B.equals(S[1].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${B.toString("hex")}", got "${S[1].hash(0).toString("hex")}"`);
    return {
        proofDepth1: O,
        proofDepth2: F,
        proofHash1: $,
        proofHash2: B
    }
}
exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate;
var exoticPruned$1 = {}
  , LevelMask$1 = {};
Object.defineProperty(LevelMask$1, "__esModule", {
    value: !0
});
LevelMask$1.LevelMask = void 0;
class LevelMask {
    constructor(S=0) {
        this._mask = 0,
        this._mask = S,
        this._hashIndex = countSetBits(this._mask),
        this._hashCount = this._hashIndex + 1
    }
    get value() {
        return this._mask
    }
    get level() {
        return 32 - Math.clz32(this._mask)
    }
    get hashIndex() {
        return this._hashIndex
    }
    get hashCount() {
        return this._hashCount
    }
    apply(S) {
        return new LevelMask(this._mask & (1 << S) - 1)
    }
    isSignificant(S) {
        return S === 0 || (this._mask >> S - 1) % 2 !== 0
    }
}
LevelMask$1.LevelMask = LevelMask;
function countSetBits(C) {
    return C = C - (C >> 1 & 1431655765),
    C = (C & 858993459) + (C >> 2 & 858993459),
    (C + (C >> 4) & 252645135) * 16843009 >> 24
}
Object.defineProperty(exoticPruned$1, "__esModule", {
    value: !0
});
exoticPruned$1.exoticPruned = void 0;
const BitReader_1$1 = BitReader$1
  , LevelMask_1$2 = LevelMask$1;
function exoticPruned(C, S) {
    let E = new BitReader_1$1.BitReader(C)
      , M = E.loadUint(8);
    if (M !== 1)
        throw new Error(`Pruned branch cell must have type 1, got "${M}"`);
    if (S.length !== 0)
        throw new Error(`Pruned Branch cell can't has refs, got "${S.length}"`);
    let T;
    if (C.length === 280)
        T = new LevelMask_1$2.LevelMask(1);
    else {
        if (T = new LevelMask_1$2.LevelMask(E.loadUint(8)),
        T.level < 1 || T.level > 3)
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${T.level}/${T.value}"`);
        const F = 16 + T.apply(T.level - 1).hashCount * 272;
        if (C.length !== F)
            throw new Error(`Pruned branch cell must have exactly ${F} bits, got "${C.length}"`)
    }
    let $ = []
      , B = []
      , O = [];
    for (let F = 0; F < T.level; F++)
        B.push(E.loadBuffer(32));
    for (let F = 0; F < T.level; F++)
        O.push(E.loadUint(16));
    for (let F = 0; F < T.level; F++)
        $.push({
            depth: O[F],
            hash: B[F]
        });
    return {
        mask: T.value,
        pruned: $
    }
}
exoticPruned$1.exoticPruned = exoticPruned;
Object.defineProperty(resolveExotic$1, "__esModule", {
    value: !0
});
resolveExotic$1.resolveExotic = void 0;
const BitReader_1 = BitReader$1
  , CellType_1$2 = CellType
  , exoticLibrary_1$1 = exoticLibrary$1
  , exoticMerkleProof_1$1 = exoticMerkleProof$1
  , exoticMerkleUpdate_1$1 = exoticMerkleUpdate$1
  , exoticPruned_1$1 = exoticPruned$1
  , LevelMask_1$1 = LevelMask$1;
function resolvePruned(C, S) {
    let E = (0,
    exoticPruned_1$1.exoticPruned)(C, S)
      , M = []
      , T = []
      , $ = new LevelMask_1$1.LevelMask(E.mask);
    for (let B = 0; B < E.pruned.length; B++)
        M.push(E.pruned[B].depth),
        T.push(E.pruned[B].hash);
    return {
        type: CellType_1$2.CellType.PrunedBranch,
        depths: M,
        hashes: T,
        mask: $
    }
}
function resolveLibrary(C, S) {
    (0,
    exoticLibrary_1$1.exoticLibrary)(C, S);
    let E = []
      , M = []
      , T = new LevelMask_1$1.LevelMask;
    return {
        type: CellType_1$2.CellType.Library,
        depths: E,
        hashes: M,
        mask: T
    }
}
function resolveMerkleProof(C, S) {
    (0,
    exoticMerkleProof_1$1.exoticMerkleProof)(C, S);
    let E = []
      , M = []
      , T = new LevelMask_1$1.LevelMask(S[0].level() >> 1);
    return {
        type: CellType_1$2.CellType.MerkleProof,
        depths: E,
        hashes: M,
        mask: T
    }
}
function resolveMerkleUpdate(C, S) {
    (0,
    exoticMerkleUpdate_1$1.exoticMerkleUpdate)(C, S);
    let E = []
      , M = []
      , T = new LevelMask_1$1.LevelMask((S[0].level() | S[1].level()) >> 1);
    return {
        type: CellType_1$2.CellType.MerkleUpdate,
        depths: E,
        hashes: M,
        mask: T
    }
}
function resolveExotic(C, S) {
    let M = new BitReader_1.BitReader(C).preloadUint(8);
    if (M === 1)
        return resolvePruned(C, S);
    if (M === 2)
        return resolveLibrary(C, S);
    if (M === 3)
        return resolveMerkleProof(C, S);
    if (M === 4)
        return resolveMerkleUpdate(C, S);
    throw Error("Invalid exotic cell type: " + M)
}
resolveExotic$1.resolveExotic = resolveExotic;
var wonderCalculator$1 = {}
  , descriptor = {};
Object.defineProperty(descriptor, "__esModule", {
    value: !0
});
descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
const CellType_1$1 = CellType
  , paddedBits_1 = requirePaddedBits();
function getRefsDescriptor(C, S, E) {
    return C.length + (E !== CellType_1$1.CellType.Ordinary ? 1 : 0) * 8 + S * 32
}
descriptor.getRefsDescriptor = getRefsDescriptor;
function getBitsDescriptor(C) {
    let S = C.length;
    return Math.ceil(S / 8) + Math.floor(S / 8)
}
descriptor.getBitsDescriptor = getBitsDescriptor;
function getRepr(C, S, E, M, T) {
    const $ = Math.ceil(S.length / 8)
      , B = Buffer.alloc(2 + $ + 34 * E.length);
    let O = 0;
    B[O++] = getRefsDescriptor(E, M, T),
    B[O++] = getBitsDescriptor(C),
    (0,
    paddedBits_1.bitsToPaddedBuffer)(S).copy(B, O),
    O += $;
    for (const F of E) {
        let N;
        T == CellType_1$1.CellType.MerkleProof || T == CellType_1$1.CellType.MerkleUpdate ? N = F.depth(M + 1) : N = F.depth(M),
        B[O++] = Math.floor(N / 256),
        B[O++] = N % 256
    }
    for (const F of E) {
        let N;
        T == CellType_1$1.CellType.MerkleProof || T == CellType_1$1.CellType.MerkleUpdate ? N = F.hash(M + 1) : N = F.hash(M),
        N.copy(B, O),
        O += 32
    }
    return B
}
descriptor.getRepr = getRepr;
var dist$3 = {}
  , sha256$9 = {}
  , sha$2 = {
    exports: {}
};
(function(C, S) {
    (function(E, M) {
        C.exports = M()
    }
    )(commonjsGlobal, function() {
        var E = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function M(je, $e, Ie, He) {
            var qe, Ne, at, Ye = $e || [0], it = (Ie = Ie || 0) >>> 3, At = He === -1 ? 3 : 0;
            for (qe = 0; qe < je.length; qe += 1)
                Ne = (at = qe + it) >>> 2,
                Ye.length <= Ne && Ye.push(0),
                Ye[Ne] |= je[qe] << 8 * (At + He * (at % 4));
            return {
                value: Ye,
                binLen: 8 * je.length + Ie
            }
        }
        function T(je, $e, Ie) {
            switch ($e) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
                break;
            default:
                throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")
            }
            switch (je) {
            case "HEX":
                return function(He, qe, Ne) {
                    return function(at, Ye, it, At) {
                        var pt, ut, Rt, yt;
                        if (at.length % 2 != 0)
                            throw new Error("String of HEX type must be in byte increments");
                        var st = Ye || [0]
                          , Wt = (it = it || 0) >>> 3
                          , Ct = At === -1 ? 3 : 0;
                        for (pt = 0; pt < at.length; pt += 2) {
                            if (ut = parseInt(at.substr(pt, 2), 16),
                            isNaN(ut))
                                throw new Error("String of HEX type contains invalid characters");
                            for (Rt = (yt = (pt >>> 1) + Wt) >>> 2; st.length <= Rt; )
                                st.push(0);
                            st[Rt] |= ut << 8 * (Ct + At * (yt % 4))
                        }
                        return {
                            value: st,
                            binLen: 4 * at.length + it
                        }
                    }(He, qe, Ne, Ie)
                }
                ;
            case "TEXT":
                return function(He, qe, Ne) {
                    return function(at, Ye, it, At, pt) {
                        var ut, Rt, yt, st, Wt, Ct, Mt, Kt, Pt = 0, St = it || [0], Zt = (At = At || 0) >>> 3;
                        if (Ye === "UTF8")
                            for (Mt = pt === -1 ? 3 : 0,
                            yt = 0; yt < at.length; yt += 1)
                                for (Rt = [],
                                128 > (ut = at.charCodeAt(yt)) ? Rt.push(ut) : 2048 > ut ? (Rt.push(192 | ut >>> 6),
                                Rt.push(128 | 63 & ut)) : 55296 > ut || 57344 <= ut ? Rt.push(224 | ut >>> 12, 128 | ut >>> 6 & 63, 128 | 63 & ut) : (yt += 1,
                                ut = 65536 + ((1023 & ut) << 10 | 1023 & at.charCodeAt(yt)),
                                Rt.push(240 | ut >>> 18, 128 | ut >>> 12 & 63, 128 | ut >>> 6 & 63, 128 | 63 & ut)),
                                st = 0; st < Rt.length; st += 1) {
                                    for (Wt = (Ct = Pt + Zt) >>> 2; St.length <= Wt; )
                                        St.push(0);
                                    St[Wt] |= Rt[st] << 8 * (Mt + pt * (Ct % 4)),
                                    Pt += 1
                                }
                        else
                            for (Mt = pt === -1 ? 2 : 0,
                            Kt = Ye === "UTF16LE" && pt !== 1 || Ye !== "UTF16LE" && pt === 1,
                            yt = 0; yt < at.length; yt += 1) {
                                for (ut = at.charCodeAt(yt),
                                Kt === !0 && (ut = (st = 255 & ut) << 8 | ut >>> 8),
                                Wt = (Ct = Pt + Zt) >>> 2; St.length <= Wt; )
                                    St.push(0);
                                St[Wt] |= ut << 8 * (Mt + pt * (Ct % 4)),
                                Pt += 2
                            }
                        return {
                            value: St,
                            binLen: 8 * Pt + At
                        }
                    }(He, $e, qe, Ne, Ie)
                }
                ;
            case "B64":
                return function(He, qe, Ne) {
                    return function(at, Ye, it, At) {
                        var pt, ut, Rt, yt, st, Wt, Ct = 0, Mt = Ye || [0], Kt = (it = it || 0) >>> 3, Pt = At === -1 ? 3 : 0, St = at.indexOf("=");
                        if (at.search(/^[a-zA-Z0-9=+/]+$/) === -1)
                            throw new Error("Invalid character in base-64 string");
                        if (at = at.replace(/=/g, ""),
                        St !== -1 && St < at.length)
                            throw new Error("Invalid '=' found in base-64 string");
                        for (pt = 0; pt < at.length; pt += 4) {
                            for (yt = at.substr(pt, 4),
                            Rt = 0,
                            ut = 0; ut < yt.length; ut += 1)
                                Rt |= E.indexOf(yt.charAt(ut)) << 18 - 6 * ut;
                            for (ut = 0; ut < yt.length - 1; ut += 1) {
                                for (st = (Wt = Ct + Kt) >>> 2; Mt.length <= st; )
                                    Mt.push(0);
                                Mt[st] |= (Rt >>> 16 - 8 * ut & 255) << 8 * (Pt + At * (Wt % 4)),
                                Ct += 1
                            }
                        }
                        return {
                            value: Mt,
                            binLen: 8 * Ct + it
                        }
                    }(He, qe, Ne, Ie)
                }
                ;
            case "BYTES":
                return function(He, qe, Ne) {
                    return function(at, Ye, it, At) {
                        var pt, ut, Rt, yt, st = Ye || [0], Wt = (it = it || 0) >>> 3, Ct = At === -1 ? 3 : 0;
                        for (ut = 0; ut < at.length; ut += 1)
                            pt = at.charCodeAt(ut),
                            Rt = (yt = ut + Wt) >>> 2,
                            st.length <= Rt && st.push(0),
                            st[Rt] |= pt << 8 * (Ct + At * (yt % 4));
                        return {
                            value: st,
                            binLen: 8 * at.length + it
                        }
                    }(He, qe, Ne, Ie)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(He, qe, Ne) {
                    return function(at, Ye, it, At) {
                        return M(new Uint8Array(at), Ye, it, At)
                    }(He, qe, Ne, Ie)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(He, qe, Ne) {
                    return M(He, qe, Ne, Ie)
                }
                ;
            default:
                throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        function $(je, $e, Ie, He) {
            switch (je) {
            case "HEX":
                return function(qe) {
                    return function(Ne, at, Ye, it) {
                        var At, pt, ut = "", Rt = at / 8, yt = Ye === -1 ? 3 : 0;
                        for (At = 0; At < Rt; At += 1)
                            pt = Ne[At >>> 2] >>> 8 * (yt + Ye * (At % 4)),
                            ut += "0123456789abcdef".charAt(pt >>> 4 & 15) + "0123456789abcdef".charAt(15 & pt);
                        return it.outputUpper ? ut.toUpperCase() : ut
                    }(qe, $e, Ie, He)
                }
                ;
            case "B64":
                return function(qe) {
                    return function(Ne, at, Ye, it) {
                        var At, pt, ut, Rt, yt, st = "", Wt = at / 8, Ct = Ye === -1 ? 3 : 0;
                        for (At = 0; At < Wt; At += 3)
                            for (Rt = At + 1 < Wt ? Ne[At + 1 >>> 2] : 0,
                            yt = At + 2 < Wt ? Ne[At + 2 >>> 2] : 0,
                            ut = (Ne[At >>> 2] >>> 8 * (Ct + Ye * (At % 4)) & 255) << 16 | (Rt >>> 8 * (Ct + Ye * ((At + 1) % 4)) & 255) << 8 | yt >>> 8 * (Ct + Ye * ((At + 2) % 4)) & 255,
                            pt = 0; pt < 4; pt += 1)
                                st += 8 * At + 6 * pt <= at ? E.charAt(ut >>> 6 * (3 - pt) & 63) : it.b64Pad;
                        return st
                    }(qe, $e, Ie, He)
                }
                ;
            case "BYTES":
                return function(qe) {
                    return function(Ne, at, Ye) {
                        var it, At, pt = "", ut = at / 8, Rt = Ye === -1 ? 3 : 0;
                        for (it = 0; it < ut; it += 1)
                            At = Ne[it >>> 2] >>> 8 * (Rt + Ye * (it % 4)) & 255,
                            pt += String.fromCharCode(At);
                        return pt
                    }(qe, $e, Ie)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(qe) {
                    return function(Ne, at, Ye) {
                        var it, At = at / 8, pt = new ArrayBuffer(At), ut = new Uint8Array(pt), Rt = Ye === -1 ? 3 : 0;
                        for (it = 0; it < At; it += 1)
                            ut[it] = Ne[it >>> 2] >>> 8 * (Rt + Ye * (it % 4)) & 255;
                        return pt
                    }(qe, $e, Ie)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(qe) {
                    return function(Ne, at, Ye) {
                        var it, At = at / 8, pt = Ye === -1 ? 3 : 0, ut = new Uint8Array(At);
                        for (it = 0; it < At; it += 1)
                            ut[it] = Ne[it >>> 2] >>> 8 * (pt + Ye * (it % 4)) & 255;
                        return ut
                    }(qe, $e, Ie)
                }
                ;
            default:
                throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        var B = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
          , O = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
          , F = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]
          , N = "Chosen SHA variant is not supported";
        function U(je, $e) {
            var Ie, He, qe = je.binLen >>> 3, Ne = $e.binLen >>> 3, at = qe << 3, Ye = 4 - qe << 3;
            if (qe % 4 != 0) {
                for (Ie = 0; Ie < Ne; Ie += 4)
                    He = qe + Ie >>> 2,
                    je.value[He] |= $e.value[Ie >>> 2] << at,
                    je.value.push(0),
                    je.value[He + 1] |= $e.value[Ie >>> 2] >>> Ye;
                return (je.value.length << 2) - 4 >= Ne + qe && je.value.pop(),
                {
                    value: je.value,
                    binLen: je.binLen + $e.binLen
                }
            }
            return {
                value: je.value.concat($e.value),
                binLen: je.binLen + $e.binLen
            }
        }
        function H(je) {
            var $e = {
                outputUpper: !1,
                b64Pad: "=",
                outputLen: -1
            }
              , Ie = je || {}
              , He = "Output length must be a multiple of 8";
            if ($e.outputUpper = Ie.outputUpper || !1,
            Ie.b64Pad && ($e.b64Pad = Ie.b64Pad),
            Ie.outputLen) {
                if (Ie.outputLen % 8 != 0)
                    throw new Error(He);
                $e.outputLen = Ie.outputLen
            } else if (Ie.shakeLen) {
                if (Ie.shakeLen % 8 != 0)
                    throw new Error(He);
                $e.outputLen = Ie.shakeLen
            }
            if (typeof $e.outputUpper != "boolean")
                throw new Error("Invalid outputUpper formatting option");
            if (typeof $e.b64Pad != "string")
                throw new Error("Invalid b64Pad formatting option");
            return $e
        }
        function Z(je, $e, Ie, He) {
            var qe = je + " must include a value and format";
            if (!$e) {
                if (!He)
                    throw new Error(qe);
                return He
            }
            if ($e.value === void 0 || !$e.format)
                throw new Error(qe);
            return T($e.format, $e.encoding || "UTF8", Ie)($e.value)
        }
        var J = function() {
            function je($e, Ie, He) {
                var qe = He || {};
                if (this.t = Ie,
                this.i = qe.encoding || "UTF8",
                this.numRounds = qe.numRounds || 1,
                isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
                    throw new Error("numRounds must a integer >= 1");
                this.o = $e,
                this.u = [],
                this.s = 0,
                this.h = !1,
                this.v = 0,
                this.A = !1,
                this.l = [],
                this.H = []
            }
            return je.prototype.update = function($e) {
                var Ie, He = 0, qe = this.S >>> 5, Ne = this.p($e, this.u, this.s), at = Ne.binLen, Ye = Ne.value, it = at >>> 5;
                for (Ie = 0; Ie < it; Ie += qe)
                    He + this.S <= at && (this.m = this.R(Ye.slice(Ie, Ie + qe), this.m),
                    He += this.S);
                this.v += He,
                this.u = Ye.slice(He >>> 5),
                this.s = at % this.S,
                this.h = !0
            }
            ,
            je.prototype.getHash = function($e, Ie) {
                var He, qe, Ne = this.U, at = H(Ie);
                if (this.T) {
                    if (at.outputLen === -1)
                        throw new Error("Output length must be specified in options");
                    Ne = at.outputLen
                }
                var Ye = $($e, Ne, this.C, at);
                if (this.A && this.F)
                    return Ye(this.F(at));
                for (qe = this.K(this.u.slice(), this.s, this.v, this.B(this.m), Ne),
                He = 1; He < this.numRounds; He += 1)
                    this.T && Ne % 32 != 0 && (qe[qe.length - 1] &= 16777215 >>> 24 - Ne % 32),
                    qe = this.K(qe, Ne, 0, this.L(this.o), Ne);
                return Ye(qe)
            }
            ,
            je.prototype.setHMACKey = function($e, Ie, He) {
                if (!this.g)
                    throw new Error("Variant does not support HMAC");
                if (this.h)
                    throw new Error("Cannot set MAC key after calling update");
                var qe = T(Ie, (He || {}).encoding || "UTF8", this.C);
                this.k(qe($e))
            }
            ,
            je.prototype.k = function($e) {
                var Ie, He = this.S >>> 3, qe = He / 4 - 1;
                if (this.numRounds !== 1)
                    throw new Error("Cannot set numRounds with MAC");
                if (this.A)
                    throw new Error("MAC key already set");
                for (He < $e.binLen / 8 && ($e.value = this.K($e.value, $e.binLen, 0, this.L(this.o), this.U)); $e.value.length <= qe; )
                    $e.value.push(0);
                for (Ie = 0; Ie <= qe; Ie += 1)
                    this.l[Ie] = 909522486 ^ $e.value[Ie],
                    this.H[Ie] = 1549556828 ^ $e.value[Ie];
                this.m = this.R(this.l, this.m),
                this.v = this.S,
                this.A = !0
            }
            ,
            je.prototype.getHMAC = function($e, Ie) {
                var He = H(Ie);
                return $($e, this.U, this.C, He)(this.Y())
            }
            ,
            je.prototype.Y = function() {
                var $e;
                if (!this.A)
                    throw new Error("Cannot call getHMAC without first setting MAC key");
                var Ie = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
                return $e = this.R(this.H, this.L(this.o)),
                $e = this.K(Ie, this.U, this.S, $e, this.U)
            }
            ,
            je
        }()
          , ie = function(je, $e) {
            return (ie = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(Ie, He) {
                Ie.__proto__ = He
            }
            || function(Ie, He) {
                for (var qe in He)
                    Object.prototype.hasOwnProperty.call(He, qe) && (Ie[qe] = He[qe])
            }
            )(je, $e)
        };
        function oe(je, $e) {
            function Ie() {
                this.constructor = je
            }
            ie(je, $e),
            je.prototype = $e === null ? Object.create($e) : (Ie.prototype = $e.prototype,
            new Ie)
        }
        function ae(je, $e) {
            return je << $e | je >>> 32 - $e
        }
        function se(je, $e) {
            return je >>> $e | je << 32 - $e
        }
        function le(je, $e) {
            return je >>> $e
        }
        function de(je, $e, Ie) {
            return je ^ $e ^ Ie
        }
        function fe(je, $e, Ie) {
            return je & $e ^ ~je & Ie
        }
        function pe(je, $e, Ie) {
            return je & $e ^ je & Ie ^ $e & Ie
        }
        function ge(je) {
            return se(je, 2) ^ se(je, 13) ^ se(je, 22)
        }
        function we(je, $e) {
            var Ie = (65535 & je) + (65535 & $e);
            return (65535 & (je >>> 16) + ($e >>> 16) + (Ie >>> 16)) << 16 | 65535 & Ie
        }
        function Ae(je, $e, Ie, He) {
            var qe = (65535 & je) + (65535 & $e) + (65535 & Ie) + (65535 & He);
            return (65535 & (je >>> 16) + ($e >>> 16) + (Ie >>> 16) + (He >>> 16) + (qe >>> 16)) << 16 | 65535 & qe
        }
        function Se(je, $e, Ie, He, qe) {
            var Ne = (65535 & je) + (65535 & $e) + (65535 & Ie) + (65535 & He) + (65535 & qe);
            return (65535 & (je >>> 16) + ($e >>> 16) + (Ie >>> 16) + (He >>> 16) + (qe >>> 16) + (Ne >>> 16)) << 16 | 65535 & Ne
        }
        function ue(je) {
            return se(je, 7) ^ se(je, 18) ^ le(je, 3)
        }
        function V(je) {
            return se(je, 6) ^ se(je, 11) ^ se(je, 25)
        }
        function W(je) {
            return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
        }
        function D(je, $e) {
            var Ie, He, qe, Ne, at, Ye, it, At = [];
            for (Ie = $e[0],
            He = $e[1],
            qe = $e[2],
            Ne = $e[3],
            at = $e[4],
            it = 0; it < 80; it += 1)
                At[it] = it < 16 ? je[it] : ae(At[it - 3] ^ At[it - 8] ^ At[it - 14] ^ At[it - 16], 1),
                Ye = it < 20 ? Se(ae(Ie, 5), fe(He, qe, Ne), at, 1518500249, At[it]) : it < 40 ? Se(ae(Ie, 5), de(He, qe, Ne), at, 1859775393, At[it]) : it < 60 ? Se(ae(Ie, 5), pe(He, qe, Ne), at, 2400959708, At[it]) : Se(ae(Ie, 5), de(He, qe, Ne), at, 3395469782, At[it]),
                at = Ne,
                Ne = qe,
                qe = ae(He, 30),
                He = Ie,
                Ie = Ye;
            return $e[0] = we(Ie, $e[0]),
            $e[1] = we(He, $e[1]),
            $e[2] = we(qe, $e[2]),
            $e[3] = we(Ne, $e[3]),
            $e[4] = we(at, $e[4]),
            $e
        }
        function I(je, $e, Ie, He) {
            for (var qe, Ne = 15 + ($e + 65 >>> 9 << 4), at = $e + Ie; je.length <= Ne; )
                je.push(0);
            for (je[$e >>> 5] |= 128 << 24 - $e % 32,
            je[Ne] = 4294967295 & at,
            je[Ne - 1] = at / 4294967296 | 0,
            qe = 0; qe < je.length; qe += 16)
                He = D(je.slice(qe, qe + 16), He);
            return He
        }
        var L = function(je) {
            function $e(Ie, He, qe) {
                var Ne = this;
                if (Ie !== "SHA-1")
                    throw new Error(N);
                var at = qe || {};
                return (Ne = je.call(this, Ie, He, qe) || this).g = !0,
                Ne.F = Ne.Y,
                Ne.C = -1,
                Ne.p = T(Ne.t, Ne.i, Ne.C),
                Ne.R = D,
                Ne.B = function(Ye) {
                    return Ye.slice()
                }
                ,
                Ne.L = W,
                Ne.K = I,
                Ne.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                Ne.S = 512,
                Ne.U = 160,
                Ne.T = !1,
                at.hmacKey && Ne.k(Z("hmacKey", at.hmacKey, Ne.C)),
                Ne
            }
            return oe($e, je),
            $e
        }(J);
        function K(je) {
            return je == "SHA-224" ? O.slice() : F.slice()
        }
        function X(je, $e) {
            var Ie, He, qe, Ne, at, Ye, it, At, pt, ut, Rt, yt, st = [];
            for (Ie = $e[0],
            He = $e[1],
            qe = $e[2],
            Ne = $e[3],
            at = $e[4],
            Ye = $e[5],
            it = $e[6],
            At = $e[7],
            Rt = 0; Rt < 64; Rt += 1)
                st[Rt] = Rt < 16 ? je[Rt] : Ae(se(yt = st[Rt - 2], 17) ^ se(yt, 19) ^ le(yt, 10), st[Rt - 7], ue(st[Rt - 15]), st[Rt - 16]),
                pt = Se(At, V(at), fe(at, Ye, it), B[Rt], st[Rt]),
                ut = we(ge(Ie), pe(Ie, He, qe)),
                At = it,
                it = Ye,
                Ye = at,
                at = we(Ne, pt),
                Ne = qe,
                qe = He,
                He = Ie,
                Ie = we(pt, ut);
            return $e[0] = we(Ie, $e[0]),
            $e[1] = we(He, $e[1]),
            $e[2] = we(qe, $e[2]),
            $e[3] = we(Ne, $e[3]),
            $e[4] = we(at, $e[4]),
            $e[5] = we(Ye, $e[5]),
            $e[6] = we(it, $e[6]),
            $e[7] = we(At, $e[7]),
            $e
        }
        var Y = function(je) {
            function $e(Ie, He, qe) {
                var Ne = this;
                if (Ie !== "SHA-224" && Ie !== "SHA-256")
                    throw new Error(N);
                var at = qe || {};
                return (Ne = je.call(this, Ie, He, qe) || this).F = Ne.Y,
                Ne.g = !0,
                Ne.C = -1,
                Ne.p = T(Ne.t, Ne.i, Ne.C),
                Ne.R = X,
                Ne.B = function(Ye) {
                    return Ye.slice()
                }
                ,
                Ne.L = K,
                Ne.K = function(Ye, it, At, pt) {
                    return function(ut, Rt, yt, st, Wt) {
                        for (var Ct, Mt = 15 + (Rt + 65 >>> 9 << 4), Kt = Rt + yt; ut.length <= Mt; )
                            ut.push(0);
                        for (ut[Rt >>> 5] |= 128 << 24 - Rt % 32,
                        ut[Mt] = 4294967295 & Kt,
                        ut[Mt - 1] = Kt / 4294967296 | 0,
                        Ct = 0; Ct < ut.length; Ct += 16)
                            st = X(ut.slice(Ct, Ct + 16), st);
                        return Wt === "SHA-224" ? [st[0], st[1], st[2], st[3], st[4], st[5], st[6]] : st
                    }(Ye, it, At, pt, Ie)
                }
                ,
                Ne.m = K(Ie),
                Ne.S = 512,
                Ne.U = Ie === "SHA-224" ? 224 : 256,
                Ne.T = !1,
                at.hmacKey && Ne.k(Z("hmacKey", at.hmacKey, Ne.C)),
                Ne
            }
            return oe($e, je),
            $e
        }(J)
          , j = function(je, $e) {
            this.N = je,
            this.I = $e
        };
        function G(je, $e) {
            var Ie;
            return $e > 32 ? (Ie = 64 - $e,
            new j(je.I << $e | je.N >>> Ie,je.N << $e | je.I >>> Ie)) : $e !== 0 ? (Ie = 32 - $e,
            new j(je.N << $e | je.I >>> Ie,je.I << $e | je.N >>> Ie)) : je
        }
        function ne(je, $e) {
            var Ie;
            return $e < 32 ? (Ie = 32 - $e,
            new j(je.N >>> $e | je.I << Ie,je.I >>> $e | je.N << Ie)) : (Ie = 64 - $e,
            new j(je.I >>> $e | je.N << Ie,je.N >>> $e | je.I << Ie))
        }
        function te(je, $e) {
            return new j(je.N >>> $e,je.I >>> $e | je.N << 32 - $e)
        }
        function ce(je, $e, Ie) {
            return new j(je.N & $e.N ^ ~je.N & Ie.N,je.I & $e.I ^ ~je.I & Ie.I)
        }
        function Ee(je, $e, Ie) {
            return new j(je.N & $e.N ^ je.N & Ie.N ^ $e.N & Ie.N,je.I & $e.I ^ je.I & Ie.I ^ $e.I & Ie.I)
        }
        function Re(je) {
            var $e = ne(je, 28)
              , Ie = ne(je, 34)
              , He = ne(je, 39);
            return new j($e.N ^ Ie.N ^ He.N,$e.I ^ Ie.I ^ He.I)
        }
        function Te(je, $e) {
            var Ie, He;
            Ie = (65535 & je.I) + (65535 & $e.I);
            var qe = (65535 & (He = (je.I >>> 16) + ($e.I >>> 16) + (Ie >>> 16))) << 16 | 65535 & Ie;
            return Ie = (65535 & je.N) + (65535 & $e.N) + (He >>> 16),
            He = (je.N >>> 16) + ($e.N >>> 16) + (Ie >>> 16),
            new j((65535 & He) << 16 | 65535 & Ie,qe)
        }
        function xe(je, $e, Ie, He) {
            var qe, Ne;
            qe = (65535 & je.I) + (65535 & $e.I) + (65535 & Ie.I) + (65535 & He.I);
            var at = (65535 & (Ne = (je.I >>> 16) + ($e.I >>> 16) + (Ie.I >>> 16) + (He.I >>> 16) + (qe >>> 16))) << 16 | 65535 & qe;
            return qe = (65535 & je.N) + (65535 & $e.N) + (65535 & Ie.N) + (65535 & He.N) + (Ne >>> 16),
            Ne = (je.N >>> 16) + ($e.N >>> 16) + (Ie.N >>> 16) + (He.N >>> 16) + (qe >>> 16),
            new j((65535 & Ne) << 16 | 65535 & qe,at)
        }
        function ve(je, $e, Ie, He, qe) {
            var Ne, at;
            Ne = (65535 & je.I) + (65535 & $e.I) + (65535 & Ie.I) + (65535 & He.I) + (65535 & qe.I);
            var Ye = (65535 & (at = (je.I >>> 16) + ($e.I >>> 16) + (Ie.I >>> 16) + (He.I >>> 16) + (qe.I >>> 16) + (Ne >>> 16))) << 16 | 65535 & Ne;
            return Ne = (65535 & je.N) + (65535 & $e.N) + (65535 & Ie.N) + (65535 & He.N) + (65535 & qe.N) + (at >>> 16),
            at = (je.N >>> 16) + ($e.N >>> 16) + (Ie.N >>> 16) + (He.N >>> 16) + (qe.N >>> 16) + (Ne >>> 16),
            new j((65535 & at) << 16 | 65535 & Ne,Ye)
        }
        function Me(je, $e) {
            return new j(je.N ^ $e.N,je.I ^ $e.I)
        }
        function Fe(je) {
            var $e = ne(je, 1)
              , Ie = ne(je, 8)
              , He = te(je, 7);
            return new j($e.N ^ Ie.N ^ He.N,$e.I ^ Ie.I ^ He.I)
        }
        function be(je) {
            var $e = ne(je, 14)
              , Ie = ne(je, 18)
              , He = ne(je, 41);
            return new j($e.N ^ Ie.N ^ He.N,$e.I ^ Ie.I ^ He.I)
        }
        var Ce = [new j(B[0],3609767458), new j(B[1],602891725), new j(B[2],3964484399), new j(B[3],2173295548), new j(B[4],4081628472), new j(B[5],3053834265), new j(B[6],2937671579), new j(B[7],3664609560), new j(B[8],2734883394), new j(B[9],1164996542), new j(B[10],1323610764), new j(B[11],3590304994), new j(B[12],4068182383), new j(B[13],991336113), new j(B[14],633803317), new j(B[15],3479774868), new j(B[16],2666613458), new j(B[17],944711139), new j(B[18],2341262773), new j(B[19],2007800933), new j(B[20],1495990901), new j(B[21],1856431235), new j(B[22],3175218132), new j(B[23],2198950837), new j(B[24],3999719339), new j(B[25],766784016), new j(B[26],2566594879), new j(B[27],3203337956), new j(B[28],1034457026), new j(B[29],2466948901), new j(B[30],3758326383), new j(B[31],168717936), new j(B[32],1188179964), new j(B[33],1546045734), new j(B[34],1522805485), new j(B[35],2643833823), new j(B[36],2343527390), new j(B[37],1014477480), new j(B[38],1206759142), new j(B[39],344077627), new j(B[40],1290863460), new j(B[41],3158454273), new j(B[42],3505952657), new j(B[43],106217008), new j(B[44],3606008344), new j(B[45],1432725776), new j(B[46],1467031594), new j(B[47],851169720), new j(B[48],3100823752), new j(B[49],1363258195), new j(B[50],3750685593), new j(B[51],3785050280), new j(B[52],3318307427), new j(B[53],3812723403), new j(B[54],2003034995), new j(B[55],3602036899), new j(B[56],1575990012), new j(B[57],1125592928), new j(B[58],2716904306), new j(B[59],442776044), new j(B[60],593698344), new j(B[61],3733110249), new j(B[62],2999351573), new j(B[63],3815920427), new j(3391569614,3928383900), new j(3515267271,566280711), new j(3940187606,3454069534), new j(4118630271,4000239992), new j(116418474,1914138554), new j(174292421,2731055270), new j(289380356,3203993006), new j(460393269,320620315), new j(685471733,587496836), new j(852142971,1086792851), new j(1017036298,365543100), new j(1126000580,2618297676), new j(1288033470,3409855158), new j(1501505948,4234509866), new j(1607167915,987167468), new j(1816402316,1246189591)];
        function ze(je) {
            return je === "SHA-384" ? [new j(3418070365,O[0]), new j(1654270250,O[1]), new j(2438529370,O[2]), new j(355462360,O[3]), new j(1731405415,O[4]), new j(41048885895,O[5]), new j(3675008525,O[6]), new j(1203062813,O[7])] : [new j(F[0],4089235720), new j(F[1],2227873595), new j(F[2],4271175723), new j(F[3],1595750129), new j(F[4],2917565137), new j(F[5],725511199), new j(F[6],4215389547), new j(F[7],327033209)]
        }
        function Ge(je, $e) {
            var Ie, He, qe, Ne, at, Ye, it, At, pt, ut, Rt, yt, st, Wt, Ct, Mt, Kt = [];
            for (Ie = $e[0],
            He = $e[1],
            qe = $e[2],
            Ne = $e[3],
            at = $e[4],
            Ye = $e[5],
            it = $e[6],
            At = $e[7],
            Rt = 0; Rt < 80; Rt += 1)
                Rt < 16 ? (yt = 2 * Rt,
                Kt[Rt] = new j(je[yt],je[yt + 1])) : Kt[Rt] = xe((st = Kt[Rt - 2],
                Wt = void 0,
                Ct = void 0,
                Mt = void 0,
                Wt = ne(st, 19),
                Ct = ne(st, 61),
                Mt = te(st, 6),
                new j(Wt.N ^ Ct.N ^ Mt.N,Wt.I ^ Ct.I ^ Mt.I)), Kt[Rt - 7], Fe(Kt[Rt - 15]), Kt[Rt - 16]),
                pt = ve(At, be(at), ce(at, Ye, it), Ce[Rt], Kt[Rt]),
                ut = Te(Re(Ie), Ee(Ie, He, qe)),
                At = it,
                it = Ye,
                Ye = at,
                at = Te(Ne, pt),
                Ne = qe,
                qe = He,
                He = Ie,
                Ie = Te(pt, ut);
            return $e[0] = Te(Ie, $e[0]),
            $e[1] = Te(He, $e[1]),
            $e[2] = Te(qe, $e[2]),
            $e[3] = Te(Ne, $e[3]),
            $e[4] = Te(at, $e[4]),
            $e[5] = Te(Ye, $e[5]),
            $e[6] = Te(it, $e[6]),
            $e[7] = Te(At, $e[7]),
            $e
        }
        var nt = function(je) {
            function $e(Ie, He, qe) {
                var Ne = this;
                if (Ie !== "SHA-384" && Ie !== "SHA-512")
                    throw new Error(N);
                var at = qe || {};
                return (Ne = je.call(this, Ie, He, qe) || this).F = Ne.Y,
                Ne.g = !0,
                Ne.C = -1,
                Ne.p = T(Ne.t, Ne.i, Ne.C),
                Ne.R = Ge,
                Ne.B = function(Ye) {
                    return Ye.slice()
                }
                ,
                Ne.L = ze,
                Ne.K = function(Ye, it, At, pt) {
                    return function(ut, Rt, yt, st, Wt) {
                        for (var Ct, Mt = 31 + (Rt + 129 >>> 10 << 5), Kt = Rt + yt; ut.length <= Mt; )
                            ut.push(0);
                        for (ut[Rt >>> 5] |= 128 << 24 - Rt % 32,
                        ut[Mt] = 4294967295 & Kt,
                        ut[Mt - 1] = Kt / 4294967296 | 0,
                        Ct = 0; Ct < ut.length; Ct += 32)
                            st = Ge(ut.slice(Ct, Ct + 32), st);
                        return Wt === "SHA-384" ? [(st = st)[0].N, st[0].I, st[1].N, st[1].I, st[2].N, st[2].I, st[3].N, st[3].I, st[4].N, st[4].I, st[5].N, st[5].I] : [st[0].N, st[0].I, st[1].N, st[1].I, st[2].N, st[2].I, st[3].N, st[3].I, st[4].N, st[4].I, st[5].N, st[5].I, st[6].N, st[6].I, st[7].N, st[7].I]
                    }(Ye, it, At, pt, Ie)
                }
                ,
                Ne.m = ze(Ie),
                Ne.S = 1024,
                Ne.U = Ie === "SHA-384" ? 384 : 512,
                Ne.T = !1,
                at.hmacKey && Ne.k(Z("hmacKey", at.hmacKey, Ne.C)),
                Ne
            }
            return oe($e, je),
            $e
        }(J)
          , bt = [new j(0,1), new j(0,32898), new j(2147483648,32906), new j(2147483648,2147516416), new j(0,32907), new j(0,2147483649), new j(2147483648,2147516545), new j(2147483648,32777), new j(0,138), new j(0,136), new j(0,2147516425), new j(0,2147483658), new j(0,2147516555), new j(2147483648,139), new j(2147483648,32905), new j(2147483648,32771), new j(2147483648,32770), new j(2147483648,128), new j(0,32778), new j(2147483648,2147483658), new j(2147483648,2147516545), new j(2147483648,32896), new j(0,2147483649), new j(2147483648,2147516424)]
          , ct = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function De(je) {
            var $e, Ie = [];
            for ($e = 0; $e < 5; $e += 1)
                Ie[$e] = [new j(0,0), new j(0,0), new j(0,0), new j(0,0), new j(0,0)];
            return Ie
        }
        function Ue(je) {
            var $e, Ie = [];
            for ($e = 0; $e < 5; $e += 1)
                Ie[$e] = je[$e].slice();
            return Ie
        }
        function We(je, $e) {
            var Ie, He, qe, Ne, at, Ye, it, At, pt, ut = [], Rt = [];
            if (je !== null)
                for (He = 0; He < je.length; He += 2)
                    $e[(He >>> 1) % 5][(He >>> 1) / 5 | 0] = Me($e[(He >>> 1) % 5][(He >>> 1) / 5 | 0], new j(je[He + 1],je[He]));
            for (Ie = 0; Ie < 24; Ie += 1) {
                for (Ne = De(),
                He = 0; He < 5; He += 1)
                    ut[He] = (at = $e[He][0],
                    Ye = $e[He][1],
                    it = $e[He][2],
                    At = $e[He][3],
                    pt = $e[He][4],
                    new j(at.N ^ Ye.N ^ it.N ^ At.N ^ pt.N,at.I ^ Ye.I ^ it.I ^ At.I ^ pt.I));
                for (He = 0; He < 5; He += 1)
                    Rt[He] = Me(ut[(He + 4) % 5], G(ut[(He + 1) % 5], 1));
                for (He = 0; He < 5; He += 1)
                    for (qe = 0; qe < 5; qe += 1)
                        $e[He][qe] = Me($e[He][qe], Rt[He]);
                for (He = 0; He < 5; He += 1)
                    for (qe = 0; qe < 5; qe += 1)
                        Ne[qe][(2 * He + 3 * qe) % 5] = G($e[He][qe], ct[He][qe]);
                for (He = 0; He < 5; He += 1)
                    for (qe = 0; qe < 5; qe += 1)
                        $e[He][qe] = Me(Ne[He][qe], new j(~Ne[(He + 1) % 5][qe].N & Ne[(He + 2) % 5][qe].N,~Ne[(He + 1) % 5][qe].I & Ne[(He + 2) % 5][qe].I));
                $e[0][0] = Me($e[0][0], bt[Ie])
            }
            return $e
        }
        function Xe(je) {
            var $e, Ie, He = 0, qe = [0, 0], Ne = [4294967295 & je, je / 4294967296 & 2097151];
            for ($e = 6; $e >= 0; $e--)
                (Ie = Ne[$e >> 2] >>> 8 * $e & 255) === 0 && He === 0 || (qe[He + 1 >> 2] |= Ie << 8 * (He + 1),
                He += 1);
            return He = He !== 0 ? He : 1,
            qe[0] |= He,
            {
                value: He + 1 > 4 ? qe : [qe[0]],
                binLen: 8 + 8 * He
            }
        }
        function ht(je) {
            return U(Xe(je.binLen), je)
        }
        function Je(je, $e) {
            var Ie, He = Xe($e), qe = $e >>> 2, Ne = (qe - (He = U(He, je)).value.length % qe) % qe;
            for (Ie = 0; Ie < Ne; Ie++)
                He.value.push(0);
            return He.value
        }
        var ot = function(je) {
            function $e(Ie, He, qe) {
                var Ne = this
                  , at = 6
                  , Ye = 0
                  , it = qe || {};
                if ((Ne = je.call(this, Ie, He, qe) || this).numRounds !== 1) {
                    if (it.kmacKey || it.hmacKey)
                        throw new Error("Cannot set numRounds with MAC");
                    if (Ne.o === "CSHAKE128" || Ne.o === "CSHAKE256")
                        throw new Error("Cannot set numRounds for CSHAKE variants")
                }
                switch (Ne.C = 1,
                Ne.p = T(Ne.t, Ne.i, Ne.C),
                Ne.R = We,
                Ne.B = Ue,
                Ne.L = De,
                Ne.m = De(),
                Ne.T = !1,
                Ie) {
                case "SHA3-224":
                    Ne.S = Ye = 1152,
                    Ne.U = 224,
                    Ne.g = !0,
                    Ne.F = Ne.Y;
                    break;
                case "SHA3-256":
                    Ne.S = Ye = 1088,
                    Ne.U = 256,
                    Ne.g = !0,
                    Ne.F = Ne.Y;
                    break;
                case "SHA3-384":
                    Ne.S = Ye = 832,
                    Ne.U = 384,
                    Ne.g = !0,
                    Ne.F = Ne.Y;
                    break;
                case "SHA3-512":
                    Ne.S = Ye = 576,
                    Ne.U = 512,
                    Ne.g = !0,
                    Ne.F = Ne.Y;
                    break;
                case "SHAKE128":
                    at = 31,
                    Ne.S = Ye = 1344,
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = null;
                    break;
                case "SHAKE256":
                    at = 31,
                    Ne.S = Ye = 1088,
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = null;
                    break;
                case "KMAC128":
                    at = 4,
                    Ne.S = Ye = 1344,
                    Ne.M(qe),
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = Ne.X;
                    break;
                case "KMAC256":
                    at = 4,
                    Ne.S = Ye = 1088,
                    Ne.M(qe),
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = Ne.X;
                    break;
                case "CSHAKE128":
                    Ne.S = Ye = 1344,
                    at = Ne.O(qe),
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = null;
                    break;
                case "CSHAKE256":
                    Ne.S = Ye = 1088,
                    at = Ne.O(qe),
                    Ne.U = -1,
                    Ne.T = !0,
                    Ne.g = !1,
                    Ne.F = null;
                    break;
                default:
                    throw new Error(N)
                }
                return Ne.K = function(At, pt, ut, Rt, yt) {
                    return function(st, Wt, Ct, Mt, Kt, Pt, St) {
                        var Zt, Nt, $t = 0, Gt = [], Ot = Kt >>> 5, Bt = Wt >>> 5;
                        for (Zt = 0; Zt < Bt && Wt >= Kt; Zt += Ot)
                            Mt = We(st.slice(Zt, Zt + Ot), Mt),
                            Wt -= Kt;
                        for (st = st.slice(Zt),
                        Wt %= Kt; st.length < Ot; )
                            st.push(0);
                        for (st[(Zt = Wt >>> 3) >> 2] ^= Pt << Zt % 4 * 8,
                        st[Ot - 1] ^= 2147483648,
                        Mt = We(st, Mt); 32 * Gt.length < St && (Nt = Mt[$t % 5][$t / 5 | 0],
                        Gt.push(Nt.I),
                        !(32 * Gt.length >= St)); )
                            Gt.push(Nt.N),
                            64 * ($t += 1) % Kt == 0 && (We(null, Mt),
                            $t = 0);
                        return Gt
                    }(At, pt, 0, Rt, Ye, at, yt)
                }
                ,
                it.hmacKey && Ne.k(Z("hmacKey", it.hmacKey, Ne.C)),
                Ne
            }
            return oe($e, je),
            $e.prototype.O = function(Ie, He) {
                var qe = function(it) {
                    var At = it || {};
                    return {
                        funcName: Z("funcName", At.funcName, 1, {
                            value: [],
                            binLen: 0
                        }),
                        customization: Z("Customization", At.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Ie || {});
                He && (qe.funcName = He);
                var Ne = U(ht(qe.funcName), ht(qe.customization));
                if (qe.customization.binLen !== 0 || qe.funcName.binLen !== 0) {
                    for (var at = Je(Ne, this.S >>> 3), Ye = 0; Ye < at.length; Ye += this.S >>> 5)
                        this.m = this.R(at.slice(Ye, Ye + (this.S >>> 5)), this.m),
                        this.v += this.S;
                    return 4
                }
                return 31
            }
            ,
            $e.prototype.M = function(Ie) {
                var He = function(at) {
                    var Ye = at || {};
                    return {
                        kmacKey: Z("kmacKey", Ye.kmacKey, 1),
                        funcName: {
                            value: [1128353099],
                            binLen: 32
                        },
                        customization: Z("Customization", Ye.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Ie || {});
                this.O(Ie, He.funcName);
                for (var qe = Je(ht(He.kmacKey), this.S >>> 3), Ne = 0; Ne < qe.length; Ne += this.S >>> 5)
                    this.m = this.R(qe.slice(Ne, Ne + (this.S >>> 5)), this.m),
                    this.v += this.S;
                this.A = !0
            }
            ,
            $e.prototype.X = function(Ie) {
                var He = U({
                    value: this.u.slice(),
                    binLen: this.s
                }, function(qe) {
                    var Ne, at, Ye = 0, it = [0, 0], At = [4294967295 & qe, qe / 4294967296 & 2097151];
                    for (Ne = 6; Ne >= 0; Ne--)
                        (at = At[Ne >> 2] >>> 8 * Ne & 255) == 0 && Ye === 0 || (it[Ye >> 2] |= at << 8 * Ye,
                        Ye += 1);
                    return it[(Ye = Ye !== 0 ? Ye : 1) >> 2] |= Ye << 8 * Ye,
                    {
                        value: Ye + 1 > 4 ? it : [it[0]],
                        binLen: 8 + 8 * Ye
                    }
                }(Ie.outputLen));
                return this.K(He.value, He.binLen, this.v, this.B(this.m), Ie.outputLen)
            }
            ,
            $e
        }(J);
        return function() {
            function je($e, Ie, He) {
                if ($e == "SHA-1")
                    this.j = new L($e,Ie,He);
                else if ($e == "SHA-224" || $e == "SHA-256")
                    this.j = new Y($e,Ie,He);
                else if ($e == "SHA-384" || $e == "SHA-512")
                    this.j = new nt($e,Ie,He);
                else {
                    if ($e != "SHA3-224" && $e != "SHA3-256" && $e != "SHA3-384" && $e != "SHA3-512" && $e != "SHAKE128" && $e != "SHAKE256" && $e != "CSHAKE128" && $e != "CSHAKE256" && $e != "KMAC128" && $e != "KMAC256")
                        throw new Error(N);
                    this.j = new ot($e,Ie,He)
                }
            }
            return je.prototype.update = function($e) {
                this.j.update($e)
            }
            ,
            je.prototype.getHash = function($e, Ie) {
                return this.j.getHash($e, Ie)
            }
            ,
            je.prototype.setHMACKey = function($e, Ie, He) {
                this.j.setHMACKey($e, Ie, He)
            }
            ,
            je.prototype.getHMAC = function($e, Ie) {
                return this.j.getHMAC($e, Ie)
            }
            ,
            je
        }()
    })
}
)(sha$2);
var shaExports = sha$2.exports
  , browser$f = {}
  , getSecureRandom$1 = {};
Object.defineProperty(getSecureRandom$1, "__esModule", {
    value: !0
});
getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
function getSecureRandomBytes$1(C) {
    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(C)))
}
getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes$1;
function getSecureRandomWords$1(C) {
    return window.crypto.getRandomValues(new Uint16Array(C))
}
getSecureRandom$1.getSecureRandomWords = getSecureRandomWords$1;
var hmac_sha512$3 = {};
Object.defineProperty(hmac_sha512$3, "__esModule", {
    value: !0
});
hmac_sha512$3.hmac_sha512 = void 0;
async function hmac_sha512$2(C, S) {
    let E = typeof C == "string" ? Buffer.from(C, "utf-8") : C
      , M = typeof S == "string" ? Buffer.from(S, "utf-8") : S;
    const T = {
        name: "HMAC",
        hash: "SHA-512"
    }
      , $ = await window.crypto.subtle.importKey("raw", E, T, !1, ["sign"]);
    return Buffer.from(await crypto.subtle.sign(T, $, M))
}
hmac_sha512$3.hmac_sha512 = hmac_sha512$2;
var pbkdf2_sha512$3 = {};
Object.defineProperty(pbkdf2_sha512$3, "__esModule", {
    value: !0
});
pbkdf2_sha512$3.pbkdf2_sha512 = void 0;
async function pbkdf2_sha512$2(C, S, E, M) {
    const T = typeof C == "string" ? Buffer.from(C, "utf-8") : C
      , $ = typeof S == "string" ? Buffer.from(S, "utf-8") : S
      , B = await window.crypto.subtle.importKey("raw", T, {
        name: "PBKDF2"
    }, !1, ["deriveBits"])
      , O = await window.crypto.subtle.deriveBits({
        name: "PBKDF2",
        hash: "SHA-512",
        salt: $,
        iterations: E
    }, B, M * 8);
    return Buffer.from(O)
}
pbkdf2_sha512$3.pbkdf2_sha512 = pbkdf2_sha512$2;
var sha256$8 = {};
Object.defineProperty(sha256$8, "__esModule", {
    value: !0
});
sha256$8.sha256 = void 0;
async function sha256$7(C) {
    return typeof C == "string" ? Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(C, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-256", C))
}
sha256$8.sha256 = sha256$7;
var sha512$5 = {};
Object.defineProperty(sha512$5, "__esModule", {
    value: !0
});
sha512$5.sha512 = void 0;
async function sha512$4(C) {
    return typeof C == "string" ? Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(C, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-512", C))
}
sha512$5.sha512 = sha512$4;
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.sha512 = C.sha256 = C.pbkdf2_sha512 = C.hmac_sha512 = C.getSecureRandomWords = C.getSecureRandomBytes = void 0;
    var S = getSecureRandom$1;
    Object.defineProperty(C, "getSecureRandomBytes", {
        enumerable: !0,
        get: function() {
            return S.getSecureRandomBytes
        }
    }),
    Object.defineProperty(C, "getSecureRandomWords", {
        enumerable: !0,
        get: function() {
            return S.getSecureRandomWords
        }
    });
    var E = hmac_sha512$3;
    Object.defineProperty(C, "hmac_sha512", {
        enumerable: !0,
        get: function() {
            return E.hmac_sha512
        }
    });
    var M = pbkdf2_sha512$3;
    Object.defineProperty(C, "pbkdf2_sha512", {
        enumerable: !0,
        get: function() {
            return M.pbkdf2_sha512
        }
    });
    var T = sha256$8;
    Object.defineProperty(C, "sha256", {
        enumerable: !0,
        get: function() {
            return T.sha256
        }
    });
    var $ = sha512$5;
    Object.defineProperty(C, "sha512", {
        enumerable: !0,
        get: function() {
            return $.sha512
        }
    })
}
)(browser$f);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(sha256$9, "__esModule", {
    value: !0
});
sha256$9.sha256 = sha256$9.sha256_fallback = sha256$9.sha256_sync = void 0;
const jssha_1$2 = __importDefault$7(shaExports)
  , crypto_primitives_1$4 = browser$f;
function sha256_sync(C) {
    let S;
    typeof C == "string" ? S = Buffer.from(C, "utf-8").toString("hex") : S = C.toString("hex");
    let E = new jssha_1$2.default("SHA-256","HEX");
    E.update(S);
    let M = E.getHash("HEX");
    return Buffer.from(M, "hex")
}
sha256$9.sha256_sync = sha256_sync;
async function sha256_fallback(C) {
    return sha256_sync(C)
}
sha256$9.sha256_fallback = sha256_fallback;
function sha256$6(C) {
    return (0,
    crypto_primitives_1$4.sha256)(C)
}
sha256$9.sha256 = sha256$6;
var sha512$3 = {}
  , __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(sha512$3, "__esModule", {
    value: !0
});
sha512$3.sha512 = sha512$3.sha512_fallback = sha512$3.sha512_sync = void 0;
const jssha_1$1 = __importDefault$6(shaExports)
  , crypto_primitives_1$3 = browser$f;
function sha512_sync(C) {
    let S;
    typeof C == "string" ? S = Buffer.from(C, "utf-8").toString("hex") : S = C.toString("hex");
    let E = new jssha_1$1.default("SHA-512","HEX");
    E.update(S);
    let M = E.getHash("HEX");
    return Buffer.from(M, "hex")
}
sha512$3.sha512_sync = sha512_sync;
async function sha512_fallback(C) {
    return sha512_sync(C)
}
sha512$3.sha512_fallback = sha512_fallback;
async function sha512$2(C) {
    return (0,
    crypto_primitives_1$3.sha512)(C)
}
sha512$3.sha512 = sha512$2;
var pbkdf2_sha512$1 = {};
Object.defineProperty(pbkdf2_sha512$1, "__esModule", {
    value: !0
});
pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
const crypto_primitives_1$2 = browser$f;
function pbkdf2_sha512(C, S, E, M) {
    return (0,
    crypto_primitives_1$2.pbkdf2_sha512)(C, S, E, M)
}
pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
var hmac_sha512$1 = {}
  , __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(hmac_sha512$1, "__esModule", {
    value: !0
});
hmac_sha512$1.hmac_sha512 = hmac_sha512$1.hmac_sha512_fallback = void 0;
const jssha_1 = __importDefault$5(shaExports)
  , crypto_primitives_1$1 = browser$f;
async function hmac_sha512_fallback(C, S) {
    let E = typeof C == "string" ? Buffer.from(C, "utf-8") : C
      , M = typeof S == "string" ? Buffer.from(S, "utf-8") : S;
    const T = new jssha_1.default("SHA-512","HEX",{
        hmacKey: {
            value: E.toString("hex"),
            format: "HEX"
        }
    });
    T.update(M.toString("hex"));
    const $ = T.getHash("HEX");
    return Buffer.from($, "hex")
}
hmac_sha512$1.hmac_sha512_fallback = hmac_sha512_fallback;
function hmac_sha512(C, S) {
    return (0,
    crypto_primitives_1$1.hmac_sha512)(C, S)
}
hmac_sha512$1.hmac_sha512 = hmac_sha512;
var getSecureRandom = {};
Object.defineProperty(getSecureRandom, "__esModule", {
    value: !0
});
getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
const crypto_primitives_1 = browser$f;
async function getSecureRandomBytes(C) {
    return (0,
    crypto_primitives_1.getSecureRandomBytes)(C)
}
getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
async function getSecureRandomWords(C) {
    return getSecureRandomWords()
}
getSecureRandom.getSecureRandomWords = getSecureRandomWords;
async function getSecureRandomNumber(C, S) {
    let E = S - C;
    var M = Math.ceil(Math.log2(E));
    if (M > 53)
        throw new Error("Range is too large");
    for (var T = Math.ceil(M / 8), $ = Math.pow(2, M) - 1; ; ) {
        let O = await getSecureRandomBytes(M)
          , F = (T - 1) * 8
          , N = 0;
        for (var B = 0; B < T; B++)
            N += O[B] * Math.pow(2, F),
            F -= 8;
        if (N = N & $,
        !(N >= E))
            return C + N
    }
}
getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
var newSecureWords$1 = {}
  , wordlist$1 = {};
Object.defineProperty(wordlist$1, "__esModule", {
    value: !0
});
wordlist$1.wordlist = void 0;
wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"];
Object.defineProperty(newSecureWords$1, "__esModule", {
    value: !0
});
newSecureWords$1.newSecureWords = void 0;
const getSecureRandom_1$1 = getSecureRandom
  , wordlist_1$1 = wordlist$1;
async function newSecureWords(C=6) {
    let S = [];
    for (let E = 0; E < C; E++)
        S.push(wordlist_1$1.wordlist[await (0,
        getSecureRandom_1$1.getSecureRandomNumber)(0, wordlist_1$1.wordlist.length)]);
    return S
}
newSecureWords$1.newSecureWords = newSecureWords;
var newSecurePassphrase = {}, hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
    if (hasRequiredNewSecurePassphrase)
        return newSecurePassphrase;
    hasRequiredNewSecurePassphrase = 1,
    Object.defineProperty(newSecurePassphrase, "__esModule", {
        value: !0
    }),
    newSecurePassphrase.newSecurePassphrase = void 0;
    const C = requireDist();
    async function S(E=6) {
        return (await (0,
        C.newSecureWords)(E)).join("-")
    }
    return newSecurePassphrase.newSecurePassphrase = S,
    newSecurePassphrase
}
var mnemonic = {};
function commonjsRequire(C) {
    throw new Error('Could not dynamically require "' + C + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
    exports: {}
}
  , cryptoBrowserify = {};
function getDefaultExportFromCjs(C) {
    return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, "default") ? C.default : C
}
var browser$e = {
    exports: {}
}, process = browser$e.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}
(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
}
)();
function runTimeout(C) {
    if (cachedSetTimeout === setTimeout)
        return setTimeout(C, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
        return cachedSetTimeout = setTimeout,
        setTimeout(C, 0);
    try {
        return cachedSetTimeout(C, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, C, 0)
        } catch {
            return cachedSetTimeout.call(this, C, 0)
        }
    }
}
function runClearTimeout(C) {
    if (cachedClearTimeout === clearTimeout)
        return clearTimeout(C);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
        return cachedClearTimeout = clearTimeout,
        clearTimeout(C);
    try {
        return cachedClearTimeout(C)
    } catch {
        try {
            return cachedClearTimeout.call(null, C)
        } catch {
            return cachedClearTimeout.call(this, C)
        }
    }
}
var queue$1 = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1,
    currentQueue.length ? queue$1 = currentQueue.concat(queue$1) : queueIndex = -1,
    queue$1.length && drainQueue())
}
function drainQueue() {
    if (!draining) {
        var C = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var S = queue$1.length; S; ) {
            for (currentQueue = queue$1,
            queue$1 = []; ++queueIndex < S; )
                currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1,
            S = queue$1.length
        }
        currentQueue = null,
        draining = !1,
        runClearTimeout(C)
    }
}
process.nextTick = function(C) {
    var S = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var E = 1; E < arguments.length; E++)
            S[E - 1] = arguments[E];
    queue$1.push(new Item(C,S)),
    queue$1.length === 1 && !draining && runTimeout(drainQueue)
}
;
function Item(C, S) {
    this.fun = C,
    this.array = S
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$4() {}
process.on = noop$4;
process.addListener = noop$4;
process.once = noop$4;
process.off = noop$4;
process.removeListener = noop$4;
process.removeAllListeners = noop$4;
process.emit = noop$4;
process.prependListener = noop$4;
process.prependOnceListener = noop$4;
process.listeners = function(C) {
    return []
}
;
process.binding = function(C) {
    throw new Error("process.binding is not supported")
}
;
process.cwd = function() {
    return "/"
}
;
process.chdir = function(C) {
    throw new Error("process.chdir is not supported")
}
;
process.umask = function() {
    return 0
}
;
var browserExports = browser$e.exports;
const process$1 = getDefaultExportFromCjs(browserExports);
var browser$d = {
    exports: {}
}
  , safeBuffer$1 = {
    exports: {}
};
const require$$0$2 = getAugmentedNamespace(dist$5);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
    return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1,
    function(C, S) {
        var E = require$$0$2
          , M = E.Buffer;
        function T(B, O) {
            for (var F in B)
                O[F] = B[F]
        }
        M.from && M.alloc && M.allocUnsafe && M.allocUnsafeSlow ? C.exports = E : (T(E, S),
        S.Buffer = $);
        function $(B, O, F) {
            return M(B, O, F)
        }
        $.prototype = Object.create(M.prototype),
        T(M, $),
        $.from = function(B, O, F) {
            if (typeof B == "number")
                throw new TypeError("Argument must not be a number");
            return M(B, O, F)
        }
        ,
        $.alloc = function(B, O, F) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            var N = M(B);
            return O !== void 0 ? typeof F == "string" ? N.fill(O, F) : N.fill(O) : N.fill(0),
            N
        }
        ,
        $.allocUnsafe = function(B) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            return M(B)
        }
        ,
        $.allocUnsafeSlow = function(B) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            return E.SlowBuffer(B)
        }
    }(safeBuffer$1, safeBuffer$1.exports)),
    safeBuffer$1.exports
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
    if (hasRequiredBrowser$b)
        return browser$d.exports;
    hasRequiredBrowser$b = 1;
    var C = 65536
      , S = 4294967295;
    function E() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
    }
    var M = requireSafeBuffer$1().Buffer
      , T = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
    T && T.getRandomValues ? browser$d.exports = $ : browser$d.exports = E;
    function $(B, O) {
        if (B > S)
            throw new RangeError("requested too many random bytes");
        var F = M.allocUnsafe(B);
        if (B > 0)
            if (B > C)
                for (var N = 0; N < B; N += C)
                    T.getRandomValues(F.slice(N, N + C));
            else
                T.getRandomValues(F);
        return typeof O == "function" ? process$1.nextTick(function() {
            O(null, F)
        }) : F
    }
    return browser$d.exports
}
var inherits_browser = {
    exports: {}
}, hasRequiredInherits_browser;
function requireInherits_browser() {
    return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1,
    typeof Object.create == "function" ? inherits_browser.exports = function(S, E) {
        E && (S.super_ = E,
        S.prototype = Object.create(E.prototype, {
            constructor: {
                value: S,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    }
    : inherits_browser.exports = function(S, E) {
        if (E) {
            S.super_ = E;
            var M = function() {};
            M.prototype = E.prototype,
            S.prototype = new M,
            S.prototype.constructor = S
        }
    }
    ),
    inherits_browser.exports
}
var readableBrowser$1 = {
    exports: {}
}, events = {
    exports: {}
}, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(S, E, M) {
    return Function.prototype.apply.call(S, E, M)
}
, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(S) {
    return Object.getOwnPropertyNames(S).concat(Object.getOwnPropertySymbols(S))
}
: ReflectOwnKeys = function(S) {
    return Object.getOwnPropertyNames(S)
}
;
function ProcessEmitWarning(C) {
    console && console.warn && console.warn(C)
}
var NumberIsNaN = Number.isNaN || function(S) {
    return S !== S
}
;
function EventEmitter() {
    EventEmitter.init.call(this)
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(C) {
    if (typeof C != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof C)
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return defaultMaxListeners
    },
    set: function(C) {
        if (typeof C != "number" || C < 0 || NumberIsNaN(C))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + C + ".");
        defaultMaxListeners = C
    }
});
EventEmitter.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
    this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
}
;
EventEmitter.prototype.setMaxListeners = function(S) {
    if (typeof S != "number" || S < 0 || NumberIsNaN(S))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + S + ".");
    return this._maxListeners = S,
    this
}
;
function _getMaxListeners(C) {
    return C._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : C._maxListeners
}
EventEmitter.prototype.getMaxListeners = function() {
    return _getMaxListeners(this)
}
;
EventEmitter.prototype.emit = function(S) {
    for (var E = [], M = 1; M < arguments.length; M++)
        E.push(arguments[M]);
    var T = S === "error"
      , $ = this._events;
    if ($ !== void 0)
        T = T && $.error === void 0;
    else if (!T)
        return !1;
    if (T) {
        var B;
        if (E.length > 0 && (B = E[0]),
        B instanceof Error)
            throw B;
        var O = new Error("Unhandled error." + (B ? " (" + B.message + ")" : ""));
        throw O.context = B,
        O
    }
    var F = $[S];
    if (F === void 0)
        return !1;
    if (typeof F == "function")
        ReflectApply(F, this, E);
    else
        for (var N = F.length, U = arrayClone(F, N), M = 0; M < N; ++M)
            ReflectApply(U[M], this, E);
    return !0
}
;
function _addListener(C, S, E, M) {
    var T, $, B;
    if (checkListener(E),
    $ = C._events,
    $ === void 0 ? ($ = C._events = Object.create(null),
    C._eventsCount = 0) : ($.newListener !== void 0 && (C.emit("newListener", S, E.listener ? E.listener : E),
    $ = C._events),
    B = $[S]),
    B === void 0)
        B = $[S] = E,
        ++C._eventsCount;
    else if (typeof B == "function" ? B = $[S] = M ? [E, B] : [B, E] : M ? B.unshift(E) : B.push(E),
    T = _getMaxListeners(C),
    T > 0 && B.length > T && !B.warned) {
        B.warned = !0;
        var O = new Error("Possible EventEmitter memory leak detected. " + B.length + " " + String(S) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        O.name = "MaxListenersExceededWarning",
        O.emitter = C,
        O.type = S,
        O.count = B.length,
        ProcessEmitWarning(O)
    }
    return C
}
EventEmitter.prototype.addListener = function(S, E) {
    return _addListener(this, S, E, !1)
}
;
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(S, E) {
    return _addListener(this, S, E, !0)
}
;
function onceWrapper() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn),
        this.fired = !0,
        arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function _onceWrap(C, S, E) {
    var M = {
        fired: !1,
        wrapFn: void 0,
        target: C,
        type: S,
        listener: E
    }
      , T = onceWrapper.bind(M);
    return T.listener = E,
    M.wrapFn = T,
    T
}
EventEmitter.prototype.once = function(S, E) {
    return checkListener(E),
    this.on(S, _onceWrap(this, S, E)),
    this
}
;
EventEmitter.prototype.prependOnceListener = function(S, E) {
    return checkListener(E),
    this.prependListener(S, _onceWrap(this, S, E)),
    this
}
;
EventEmitter.prototype.removeListener = function(S, E) {
    var M, T, $, B, O;
    if (checkListener(E),
    T = this._events,
    T === void 0)
        return this;
    if (M = T[S],
    M === void 0)
        return this;
    if (M === E || M.listener === E)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete T[S],
        T.removeListener && this.emit("removeListener", S, M.listener || E));
    else if (typeof M != "function") {
        for ($ = -1,
        B = M.length - 1; B >= 0; B--)
            if (M[B] === E || M[B].listener === E) {
                O = M[B].listener,
                $ = B;
                break
            }
        if ($ < 0)
            return this;
        $ === 0 ? M.shift() : spliceOne(M, $),
        M.length === 1 && (T[S] = M[0]),
        T.removeListener !== void 0 && this.emit("removeListener", S, O || E)
    }
    return this
}
;
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(S) {
    var E, M, T;
    if (M = this._events,
    M === void 0)
        return this;
    if (M.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null),
        this._eventsCount = 0) : M[S] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete M[S]),
        this;
    if (arguments.length === 0) {
        var $ = Object.keys(M), B;
        for (T = 0; T < $.length; ++T)
            B = $[T],
            B !== "removeListener" && this.removeAllListeners(B);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (E = M[S],
    typeof E == "function")
        this.removeListener(S, E);
    else if (E !== void 0)
        for (T = E.length - 1; T >= 0; T--)
            this.removeListener(S, E[T]);
    return this
}
;
function _listeners(C, S, E) {
    var M = C._events;
    if (M === void 0)
        return [];
    var T = M[S];
    return T === void 0 ? [] : typeof T == "function" ? E ? [T.listener || T] : [T] : E ? unwrapListeners(T) : arrayClone(T, T.length)
}
EventEmitter.prototype.listeners = function(S) {
    return _listeners(this, S, !0)
}
;
EventEmitter.prototype.rawListeners = function(S) {
    return _listeners(this, S, !1)
}
;
EventEmitter.listenerCount = function(C, S) {
    return typeof C.listenerCount == "function" ? C.listenerCount(S) : listenerCount.call(C, S)
}
;
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(C) {
    var S = this._events;
    if (S !== void 0) {
        var E = S[C];
        if (typeof E == "function")
            return 1;
        if (E !== void 0)
            return E.length
    }
    return 0
}
EventEmitter.prototype.eventNames = function() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
}
;
function arrayClone(C, S) {
    for (var E = new Array(S), M = 0; M < S; ++M)
        E[M] = C[M];
    return E
}
function spliceOne(C, S) {
    for (; S + 1 < C.length; S++)
        C[S] = C[S + 1];
    C.pop()
}
function unwrapListeners(C) {
    for (var S = new Array(C.length), E = 0; E < S.length; ++E)
        S[E] = C[E].listener || C[E];
    return S
}
function once(C, S) {
    return new Promise(function(E, M) {
        function T(B) {
            C.removeListener(S, $),
            M(B)
        }
        function $() {
            typeof C.removeListener == "function" && C.removeListener("error", T),
            E([].slice.call(arguments))
        }
        eventTargetAgnosticAddListener(C, S, $, {
            once: !0
        }),
        S !== "error" && addErrorHandlerIfEventEmitter(C, T, {
            once: !0
        })
    }
    )
}
function addErrorHandlerIfEventEmitter(C, S, E) {
    typeof C.on == "function" && eventTargetAgnosticAddListener(C, "error", S, E)
}
function eventTargetAgnosticAddListener(C, S, E, M) {
    if (typeof C.on == "function")
        M.once ? C.once(S, E) : C.on(S, E);
    else if (typeof C.addEventListener == "function")
        C.addEventListener(S, function T($) {
            M.once && C.removeEventListener(S, T),
            E($)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof C)
}
var eventsExports = events.exports;
const EventEmitter$1 = getDefaultExportFromCjs$1(eventsExports);
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
    return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1,
    streamBrowser$1 = eventsExports.EventEmitter),
    streamBrowser$1
}
var util$2 = {}, types$2 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
    return hasRequiredShams$1 || (hasRequiredShams$1 = 1,
    shams$1 = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return !1;
        if (typeof Symbol.iterator == "symbol")
            return !0;
        var S = {}
          , E = Symbol("test")
          , M = Object(E);
        if (typeof E == "string" || Object.prototype.toString.call(E) !== "[object Symbol]" || Object.prototype.toString.call(M) !== "[object Symbol]")
            return !1;
        var T = 42;
        S[E] = T;
        for (E in S)
            return !1;
        if (typeof Object.keys == "function" && Object.keys(S).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(S).length !== 0)
            return !1;
        var $ = Object.getOwnPropertySymbols(S);
        if ($.length !== 1 || $[0] !== E || !Object.prototype.propertyIsEnumerable.call(S, E))
            return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var B = Object.getOwnPropertyDescriptor(S, E);
            if (B.value !== T || B.enumerable !== !0)
                return !1
        }
        return !0
    }
    ),
    shams$1
}
var shams, hasRequiredShams;
function requireShams() {
    if (hasRequiredShams)
        return shams;
    hasRequiredShams = 1;
    var C = requireShams$1();
    return shams = function() {
        return C() && !!Symbol.toStringTag
    }
    ,
    shams
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
    return hasRequiredEsErrors || (hasRequiredEsErrors = 1,
    esErrors = Error),
    esErrors
}
var _eval, hasRequired_eval;
function require_eval() {
    return hasRequired_eval || (hasRequired_eval = 1,
    _eval = EvalError),
    _eval
}
var range$2, hasRequiredRange$1;
function requireRange$1() {
    return hasRequiredRange$1 || (hasRequiredRange$1 = 1,
    range$2 = RangeError),
    range$2
}
var ref, hasRequiredRef;
function requireRef() {
    return hasRequiredRef || (hasRequiredRef = 1,
    ref = ReferenceError),
    ref
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
    return hasRequiredSyntax || (hasRequiredSyntax = 1,
    syntax = SyntaxError),
    syntax
}
var type, hasRequiredType;
function requireType() {
    return hasRequiredType || (hasRequiredType = 1,
    type = TypeError),
    type
}
var uri, hasRequiredUri;
function requireUri() {
    return hasRequiredUri || (hasRequiredUri = 1,
    uri = URIError),
    uri
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
    if (hasRequiredHasSymbols)
        return hasSymbols;
    hasRequiredHasSymbols = 1;
    var C = typeof Symbol < "u" && Symbol
      , S = requireShams$1();
    return hasSymbols = function() {
        return typeof C != "function" || typeof Symbol != "function" || typeof C("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : S()
    }
    ,
    hasSymbols
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
    if (hasRequiredHasProto)
        return hasProto;
    hasRequiredHasProto = 1;
    var C = {
        __proto__: null,
        foo: {}
    }
      , S = Object;
    return hasProto = function() {
        return {
            __proto__: C
        }.foo === C.foo && !(C instanceof S)
    }
    ,
    hasProto
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
    if (hasRequiredImplementation)
        return implementation;
    hasRequiredImplementation = 1;
    var C = "Function.prototype.bind called on incompatible "
      , S = Object.prototype.toString
      , E = Math.max
      , M = "[object Function]"
      , T = function(F, N) {
        for (var U = [], H = 0; H < F.length; H += 1)
            U[H] = F[H];
        for (var Z = 0; Z < N.length; Z += 1)
            U[Z + F.length] = N[Z];
        return U
    }
      , $ = function(F, N) {
        for (var U = [], H = N || 0, Z = 0; H < F.length; H += 1,
        Z += 1)
            U[Z] = F[H];
        return U
    }
      , B = function(O, F) {
        for (var N = "", U = 0; U < O.length; U += 1)
            N += O[U],
            U + 1 < O.length && (N += F);
        return N
    };
    return implementation = function(F) {
        var N = this;
        if (typeof N != "function" || S.apply(N) !== M)
            throw new TypeError(C + N);
        for (var U = $(arguments, 1), H, Z = function() {
            if (this instanceof H) {
                var se = N.apply(this, T(U, arguments));
                return Object(se) === se ? se : this
            }
            return N.apply(F, T(U, arguments))
        }, J = E(0, N.length - U.length), ie = [], oe = 0; oe < J; oe++)
            ie[oe] = "$" + oe;
        if (H = Function("binder", "return function (" + B(ie, ",") + "){ return binder.apply(this,arguments); }")(Z),
        N.prototype) {
            var ae = function() {};
            ae.prototype = N.prototype,
            H.prototype = new ae,
            ae.prototype = null
        }
        return H
    }
    ,
    implementation
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
    if (hasRequiredFunctionBind)
        return functionBind;
    hasRequiredFunctionBind = 1;
    var C = requireImplementation();
    return functionBind = Function.prototype.bind || C,
    functionBind
}
var hasown, hasRequiredHasown;
function requireHasown() {
    if (hasRequiredHasown)
        return hasown;
    hasRequiredHasown = 1;
    var C = Function.prototype.call
      , S = Object.prototype.hasOwnProperty
      , E = requireFunctionBind();
    return hasown = E.call(C, S),
    hasown
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
        return getIntrinsic;
    hasRequiredGetIntrinsic = 1;
    var C, S = requireEsErrors(), E = require_eval(), M = requireRange$1(), T = requireRef(), $ = requireSyntax(), B = requireType(), O = requireUri(), F = Function, N = function(X) {
        try {
            return F('"use strict"; return (' + X + ").constructor;")()
        } catch {}
    }, U = Object.getOwnPropertyDescriptor;
    if (U)
        try {
            U({}, "")
        } catch {
            U = null
        }
    var H = function() {
        throw new B
    }
      , Z = U ? function() {
        try {
            return arguments.callee,
            H
        } catch {
            try {
                return U(arguments, "callee").get
            } catch {
                return H
            }
        }
    }() : H
      , J = requireHasSymbols()()
      , ie = requireHasProto()()
      , oe = Object.getPrototypeOf || (ie ? function(X) {
        return X.__proto__
    }
    : null)
      , ae = {}
      , se = typeof Uint8Array > "u" || !oe ? C : oe(Uint8Array)
      , le = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? C : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? C : ArrayBuffer,
        "%ArrayIteratorPrototype%": J && oe ? oe([][Symbol.iterator]()) : C,
        "%AsyncFromSyncIteratorPrototype%": C,
        "%AsyncFunction%": ae,
        "%AsyncGenerator%": ae,
        "%AsyncGeneratorFunction%": ae,
        "%AsyncIteratorPrototype%": ae,
        "%Atomics%": typeof Atomics > "u" ? C : Atomics,
        "%BigInt%": typeof BigInt > "u" ? C : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? C : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? C : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? C : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": S,
        "%eval%": eval,
        "%EvalError%": E,
        "%Float32Array%": typeof Float32Array > "u" ? C : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? C : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? C : FinalizationRegistry,
        "%Function%": F,
        "%GeneratorFunction%": ae,
        "%Int8Array%": typeof Int8Array > "u" ? C : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? C : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? C : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": J && oe ? oe(oe([][Symbol.iterator]())) : C,
        "%JSON%": typeof JSON == "object" ? JSON : C,
        "%Map%": typeof Map > "u" ? C : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !J || !oe ? C : oe(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? C : Promise,
        "%Proxy%": typeof Proxy > "u" ? C : Proxy,
        "%RangeError%": M,
        "%ReferenceError%": T,
        "%Reflect%": typeof Reflect > "u" ? C : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? C : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !J || !oe ? C : oe(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? C : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": J && oe ? oe(""[Symbol.iterator]()) : C,
        "%Symbol%": J ? Symbol : C,
        "%SyntaxError%": $,
        "%ThrowTypeError%": Z,
        "%TypedArray%": se,
        "%TypeError%": B,
        "%Uint8Array%": typeof Uint8Array > "u" ? C : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? C : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? C : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? C : Uint32Array,
        "%URIError%": O,
        "%WeakMap%": typeof WeakMap > "u" ? C : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? C : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? C : WeakSet
    };
    if (oe)
        try {
            null.error
        } catch (X) {
            var de = oe(oe(X));
            le["%Error.prototype%"] = de
        }
    var fe = function X(Y) {
        var j;
        if (Y === "%AsyncFunction%")
            j = N("async function () {}");
        else if (Y === "%GeneratorFunction%")
            j = N("function* () {}");
        else if (Y === "%AsyncGeneratorFunction%")
            j = N("async function* () {}");
        else if (Y === "%AsyncGenerator%") {
            var G = X("%AsyncGeneratorFunction%");
            G && (j = G.prototype)
        } else if (Y === "%AsyncIteratorPrototype%") {
            var ne = X("%AsyncGenerator%");
            ne && oe && (j = oe(ne.prototype))
        }
        return le[Y] = j,
        j
    }
      , pe = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , ge = requireFunctionBind()
      , we = requireHasown()
      , Ae = ge.call(Function.call, Array.prototype.concat)
      , Se = ge.call(Function.apply, Array.prototype.splice)
      , ue = ge.call(Function.call, String.prototype.replace)
      , V = ge.call(Function.call, String.prototype.slice)
      , W = ge.call(Function.call, RegExp.prototype.exec)
      , D = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , I = /\\(\\)?/g
      , L = function(Y) {
        var j = V(Y, 0, 1)
          , G = V(Y, -1);
        if (j === "%" && G !== "%")
            throw new $("invalid intrinsic syntax, expected closing `%`");
        if (G === "%" && j !== "%")
            throw new $("invalid intrinsic syntax, expected opening `%`");
        var ne = [];
        return ue(Y, D, function(te, ce, Ee, Re) {
            ne[ne.length] = Ee ? ue(Re, I, "$1") : ce || te
        }),
        ne
    }
      , K = function(Y, j) {
        var G = Y, ne;
        if (we(pe, G) && (ne = pe[G],
        G = "%" + ne[0] + "%"),
        we(le, G)) {
            var te = le[G];
            if (te === ae && (te = fe(G)),
            typeof te > "u" && !j)
                throw new B("intrinsic " + Y + " exists, but is not available. Please file an issue!");
            return {
                alias: ne,
                name: G,
                value: te
            }
        }
        throw new $("intrinsic " + Y + " does not exist!")
    };
    return getIntrinsic = function(Y, j) {
        if (typeof Y != "string" || Y.length === 0)
            throw new B("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof j != "boolean")
            throw new B('"allowMissing" argument must be a boolean');
        if (W(/^%?[^%]*%?$/, Y) === null)
            throw new $("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var G = L(Y)
          , ne = G.length > 0 ? G[0] : ""
          , te = K("%" + ne + "%", j)
          , ce = te.name
          , Ee = te.value
          , Re = !1
          , Te = te.alias;
        Te && (ne = Te[0],
        Se(G, Ae([0, 1], Te)));
        for (var xe = 1, ve = !0; xe < G.length; xe += 1) {
            var Me = G[xe]
              , Fe = V(Me, 0, 1)
              , be = V(Me, -1);
            if ((Fe === '"' || Fe === "'" || Fe === "`" || be === '"' || be === "'" || be === "`") && Fe !== be)
                throw new $("property names with quotes must have matching quotes");
            if ((Me === "constructor" || !ve) && (Re = !0),
            ne += "." + Me,
            ce = "%" + ne + "%",
            we(le, ce))
                Ee = le[ce];
            else if (Ee != null) {
                if (!(Me in Ee)) {
                    if (!j)
                        throw new B("base intrinsic for " + Y + " exists, but the property is not available.");
                    return
                }
                if (U && xe + 1 >= G.length) {
                    var Ce = U(Ee, Me);
                    ve = !!Ce,
                    ve && "get"in Ce && !("originalValue"in Ce.get) ? Ee = Ce.get : Ee = Ee[Me]
                } else
                    ve = we(Ee, Me),
                    Ee = Ee[Me];
                ve && !Re && (le[ce] = Ee)
            }
        }
        return Ee
    }
    ,
    getIntrinsic
}
var callBind = {
    exports: {}
}, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty)
        return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var C = requireGetIntrinsic()
      , S = C("%Object.defineProperty%", !0) || !1;
    if (S)
        try {
            S({}, "a", {
                value: 1
            })
        } catch {
            S = !1
        }
    return esDefineProperty = S,
    esDefineProperty
}
var gopd, hasRequiredGopd;
function requireGopd() {
    if (hasRequiredGopd)
        return gopd;
    hasRequiredGopd = 1;
    var C = requireGetIntrinsic()
      , S = C("%Object.getOwnPropertyDescriptor%", !0);
    if (S)
        try {
            S([], "length")
        } catch {
            S = null
        }
    return gopd = S,
    gopd
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
    if (hasRequiredDefineDataProperty)
        return defineDataProperty;
    hasRequiredDefineDataProperty = 1;
    var C = requireEsDefineProperty()
      , S = requireSyntax()
      , E = requireType()
      , M = requireGopd();
    return defineDataProperty = function($, B, O) {
        if (!$ || typeof $ != "object" && typeof $ != "function")
            throw new E("`obj` must be an object or a function`");
        if (typeof B != "string" && typeof B != "symbol")
            throw new E("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
            throw new E("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
            throw new E("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
            throw new E("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean")
            throw new E("`loose`, if provided, must be a boolean");
        var F = arguments.length > 3 ? arguments[3] : null
          , N = arguments.length > 4 ? arguments[4] : null
          , U = arguments.length > 5 ? arguments[5] : null
          , H = arguments.length > 6 ? arguments[6] : !1
          , Z = !!M && M($, B);
        if (C)
            C($, B, {
                configurable: U === null && Z ? Z.configurable : !U,
                enumerable: F === null && Z ? Z.enumerable : !F,
                value: O,
                writable: N === null && Z ? Z.writable : !N
            });
        else if (H || !F && !N && !U)
            $[B] = O;
        else
            throw new S("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    }
    ,
    defineDataProperty
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
    if (hasRequiredHasPropertyDescriptors)
        return hasPropertyDescriptors_1;
    hasRequiredHasPropertyDescriptors = 1;
    var C = requireEsDefineProperty()
      , S = function() {
        return !!C
    };
    return S.hasArrayLengthDefineBug = function() {
        if (!C)
            return null;
        try {
            return C([], "length", {
                value: 1
            }).length !== 1
        } catch {
            return !0
        }
    }
    ,
    hasPropertyDescriptors_1 = S,
    hasPropertyDescriptors_1
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
    if (hasRequiredSetFunctionLength)
        return setFunctionLength;
    hasRequiredSetFunctionLength = 1;
    var C = requireGetIntrinsic()
      , S = requireDefineDataProperty()
      , E = requireHasPropertyDescriptors()()
      , M = requireGopd()
      , T = requireType()
      , $ = C("%Math.floor%");
    return setFunctionLength = function(O, F) {
        if (typeof O != "function")
            throw new T("`fn` is not a function");
        if (typeof F != "number" || F < 0 || F > 4294967295 || $(F) !== F)
            throw new T("`length` must be a positive 32-bit integer");
        var N = arguments.length > 2 && !!arguments[2]
          , U = !0
          , H = !0;
        if ("length"in O && M) {
            var Z = M(O, "length");
            Z && !Z.configurable && (U = !1),
            Z && !Z.writable && (H = !1)
        }
        return (U || H || !N) && (E ? S(O, "length", F, !0, !0) : S(O, "length", F)),
        O
    }
    ,
    setFunctionLength
}
var hasRequiredCallBind;
function requireCallBind() {
    return hasRequiredCallBind || (hasRequiredCallBind = 1,
    function(C) {
        var S = requireFunctionBind()
          , E = requireGetIntrinsic()
          , M = requireSetFunctionLength()
          , T = requireType()
          , $ = E("%Function.prototype.apply%")
          , B = E("%Function.prototype.call%")
          , O = E("%Reflect.apply%", !0) || S.call(B, $)
          , F = requireEsDefineProperty()
          , N = E("%Math.max%");
        C.exports = function(Z) {
            if (typeof Z != "function")
                throw new T("a function is required");
            var J = O(S, B, arguments);
            return M(J, 1 + N(0, Z.length - (arguments.length - 1)), !0)
        }
        ;
        var U = function() {
            return O(S, $, arguments)
        };
        F ? F(C.exports, "apply", {
            value: U
        }) : C.exports.apply = U
    }(callBind)),
    callBind.exports
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
    if (hasRequiredCallBound)
        return callBound;
    hasRequiredCallBound = 1;
    var C = requireGetIntrinsic()
      , S = requireCallBind()
      , E = S(C("String.prototype.indexOf"));
    return callBound = function(T, $) {
        var B = C(T, !!$);
        return typeof B == "function" && E(T, ".prototype.") > -1 ? S(B) : B
    }
    ,
    callBound
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
    if (hasRequiredIsArguments)
        return isArguments;
    hasRequiredIsArguments = 1;
    var C = requireShams()()
      , S = requireCallBound()
      , E = S("Object.prototype.toString")
      , M = function(O) {
        return C && O && typeof O == "object" && Symbol.toStringTag in O ? !1 : E(O) === "[object Arguments]"
    }
      , T = function(O) {
        return M(O) ? !0 : O !== null && typeof O == "object" && typeof O.length == "number" && O.length >= 0 && E(O) !== "[object Array]" && E(O.callee) === "[object Function]"
    }
      , $ = function() {
        return M(arguments)
    }();
    return M.isLegacyArguments = T,
    isArguments = $ ? M : T,
    isArguments
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
    if (hasRequiredIsGeneratorFunction)
        return isGeneratorFunction;
    hasRequiredIsGeneratorFunction = 1;
    var C = Object.prototype.toString, S = Function.prototype.toString, E = /^\s*(?:function)?\*/, M = requireShams()(), T = Object.getPrototypeOf, $ = function() {
        if (!M)
            return !1;
        try {
            return Function("return function*() {}")()
        } catch {}
    }, B;
    return isGeneratorFunction = function(F) {
        if (typeof F != "function")
            return !1;
        if (E.test(S.call(F)))
            return !0;
        if (!M) {
            var N = C.call(F);
            return N === "[object GeneratorFunction]"
        }
        if (!T)
            return !1;
        if (typeof B > "u") {
            var U = $();
            B = U ? T(U) : !1
        }
        return T(F) === B
    }
    ,
    isGeneratorFunction
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
    if (hasRequiredIsCallable)
        return isCallable;
    hasRequiredIsCallable = 1;
    var C = Function.prototype.toString, S = typeof Reflect == "object" && Reflect !== null && Reflect.apply, E, M;
    if (typeof S == "function" && typeof Object.defineProperty == "function")
        try {
            E = Object.defineProperty({}, "length", {
                get: function() {
                    throw M
                }
            }),
            M = {},
            S(function() {
                throw 42
            }, null, E)
        } catch (le) {
            le !== M && (S = null)
        }
    else
        S = null;
    var T = /^\s*class\b/
      , $ = function(de) {
        try {
            var fe = C.call(de);
            return T.test(fe)
        } catch {
            return !1
        }
    }
      , B = function(de) {
        try {
            return $(de) ? !1 : (C.call(de),
            !0)
        } catch {
            return !1
        }
    }
      , O = Object.prototype.toString
      , F = "[object Object]"
      , N = "[object Function]"
      , U = "[object GeneratorFunction]"
      , H = "[object HTMLAllCollection]"
      , Z = "[object HTML document.all class]"
      , J = "[object HTMLCollection]"
      , ie = typeof Symbol == "function" && !!Symbol.toStringTag
      , oe = !(0 in [, ])
      , ae = function() {
        return !1
    };
    if (typeof document == "object") {
        var se = document.all;
        O.call(se) === O.call(document.all) && (ae = function(de) {
            if ((oe || !de) && (typeof de > "u" || typeof de == "object"))
                try {
                    var fe = O.call(de);
                    return (fe === H || fe === Z || fe === J || fe === F) && de("") == null
                } catch {}
            return !1
        }
        )
    }
    return isCallable = S ? function(de) {
        if (ae(de))
            return !0;
        if (!de || typeof de != "function" && typeof de != "object")
            return !1;
        try {
            S(de, null, E)
        } catch (fe) {
            if (fe !== M)
                return !1
        }
        return !$(de) && B(de)
    }
    : function(de) {
        if (ae(de))
            return !0;
        if (!de || typeof de != "function" && typeof de != "object")
            return !1;
        if (ie)
            return B(de);
        if ($(de))
            return !1;
        var fe = O.call(de);
        return fe !== N && fe !== U && !/^\[object HTML/.test(fe) ? !1 : B(de)
    }
    ,
    isCallable
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
    if (hasRequiredForEach)
        return forEach_1;
    hasRequiredForEach = 1;
    var C = requireIsCallable()
      , S = Object.prototype.toString
      , E = Object.prototype.hasOwnProperty
      , M = function(F, N, U) {
        for (var H = 0, Z = F.length; H < Z; H++)
            E.call(F, H) && (U == null ? N(F[H], H, F) : N.call(U, F[H], H, F))
    }
      , T = function(F, N, U) {
        for (var H = 0, Z = F.length; H < Z; H++)
            U == null ? N(F.charAt(H), H, F) : N.call(U, F.charAt(H), H, F)
    }
      , $ = function(F, N, U) {
        for (var H in F)
            E.call(F, H) && (U == null ? N(F[H], H, F) : N.call(U, F[H], H, F))
    }
      , B = function(F, N, U) {
        if (!C(N))
            throw new TypeError("iterator must be a function");
        var H;
        arguments.length >= 3 && (H = U),
        S.call(F) === "[object Array]" ? M(F, N, H) : typeof F == "string" ? T(F, N, H) : $(F, N, H)
    };
    return forEach_1 = B,
    forEach_1
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
    return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1,
    possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]),
    possibleTypedArrayNames
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
    if (hasRequiredAvailableTypedArrays)
        return availableTypedArrays;
    hasRequiredAvailableTypedArrays = 1;
    var C = requirePossibleTypedArrayNames()
      , S = typeof globalThis > "u" ? commonjsGlobal : globalThis;
    return availableTypedArrays = function() {
        for (var M = [], T = 0; T < C.length; T++)
            typeof S[C[T]] == "function" && (M[M.length] = C[T]);
        return M
    }
    ,
    availableTypedArrays
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
    if (hasRequiredWhichTypedArray)
        return whichTypedArray;
    hasRequiredWhichTypedArray = 1;
    var C = requireForEach()
      , S = requireAvailableTypedArrays()
      , E = requireCallBind()
      , M = requireCallBound()
      , T = requireGopd()
      , $ = M("Object.prototype.toString")
      , B = requireShams()()
      , O = typeof globalThis > "u" ? commonjsGlobal : globalThis
      , F = S()
      , N = M("String.prototype.slice")
      , U = Object.getPrototypeOf
      , H = M("Array.prototype.indexOf", !0) || function(ae, se) {
        for (var le = 0; le < ae.length; le += 1)
            if (ae[le] === se)
                return le;
        return -1
    }
      , Z = {
        __proto__: null
    };
    B && T && U ? C(F, function(oe) {
        var ae = new O[oe];
        if (Symbol.toStringTag in ae) {
            var se = U(ae)
              , le = T(se, Symbol.toStringTag);
            if (!le) {
                var de = U(se);
                le = T(de, Symbol.toStringTag)
            }
            Z["$" + oe] = E(le.get)
        }
    }) : C(F, function(oe) {
        var ae = new O[oe]
          , se = ae.slice || ae.set;
        se && (Z["$" + oe] = E(se))
    });
    var J = function(ae) {
        var se = !1;
        return C(Z, function(le, de) {
            if (!se)
                try {
                    "$" + le(ae) === de && (se = N(de, 1))
                } catch {}
        }),
        se
    }
      , ie = function(ae) {
        var se = !1;
        return C(Z, function(le, de) {
            if (!se)
                try {
                    le(ae),
                    se = N(de, 1)
                } catch {}
        }),
        se
    };
    return whichTypedArray = function(ae) {
        if (!ae || typeof ae != "object")
            return !1;
        if (!B) {
            var se = N($(ae), 8, -1);
            return H(F, se) > -1 ? se : se !== "Object" ? !1 : ie(ae)
        }
        return T ? J(ae) : null
    }
    ,
    whichTypedArray
}
var isTypedArray$1, hasRequiredIsTypedArray;
function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
        return isTypedArray$1;
    hasRequiredIsTypedArray = 1;
    var C = requireWhichTypedArray();
    return isTypedArray$1 = function(E) {
        return !!C(E)
    }
    ,
    isTypedArray$1
}
var hasRequiredTypes;
function requireTypes() {
    return hasRequiredTypes || (hasRequiredTypes = 1,
    function(C) {
        var S = requireIsArguments()
          , E = requireIsGeneratorFunction()
          , M = requireWhichTypedArray()
          , T = requireIsTypedArray();
        function $(Ue) {
            return Ue.call.bind(Ue)
        }
        var B = typeof BigInt < "u"
          , O = typeof Symbol < "u"
          , F = $(Object.prototype.toString)
          , N = $(Number.prototype.valueOf)
          , U = $(String.prototype.valueOf)
          , H = $(Boolean.prototype.valueOf);
        if (B)
            var Z = $(BigInt.prototype.valueOf);
        if (O)
            var J = $(Symbol.prototype.valueOf);
        function ie(Ue, We) {
            if (typeof Ue != "object")
                return !1;
            try {
                return We(Ue),
                !0
            } catch {
                return !1
            }
        }
        C.isArgumentsObject = S,
        C.isGeneratorFunction = E,
        C.isTypedArray = T;
        function oe(Ue) {
            return typeof Promise < "u" && Ue instanceof Promise || Ue !== null && typeof Ue == "object" && typeof Ue.then == "function" && typeof Ue.catch == "function"
        }
        C.isPromise = oe;
        function ae(Ue) {
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ue) : T(Ue) || ce(Ue)
        }
        C.isArrayBufferView = ae;
        function se(Ue) {
            return M(Ue) === "Uint8Array"
        }
        C.isUint8Array = se;
        function le(Ue) {
            return M(Ue) === "Uint8ClampedArray"
        }
        C.isUint8ClampedArray = le;
        function de(Ue) {
            return M(Ue) === "Uint16Array"
        }
        C.isUint16Array = de;
        function fe(Ue) {
            return M(Ue) === "Uint32Array"
        }
        C.isUint32Array = fe;
        function pe(Ue) {
            return M(Ue) === "Int8Array"
        }
        C.isInt8Array = pe;
        function ge(Ue) {
            return M(Ue) === "Int16Array"
        }
        C.isInt16Array = ge;
        function we(Ue) {
            return M(Ue) === "Int32Array"
        }
        C.isInt32Array = we;
        function Ae(Ue) {
            return M(Ue) === "Float32Array"
        }
        C.isFloat32Array = Ae;
        function Se(Ue) {
            return M(Ue) === "Float64Array"
        }
        C.isFloat64Array = Se;
        function ue(Ue) {
            return M(Ue) === "BigInt64Array"
        }
        C.isBigInt64Array = ue;
        function V(Ue) {
            return M(Ue) === "BigUint64Array"
        }
        C.isBigUint64Array = V;
        function W(Ue) {
            return F(Ue) === "[object Map]"
        }
        W.working = typeof Map < "u" && W(new Map);
        function D(Ue) {
            return typeof Map > "u" ? !1 : W.working ? W(Ue) : Ue instanceof Map
        }
        C.isMap = D;
        function I(Ue) {
            return F(Ue) === "[object Set]"
        }
        I.working = typeof Set < "u" && I(new Set);
        function L(Ue) {
            return typeof Set > "u" ? !1 : I.working ? I(Ue) : Ue instanceof Set
        }
        C.isSet = L;
        function K(Ue) {
            return F(Ue) === "[object WeakMap]"
        }
        K.working = typeof WeakMap < "u" && K(new WeakMap);
        function X(Ue) {
            return typeof WeakMap > "u" ? !1 : K.working ? K(Ue) : Ue instanceof WeakMap
        }
        C.isWeakMap = X;
        function Y(Ue) {
            return F(Ue) === "[object WeakSet]"
        }
        Y.working = typeof WeakSet < "u" && Y(new WeakSet);
        function j(Ue) {
            return Y(Ue)
        }
        C.isWeakSet = j;
        function G(Ue) {
            return F(Ue) === "[object ArrayBuffer]"
        }
        G.working = typeof ArrayBuffer < "u" && G(new ArrayBuffer);
        function ne(Ue) {
            return typeof ArrayBuffer > "u" ? !1 : G.working ? G(Ue) : Ue instanceof ArrayBuffer
        }
        C.isArrayBuffer = ne;
        function te(Ue) {
            return F(Ue) === "[object DataView]"
        }
        te.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && te(new DataView(new ArrayBuffer(1),0,1));
        function ce(Ue) {
            return typeof DataView > "u" ? !1 : te.working ? te(Ue) : Ue instanceof DataView
        }
        C.isDataView = ce;
        var Ee = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function Re(Ue) {
            return F(Ue) === "[object SharedArrayBuffer]"
        }
        function Te(Ue) {
            return typeof Ee > "u" ? !1 : (typeof Re.working > "u" && (Re.working = Re(new Ee)),
            Re.working ? Re(Ue) : Ue instanceof Ee)
        }
        C.isSharedArrayBuffer = Te;
        function xe(Ue) {
            return F(Ue) === "[object AsyncFunction]"
        }
        C.isAsyncFunction = xe;
        function ve(Ue) {
            return F(Ue) === "[object Map Iterator]"
        }
        C.isMapIterator = ve;
        function Me(Ue) {
            return F(Ue) === "[object Set Iterator]"
        }
        C.isSetIterator = Me;
        function Fe(Ue) {
            return F(Ue) === "[object Generator]"
        }
        C.isGeneratorObject = Fe;
        function be(Ue) {
            return F(Ue) === "[object WebAssembly.Module]"
        }
        C.isWebAssemblyCompiledModule = be;
        function Ce(Ue) {
            return ie(Ue, N)
        }
        C.isNumberObject = Ce;
        function ze(Ue) {
            return ie(Ue, U)
        }
        C.isStringObject = ze;
        function Ge(Ue) {
            return ie(Ue, H)
        }
        C.isBooleanObject = Ge;
        function nt(Ue) {
            return B && ie(Ue, Z)
        }
        C.isBigIntObject = nt;
        function bt(Ue) {
            return O && ie(Ue, J)
        }
        C.isSymbolObject = bt;
        function ct(Ue) {
            return Ce(Ue) || ze(Ue) || Ge(Ue) || nt(Ue) || bt(Ue)
        }
        C.isBoxedPrimitive = ct;
        function De(Ue) {
            return typeof Uint8Array < "u" && (ne(Ue) || Te(Ue))
        }
        C.isAnyArrayBuffer = De,
        ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ue) {
            Object.defineProperty(C, Ue, {
                enumerable: !1,
                value: function() {
                    throw new Error(Ue + " is not supported in userland")
                }
            })
        })
    }(types$2)),
    types$2
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
    return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1,
    isBufferBrowser = function(S) {
        return S && typeof S == "object" && typeof S.copy == "function" && typeof S.fill == "function" && typeof S.readUInt8 == "function"
    }
    ),
    isBufferBrowser
}
var hasRequiredUtil$1;
function requireUtil$1() {
    return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1,
    function(C) {
        var S = {}
          , E = Object.getOwnPropertyDescriptors || function(Ee) {
            for (var Re = Object.keys(Ee), Te = {}, xe = 0; xe < Re.length; xe++)
                Te[Re[xe]] = Object.getOwnPropertyDescriptor(Ee, Re[xe]);
            return Te
        }
          , M = /%[sdj%]/g;
        C.format = function(ce) {
            if (!ge(ce)) {
                for (var Ee = [], Re = 0; Re < arguments.length; Re++)
                    Ee.push(O(arguments[Re]));
                return Ee.join(" ")
            }
            for (var Re = 1, Te = arguments, xe = Te.length, ve = String(ce).replace(M, function(Fe) {
                if (Fe === "%%")
                    return "%";
                if (Re >= xe)
                    return Fe;
                switch (Fe) {
                case "%s":
                    return String(Te[Re++]);
                case "%d":
                    return Number(Te[Re++]);
                case "%j":
                    try {
                        return JSON.stringify(Te[Re++])
                    } catch {
                        return "[Circular]"
                    }
                default:
                    return Fe
                }
            }), Me = Te[Re]; Re < xe; Me = Te[++Re])
                de(Me) || !ue(Me) ? ve += " " + Me : ve += " " + O(Me);
            return ve
        }
        ,
        C.deprecate = function(ce, Ee) {
            if (typeof process$1 < "u" && process$1.noDeprecation === !0)
                return ce;
            if (typeof process$1 > "u")
                return function() {
                    return C.deprecate(ce, Ee).apply(this, arguments)
                }
                ;
            var Re = !1;
            function Te() {
                if (!Re) {
                    if (process$1.throwDeprecation)
                        throw new Error(Ee);
                    process$1.traceDeprecation ? console.trace(Ee) : console.error(Ee),
                    Re = !0
                }
                return ce.apply(this, arguments)
            }
            return Te
        }
        ;
        var T = {}
          , $ = /^$/;
        if (S.NODE_DEBUG) {
            var B = S.NODE_DEBUG;
            B = B.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(),
            $ = new RegExp("^" + B + "$","i")
        }
        C.debuglog = function(ce) {
            if (ce = ce.toUpperCase(),
            !T[ce])
                if ($.test(ce)) {
                    var Ee = process$1.pid;
                    T[ce] = function() {
                        var Re = C.format.apply(C, arguments);
                        console.error("%s %d: %s", ce, Ee, Re)
                    }
                } else
                    T[ce] = function() {}
                    ;
            return T[ce]
        }
        ;
        function O(ce, Ee) {
            var Re = {
                seen: [],
                stylize: N
            };
            return arguments.length >= 3 && (Re.depth = arguments[2]),
            arguments.length >= 4 && (Re.colors = arguments[3]),
            le(Ee) ? Re.showHidden = Ee : Ee && C._extend(Re, Ee),
            Ae(Re.showHidden) && (Re.showHidden = !1),
            Ae(Re.depth) && (Re.depth = 2),
            Ae(Re.colors) && (Re.colors = !1),
            Ae(Re.customInspect) && (Re.customInspect = !0),
            Re.colors && (Re.stylize = F),
            H(Re, ce, Re.depth)
        }
        C.inspect = O,
        O.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        },
        O.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        };
        function F(ce, Ee) {
            var Re = O.styles[Ee];
            return Re ? "\x1B[" + O.colors[Re][0] + "m" + ce + "\x1B[" + O.colors[Re][1] + "m" : ce
        }
        function N(ce, Ee) {
            return ce
        }
        function U(ce) {
            var Ee = {};
            return ce.forEach(function(Re, Te) {
                Ee[Re] = !0
            }),
            Ee
        }
        function H(ce, Ee, Re) {
            if (ce.customInspect && Ee && D(Ee.inspect) && Ee.inspect !== C.inspect && !(Ee.constructor && Ee.constructor.prototype === Ee)) {
                var Te = Ee.inspect(Re, ce);
                return ge(Te) || (Te = H(ce, Te, Re)),
                Te
            }
            var xe = Z(ce, Ee);
            if (xe)
                return xe;
            var ve = Object.keys(Ee)
              , Me = U(ve);
            if (ce.showHidden && (ve = Object.getOwnPropertyNames(Ee)),
            W(Ee) && (ve.indexOf("message") >= 0 || ve.indexOf("description") >= 0))
                return J(Ee);
            if (ve.length === 0) {
                if (D(Ee)) {
                    var Fe = Ee.name ? ": " + Ee.name : "";
                    return ce.stylize("[Function" + Fe + "]", "special")
                }
                if (Se(Ee))
                    return ce.stylize(RegExp.prototype.toString.call(Ee), "regexp");
                if (V(Ee))
                    return ce.stylize(Date.prototype.toString.call(Ee), "date");
                if (W(Ee))
                    return J(Ee)
            }
            var be = ""
              , Ce = !1
              , ze = ["{", "}"];
            if (se(Ee) && (Ce = !0,
            ze = ["[", "]"]),
            D(Ee)) {
                var Ge = Ee.name ? ": " + Ee.name : "";
                be = " [Function" + Ge + "]"
            }
            if (Se(Ee) && (be = " " + RegExp.prototype.toString.call(Ee)),
            V(Ee) && (be = " " + Date.prototype.toUTCString.call(Ee)),
            W(Ee) && (be = " " + J(Ee)),
            ve.length === 0 && (!Ce || Ee.length == 0))
                return ze[0] + be + ze[1];
            if (Re < 0)
                return Se(Ee) ? ce.stylize(RegExp.prototype.toString.call(Ee), "regexp") : ce.stylize("[Object]", "special");
            ce.seen.push(Ee);
            var nt;
            return Ce ? nt = ie(ce, Ee, Re, Me, ve) : nt = ve.map(function(bt) {
                return oe(ce, Ee, Re, Me, bt, Ce)
            }),
            ce.seen.pop(),
            ae(nt, be, ze)
        }
        function Z(ce, Ee) {
            if (Ae(Ee))
                return ce.stylize("undefined", "undefined");
            if (ge(Ee)) {
                var Re = "'" + JSON.stringify(Ee).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ce.stylize(Re, "string")
            }
            if (pe(Ee))
                return ce.stylize("" + Ee, "number");
            if (le(Ee))
                return ce.stylize("" + Ee, "boolean");
            if (de(Ee))
                return ce.stylize("null", "null")
        }
        function J(ce) {
            return "[" + Error.prototype.toString.call(ce) + "]"
        }
        function ie(ce, Ee, Re, Te, xe) {
            for (var ve = [], Me = 0, Fe = Ee.length; Me < Fe; ++Me)
                j(Ee, String(Me)) ? ve.push(oe(ce, Ee, Re, Te, String(Me), !0)) : ve.push("");
            return xe.forEach(function(be) {
                be.match(/^\d+$/) || ve.push(oe(ce, Ee, Re, Te, be, !0))
            }),
            ve
        }
        function oe(ce, Ee, Re, Te, xe, ve) {
            var Me, Fe, be;
            if (be = Object.getOwnPropertyDescriptor(Ee, xe) || {
                value: Ee[xe]
            },
            be.get ? be.set ? Fe = ce.stylize("[Getter/Setter]", "special") : Fe = ce.stylize("[Getter]", "special") : be.set && (Fe = ce.stylize("[Setter]", "special")),
            j(Te, xe) || (Me = "[" + xe + "]"),
            Fe || (ce.seen.indexOf(be.value) < 0 ? (de(Re) ? Fe = H(ce, be.value, null) : Fe = H(ce, be.value, Re - 1),
            Fe.indexOf(`
`) > -1 && (ve ? Fe = Fe.split(`
`).map(function(Ce) {
                return "  " + Ce
            }).join(`
`).slice(2) : Fe = `
` + Fe.split(`
`).map(function(Ce) {
                return "   " + Ce
            }).join(`
`))) : Fe = ce.stylize("[Circular]", "special")),
            Ae(Me)) {
                if (ve && xe.match(/^\d+$/))
                    return Fe;
                Me = JSON.stringify("" + xe),
                Me.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Me = Me.slice(1, -1),
                Me = ce.stylize(Me, "name")) : (Me = Me.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
                Me = ce.stylize(Me, "string"))
            }
            return Me + ": " + Fe
        }
        function ae(ce, Ee, Re) {
            var Te = ce.reduce(function(xe, ve) {
                return ve.indexOf(`
`) >= 0,
                xe + ve.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0);
            return Te > 60 ? Re[0] + (Ee === "" ? "" : Ee + `
 `) + " " + ce.join(`,
  `) + " " + Re[1] : Re[0] + Ee + " " + ce.join(", ") + " " + Re[1]
        }
        C.types = requireTypes();
        function se(ce) {
            return Array.isArray(ce)
        }
        C.isArray = se;
        function le(ce) {
            return typeof ce == "boolean"
        }
        C.isBoolean = le;
        function de(ce) {
            return ce === null
        }
        C.isNull = de;
        function fe(ce) {
            return ce == null
        }
        C.isNullOrUndefined = fe;
        function pe(ce) {
            return typeof ce == "number"
        }
        C.isNumber = pe;
        function ge(ce) {
            return typeof ce == "string"
        }
        C.isString = ge;
        function we(ce) {
            return typeof ce == "symbol"
        }
        C.isSymbol = we;
        function Ae(ce) {
            return ce === void 0
        }
        C.isUndefined = Ae;
        function Se(ce) {
            return ue(ce) && L(ce) === "[object RegExp]"
        }
        C.isRegExp = Se,
        C.types.isRegExp = Se;
        function ue(ce) {
            return typeof ce == "object" && ce !== null
        }
        C.isObject = ue;
        function V(ce) {
            return ue(ce) && L(ce) === "[object Date]"
        }
        C.isDate = V,
        C.types.isDate = V;
        function W(ce) {
            return ue(ce) && (L(ce) === "[object Error]" || ce instanceof Error)
        }
        C.isError = W,
        C.types.isNativeError = W;
        function D(ce) {
            return typeof ce == "function"
        }
        C.isFunction = D;
        function I(ce) {
            return ce === null || typeof ce == "boolean" || typeof ce == "number" || typeof ce == "string" || typeof ce == "symbol" || typeof ce > "u"
        }
        C.isPrimitive = I,
        C.isBuffer = requireIsBufferBrowser();
        function L(ce) {
            return Object.prototype.toString.call(ce)
        }
        function K(ce) {
            return ce < 10 ? "0" + ce.toString(10) : ce.toString(10)
        }
        var X = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function Y() {
            var ce = new Date
              , Ee = [K(ce.getHours()), K(ce.getMinutes()), K(ce.getSeconds())].join(":");
            return [ce.getDate(), X[ce.getMonth()], Ee].join(" ")
        }
        C.log = function() {
            console.log("%s - %s", Y(), C.format.apply(C, arguments))
        }
        ,
        C.inherits = requireInherits_browser(),
        C._extend = function(ce, Ee) {
            if (!Ee || !ue(Ee))
                return ce;
            for (var Re = Object.keys(Ee), Te = Re.length; Te--; )
                ce[Re[Te]] = Ee[Re[Te]];
            return ce
        }
        ;
        function j(ce, Ee) {
            return Object.prototype.hasOwnProperty.call(ce, Ee)
        }
        var G = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        C.promisify = function(Ee) {
            if (typeof Ee != "function")
                throw new TypeError('The "original" argument must be of type Function');
            if (G && Ee[G]) {
                var Re = Ee[G];
                if (typeof Re != "function")
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(Re, G, {
                    value: Re,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }),
                Re
            }
            function Re() {
                for (var Te, xe, ve = new Promise(function(be, Ce) {
                    Te = be,
                    xe = Ce
                }
                ), Me = [], Fe = 0; Fe < arguments.length; Fe++)
                    Me.push(arguments[Fe]);
                Me.push(function(be, Ce) {
                    be ? xe(be) : Te(Ce)
                });
                try {
                    Ee.apply(this, Me)
                } catch (be) {
                    xe(be)
                }
                return ve
            }
            return Object.setPrototypeOf(Re, Object.getPrototypeOf(Ee)),
            G && Object.defineProperty(Re, G, {
                value: Re,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }),
            Object.defineProperties(Re, E(Ee))
        }
        ,
        C.promisify.custom = G;
        function ne(ce, Ee) {
            if (!ce) {
                var Re = new Error("Promise was rejected with a falsy value");
                Re.reason = ce,
                ce = Re
            }
            return Ee(ce)
        }
        function te(ce) {
            if (typeof ce != "function")
                throw new TypeError('The "original" argument must be of type Function');
            function Ee() {
                for (var Re = [], Te = 0; Te < arguments.length; Te++)
                    Re.push(arguments[Te]);
                var xe = Re.pop();
                if (typeof xe != "function")
                    throw new TypeError("The last argument must be of type Function");
                var ve = this
                  , Me = function() {
                    return xe.apply(ve, arguments)
                };
                ce.apply(this, Re).then(function(Fe) {
                    process$1.nextTick(Me.bind(null, null, Fe))
                }, function(Fe) {
                    process$1.nextTick(ne.bind(null, Fe, Me))
                })
            }
            return Object.setPrototypeOf(Ee, Object.getPrototypeOf(ce)),
            Object.defineProperties(Ee, E(ce)),
            Ee
        }
        C.callbackify = te
    }(util$2)),
    util$2
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
    if (hasRequiredBuffer_list)
        return buffer_list;
    hasRequiredBuffer_list = 1;
    function C(ie, oe) {
        var ae = Object.keys(ie);
        if (Object.getOwnPropertySymbols) {
            var se = Object.getOwnPropertySymbols(ie);
            oe && (se = se.filter(function(le) {
                return Object.getOwnPropertyDescriptor(ie, le).enumerable
            })),
            ae.push.apply(ae, se)
        }
        return ae
    }
    function S(ie) {
        for (var oe = 1; oe < arguments.length; oe++) {
            var ae = arguments[oe] != null ? arguments[oe] : {};
            oe % 2 ? C(Object(ae), !0).forEach(function(se) {
                E(ie, se, ae[se])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ie, Object.getOwnPropertyDescriptors(ae)) : C(Object(ae)).forEach(function(se) {
                Object.defineProperty(ie, se, Object.getOwnPropertyDescriptor(ae, se))
            })
        }
        return ie
    }
    function E(ie, oe, ae) {
        return oe = B(oe),
        oe in ie ? Object.defineProperty(ie, oe, {
            value: ae,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : ie[oe] = ae,
        ie
    }
    function M(ie, oe) {
        if (!(ie instanceof oe))
            throw new TypeError("Cannot call a class as a function")
    }
    function T(ie, oe) {
        for (var ae = 0; ae < oe.length; ae++) {
            var se = oe[ae];
            se.enumerable = se.enumerable || !1,
            se.configurable = !0,
            "value"in se && (se.writable = !0),
            Object.defineProperty(ie, B(se.key), se)
        }
    }
    function $(ie, oe, ae) {
        return oe && T(ie.prototype, oe),
        ae && T(ie, ae),
        Object.defineProperty(ie, "prototype", {
            writable: !1
        }),
        ie
    }
    function B(ie) {
        var oe = O(ie, "string");
        return typeof oe == "symbol" ? oe : String(oe)
    }
    function O(ie, oe) {
        if (typeof ie != "object" || ie === null)
            return ie;
        var ae = ie[Symbol.toPrimitive];
        if (ae !== void 0) {
            var se = ae.call(ie, oe || "default");
            if (typeof se != "object")
                return se;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (oe === "string" ? String : Number)(ie)
    }
    var F = require$$0$2
      , N = F.Buffer
      , U = requireUtil$1()
      , H = U.inspect
      , Z = H && H.custom || "inspect";
    function J(ie, oe, ae) {
        N.prototype.copy.call(ie, oe, ae)
    }
    return buffer_list = function() {
        function ie() {
            M(this, ie),
            this.head = null,
            this.tail = null,
            this.length = 0
        }
        return $(ie, [{
            key: "push",
            value: function(ae) {
                var se = {
                    data: ae,
                    next: null
                };
                this.length > 0 ? this.tail.next = se : this.head = se,
                this.tail = se,
                ++this.length
            }
        }, {
            key: "unshift",
            value: function(ae) {
                var se = {
                    data: ae,
                    next: this.head
                };
                this.length === 0 && (this.tail = se),
                this.head = se,
                ++this.length
            }
        }, {
            key: "shift",
            value: function() {
                if (this.length !== 0) {
                    var ae = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    ae
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.head = this.tail = null,
                this.length = 0
            }
        }, {
            key: "join",
            value: function(ae) {
                if (this.length === 0)
                    return "";
                for (var se = this.head, le = "" + se.data; se = se.next; )
                    le += ae + se.data;
                return le
            }
        }, {
            key: "concat",
            value: function(ae) {
                if (this.length === 0)
                    return N.alloc(0);
                for (var se = N.allocUnsafe(ae >>> 0), le = this.head, de = 0; le; )
                    J(le.data, se, de),
                    de += le.data.length,
                    le = le.next;
                return se
            }
        }, {
            key: "consume",
            value: function(ae, se) {
                var le;
                return ae < this.head.data.length ? (le = this.head.data.slice(0, ae),
                this.head.data = this.head.data.slice(ae)) : ae === this.head.data.length ? le = this.shift() : le = se ? this._getString(ae) : this._getBuffer(ae),
                le
            }
        }, {
            key: "first",
            value: function() {
                return this.head.data
            }
        }, {
            key: "_getString",
            value: function(ae) {
                var se = this.head
                  , le = 1
                  , de = se.data;
                for (ae -= de.length; se = se.next; ) {
                    var fe = se.data
                      , pe = ae > fe.length ? fe.length : ae;
                    if (pe === fe.length ? de += fe : de += fe.slice(0, ae),
                    ae -= pe,
                    ae === 0) {
                        pe === fe.length ? (++le,
                        se.next ? this.head = se.next : this.head = this.tail = null) : (this.head = se,
                        se.data = fe.slice(pe));
                        break
                    }
                    ++le
                }
                return this.length -= le,
                de
            }
        }, {
            key: "_getBuffer",
            value: function(ae) {
                var se = N.allocUnsafe(ae)
                  , le = this.head
                  , de = 1;
                for (le.data.copy(se),
                ae -= le.data.length; le = le.next; ) {
                    var fe = le.data
                      , pe = ae > fe.length ? fe.length : ae;
                    if (fe.copy(se, se.length - ae, 0, pe),
                    ae -= pe,
                    ae === 0) {
                        pe === fe.length ? (++de,
                        le.next ? this.head = le.next : this.head = this.tail = null) : (this.head = le,
                        le.data = fe.slice(pe));
                        break
                    }
                    ++de
                }
                return this.length -= de,
                se
            }
        }, {
            key: Z,
            value: function(ae, se) {
                return H(this, S(S({}, se), {}, {
                    depth: 0,
                    customInspect: !1
                }))
            }
        }]),
        ie
    }(),
    buffer_list
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
    if (hasRequiredDestroy$1)
        return destroy_1$1;
    hasRequiredDestroy$1 = 1;
    function C(B, O) {
        var F = this
          , N = this._readableState && this._readableState.destroyed
          , U = this._writableState && this._writableState.destroyed;
        return N || U ? (O ? O(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        process$1.nextTick(T, this, B)) : process$1.nextTick(T, this, B)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(B || null, function(H) {
            !O && H ? F._writableState ? F._writableState.errorEmitted ? process$1.nextTick(E, F) : (F._writableState.errorEmitted = !0,
            process$1.nextTick(S, F, H)) : process$1.nextTick(S, F, H) : O ? (process$1.nextTick(E, F),
            O(H)) : process$1.nextTick(E, F)
        }),
        this)
    }
    function S(B, O) {
        T(B, O),
        E(B)
    }
    function E(B) {
        B._writableState && !B._writableState.emitClose || B._readableState && !B._readableState.emitClose || B.emit("close")
    }
    function M() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function T(B, O) {
        B.emit("error", O)
    }
    function $(B, O) {
        var F = B._readableState
          , N = B._writableState;
        F && F.autoDestroy || N && N.autoDestroy ? B.destroy(O) : B.emit("error", O)
    }
    return destroy_1$1 = {
        destroy: C,
        undestroy: M,
        errorOrDestroy: $
    },
    destroy_1$1
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
    if (hasRequiredErrorsBrowser)
        return errorsBrowser;
    hasRequiredErrorsBrowser = 1;
    function C(O, F) {
        O.prototype = Object.create(F.prototype),
        O.prototype.constructor = O,
        O.__proto__ = F
    }
    var S = {};
    function E(O, F, N) {
        N || (N = Error);
        function U(Z, J, ie) {
            return typeof F == "string" ? F : F(Z, J, ie)
        }
        var H = function(Z) {
            C(J, Z);
            function J(ie, oe, ae) {
                return Z.call(this, U(ie, oe, ae)) || this
            }
            return J
        }(N);
        H.prototype.name = N.name,
        H.prototype.code = O,
        S[O] = H
    }
    function M(O, F) {
        if (Array.isArray(O)) {
            var N = O.length;
            return O = O.map(function(U) {
                return String(U)
            }),
            N > 2 ? "one of ".concat(F, " ").concat(O.slice(0, N - 1).join(", "), ", or ") + O[N - 1] : N === 2 ? "one of ".concat(F, " ").concat(O[0], " or ").concat(O[1]) : "of ".concat(F, " ").concat(O[0])
        } else
            return "of ".concat(F, " ").concat(String(O))
    }
    function T(O, F, N) {
        return O.substr(!N || N < 0 ? 0 : +N, F.length) === F
    }
    function $(O, F, N) {
        return (N === void 0 || N > O.length) && (N = O.length),
        O.substring(N - F.length, N) === F
    }
    function B(O, F, N) {
        return typeof N != "number" && (N = 0),
        N + F.length > O.length ? !1 : O.indexOf(F, N) !== -1
    }
    return E("ERR_INVALID_OPT_VALUE", function(O, F) {
        return 'The value "' + F + '" is invalid for option "' + O + '"'
    }, TypeError),
    E("ERR_INVALID_ARG_TYPE", function(O, F, N) {
        var U;
        typeof F == "string" && T(F, "not ") ? (U = "must not be",
        F = F.replace(/^not /, "")) : U = "must be";
        var H;
        if ($(O, " argument"))
            H = "The ".concat(O, " ").concat(U, " ").concat(M(F, "type"));
        else {
            var Z = B(O, ".") ? "property" : "argument";
            H = 'The "'.concat(O, '" ').concat(Z, " ").concat(U, " ").concat(M(F, "type"))
        }
        return H += ". Received type ".concat(typeof N),
        H
    }, TypeError),
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
    E("ERR_METHOD_NOT_IMPLEMENTED", function(O) {
        return "The " + O + " method is not implemented"
    }),
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
    E("ERR_STREAM_DESTROYED", function(O) {
        return "Cannot call " + O + " after a stream was destroyed"
    }),
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
    E("ERR_STREAM_WRITE_AFTER_END", "write after end"),
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError),
    E("ERR_UNKNOWN_ENCODING", function(O) {
        return "Unknown encoding: " + O
    }, TypeError),
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"),
    errorsBrowser.codes = S,
    errorsBrowser
}
var state, hasRequiredState;
function requireState() {
    if (hasRequiredState)
        return state;
    hasRequiredState = 1;
    var C = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
    function S(M, T, $) {
        return M.highWaterMark != null ? M.highWaterMark : T ? M[$] : null
    }
    function E(M, T, $, B) {
        var O = S(T, B, $);
        if (O != null) {
            if (!(isFinite(O) && Math.floor(O) === O) || O < 0) {
                var F = B ? $ : "highWaterMark";
                throw new C(F,O)
            }
            return Math.floor(O)
        }
        return M.objectMode ? 16 : 16 * 1024
    }
    return state = {
        getHighWaterMark: E
    },
    state
}
var browser$c, hasRequiredBrowser$a;
function requireBrowser$a() {
    if (hasRequiredBrowser$a)
        return browser$c;
    hasRequiredBrowser$a = 1,
    browser$c = C;
    function C(E, M) {
        if (S("noDeprecation"))
            return E;
        var T = !1;
        function $() {
            if (!T) {
                if (S("throwDeprecation"))
                    throw new Error(M);
                S("traceDeprecation") ? console.trace(M) : console.warn(M),
                T = !0
            }
            return E.apply(this, arguments)
        }
        return $
    }
    function S(E) {
        try {
            if (!commonjsGlobal.localStorage)
                return !1
        } catch {
            return !1
        }
        var M = commonjsGlobal.localStorage[E];
        return M == null ? !1 : String(M).toLowerCase() === "true"
    }
    return browser$c
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
    if (hasRequired_stream_writable$1)
        return _stream_writable$1;
    hasRequired_stream_writable$1 = 1,
    _stream_writable$1 = Ae;
    function C(Te) {
        var xe = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            Re(xe, Te)
        }
    }
    var S;
    Ae.WritableState = ge;
    var E = {
        deprecate: requireBrowser$a()
    }
      , M = requireStreamBrowser$1()
      , T = require$$0$2.Buffer
      , $ = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function B(Te) {
        return T.from(Te)
    }
    function O(Te) {
        return T.isBuffer(Te) || Te instanceof $
    }
    var F = requireDestroy$1()
      , N = requireState()
      , U = N.getHighWaterMark
      , H = requireErrorsBrowser().codes
      , Z = H.ERR_INVALID_ARG_TYPE
      , J = H.ERR_METHOD_NOT_IMPLEMENTED
      , ie = H.ERR_MULTIPLE_CALLBACK
      , oe = H.ERR_STREAM_CANNOT_PIPE
      , ae = H.ERR_STREAM_DESTROYED
      , se = H.ERR_STREAM_NULL_VALUES
      , le = H.ERR_STREAM_WRITE_AFTER_END
      , de = H.ERR_UNKNOWN_ENCODING
      , fe = F.errorOrDestroy;
    requireInherits_browser()(Ae, M);
    function pe() {}
    function ge(Te, xe, ve) {
        S = S || require_stream_duplex$1(),
        Te = Te || {},
        typeof ve != "boolean" && (ve = xe instanceof S),
        this.objectMode = !!Te.objectMode,
        ve && (this.objectMode = this.objectMode || !!Te.writableObjectMode),
        this.highWaterMark = U(this, Te, "writableHighWaterMark", ve),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var Me = Te.decodeStrings === !1;
        this.decodeStrings = !Me,
        this.defaultEncoding = Te.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function(Fe) {
            K(xe, Fe)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.emitClose = Te.emitClose !== !1,
        this.autoDestroy = !!Te.autoDestroy,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new C(this)
    }
    ge.prototype.getBuffer = function() {
        for (var xe = this.bufferedRequest, ve = []; xe; )
            ve.push(xe),
            xe = xe.next;
        return ve
    }
    ,
    function() {
        try {
            Object.defineProperty(ge.prototype, "buffer", {
                get: E.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var we;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (we = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(Ae, Symbol.hasInstance, {
        value: function(xe) {
            return we.call(this, xe) ? !0 : this !== Ae ? !1 : xe && xe._writableState instanceof ge
        }
    })) : we = function(xe) {
        return xe instanceof this
    }
    ;
    function Ae(Te) {
        S = S || require_stream_duplex$1();
        var xe = this instanceof S;
        if (!xe && !we.call(Ae, this))
            return new Ae(Te);
        this._writableState = new ge(Te,this,xe),
        this.writable = !0,
        Te && (typeof Te.write == "function" && (this._write = Te.write),
        typeof Te.writev == "function" && (this._writev = Te.writev),
        typeof Te.destroy == "function" && (this._destroy = Te.destroy),
        typeof Te.final == "function" && (this._final = Te.final)),
        M.call(this)
    }
    Ae.prototype.pipe = function() {
        fe(this, new oe)
    }
    ;
    function Se(Te, xe) {
        var ve = new le;
        fe(Te, ve),
        process$1.nextTick(xe, ve)
    }
    function ue(Te, xe, ve, Me) {
        var Fe;
        return ve === null ? Fe = new se : typeof ve != "string" && !xe.objectMode && (Fe = new Z("chunk",["string", "Buffer"],ve)),
        Fe ? (fe(Te, Fe),
        process$1.nextTick(Me, Fe),
        !1) : !0
    }
    Ae.prototype.write = function(Te, xe, ve) {
        var Me = this._writableState
          , Fe = !1
          , be = !Me.objectMode && O(Te);
        return be && !T.isBuffer(Te) && (Te = B(Te)),
        typeof xe == "function" && (ve = xe,
        xe = null),
        be ? xe = "buffer" : xe || (xe = Me.defaultEncoding),
        typeof ve != "function" && (ve = pe),
        Me.ending ? Se(this, ve) : (be || ue(this, Me, Te, ve)) && (Me.pendingcb++,
        Fe = W(this, Me, be, Te, xe, ve)),
        Fe
    }
    ,
    Ae.prototype.cork = function() {
        this._writableState.corked++
    }
    ,
    Ae.prototype.uncork = function() {
        var Te = this._writableState;
        Te.corked && (Te.corked--,
        !Te.writing && !Te.corked && !Te.bufferProcessing && Te.bufferedRequest && j(this, Te))
    }
    ,
    Ae.prototype.setDefaultEncoding = function(xe) {
        if (typeof xe == "string" && (xe = xe.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((xe + "").toLowerCase()) > -1))
            throw new de(xe);
        return this._writableState.defaultEncoding = xe,
        this
    }
    ,
    Object.defineProperty(Ae.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    });
    function V(Te, xe, ve) {
        return !Te.objectMode && Te.decodeStrings !== !1 && typeof xe == "string" && (xe = T.from(xe, ve)),
        xe
    }
    Object.defineProperty(Ae.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function W(Te, xe, ve, Me, Fe, be) {
        if (!ve) {
            var Ce = V(xe, Me, Fe);
            Me !== Ce && (ve = !0,
            Fe = "buffer",
            Me = Ce)
        }
        var ze = xe.objectMode ? 1 : Me.length;
        xe.length += ze;
        var Ge = xe.length < xe.highWaterMark;
        if (Ge || (xe.needDrain = !0),
        xe.writing || xe.corked) {
            var nt = xe.lastBufferedRequest;
            xe.lastBufferedRequest = {
                chunk: Me,
                encoding: Fe,
                isBuf: ve,
                callback: be,
                next: null
            },
            nt ? nt.next = xe.lastBufferedRequest : xe.bufferedRequest = xe.lastBufferedRequest,
            xe.bufferedRequestCount += 1
        } else
            D(Te, xe, !1, ze, Me, Fe, be);
        return Ge
    }
    function D(Te, xe, ve, Me, Fe, be, Ce) {
        xe.writelen = Me,
        xe.writecb = Ce,
        xe.writing = !0,
        xe.sync = !0,
        xe.destroyed ? xe.onwrite(new ae("write")) : ve ? Te._writev(Fe, xe.onwrite) : Te._write(Fe, be, xe.onwrite),
        xe.sync = !1
    }
    function I(Te, xe, ve, Me, Fe) {
        --xe.pendingcb,
        ve ? (process$1.nextTick(Fe, Me),
        process$1.nextTick(ce, Te, xe),
        Te._writableState.errorEmitted = !0,
        fe(Te, Me)) : (Fe(Me),
        Te._writableState.errorEmitted = !0,
        fe(Te, Me),
        ce(Te, xe))
    }
    function L(Te) {
        Te.writing = !1,
        Te.writecb = null,
        Te.length -= Te.writelen,
        Te.writelen = 0
    }
    function K(Te, xe) {
        var ve = Te._writableState
          , Me = ve.sync
          , Fe = ve.writecb;
        if (typeof Fe != "function")
            throw new ie;
        if (L(ve),
        xe)
            I(Te, ve, Me, xe, Fe);
        else {
            var be = G(ve) || Te.destroyed;
            !be && !ve.corked && !ve.bufferProcessing && ve.bufferedRequest && j(Te, ve),
            Me ? process$1.nextTick(X, Te, ve, be, Fe) : X(Te, ve, be, Fe)
        }
    }
    function X(Te, xe, ve, Me) {
        ve || Y(Te, xe),
        xe.pendingcb--,
        Me(),
        ce(Te, xe)
    }
    function Y(Te, xe) {
        xe.length === 0 && xe.needDrain && (xe.needDrain = !1,
        Te.emit("drain"))
    }
    function j(Te, xe) {
        xe.bufferProcessing = !0;
        var ve = xe.bufferedRequest;
        if (Te._writev && ve && ve.next) {
            var Me = xe.bufferedRequestCount
              , Fe = new Array(Me)
              , be = xe.corkedRequestsFree;
            be.entry = ve;
            for (var Ce = 0, ze = !0; ve; )
                Fe[Ce] = ve,
                ve.isBuf || (ze = !1),
                ve = ve.next,
                Ce += 1;
            Fe.allBuffers = ze,
            D(Te, xe, !0, xe.length, Fe, "", be.finish),
            xe.pendingcb++,
            xe.lastBufferedRequest = null,
            be.next ? (xe.corkedRequestsFree = be.next,
            be.next = null) : xe.corkedRequestsFree = new C(xe),
            xe.bufferedRequestCount = 0
        } else {
            for (; ve; ) {
                var Ge = ve.chunk
                  , nt = ve.encoding
                  , bt = ve.callback
                  , ct = xe.objectMode ? 1 : Ge.length;
                if (D(Te, xe, !1, ct, Ge, nt, bt),
                ve = ve.next,
                xe.bufferedRequestCount--,
                xe.writing)
                    break
            }
            ve === null && (xe.lastBufferedRequest = null)
        }
        xe.bufferedRequest = ve,
        xe.bufferProcessing = !1
    }
    Ae.prototype._write = function(Te, xe, ve) {
        ve(new J("_write()"))
    }
    ,
    Ae.prototype._writev = null,
    Ae.prototype.end = function(Te, xe, ve) {
        var Me = this._writableState;
        return typeof Te == "function" ? (ve = Te,
        Te = null,
        xe = null) : typeof xe == "function" && (ve = xe,
        xe = null),
        Te != null && this.write(Te, xe),
        Me.corked && (Me.corked = 1,
        this.uncork()),
        Me.ending || Ee(this, Me, ve),
        this
    }
    ,
    Object.defineProperty(Ae.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function G(Te) {
        return Te.ending && Te.length === 0 && Te.bufferedRequest === null && !Te.finished && !Te.writing
    }
    function ne(Te, xe) {
        Te._final(function(ve) {
            xe.pendingcb--,
            ve && fe(Te, ve),
            xe.prefinished = !0,
            Te.emit("prefinish"),
            ce(Te, xe)
        })
    }
    function te(Te, xe) {
        !xe.prefinished && !xe.finalCalled && (typeof Te._final == "function" && !xe.destroyed ? (xe.pendingcb++,
        xe.finalCalled = !0,
        process$1.nextTick(ne, Te, xe)) : (xe.prefinished = !0,
        Te.emit("prefinish")))
    }
    function ce(Te, xe) {
        var ve = G(xe);
        if (ve && (te(Te, xe),
        xe.pendingcb === 0 && (xe.finished = !0,
        Te.emit("finish"),
        xe.autoDestroy))) {
            var Me = Te._readableState;
            (!Me || Me.autoDestroy && Me.endEmitted) && Te.destroy()
        }
        return ve
    }
    function Ee(Te, xe, ve) {
        xe.ending = !0,
        ce(Te, xe),
        ve && (xe.finished ? process$1.nextTick(ve) : Te.once("finish", ve)),
        xe.ended = !0,
        Te.writable = !1
    }
    function Re(Te, xe, ve) {
        var Me = Te.entry;
        for (Te.entry = null; Me; ) {
            var Fe = Me.callback;
            xe.pendingcb--,
            Fe(ve),
            Me = Me.next
        }
        xe.corkedRequestsFree.next = Te
    }
    return Object.defineProperty(Ae.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(xe) {
            this._writableState && (this._writableState.destroyed = xe)
        }
    }),
    Ae.prototype.destroy = F.destroy,
    Ae.prototype._undestroy = F.undestroy,
    Ae.prototype._destroy = function(Te, xe) {
        xe(Te)
    }
    ,
    _stream_writable$1
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
    if (hasRequired_stream_duplex$1)
        return _stream_duplex$1;
    hasRequired_stream_duplex$1 = 1;
    var C = Object.keys || function(N) {
        var U = [];
        for (var H in N)
            U.push(H);
        return U
    }
    ;
    _stream_duplex$1 = B;
    var S = require_stream_readable$1()
      , E = require_stream_writable$1();
    requireInherits_browser()(B, S);
    for (var M = C(E.prototype), T = 0; T < M.length; T++) {
        var $ = M[T];
        B.prototype[$] || (B.prototype[$] = E.prototype[$])
    }
    function B(N) {
        if (!(this instanceof B))
            return new B(N);
        S.call(this, N),
        E.call(this, N),
        this.allowHalfOpen = !0,
        N && (N.readable === !1 && (this.readable = !1),
        N.writable === !1 && (this.writable = !1),
        N.allowHalfOpen === !1 && (this.allowHalfOpen = !1,
        this.once("end", O)))
    }
    Object.defineProperty(B.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    }),
    Object.defineProperty(B.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    }),
    Object.defineProperty(B.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });
    function O() {
        this._writableState.ended || process$1.nextTick(F, this)
    }
    function F(N) {
        N.end()
    }
    return Object.defineProperty(B.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(U) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = U,
            this._writableState.destroyed = U)
        }
    }),
    _stream_duplex$1
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
    if (hasRequiredString_decoder)
        return string_decoder;
    hasRequiredString_decoder = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = C.isEncoding || function(se) {
        switch (se = "" + se,
        se && se.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1
        }
    }
    ;
    function E(se) {
        if (!se)
            return "utf8";
        for (var le; ; )
            switch (se) {
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return se;
            default:
                if (le)
                    return;
                se = ("" + se).toLowerCase(),
                le = !0
            }
    }
    function M(se) {
        var le = E(se);
        if (typeof le != "string" && (C.isEncoding === S || !S(se)))
            throw new Error("Unknown encoding: " + se);
        return le || se
    }
    string_decoder.StringDecoder = T;
    function T(se) {
        this.encoding = M(se);
        var le;
        switch (this.encoding) {
        case "utf16le":
            this.text = H,
            this.end = Z,
            le = 4;
            break;
        case "utf8":
            this.fillLast = F,
            le = 4;
            break;
        case "base64":
            this.text = J,
            this.end = ie,
            le = 3;
            break;
        default:
            this.write = oe,
            this.end = ae;
            return
        }
        this.lastNeed = 0,
        this.lastTotal = 0,
        this.lastChar = C.allocUnsafe(le)
    }
    T.prototype.write = function(se) {
        if (se.length === 0)
            return "";
        var le, de;
        if (this.lastNeed) {
            if (le = this.fillLast(se),
            le === void 0)
                return "";
            de = this.lastNeed,
            this.lastNeed = 0
        } else
            de = 0;
        return de < se.length ? le ? le + this.text(se, de) : this.text(se, de) : le || ""
    }
    ,
    T.prototype.end = U,
    T.prototype.text = N,
    T.prototype.fillLast = function(se) {
        if (this.lastNeed <= se.length)
            return se.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        se.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, se.length),
        this.lastNeed -= se.length
    }
    ;
    function $(se) {
        return se <= 127 ? 0 : se >> 5 === 6 ? 2 : se >> 4 === 14 ? 3 : se >> 3 === 30 ? 4 : se >> 6 === 2 ? -1 : -2
    }
    function B(se, le, de) {
        var fe = le.length - 1;
        if (fe < de)
            return 0;
        var pe = $(le[fe]);
        return pe >= 0 ? (pe > 0 && (se.lastNeed = pe - 1),
        pe) : --fe < de || pe === -2 ? 0 : (pe = $(le[fe]),
        pe >= 0 ? (pe > 0 && (se.lastNeed = pe - 2),
        pe) : --fe < de || pe === -2 ? 0 : (pe = $(le[fe]),
        pe >= 0 ? (pe > 0 && (pe === 2 ? pe = 0 : se.lastNeed = pe - 3),
        pe) : 0))
    }
    function O(se, le, de) {
        if ((le[0] & 192) !== 128)
            return se.lastNeed = 0,
            "";
        if (se.lastNeed > 1 && le.length > 1) {
            if ((le[1] & 192) !== 128)
                return se.lastNeed = 1,
                "";
            if (se.lastNeed > 2 && le.length > 2 && (le[2] & 192) !== 128)
                return se.lastNeed = 2,
                ""
        }
    }
    function F(se) {
        var le = this.lastTotal - this.lastNeed
          , de = O(this, se);
        if (de !== void 0)
            return de;
        if (this.lastNeed <= se.length)
            return se.copy(this.lastChar, le, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        se.copy(this.lastChar, le, 0, se.length),
        this.lastNeed -= se.length
    }
    function N(se, le) {
        var de = B(this, se, le);
        if (!this.lastNeed)
            return se.toString("utf8", le);
        this.lastTotal = de;
        var fe = se.length - (de - this.lastNeed);
        return se.copy(this.lastChar, 0, fe),
        se.toString("utf8", le, fe)
    }
    function U(se) {
        var le = se && se.length ? this.write(se) : "";
        return this.lastNeed ? le + "" : le
    }
    function H(se, le) {
        if ((se.length - le) % 2 === 0) {
            var de = se.toString("utf16le", le);
            if (de) {
                var fe = de.charCodeAt(de.length - 1);
                if (fe >= 55296 && fe <= 56319)
                    return this.lastNeed = 2,
                    this.lastTotal = 4,
                    this.lastChar[0] = se[se.length - 2],
                    this.lastChar[1] = se[se.length - 1],
                    de.slice(0, -1)
            }
            return de
        }
        return this.lastNeed = 1,
        this.lastTotal = 2,
        this.lastChar[0] = se[se.length - 1],
        se.toString("utf16le", le, se.length - 1)
    }
    function Z(se) {
        var le = se && se.length ? this.write(se) : "";
        if (this.lastNeed) {
            var de = this.lastTotal - this.lastNeed;
            return le + this.lastChar.toString("utf16le", 0, de)
        }
        return le
    }
    function J(se, le) {
        var de = (se.length - le) % 3;
        return de === 0 ? se.toString("base64", le) : (this.lastNeed = 3 - de,
        this.lastTotal = 3,
        de === 1 ? this.lastChar[0] = se[se.length - 1] : (this.lastChar[0] = se[se.length - 2],
        this.lastChar[1] = se[se.length - 1]),
        se.toString("base64", le, se.length - de))
    }
    function ie(se) {
        var le = se && se.length ? this.write(se) : "";
        return this.lastNeed ? le + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : le
    }
    function oe(se) {
        return se.toString(this.encoding)
    }
    function ae(se) {
        return se && se.length ? this.write(se) : ""
    }
    return string_decoder
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
    if (hasRequiredEndOfStream)
        return endOfStream;
    hasRequiredEndOfStream = 1;
    var C = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function S($) {
        var B = !1;
        return function() {
            if (!B) {
                B = !0;
                for (var O = arguments.length, F = new Array(O), N = 0; N < O; N++)
                    F[N] = arguments[N];
                $.apply(this, F)
            }
        }
    }
    function E() {}
    function M($) {
        return $.setHeader && typeof $.abort == "function"
    }
    function T($, B, O) {
        if (typeof B == "function")
            return T($, null, B);
        B || (B = {}),
        O = S(O || E);
        var F = B.readable || B.readable !== !1 && $.readable
          , N = B.writable || B.writable !== !1 && $.writable
          , U = function() {
            $.writable || Z()
        }
          , H = $._writableState && $._writableState.finished
          , Z = function() {
            N = !1,
            H = !0,
            F || O.call($)
        }
          , J = $._readableState && $._readableState.endEmitted
          , ie = function() {
            F = !1,
            J = !0,
            N || O.call($)
        }
          , oe = function(de) {
            O.call($, de)
        }
          , ae = function() {
            var de;
            if (F && !J)
                return (!$._readableState || !$._readableState.ended) && (de = new C),
                O.call($, de);
            if (N && !H)
                return (!$._writableState || !$._writableState.ended) && (de = new C),
                O.call($, de)
        }
          , se = function() {
            $.req.on("finish", Z)
        };
        return M($) ? ($.on("complete", Z),
        $.on("abort", ae),
        $.req ? se() : $.on("request", se)) : N && !$._writableState && ($.on("end", U),
        $.on("close", U)),
        $.on("end", ie),
        $.on("finish", Z),
        B.error !== !1 && $.on("error", oe),
        $.on("close", ae),
        function() {
            $.removeListener("complete", Z),
            $.removeListener("abort", ae),
            $.removeListener("request", se),
            $.req && $.req.removeListener("finish", Z),
            $.removeListener("end", U),
            $.removeListener("close", U),
            $.removeListener("finish", Z),
            $.removeListener("end", ie),
            $.removeListener("error", oe),
            $.removeListener("close", ae)
        }
    }
    return endOfStream = T,
    endOfStream
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
    if (hasRequiredAsync_iterator)
        return async_iterator;
    hasRequiredAsync_iterator = 1;
    var C;
    function S(de, fe, pe) {
        return fe = E(fe),
        fe in de ? Object.defineProperty(de, fe, {
            value: pe,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : de[fe] = pe,
        de
    }
    function E(de) {
        var fe = M(de, "string");
        return typeof fe == "symbol" ? fe : String(fe)
    }
    function M(de, fe) {
        if (typeof de != "object" || de === null)
            return de;
        var pe = de[Symbol.toPrimitive];
        if (pe !== void 0) {
            var ge = pe.call(de, fe || "default");
            if (typeof ge != "object")
                return ge;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (fe === "string" ? String : Number)(de)
    }
    var T = requireEndOfStream()
      , $ = Symbol("lastResolve")
      , B = Symbol("lastReject")
      , O = Symbol("error")
      , F = Symbol("ended")
      , N = Symbol("lastPromise")
      , U = Symbol("handlePromise")
      , H = Symbol("stream");
    function Z(de, fe) {
        return {
            value: de,
            done: fe
        }
    }
    function J(de) {
        var fe = de[$];
        if (fe !== null) {
            var pe = de[H].read();
            pe !== null && (de[N] = null,
            de[$] = null,
            de[B] = null,
            fe(Z(pe, !1)))
        }
    }
    function ie(de) {
        process$1.nextTick(J, de)
    }
    function oe(de, fe) {
        return function(pe, ge) {
            de.then(function() {
                if (fe[F]) {
                    pe(Z(void 0, !0));
                    return
                }
                fe[U](pe, ge)
            }, ge)
        }
    }
    var ae = Object.getPrototypeOf(function() {})
      , se = Object.setPrototypeOf((C = {
        get stream() {
            return this[H]
        },
        next: function() {
            var fe = this
              , pe = this[O];
            if (pe !== null)
                return Promise.reject(pe);
            if (this[F])
                return Promise.resolve(Z(void 0, !0));
            if (this[H].destroyed)
                return new Promise(function(Se, ue) {
                    process$1.nextTick(function() {
                        fe[O] ? ue(fe[O]) : Se(Z(void 0, !0))
                    })
                }
                );
            var ge = this[N], we;
            if (ge)
                we = new Promise(oe(ge, this));
            else {
                var Ae = this[H].read();
                if (Ae !== null)
                    return Promise.resolve(Z(Ae, !1));
                we = new Promise(this[U])
            }
            return this[N] = we,
            we
        }
    },
    S(C, Symbol.asyncIterator, function() {
        return this
    }),
    S(C, "return", function() {
        var fe = this;
        return new Promise(function(pe, ge) {
            fe[H].destroy(null, function(we) {
                if (we) {
                    ge(we);
                    return
                }
                pe(Z(void 0, !0))
            })
        }
        )
    }),
    C), ae)
      , le = function(fe) {
        var pe, ge = Object.create(se, (pe = {},
        S(pe, H, {
            value: fe,
            writable: !0
        }),
        S(pe, $, {
            value: null,
            writable: !0
        }),
        S(pe, B, {
            value: null,
            writable: !0
        }),
        S(pe, O, {
            value: null,
            writable: !0
        }),
        S(pe, F, {
            value: fe._readableState.endEmitted,
            writable: !0
        }),
        S(pe, U, {
            value: function(Ae, Se) {
                var ue = ge[H].read();
                ue ? (ge[N] = null,
                ge[$] = null,
                ge[B] = null,
                Ae(Z(ue, !1))) : (ge[$] = Ae,
                ge[B] = Se)
            },
            writable: !0
        }),
        pe));
        return ge[N] = null,
        T(fe, function(we) {
            if (we && we.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var Ae = ge[B];
                Ae !== null && (ge[N] = null,
                ge[$] = null,
                ge[B] = null,
                Ae(we)),
                ge[O] = we;
                return
            }
            var Se = ge[$];
            Se !== null && (ge[N] = null,
            ge[$] = null,
            ge[B] = null,
            Se(Z(void 0, !0))),
            ge[F] = !0
        }),
        fe.on("readable", ie.bind(null, ge)),
        ge
    };
    return async_iterator = le,
    async_iterator
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
    return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1,
    fromBrowser = function() {
        throw new Error("Readable.from is not available in the browser")
    }
    ),
    fromBrowser
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
    if (hasRequired_stream_readable$1)
        return _stream_readable$1;
    hasRequired_stream_readable$1 = 1,
    _stream_readable$1 = Se;
    var C;
    Se.ReadableState = Ae,
    eventsExports.EventEmitter;
    var S = function(Ce, ze) {
        return Ce.listeners(ze).length
    }
      , E = requireStreamBrowser$1()
      , M = require$$0$2.Buffer
      , T = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function $(be) {
        return M.from(be)
    }
    function B(be) {
        return M.isBuffer(be) || be instanceof T
    }
    var O = requireUtil$1(), F;
    O && O.debuglog ? F = O.debuglog("stream") : F = function() {}
    ;
    var N = requireBuffer_list(), U = requireDestroy$1(), H = requireState(), Z = H.getHighWaterMark, J = requireErrorsBrowser().codes, ie = J.ERR_INVALID_ARG_TYPE, oe = J.ERR_STREAM_PUSH_AFTER_EOF, ae = J.ERR_METHOD_NOT_IMPLEMENTED, se = J.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, le, de, fe;
    requireInherits_browser()(Se, E);
    var pe = U.errorOrDestroy
      , ge = ["error", "close", "destroy", "pause", "resume"];
    function we(be, Ce, ze) {
        if (typeof be.prependListener == "function")
            return be.prependListener(Ce, ze);
        !be._events || !be._events[Ce] ? be.on(Ce, ze) : Array.isArray(be._events[Ce]) ? be._events[Ce].unshift(ze) : be._events[Ce] = [ze, be._events[Ce]]
    }
    function Ae(be, Ce, ze) {
        C = C || require_stream_duplex$1(),
        be = be || {},
        typeof ze != "boolean" && (ze = Ce instanceof C),
        this.objectMode = !!be.objectMode,
        ze && (this.objectMode = this.objectMode || !!be.readableObjectMode),
        this.highWaterMark = Z(this, be, "readableHighWaterMark", ze),
        this.buffer = new N,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.paused = !0,
        this.emitClose = be.emitClose !== !1,
        this.autoDestroy = !!be.autoDestroy,
        this.destroyed = !1,
        this.defaultEncoding = be.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        be.encoding && (le || (le = requireString_decoder().StringDecoder),
        this.decoder = new le(be.encoding),
        this.encoding = be.encoding)
    }
    function Se(be) {
        if (C = C || require_stream_duplex$1(),
        !(this instanceof Se))
            return new Se(be);
        var Ce = this instanceof C;
        this._readableState = new Ae(be,this,Ce),
        this.readable = !0,
        be && (typeof be.read == "function" && (this._read = be.read),
        typeof be.destroy == "function" && (this._destroy = be.destroy)),
        E.call(this)
    }
    Object.defineProperty(Se.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(Ce) {
            this._readableState && (this._readableState.destroyed = Ce)
        }
    }),
    Se.prototype.destroy = U.destroy,
    Se.prototype._undestroy = U.undestroy,
    Se.prototype._destroy = function(be, Ce) {
        Ce(be)
    }
    ,
    Se.prototype.push = function(be, Ce) {
        var ze = this._readableState, Ge;
        return ze.objectMode ? Ge = !0 : typeof be == "string" && (Ce = Ce || ze.defaultEncoding,
        Ce !== ze.encoding && (be = M.from(be, Ce),
        Ce = ""),
        Ge = !0),
        ue(this, be, Ce, !1, Ge)
    }
    ,
    Se.prototype.unshift = function(be) {
        return ue(this, be, null, !0, !1)
    }
    ;
    function ue(be, Ce, ze, Ge, nt) {
        F("readableAddChunk", Ce);
        var bt = be._readableState;
        if (Ce === null)
            bt.reading = !1,
            K(be, bt);
        else {
            var ct;
            if (nt || (ct = W(bt, Ce)),
            ct)
                pe(be, ct);
            else if (bt.objectMode || Ce && Ce.length > 0)
                if (typeof Ce != "string" && !bt.objectMode && Object.getPrototypeOf(Ce) !== M.prototype && (Ce = $(Ce)),
                Ge)
                    bt.endEmitted ? pe(be, new se) : V(be, bt, Ce, !0);
                else if (bt.ended)
                    pe(be, new oe);
                else {
                    if (bt.destroyed)
                        return !1;
                    bt.reading = !1,
                    bt.decoder && !ze ? (Ce = bt.decoder.write(Ce),
                    bt.objectMode || Ce.length !== 0 ? V(be, bt, Ce, !1) : j(be, bt)) : V(be, bt, Ce, !1)
                }
            else
                Ge || (bt.reading = !1,
                j(be, bt))
        }
        return !bt.ended && (bt.length < bt.highWaterMark || bt.length === 0)
    }
    function V(be, Ce, ze, Ge) {
        Ce.flowing && Ce.length === 0 && !Ce.sync ? (Ce.awaitDrain = 0,
        be.emit("data", ze)) : (Ce.length += Ce.objectMode ? 1 : ze.length,
        Ge ? Ce.buffer.unshift(ze) : Ce.buffer.push(ze),
        Ce.needReadable && X(be)),
        j(be, Ce)
    }
    function W(be, Ce) {
        var ze;
        return !B(Ce) && typeof Ce != "string" && Ce !== void 0 && !be.objectMode && (ze = new ie("chunk",["string", "Buffer", "Uint8Array"],Ce)),
        ze
    }
    Se.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    Se.prototype.setEncoding = function(be) {
        le || (le = requireString_decoder().StringDecoder);
        var Ce = new le(be);
        this._readableState.decoder = Ce,
        this._readableState.encoding = this._readableState.decoder.encoding;
        for (var ze = this._readableState.buffer.head, Ge = ""; ze !== null; )
            Ge += Ce.write(ze.data),
            ze = ze.next;
        return this._readableState.buffer.clear(),
        Ge !== "" && this._readableState.buffer.push(Ge),
        this._readableState.length = Ge.length,
        this
    }
    ;
    var D = 1073741824;
    function I(be) {
        return be >= D ? be = D : (be--,
        be |= be >>> 1,
        be |= be >>> 2,
        be |= be >>> 4,
        be |= be >>> 8,
        be |= be >>> 16,
        be++),
        be
    }
    function L(be, Ce) {
        return be <= 0 || Ce.length === 0 && Ce.ended ? 0 : Ce.objectMode ? 1 : be !== be ? Ce.flowing && Ce.length ? Ce.buffer.head.data.length : Ce.length : (be > Ce.highWaterMark && (Ce.highWaterMark = I(be)),
        be <= Ce.length ? be : Ce.ended ? Ce.length : (Ce.needReadable = !0,
        0))
    }
    Se.prototype.read = function(be) {
        F("read", be),
        be = parseInt(be, 10);
        var Ce = this._readableState
          , ze = be;
        if (be !== 0 && (Ce.emittedReadable = !1),
        be === 0 && Ce.needReadable && ((Ce.highWaterMark !== 0 ? Ce.length >= Ce.highWaterMark : Ce.length > 0) || Ce.ended))
            return F("read: emitReadable", Ce.length, Ce.ended),
            Ce.length === 0 && Ce.ended ? ve(this) : X(this),
            null;
        if (be = L(be, Ce),
        be === 0 && Ce.ended)
            return Ce.length === 0 && ve(this),
            null;
        var Ge = Ce.needReadable;
        F("need readable", Ge),
        (Ce.length === 0 || Ce.length - be < Ce.highWaterMark) && (Ge = !0,
        F("length less than watermark", Ge)),
        Ce.ended || Ce.reading ? (Ge = !1,
        F("reading or ended", Ge)) : Ge && (F("do read"),
        Ce.reading = !0,
        Ce.sync = !0,
        Ce.length === 0 && (Ce.needReadable = !0),
        this._read(Ce.highWaterMark),
        Ce.sync = !1,
        Ce.reading || (be = L(ze, Ce)));
        var nt;
        return be > 0 ? nt = xe(be, Ce) : nt = null,
        nt === null ? (Ce.needReadable = Ce.length <= Ce.highWaterMark,
        be = 0) : (Ce.length -= be,
        Ce.awaitDrain = 0),
        Ce.length === 0 && (Ce.ended || (Ce.needReadable = !0),
        ze !== be && Ce.ended && ve(this)),
        nt !== null && this.emit("data", nt),
        nt
    }
    ;
    function K(be, Ce) {
        if (F("onEofChunk"),
        !Ce.ended) {
            if (Ce.decoder) {
                var ze = Ce.decoder.end();
                ze && ze.length && (Ce.buffer.push(ze),
                Ce.length += Ce.objectMode ? 1 : ze.length)
            }
            Ce.ended = !0,
            Ce.sync ? X(be) : (Ce.needReadable = !1,
            Ce.emittedReadable || (Ce.emittedReadable = !0,
            Y(be)))
        }
    }
    function X(be) {
        var Ce = be._readableState;
        F("emitReadable", Ce.needReadable, Ce.emittedReadable),
        Ce.needReadable = !1,
        Ce.emittedReadable || (F("emitReadable", Ce.flowing),
        Ce.emittedReadable = !0,
        process$1.nextTick(Y, be))
    }
    function Y(be) {
        var Ce = be._readableState;
        F("emitReadable_", Ce.destroyed, Ce.length, Ce.ended),
        !Ce.destroyed && (Ce.length || Ce.ended) && (be.emit("readable"),
        Ce.emittedReadable = !1),
        Ce.needReadable = !Ce.flowing && !Ce.ended && Ce.length <= Ce.highWaterMark,
        Te(be)
    }
    function j(be, Ce) {
        Ce.readingMore || (Ce.readingMore = !0,
        process$1.nextTick(G, be, Ce))
    }
    function G(be, Ce) {
        for (; !Ce.reading && !Ce.ended && (Ce.length < Ce.highWaterMark || Ce.flowing && Ce.length === 0); ) {
            var ze = Ce.length;
            if (F("maybeReadMore read 0"),
            be.read(0),
            ze === Ce.length)
                break
        }
        Ce.readingMore = !1
    }
    Se.prototype._read = function(be) {
        pe(this, new ae("_read()"))
    }
    ,
    Se.prototype.pipe = function(be, Ce) {
        var ze = this
          , Ge = this._readableState;
        switch (Ge.pipesCount) {
        case 0:
            Ge.pipes = be;
            break;
        case 1:
            Ge.pipes = [Ge.pipes, be];
            break;
        default:
            Ge.pipes.push(be);
            break
        }
        Ge.pipesCount += 1,
        F("pipe count=%d opts=%j", Ge.pipesCount, Ce);
        var nt = (!Ce || Ce.end !== !1) && be !== process$1.stdout && be !== process$1.stderr
          , bt = nt ? De : $e;
        Ge.endEmitted ? process$1.nextTick(bt) : ze.once("end", bt),
        be.on("unpipe", ct);
        function ct(Ie, He) {
            F("onunpipe"),
            Ie === ze && He && He.hasUnpiped === !1 && (He.hasUnpiped = !0,
            Xe())
        }
        function De() {
            F("onend"),
            be.end()
        }
        var Ue = ne(ze);
        be.on("drain", Ue);
        var We = !1;
        function Xe() {
            F("cleanup"),
            be.removeListener("close", ot),
            be.removeListener("finish", je),
            be.removeListener("drain", Ue),
            be.removeListener("error", Je),
            be.removeListener("unpipe", ct),
            ze.removeListener("end", De),
            ze.removeListener("end", $e),
            ze.removeListener("data", ht),
            We = !0,
            Ge.awaitDrain && (!be._writableState || be._writableState.needDrain) && Ue()
        }
        ze.on("data", ht);
        function ht(Ie) {
            F("ondata");
            var He = be.write(Ie);
            F("dest.write", He),
            He === !1 && ((Ge.pipesCount === 1 && Ge.pipes === be || Ge.pipesCount > 1 && Fe(Ge.pipes, be) !== -1) && !We && (F("false write response, pause", Ge.awaitDrain),
            Ge.awaitDrain++),
            ze.pause())
        }
        function Je(Ie) {
            F("onerror", Ie),
            $e(),
            be.removeListener("error", Je),
            S(be, "error") === 0 && pe(be, Ie)
        }
        we(be, "error", Je);
        function ot() {
            be.removeListener("finish", je),
            $e()
        }
        be.once("close", ot);
        function je() {
            F("onfinish"),
            be.removeListener("close", ot),
            $e()
        }
        be.once("finish", je);
        function $e() {
            F("unpipe"),
            ze.unpipe(be)
        }
        return be.emit("pipe", ze),
        Ge.flowing || (F("pipe resume"),
        ze.resume()),
        be
    }
    ;
    function ne(be) {
        return function() {
            var ze = be._readableState;
            F("pipeOnDrain", ze.awaitDrain),
            ze.awaitDrain && ze.awaitDrain--,
            ze.awaitDrain === 0 && S(be, "data") && (ze.flowing = !0,
            Te(be))
        }
    }
    Se.prototype.unpipe = function(be) {
        var Ce = this._readableState
          , ze = {
            hasUnpiped: !1
        };
        if (Ce.pipesCount === 0)
            return this;
        if (Ce.pipesCount === 1)
            return be && be !== Ce.pipes ? this : (be || (be = Ce.pipes),
            Ce.pipes = null,
            Ce.pipesCount = 0,
            Ce.flowing = !1,
            be && be.emit("unpipe", this, ze),
            this);
        if (!be) {
            var Ge = Ce.pipes
              , nt = Ce.pipesCount;
            Ce.pipes = null,
            Ce.pipesCount = 0,
            Ce.flowing = !1;
            for (var bt = 0; bt < nt; bt++)
                Ge[bt].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var ct = Fe(Ce.pipes, be);
        return ct === -1 ? this : (Ce.pipes.splice(ct, 1),
        Ce.pipesCount -= 1,
        Ce.pipesCount === 1 && (Ce.pipes = Ce.pipes[0]),
        be.emit("unpipe", this, ze),
        this)
    }
    ,
    Se.prototype.on = function(be, Ce) {
        var ze = E.prototype.on.call(this, be, Ce)
          , Ge = this._readableState;
        return be === "data" ? (Ge.readableListening = this.listenerCount("readable") > 0,
        Ge.flowing !== !1 && this.resume()) : be === "readable" && !Ge.endEmitted && !Ge.readableListening && (Ge.readableListening = Ge.needReadable = !0,
        Ge.flowing = !1,
        Ge.emittedReadable = !1,
        F("on readable", Ge.length, Ge.reading),
        Ge.length ? X(this) : Ge.reading || process$1.nextTick(ce, this)),
        ze
    }
    ,
    Se.prototype.addListener = Se.prototype.on,
    Se.prototype.removeListener = function(be, Ce) {
        var ze = E.prototype.removeListener.call(this, be, Ce);
        return be === "readable" && process$1.nextTick(te, this),
        ze
    }
    ,
    Se.prototype.removeAllListeners = function(be) {
        var Ce = E.prototype.removeAllListeners.apply(this, arguments);
        return (be === "readable" || be === void 0) && process$1.nextTick(te, this),
        Ce
    }
    ;
    function te(be) {
        var Ce = be._readableState;
        Ce.readableListening = be.listenerCount("readable") > 0,
        Ce.resumeScheduled && !Ce.paused ? Ce.flowing = !0 : be.listenerCount("data") > 0 && be.resume()
    }
    function ce(be) {
        F("readable nexttick read 0"),
        be.read(0)
    }
    Se.prototype.resume = function() {
        var be = this._readableState;
        return be.flowing || (F("resume"),
        be.flowing = !be.readableListening,
        Ee(this, be)),
        be.paused = !1,
        this
    }
    ;
    function Ee(be, Ce) {
        Ce.resumeScheduled || (Ce.resumeScheduled = !0,
        process$1.nextTick(Re, be, Ce))
    }
    function Re(be, Ce) {
        F("resume", Ce.reading),
        Ce.reading || be.read(0),
        Ce.resumeScheduled = !1,
        be.emit("resume"),
        Te(be),
        Ce.flowing && !Ce.reading && be.read(0)
    }
    Se.prototype.pause = function() {
        return F("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (F("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this._readableState.paused = !0,
        this
    }
    ;
    function Te(be) {
        var Ce = be._readableState;
        for (F("flow", Ce.flowing); Ce.flowing && be.read() !== null; )
            ;
    }
    Se.prototype.wrap = function(be) {
        var Ce = this
          , ze = this._readableState
          , Ge = !1;
        be.on("end", function() {
            if (F("wrapped end"),
            ze.decoder && !ze.ended) {
                var ct = ze.decoder.end();
                ct && ct.length && Ce.push(ct)
            }
            Ce.push(null)
        }),
        be.on("data", function(ct) {
            if (F("wrapped data"),
            ze.decoder && (ct = ze.decoder.write(ct)),
            !(ze.objectMode && ct == null) && !(!ze.objectMode && (!ct || !ct.length))) {
                var De = Ce.push(ct);
                De || (Ge = !0,
                be.pause())
            }
        });
        for (var nt in be)
            this[nt] === void 0 && typeof be[nt] == "function" && (this[nt] = function(De) {
                return function() {
                    return be[De].apply(be, arguments)
                }
            }(nt));
        for (var bt = 0; bt < ge.length; bt++)
            be.on(ge[bt], this.emit.bind(this, ge[bt]));
        return this._read = function(ct) {
            F("wrapped _read", ct),
            Ge && (Ge = !1,
            be.resume())
        }
        ,
        this
    }
    ,
    typeof Symbol == "function" && (Se.prototype[Symbol.asyncIterator] = function() {
        return de === void 0 && (de = requireAsync_iterator()),
        de(this)
    }
    ),
    Object.defineProperty(Se.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    Object.defineProperty(Se.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer
        }
    }),
    Object.defineProperty(Se.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing
        },
        set: function(Ce) {
            this._readableState && (this._readableState.flowing = Ce)
        }
    }),
    Se._fromList = xe,
    Object.defineProperty(Se.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length
        }
    });
    function xe(be, Ce) {
        if (Ce.length === 0)
            return null;
        var ze;
        return Ce.objectMode ? ze = Ce.buffer.shift() : !be || be >= Ce.length ? (Ce.decoder ? ze = Ce.buffer.join("") : Ce.buffer.length === 1 ? ze = Ce.buffer.first() : ze = Ce.buffer.concat(Ce.length),
        Ce.buffer.clear()) : ze = Ce.buffer.consume(be, Ce.decoder),
        ze
    }
    function ve(be) {
        var Ce = be._readableState;
        F("endReadable", Ce.endEmitted),
        Ce.endEmitted || (Ce.ended = !0,
        process$1.nextTick(Me, Ce, be))
    }
    function Me(be, Ce) {
        if (F("endReadableNT", be.endEmitted, be.length),
        !be.endEmitted && be.length === 0 && (be.endEmitted = !0,
        Ce.readable = !1,
        Ce.emit("end"),
        be.autoDestroy)) {
            var ze = Ce._writableState;
            (!ze || ze.autoDestroy && ze.finished) && Ce.destroy()
        }
    }
    typeof Symbol == "function" && (Se.from = function(be, Ce) {
        return fe === void 0 && (fe = requireFromBrowser()),
        fe(Se, be, Ce)
    }
    );
    function Fe(be, Ce) {
        for (var ze = 0, Ge = be.length; ze < Ge; ze++)
            if (be[ze] === Ce)
                return ze;
        return -1
    }
    return _stream_readable$1
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
    if (hasRequired_stream_transform$1)
        return _stream_transform$1;
    hasRequired_stream_transform$1 = 1,
    _stream_transform$1 = O;
    var C = requireErrorsBrowser().codes
      , S = C.ERR_METHOD_NOT_IMPLEMENTED
      , E = C.ERR_MULTIPLE_CALLBACK
      , M = C.ERR_TRANSFORM_ALREADY_TRANSFORMING
      , T = C.ERR_TRANSFORM_WITH_LENGTH_0
      , $ = require_stream_duplex$1();
    requireInherits_browser()(O, $);
    function B(U, H) {
        var Z = this._transformState;
        Z.transforming = !1;
        var J = Z.writecb;
        if (J === null)
            return this.emit("error", new E);
        Z.writechunk = null,
        Z.writecb = null,
        H != null && this.push(H),
        J(U);
        var ie = this._readableState;
        ie.reading = !1,
        (ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark)
    }
    function O(U) {
        if (!(this instanceof O))
            return new O(U);
        $.call(this, U),
        this._transformState = {
            afterTransform: B.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        U && (typeof U.transform == "function" && (this._transform = U.transform),
        typeof U.flush == "function" && (this._flush = U.flush)),
        this.on("prefinish", F)
    }
    function F() {
        var U = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(H, Z) {
            N(U, H, Z)
        }) : N(this, null, null)
    }
    O.prototype.push = function(U, H) {
        return this._transformState.needTransform = !1,
        $.prototype.push.call(this, U, H)
    }
    ,
    O.prototype._transform = function(U, H, Z) {
        Z(new S("_transform()"))
    }
    ,
    O.prototype._write = function(U, H, Z) {
        var J = this._transformState;
        if (J.writecb = Z,
        J.writechunk = U,
        J.writeencoding = H,
        !J.transforming) {
            var ie = this._readableState;
            (J.needTransform || ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark)
        }
    }
    ,
    O.prototype._read = function(U) {
        var H = this._transformState;
        H.writechunk !== null && !H.transforming ? (H.transforming = !0,
        this._transform(H.writechunk, H.writeencoding, H.afterTransform)) : H.needTransform = !0
    }
    ,
    O.prototype._destroy = function(U, H) {
        $.prototype._destroy.call(this, U, function(Z) {
            H(Z)
        })
    }
    ;
    function N(U, H, Z) {
        if (H)
            return U.emit("error", H);
        if (Z != null && U.push(Z),
        U._writableState.length)
            throw new T;
        if (U._transformState.transforming)
            throw new M;
        return U.push(null)
    }
    return _stream_transform$1
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
    if (hasRequired_stream_passthrough$1)
        return _stream_passthrough$1;
    hasRequired_stream_passthrough$1 = 1,
    _stream_passthrough$1 = S;
    var C = require_stream_transform$1();
    requireInherits_browser()(S, C);
    function S(E) {
        if (!(this instanceof S))
            return new S(E);
        C.call(this, E)
    }
    return S.prototype._transform = function(E, M, T) {
        T(null, E)
    }
    ,
    _stream_passthrough$1
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
    if (hasRequiredPipeline)
        return pipeline_1;
    hasRequiredPipeline = 1;
    var C;
    function S(Z) {
        var J = !1;
        return function() {
            J || (J = !0,
            Z.apply(void 0, arguments))
        }
    }
    var E = requireErrorsBrowser().codes
      , M = E.ERR_MISSING_ARGS
      , T = E.ERR_STREAM_DESTROYED;
    function $(Z) {
        if (Z)
            throw Z
    }
    function B(Z) {
        return Z.setHeader && typeof Z.abort == "function"
    }
    function O(Z, J, ie, oe) {
        oe = S(oe);
        var ae = !1;
        Z.on("close", function() {
            ae = !0
        }),
        C === void 0 && (C = requireEndOfStream()),
        C(Z, {
            readable: J,
            writable: ie
        }, function(le) {
            if (le)
                return oe(le);
            ae = !0,
            oe()
        });
        var se = !1;
        return function(le) {
            if (!ae && !se) {
                if (se = !0,
                B(Z))
                    return Z.abort();
                if (typeof Z.destroy == "function")
                    return Z.destroy();
                oe(le || new T("pipe"))
            }
        }
    }
    function F(Z) {
        Z()
    }
    function N(Z, J) {
        return Z.pipe(J)
    }
    function U(Z) {
        return !Z.length || typeof Z[Z.length - 1] != "function" ? $ : Z.pop()
    }
    function H() {
        for (var Z = arguments.length, J = new Array(Z), ie = 0; ie < Z; ie++)
            J[ie] = arguments[ie];
        var oe = U(J);
        if (Array.isArray(J[0]) && (J = J[0]),
        J.length < 2)
            throw new M("streams");
        var ae, se = J.map(function(le, de) {
            var fe = de < J.length - 1
              , pe = de > 0;
            return O(le, fe, pe, function(ge) {
                ae || (ae = ge),
                ge && se.forEach(F),
                !fe && (se.forEach(F),
                oe(ae))
            })
        });
        return J.reduce(N)
    }
    return pipeline_1 = H,
    pipeline_1
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
    return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1,
    function(C, S) {
        S = C.exports = require_stream_readable$1(),
        S.Stream = S,
        S.Readable = S,
        S.Writable = require_stream_writable$1(),
        S.Duplex = require_stream_duplex$1(),
        S.Transform = require_stream_transform$1(),
        S.PassThrough = require_stream_passthrough$1(),
        S.finished = requireEndOfStream(),
        S.pipeline = requirePipeline()
    }(readableBrowser$1, readableBrowser$1.exports)),
    readableBrowser$1.exports
}
var hashBase$1, hasRequiredHashBase$1;
function requireHashBase$1() {
    if (hasRequiredHashBase$1)
        return hashBase$1;
    hasRequiredHashBase$1 = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireReadableBrowser$1().Transform
      , E = requireInherits_browser();
    function M($, B) {
        if (!C.isBuffer($) && typeof $ != "string")
            throw new TypeError(B + " must be a string or a buffer")
    }
    function T($) {
        S.call(this),
        this._block = C.allocUnsafe($),
        this._blockSize = $,
        this._blockOffset = 0,
        this._length = [0, 0, 0, 0],
        this._finalized = !1
    }
    return E(T, S),
    T.prototype._transform = function($, B, O) {
        var F = null;
        try {
            this.update($, B)
        } catch (N) {
            F = N
        }
        O(F)
    }
    ,
    T.prototype._flush = function($) {
        var B = null;
        try {
            this.push(this.digest())
        } catch (O) {
            B = O
        }
        $(B)
    }
    ,
    T.prototype.update = function($, B) {
        if (M($, "Data"),
        this._finalized)
            throw new Error("Digest already called");
        C.isBuffer($) || ($ = C.from($, B));
        for (var O = this._block, F = 0; this._blockOffset + $.length - F >= this._blockSize; ) {
            for (var N = this._blockOffset; N < this._blockSize; )
                O[N++] = $[F++];
            this._update(),
            this._blockOffset = 0
        }
        for (; F < $.length; )
            O[this._blockOffset++] = $[F++];
        for (var U = 0, H = $.length * 8; H > 0; ++U)
            this._length[U] += H,
            H = this._length[U] / 4294967296 | 0,
            H > 0 && (this._length[U] -= 4294967296 * H);
        return this
    }
    ,
    T.prototype._update = function() {
        throw new Error("_update is not implemented")
    }
    ,
    T.prototype.digest = function($) {
        if (this._finalized)
            throw new Error("Digest already called");
        this._finalized = !0;
        var B = this._digest();
        $ !== void 0 && (B = B.toString($)),
        this._block.fill(0),
        this._blockOffset = 0;
        for (var O = 0; O < 4; ++O)
            this._length[O] = 0;
        return B
    }
    ,
    T.prototype._digest = function() {
        throw new Error("_digest is not implemented")
    }
    ,
    hashBase$1 = T,
    hashBase$1
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
    if (hasRequiredMd5_js)
        return md5_js;
    hasRequiredMd5_js = 1;
    var C = requireInherits_browser()
      , S = requireHashBase$1()
      , E = requireSafeBuffer$1().Buffer
      , M = new Array(16);
    function T() {
        S.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878
    }
    C(T, S),
    T.prototype._update = function() {
        for (var U = M, H = 0; H < 16; ++H)
            U[H] = this._block.readInt32LE(H * 4);
        var Z = this._a
          , J = this._b
          , ie = this._c
          , oe = this._d;
        Z = B(Z, J, ie, oe, U[0], 3614090360, 7),
        oe = B(oe, Z, J, ie, U[1], 3905402710, 12),
        ie = B(ie, oe, Z, J, U[2], 606105819, 17),
        J = B(J, ie, oe, Z, U[3], 3250441966, 22),
        Z = B(Z, J, ie, oe, U[4], 4118548399, 7),
        oe = B(oe, Z, J, ie, U[5], 1200080426, 12),
        ie = B(ie, oe, Z, J, U[6], 2821735955, 17),
        J = B(J, ie, oe, Z, U[7], 4249261313, 22),
        Z = B(Z, J, ie, oe, U[8], 1770035416, 7),
        oe = B(oe, Z, J, ie, U[9], 2336552879, 12),
        ie = B(ie, oe, Z, J, U[10], 4294925233, 17),
        J = B(J, ie, oe, Z, U[11], 2304563134, 22),
        Z = B(Z, J, ie, oe, U[12], 1804603682, 7),
        oe = B(oe, Z, J, ie, U[13], 4254626195, 12),
        ie = B(ie, oe, Z, J, U[14], 2792965006, 17),
        J = B(J, ie, oe, Z, U[15], 1236535329, 22),
        Z = O(Z, J, ie, oe, U[1], 4129170786, 5),
        oe = O(oe, Z, J, ie, U[6], 3225465664, 9),
        ie = O(ie, oe, Z, J, U[11], 643717713, 14),
        J = O(J, ie, oe, Z, U[0], 3921069994, 20),
        Z = O(Z, J, ie, oe, U[5], 3593408605, 5),
        oe = O(oe, Z, J, ie, U[10], 38016083, 9),
        ie = O(ie, oe, Z, J, U[15], 3634488961, 14),
        J = O(J, ie, oe, Z, U[4], 3889429448, 20),
        Z = O(Z, J, ie, oe, U[9], 568446438, 5),
        oe = O(oe, Z, J, ie, U[14], 3275163606, 9),
        ie = O(ie, oe, Z, J, U[3], 4107603335, 14),
        J = O(J, ie, oe, Z, U[8], 1163531501, 20),
        Z = O(Z, J, ie, oe, U[13], 2850285829, 5),
        oe = O(oe, Z, J, ie, U[2], 4243563512, 9),
        ie = O(ie, oe, Z, J, U[7], 1735328473, 14),
        J = O(J, ie, oe, Z, U[12], 2368359562, 20),
        Z = F(Z, J, ie, oe, U[5], 4294588738, 4),
        oe = F(oe, Z, J, ie, U[8], 2272392833, 11),
        ie = F(ie, oe, Z, J, U[11], 1839030562, 16),
        J = F(J, ie, oe, Z, U[14], 4259657740, 23),
        Z = F(Z, J, ie, oe, U[1], 2763975236, 4),
        oe = F(oe, Z, J, ie, U[4], 1272893353, 11),
        ie = F(ie, oe, Z, J, U[7], 4139469664, 16),
        J = F(J, ie, oe, Z, U[10], 3200236656, 23),
        Z = F(Z, J, ie, oe, U[13], 681279174, 4),
        oe = F(oe, Z, J, ie, U[0], 3936430074, 11),
        ie = F(ie, oe, Z, J, U[3], 3572445317, 16),
        J = F(J, ie, oe, Z, U[6], 76029189, 23),
        Z = F(Z, J, ie, oe, U[9], 3654602809, 4),
        oe = F(oe, Z, J, ie, U[12], 3873151461, 11),
        ie = F(ie, oe, Z, J, U[15], 530742520, 16),
        J = F(J, ie, oe, Z, U[2], 3299628645, 23),
        Z = N(Z, J, ie, oe, U[0], 4096336452, 6),
        oe = N(oe, Z, J, ie, U[7], 1126891415, 10),
        ie = N(ie, oe, Z, J, U[14], 2878612391, 15),
        J = N(J, ie, oe, Z, U[5], 4237533241, 21),
        Z = N(Z, J, ie, oe, U[12], 1700485571, 6),
        oe = N(oe, Z, J, ie, U[3], 2399980690, 10),
        ie = N(ie, oe, Z, J, U[10], 4293915773, 15),
        J = N(J, ie, oe, Z, U[1], 2240044497, 21),
        Z = N(Z, J, ie, oe, U[8], 1873313359, 6),
        oe = N(oe, Z, J, ie, U[15], 4264355552, 10),
        ie = N(ie, oe, Z, J, U[6], 2734768916, 15),
        J = N(J, ie, oe, Z, U[13], 1309151649, 21),
        Z = N(Z, J, ie, oe, U[4], 4149444226, 6),
        oe = N(oe, Z, J, ie, U[11], 3174756917, 10),
        ie = N(ie, oe, Z, J, U[2], 718787259, 15),
        J = N(J, ie, oe, Z, U[9], 3951481745, 21),
        this._a = this._a + Z | 0,
        this._b = this._b + J | 0,
        this._c = this._c + ie | 0,
        this._d = this._d + oe | 0
    }
    ,
    T.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var U = E.allocUnsafe(16);
        return U.writeInt32LE(this._a, 0),
        U.writeInt32LE(this._b, 4),
        U.writeInt32LE(this._c, 8),
        U.writeInt32LE(this._d, 12),
        U
    }
    ;
    function $(U, H) {
        return U << H | U >>> 32 - H
    }
    function B(U, H, Z, J, ie, oe, ae) {
        return $(U + (H & Z | ~H & J) + ie + oe | 0, ae) + H | 0
    }
    function O(U, H, Z, J, ie, oe, ae) {
        return $(U + (H & J | Z & ~J) + ie + oe | 0, ae) + H | 0
    }
    function F(U, H, Z, J, ie, oe, ae) {
        return $(U + (H ^ Z ^ J) + ie + oe | 0, ae) + H | 0
    }
    function N(U, H, Z, J, ie, oe, ae) {
        return $(U + (Z ^ (H | ~J)) + ie + oe | 0, ae) + H | 0
    }
    return md5_js = T,
    md5_js
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
    if (hasRequiredHashBase)
        return hashBase;
    hasRequiredHashBase = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireReadableBrowser$1().Transform
      , E = requireInherits_browser();
    function M($, B) {
        if (!C.isBuffer($) && typeof $ != "string")
            throw new TypeError(B + " must be a string or a buffer")
    }
    function T($) {
        S.call(this),
        this._block = C.allocUnsafe($),
        this._blockSize = $,
        this._blockOffset = 0,
        this._length = [0, 0, 0, 0],
        this._finalized = !1
    }
    return E(T, S),
    T.prototype._transform = function($, B, O) {
        var F = null;
        try {
            this.update($, B)
        } catch (N) {
            F = N
        }
        O(F)
    }
    ,
    T.prototype._flush = function($) {
        var B = null;
        try {
            this.push(this.digest())
        } catch (O) {
            B = O
        }
        $(B)
    }
    ,
    T.prototype.update = function($, B) {
        if (M($, "Data"),
        this._finalized)
            throw new Error("Digest already called");
        C.isBuffer($) || ($ = C.from($, B));
        for (var O = this._block, F = 0; this._blockOffset + $.length - F >= this._blockSize; ) {
            for (var N = this._blockOffset; N < this._blockSize; )
                O[N++] = $[F++];
            this._update(),
            this._blockOffset = 0
        }
        for (; F < $.length; )
            O[this._blockOffset++] = $[F++];
        for (var U = 0, H = $.length * 8; H > 0; ++U)
            this._length[U] += H,
            H = this._length[U] / 4294967296 | 0,
            H > 0 && (this._length[U] -= 4294967296 * H);
        return this
    }
    ,
    T.prototype._update = function() {
        throw new Error("_update is not implemented")
    }
    ,
    T.prototype.digest = function($) {
        if (this._finalized)
            throw new Error("Digest already called");
        this._finalized = !0;
        var B = this._digest();
        $ !== void 0 && (B = B.toString($)),
        this._block.fill(0),
        this._blockOffset = 0;
        for (var O = 0; O < 4; ++O)
            this._length[O] = 0;
        return B
    }
    ,
    T.prototype._digest = function() {
        throw new Error("_digest is not implemented")
    }
    ,
    hashBase = T,
    hashBase
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
    if (hasRequiredRipemd160)
        return ripemd160;
    hasRequiredRipemd160 = 1;
    var C = require$$0$2.Buffer
      , S = requireInherits_browser()
      , E = requireHashBase()
      , M = new Array(16)
      , T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , $ = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , B = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , O = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
      , F = [0, 1518500249, 1859775393, 2400959708, 2840853838]
      , N = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function U() {
        E.call(this, 64),
        this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520
    }
    S(U, E),
    U.prototype._update = function() {
        for (var se = M, le = 0; le < 16; ++le)
            se[le] = this._block.readInt32LE(le * 4);
        for (var de = this._a | 0, fe = this._b | 0, pe = this._c | 0, ge = this._d | 0, we = this._e | 0, Ae = this._a | 0, Se = this._b | 0, ue = this._c | 0, V = this._d | 0, W = this._e | 0, D = 0; D < 80; D += 1) {
            var I, L;
            D < 16 ? (I = Z(de, fe, pe, ge, we, se[T[D]], F[0], B[D]),
            L = ae(Ae, Se, ue, V, W, se[$[D]], N[0], O[D])) : D < 32 ? (I = J(de, fe, pe, ge, we, se[T[D]], F[1], B[D]),
            L = oe(Ae, Se, ue, V, W, se[$[D]], N[1], O[D])) : D < 48 ? (I = ie(de, fe, pe, ge, we, se[T[D]], F[2], B[D]),
            L = ie(Ae, Se, ue, V, W, se[$[D]], N[2], O[D])) : D < 64 ? (I = oe(de, fe, pe, ge, we, se[T[D]], F[3], B[D]),
            L = J(Ae, Se, ue, V, W, se[$[D]], N[3], O[D])) : (I = ae(de, fe, pe, ge, we, se[T[D]], F[4], B[D]),
            L = Z(Ae, Se, ue, V, W, se[$[D]], N[4], O[D])),
            de = we,
            we = ge,
            ge = H(pe, 10),
            pe = fe,
            fe = I,
            Ae = W,
            W = V,
            V = H(ue, 10),
            ue = Se,
            Se = L
        }
        var K = this._b + pe + V | 0;
        this._b = this._c + ge + W | 0,
        this._c = this._d + we + Ae | 0,
        this._d = this._e + de + Se | 0,
        this._e = this._a + fe + ue | 0,
        this._a = K
    }
    ,
    U.prototype._digest = function() {
        this._block[this._blockOffset++] = 128,
        this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64),
        this._update(),
        this._blockOffset = 0),
        this._block.fill(0, this._blockOffset, 56),
        this._block.writeUInt32LE(this._length[0], 56),
        this._block.writeUInt32LE(this._length[1], 60),
        this._update();
        var se = C.alloc ? C.alloc(20) : new C(20);
        return se.writeInt32LE(this._a, 0),
        se.writeInt32LE(this._b, 4),
        se.writeInt32LE(this._c, 8),
        se.writeInt32LE(this._d, 12),
        se.writeInt32LE(this._e, 16),
        se
    }
    ;
    function H(se, le) {
        return se << le | se >>> 32 - le
    }
    function Z(se, le, de, fe, pe, ge, we, Ae) {
        return H(se + (le ^ de ^ fe) + ge + we | 0, Ae) + pe | 0
    }
    function J(se, le, de, fe, pe, ge, we, Ae) {
        return H(se + (le & de | ~le & fe) + ge + we | 0, Ae) + pe | 0
    }
    function ie(se, le, de, fe, pe, ge, we, Ae) {
        return H(se + ((le | ~de) ^ fe) + ge + we | 0, Ae) + pe | 0
    }
    function oe(se, le, de, fe, pe, ge, we, Ae) {
        return H(se + (le & fe | de & ~fe) + ge + we | 0, Ae) + pe | 0
    }
    function ae(se, le, de, fe, pe, ge, we, Ae) {
        return H(se + (le ^ (de | ~fe)) + ge + we | 0, Ae) + pe | 0
    }
    return ripemd160 = U,
    ripemd160
}
var sha_js = {
    exports: {}
}, hash$2, hasRequiredHash$1;
function requireHash$1() {
    if (hasRequiredHash$1)
        return hash$2;
    hasRequiredHash$1 = 1;
    var C = requireSafeBuffer$1().Buffer;
    function S(E, M) {
        this._block = C.alloc(E),
        this._finalSize = M,
        this._blockSize = E,
        this._len = 0
    }
    return S.prototype.update = function(E, M) {
        typeof E == "string" && (M = M || "utf8",
        E = C.from(E, M));
        for (var T = this._block, $ = this._blockSize, B = E.length, O = this._len, F = 0; F < B; ) {
            for (var N = O % $, U = Math.min(B - F, $ - N), H = 0; H < U; H++)
                T[N + H] = E[F + H];
            O += U,
            F += U,
            O % $ === 0 && this._update(T)
        }
        return this._len += B,
        this
    }
    ,
    S.prototype.digest = function(E) {
        var M = this._len % this._blockSize;
        this._block[M] = 128,
        this._block.fill(0, M + 1),
        M >= this._finalSize && (this._update(this._block),
        this._block.fill(0));
        var T = this._len * 8;
        if (T <= 4294967295)
            this._block.writeUInt32BE(T, this._blockSize - 4);
        else {
            var $ = (T & 4294967295) >>> 0
              , B = (T - $) / 4294967296;
            this._block.writeUInt32BE(B, this._blockSize - 8),
            this._block.writeUInt32BE($, this._blockSize - 4)
        }
        this._update(this._block);
        var O = this._hash();
        return E ? O.toString(E) : O
    }
    ,
    S.prototype._update = function() {
        throw new Error("_update must be implemented by subclass")
    }
    ,
    hash$2 = S,
    hash$2
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
    if (hasRequiredSha$1)
        return sha$1;
    hasRequiredSha$1 = 1;
    var C = requireInherits_browser()
      , S = requireHash$1()
      , E = requireSafeBuffer$1().Buffer
      , M = [1518500249, 1859775393, -1894007588, -899497514]
      , T = new Array(80);
    function $() {
        this.init(),
        this._w = T,
        S.call(this, 64, 56)
    }
    C($, S),
    $.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function B(N) {
        return N << 5 | N >>> 27
    }
    function O(N) {
        return N << 30 | N >>> 2
    }
    function F(N, U, H, Z) {
        return N === 0 ? U & H | ~U & Z : N === 2 ? U & H | U & Z | H & Z : U ^ H ^ Z
    }
    return $.prototype._update = function(N) {
        for (var U = this._w, H = this._a | 0, Z = this._b | 0, J = this._c | 0, ie = this._d | 0, oe = this._e | 0, ae = 0; ae < 16; ++ae)
            U[ae] = N.readInt32BE(ae * 4);
        for (; ae < 80; ++ae)
            U[ae] = U[ae - 3] ^ U[ae - 8] ^ U[ae - 14] ^ U[ae - 16];
        for (var se = 0; se < 80; ++se) {
            var le = ~~(se / 20)
              , de = B(H) + F(le, Z, J, ie) + oe + U[se] + M[le] | 0;
            oe = ie,
            ie = J,
            J = O(Z),
            Z = H,
            H = de
        }
        this._a = H + this._a | 0,
        this._b = Z + this._b | 0,
        this._c = J + this._c | 0,
        this._d = ie + this._d | 0,
        this._e = oe + this._e | 0
    }
    ,
    $.prototype._hash = function() {
        var N = E.allocUnsafe(20);
        return N.writeInt32BE(this._a | 0, 0),
        N.writeInt32BE(this._b | 0, 4),
        N.writeInt32BE(this._c | 0, 8),
        N.writeInt32BE(this._d | 0, 12),
        N.writeInt32BE(this._e | 0, 16),
        N
    }
    ,
    sha$1 = $,
    sha$1
}
var sha1, hasRequiredSha1;
function requireSha1() {
    if (hasRequiredSha1)
        return sha1;
    hasRequiredSha1 = 1;
    var C = requireInherits_browser()
      , S = requireHash$1()
      , E = requireSafeBuffer$1().Buffer
      , M = [1518500249, 1859775393, -1894007588, -899497514]
      , T = new Array(80);
    function $() {
        this.init(),
        this._w = T,
        S.call(this, 64, 56)
    }
    C($, S),
    $.prototype.init = function() {
        return this._a = 1732584193,
        this._b = 4023233417,
        this._c = 2562383102,
        this._d = 271733878,
        this._e = 3285377520,
        this
    }
    ;
    function B(U) {
        return U << 1 | U >>> 31
    }
    function O(U) {
        return U << 5 | U >>> 27
    }
    function F(U) {
        return U << 30 | U >>> 2
    }
    function N(U, H, Z, J) {
        return U === 0 ? H & Z | ~H & J : U === 2 ? H & Z | H & J | Z & J : H ^ Z ^ J
    }
    return $.prototype._update = function(U) {
        for (var H = this._w, Z = this._a | 0, J = this._b | 0, ie = this._c | 0, oe = this._d | 0, ae = this._e | 0, se = 0; se < 16; ++se)
            H[se] = U.readInt32BE(se * 4);
        for (; se < 80; ++se)
            H[se] = B(H[se - 3] ^ H[se - 8] ^ H[se - 14] ^ H[se - 16]);
        for (var le = 0; le < 80; ++le) {
            var de = ~~(le / 20)
              , fe = O(Z) + N(de, J, ie, oe) + ae + H[le] + M[de] | 0;
            ae = oe,
            oe = ie,
            ie = F(J),
            J = Z,
            Z = fe
        }
        this._a = Z + this._a | 0,
        this._b = J + this._b | 0,
        this._c = ie + this._c | 0,
        this._d = oe + this._d | 0,
        this._e = ae + this._e | 0
    }
    ,
    $.prototype._hash = function() {
        var U = E.allocUnsafe(20);
        return U.writeInt32BE(this._a | 0, 0),
        U.writeInt32BE(this._b | 0, 4),
        U.writeInt32BE(this._c | 0, 8),
        U.writeInt32BE(this._d | 0, 12),
        U.writeInt32BE(this._e | 0, 16),
        U
    }
    ,
    sha1 = $,
    sha1
}
var sha256$5, hasRequiredSha256;
function requireSha256() {
    if (hasRequiredSha256)
        return sha256$5;
    hasRequiredSha256 = 1;
    var C = requireInherits_browser()
      , S = requireHash$1()
      , E = requireSafeBuffer$1().Buffer
      , M = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
      , T = new Array(64);
    function $() {
        this.init(),
        this._w = T,
        S.call(this, 64, 56)
    }
    C($, S),
    $.prototype.init = function() {
        return this._a = 1779033703,
        this._b = 3144134277,
        this._c = 1013904242,
        this._d = 2773480762,
        this._e = 1359893119,
        this._f = 2600822924,
        this._g = 528734635,
        this._h = 1541459225,
        this
    }
    ;
    function B(Z, J, ie) {
        return ie ^ Z & (J ^ ie)
    }
    function O(Z, J, ie) {
        return Z & J | ie & (Z | J)
    }
    function F(Z) {
        return (Z >>> 2 | Z << 30) ^ (Z >>> 13 | Z << 19) ^ (Z >>> 22 | Z << 10)
    }
    function N(Z) {
        return (Z >>> 6 | Z << 26) ^ (Z >>> 11 | Z << 21) ^ (Z >>> 25 | Z << 7)
    }
    function U(Z) {
        return (Z >>> 7 | Z << 25) ^ (Z >>> 18 | Z << 14) ^ Z >>> 3
    }
    function H(Z) {
        return (Z >>> 17 | Z << 15) ^ (Z >>> 19 | Z << 13) ^ Z >>> 10
    }
    return $.prototype._update = function(Z) {
        for (var J = this._w, ie = this._a | 0, oe = this._b | 0, ae = this._c | 0, se = this._d | 0, le = this._e | 0, de = this._f | 0, fe = this._g | 0, pe = this._h | 0, ge = 0; ge < 16; ++ge)
            J[ge] = Z.readInt32BE(ge * 4);
        for (; ge < 64; ++ge)
            J[ge] = H(J[ge - 2]) + J[ge - 7] + U(J[ge - 15]) + J[ge - 16] | 0;
        for (var we = 0; we < 64; ++we) {
            var Ae = pe + N(le) + B(le, de, fe) + M[we] + J[we] | 0
              , Se = F(ie) + O(ie, oe, ae) | 0;
            pe = fe,
            fe = de,
            de = le,
            le = se + Ae | 0,
            se = ae,
            ae = oe,
            oe = ie,
            ie = Ae + Se | 0
        }
        this._a = ie + this._a | 0,
        this._b = oe + this._b | 0,
        this._c = ae + this._c | 0,
        this._d = se + this._d | 0,
        this._e = le + this._e | 0,
        this._f = de + this._f | 0,
        this._g = fe + this._g | 0,
        this._h = pe + this._h | 0
    }
    ,
    $.prototype._hash = function() {
        var Z = E.allocUnsafe(32);
        return Z.writeInt32BE(this._a, 0),
        Z.writeInt32BE(this._b, 4),
        Z.writeInt32BE(this._c, 8),
        Z.writeInt32BE(this._d, 12),
        Z.writeInt32BE(this._e, 16),
        Z.writeInt32BE(this._f, 20),
        Z.writeInt32BE(this._g, 24),
        Z.writeInt32BE(this._h, 28),
        Z
    }
    ,
    sha256$5 = $,
    sha256$5
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
    if (hasRequiredSha224)
        return sha224$1;
    hasRequiredSha224 = 1;
    var C = requireInherits_browser()
      , S = requireSha256()
      , E = requireHash$1()
      , M = requireSafeBuffer$1().Buffer
      , T = new Array(64);
    function $() {
        this.init(),
        this._w = T,
        E.call(this, 64, 56)
    }
    return C($, S),
    $.prototype.init = function() {
        return this._a = 3238371032,
        this._b = 914150663,
        this._c = 812702999,
        this._d = 4144912697,
        this._e = 4290775857,
        this._f = 1750603025,
        this._g = 1694076839,
        this._h = 3204075428,
        this
    }
    ,
    $.prototype._hash = function() {
        var B = M.allocUnsafe(28);
        return B.writeInt32BE(this._a, 0),
        B.writeInt32BE(this._b, 4),
        B.writeInt32BE(this._c, 8),
        B.writeInt32BE(this._d, 12),
        B.writeInt32BE(this._e, 16),
        B.writeInt32BE(this._f, 20),
        B.writeInt32BE(this._g, 24),
        B
    }
    ,
    sha224$1 = $,
    sha224$1
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
    if (hasRequiredSha512)
        return sha512$1;
    hasRequiredSha512 = 1;
    var C = requireInherits_browser()
      , S = requireHash$1()
      , E = requireSafeBuffer$1().Buffer
      , M = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]
      , T = new Array(160);
    function $() {
        this.init(),
        this._w = T,
        S.call(this, 128, 112)
    }
    C($, S),
    $.prototype.init = function() {
        return this._ah = 1779033703,
        this._bh = 3144134277,
        this._ch = 1013904242,
        this._dh = 2773480762,
        this._eh = 1359893119,
        this._fh = 2600822924,
        this._gh = 528734635,
        this._hh = 1541459225,
        this._al = 4089235720,
        this._bl = 2227873595,
        this._cl = 4271175723,
        this._dl = 1595750129,
        this._el = 2917565137,
        this._fl = 725511199,
        this._gl = 4215389547,
        this._hl = 327033209,
        this
    }
    ;
    function B(oe, ae, se) {
        return se ^ oe & (ae ^ se)
    }
    function O(oe, ae, se) {
        return oe & ae | se & (oe | ae)
    }
    function F(oe, ae) {
        return (oe >>> 28 | ae << 4) ^ (ae >>> 2 | oe << 30) ^ (ae >>> 7 | oe << 25)
    }
    function N(oe, ae) {
        return (oe >>> 14 | ae << 18) ^ (oe >>> 18 | ae << 14) ^ (ae >>> 9 | oe << 23)
    }
    function U(oe, ae) {
        return (oe >>> 1 | ae << 31) ^ (oe >>> 8 | ae << 24) ^ oe >>> 7
    }
    function H(oe, ae) {
        return (oe >>> 1 | ae << 31) ^ (oe >>> 8 | ae << 24) ^ (oe >>> 7 | ae << 25)
    }
    function Z(oe, ae) {
        return (oe >>> 19 | ae << 13) ^ (ae >>> 29 | oe << 3) ^ oe >>> 6
    }
    function J(oe, ae) {
        return (oe >>> 19 | ae << 13) ^ (ae >>> 29 | oe << 3) ^ (oe >>> 6 | ae << 26)
    }
    function ie(oe, ae) {
        return oe >>> 0 < ae >>> 0 ? 1 : 0
    }
    return $.prototype._update = function(oe) {
        for (var ae = this._w, se = this._ah | 0, le = this._bh | 0, de = this._ch | 0, fe = this._dh | 0, pe = this._eh | 0, ge = this._fh | 0, we = this._gh | 0, Ae = this._hh | 0, Se = this._al | 0, ue = this._bl | 0, V = this._cl | 0, W = this._dl | 0, D = this._el | 0, I = this._fl | 0, L = this._gl | 0, K = this._hl | 0, X = 0; X < 32; X += 2)
            ae[X] = oe.readInt32BE(X * 4),
            ae[X + 1] = oe.readInt32BE(X * 4 + 4);
        for (; X < 160; X += 2) {
            var Y = ae[X - 30]
              , j = ae[X - 15 * 2 + 1]
              , G = U(Y, j)
              , ne = H(j, Y);
            Y = ae[X - 2 * 2],
            j = ae[X - 2 * 2 + 1];
            var te = Z(Y, j)
              , ce = J(j, Y)
              , Ee = ae[X - 7 * 2]
              , Re = ae[X - 7 * 2 + 1]
              , Te = ae[X - 16 * 2]
              , xe = ae[X - 16 * 2 + 1]
              , ve = ne + Re | 0
              , Me = G + Ee + ie(ve, ne) | 0;
            ve = ve + ce | 0,
            Me = Me + te + ie(ve, ce) | 0,
            ve = ve + xe | 0,
            Me = Me + Te + ie(ve, xe) | 0,
            ae[X] = Me,
            ae[X + 1] = ve
        }
        for (var Fe = 0; Fe < 160; Fe += 2) {
            Me = ae[Fe],
            ve = ae[Fe + 1];
            var be = O(se, le, de)
              , Ce = O(Se, ue, V)
              , ze = F(se, Se)
              , Ge = F(Se, se)
              , nt = N(pe, D)
              , bt = N(D, pe)
              , ct = M[Fe]
              , De = M[Fe + 1]
              , Ue = B(pe, ge, we)
              , We = B(D, I, L)
              , Xe = K + bt | 0
              , ht = Ae + nt + ie(Xe, K) | 0;
            Xe = Xe + We | 0,
            ht = ht + Ue + ie(Xe, We) | 0,
            Xe = Xe + De | 0,
            ht = ht + ct + ie(Xe, De) | 0,
            Xe = Xe + ve | 0,
            ht = ht + Me + ie(Xe, ve) | 0;
            var Je = Ge + Ce | 0
              , ot = ze + be + ie(Je, Ge) | 0;
            Ae = we,
            K = L,
            we = ge,
            L = I,
            ge = pe,
            I = D,
            D = W + Xe | 0,
            pe = fe + ht + ie(D, W) | 0,
            fe = de,
            W = V,
            de = le,
            V = ue,
            le = se,
            ue = Se,
            Se = Xe + Je | 0,
            se = ht + ot + ie(Se, Xe) | 0
        }
        this._al = this._al + Se | 0,
        this._bl = this._bl + ue | 0,
        this._cl = this._cl + V | 0,
        this._dl = this._dl + W | 0,
        this._el = this._el + D | 0,
        this._fl = this._fl + I | 0,
        this._gl = this._gl + L | 0,
        this._hl = this._hl + K | 0,
        this._ah = this._ah + se + ie(this._al, Se) | 0,
        this._bh = this._bh + le + ie(this._bl, ue) | 0,
        this._ch = this._ch + de + ie(this._cl, V) | 0,
        this._dh = this._dh + fe + ie(this._dl, W) | 0,
        this._eh = this._eh + pe + ie(this._el, D) | 0,
        this._fh = this._fh + ge + ie(this._fl, I) | 0,
        this._gh = this._gh + we + ie(this._gl, L) | 0,
        this._hh = this._hh + Ae + ie(this._hl, K) | 0
    }
    ,
    $.prototype._hash = function() {
        var oe = E.allocUnsafe(64);
        function ae(se, le, de) {
            oe.writeInt32BE(se, de),
            oe.writeInt32BE(le, de + 4)
        }
        return ae(this._ah, this._al, 0),
        ae(this._bh, this._bl, 8),
        ae(this._ch, this._cl, 16),
        ae(this._dh, this._dl, 24),
        ae(this._eh, this._el, 32),
        ae(this._fh, this._fl, 40),
        ae(this._gh, this._gl, 48),
        ae(this._hh, this._hl, 56),
        oe
    }
    ,
    sha512$1 = $,
    sha512$1
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
    if (hasRequiredSha384)
        return sha384$1;
    hasRequiredSha384 = 1;
    var C = requireInherits_browser()
      , S = requireSha512()
      , E = requireHash$1()
      , M = requireSafeBuffer$1().Buffer
      , T = new Array(160);
    function $() {
        this.init(),
        this._w = T,
        E.call(this, 128, 112)
    }
    return C($, S),
    $.prototype.init = function() {
        return this._ah = 3418070365,
        this._bh = 1654270250,
        this._ch = 2438529370,
        this._dh = 355462360,
        this._eh = 1731405415,
        this._fh = 2394180231,
        this._gh = 3675008525,
        this._hh = 1203062813,
        this._al = 3238371032,
        this._bl = 914150663,
        this._cl = 812702999,
        this._dl = 4144912697,
        this._el = 4290775857,
        this._fl = 1750603025,
        this._gl = 1694076839,
        this._hl = 3204075428,
        this
    }
    ,
    $.prototype._hash = function() {
        var B = M.allocUnsafe(48);
        function O(F, N, U) {
            B.writeInt32BE(F, U),
            B.writeInt32BE(N, U + 4)
        }
        return O(this._ah, this._al, 0),
        O(this._bh, this._bl, 8),
        O(this._ch, this._cl, 16),
        O(this._dh, this._dl, 24),
        O(this._eh, this._el, 32),
        O(this._fh, this._fl, 40),
        B
    }
    ,
    sha384$1 = $,
    sha384$1
}
var hasRequiredSha_js;
function requireSha_js() {
    if (hasRequiredSha_js)
        return sha_js.exports;
    hasRequiredSha_js = 1;
    var C = sha_js.exports = function(E) {
        E = E.toLowerCase();
        var M = C[E];
        if (!M)
            throw new Error(E + " is not supported (we accept pull requests)");
        return new M
    }
    ;
    return C.sha = requireSha$1(),
    C.sha1 = requireSha1(),
    C.sha224 = requireSha224(),
    C.sha256 = requireSha256(),
    C.sha384 = requireSha384(),
    C.sha512 = requireSha512(),
    sha_js.exports
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
    if (hasRequiredStreamBrowserify)
        return streamBrowserify;
    hasRequiredStreamBrowserify = 1,
    streamBrowserify = E;
    var C = eventsExports.EventEmitter
      , S = requireInherits_browser();
    S(E, C),
    E.Readable = require_stream_readable$1(),
    E.Writable = require_stream_writable$1(),
    E.Duplex = require_stream_duplex$1(),
    E.Transform = require_stream_transform$1(),
    E.PassThrough = require_stream_passthrough$1(),
    E.finished = requireEndOfStream(),
    E.pipeline = requirePipeline(),
    E.Stream = E;
    function E() {
        C.call(this)
    }
    return E.prototype.pipe = function(M, T) {
        var $ = this;
        function B(J) {
            M.writable && M.write(J) === !1 && $.pause && $.pause()
        }
        $.on("data", B);
        function O() {
            $.readable && $.resume && $.resume()
        }
        M.on("drain", O),
        !M._isStdio && (!T || T.end !== !1) && ($.on("end", N),
        $.on("close", U));
        var F = !1;
        function N() {
            F || (F = !0,
            M.end())
        }
        function U() {
            F || (F = !0,
            typeof M.destroy == "function" && M.destroy())
        }
        function H(J) {
            if (Z(),
            C.listenerCount(this, "error") === 0)
                throw J
        }
        $.on("error", H),
        M.on("error", H);
        function Z() {
            $.removeListener("data", B),
            M.removeListener("drain", O),
            $.removeListener("end", N),
            $.removeListener("close", U),
            $.removeListener("error", H),
            M.removeListener("error", H),
            $.removeListener("end", Z),
            $.removeListener("close", Z),
            M.removeListener("close", Z)
        }
        return $.on("end", Z),
        $.on("close", Z),
        M.on("close", Z),
        M.emit("pipe", $),
        M
    }
    ,
    streamBrowserify
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
    if (hasRequiredCipherBase)
        return cipherBase;
    hasRequiredCipherBase = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireStreamBrowserify().Transform
      , E = requireString_decoder().StringDecoder
      , M = requireInherits_browser();
    function T($) {
        S.call(this),
        this.hashMode = typeof $ == "string",
        this.hashMode ? this[$] = this._finalOrDigest : this.final = this._finalOrDigest,
        this._final && (this.__final = this._final,
        this._final = null),
        this._decoder = null,
        this._encoding = null
    }
    return M(T, S),
    T.prototype.update = function($, B, O) {
        typeof $ == "string" && ($ = C.from($, B));
        var F = this._update($);
        return this.hashMode ? this : (O && (F = this._toString(F, O)),
        F)
    }
    ,
    T.prototype.setAutoPadding = function() {}
    ,
    T.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state")
    }
    ,
    T.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state")
    }
    ,
    T.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state")
    }
    ,
    T.prototype._transform = function($, B, O) {
        var F;
        try {
            this.hashMode ? this._update($) : this.push(this._update($))
        } catch (N) {
            F = N
        } finally {
            O(F)
        }
    }
    ,
    T.prototype._flush = function($) {
        var B;
        try {
            this.push(this.__final())
        } catch (O) {
            B = O
        }
        $(B)
    }
    ,
    T.prototype._finalOrDigest = function($) {
        var B = this.__final() || C.alloc(0);
        return $ && (B = this._toString(B, $, !0)),
        B
    }
    ,
    T.prototype._toString = function($, B, O) {
        if (this._decoder || (this._decoder = new E(B),
        this._encoding = B),
        this._encoding !== B)
            throw new Error("can't switch encodings");
        var F = this._decoder.write($);
        return O && (F += this._decoder.end()),
        F
    }
    ,
    cipherBase = T,
    cipherBase
}
var browser$b, hasRequiredBrowser$9;
function requireBrowser$9() {
    if (hasRequiredBrowser$9)
        return browser$b;
    hasRequiredBrowser$9 = 1;
    var C = requireInherits_browser()
      , S = requireMd5_js()
      , E = requireRipemd160()
      , M = requireSha_js()
      , T = requireCipherBase();
    function $(B) {
        T.call(this, "digest"),
        this._hash = B
    }
    return C($, T),
    $.prototype._update = function(B) {
        this._hash.update(B)
    }
    ,
    $.prototype._final = function() {
        return this._hash.digest()
    }
    ,
    browser$b = function(O) {
        return O = O.toLowerCase(),
        O === "md5" ? new S : O === "rmd160" || O === "ripemd160" ? new E : new $(M(O))
    }
    ,
    browser$b
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
    if (hasRequiredLegacy)
        return legacy;
    hasRequiredLegacy = 1;
    var C = requireInherits_browser()
      , S = requireSafeBuffer$1().Buffer
      , E = requireCipherBase()
      , M = S.alloc(128)
      , T = 64;
    function $(B, O) {
        E.call(this, "digest"),
        typeof O == "string" && (O = S.from(O)),
        this._alg = B,
        this._key = O,
        O.length > T ? O = B(O) : O.length < T && (O = S.concat([O, M], T));
        for (var F = this._ipad = S.allocUnsafe(T), N = this._opad = S.allocUnsafe(T), U = 0; U < T; U++)
            F[U] = O[U] ^ 54,
            N[U] = O[U] ^ 92;
        this._hash = [F]
    }
    return C($, E),
    $.prototype._update = function(B) {
        this._hash.push(B)
    }
    ,
    $.prototype._final = function() {
        var B = this._alg(S.concat(this._hash));
        return this._alg(S.concat([this._opad, B]))
    }
    ,
    legacy = $,
    legacy
}
var md5, hasRequiredMd5;
function requireMd5() {
    if (hasRequiredMd5)
        return md5;
    hasRequiredMd5 = 1;
    var C = requireMd5_js();
    return md5 = function(S) {
        return new C().update(S).digest()
    }
    ,
    md5
}
var browser$a, hasRequiredBrowser$8;
function requireBrowser$8() {
    if (hasRequiredBrowser$8)
        return browser$a;
    hasRequiredBrowser$8 = 1;
    var C = requireInherits_browser()
      , S = requireLegacy()
      , E = requireCipherBase()
      , M = requireSafeBuffer$1().Buffer
      , T = requireMd5()
      , $ = requireRipemd160()
      , B = requireSha_js()
      , O = M.alloc(128);
    function F(N, U) {
        E.call(this, "digest"),
        typeof U == "string" && (U = M.from(U));
        var H = N === "sha512" || N === "sha384" ? 128 : 64;
        if (this._alg = N,
        this._key = U,
        U.length > H) {
            var Z = N === "rmd160" ? new $ : B(N);
            U = Z.update(U).digest()
        } else
            U.length < H && (U = M.concat([U, O], H));
        for (var J = this._ipad = M.allocUnsafe(H), ie = this._opad = M.allocUnsafe(H), oe = 0; oe < H; oe++)
            J[oe] = U[oe] ^ 54,
            ie[oe] = U[oe] ^ 92;
        this._hash = N === "rmd160" ? new $ : B(N),
        this._hash.update(J)
    }
    return C(F, E),
    F.prototype._update = function(N) {
        this._hash.update(N)
    }
    ,
    F.prototype._final = function() {
        var N = this._hash.digest()
          , U = this._alg === "rmd160" ? new $ : B(this._alg);
        return U.update(this._opad).update(N).digest()
    }
    ,
    browser$a = function(U, H) {
        return U = U.toLowerCase(),
        U === "rmd160" || U === "ripemd160" ? new F("rmd160",H) : U === "md5" ? new S(T,H) : new F(U,H)
    }
    ,
    browser$a
}
const sha224WithRSAEncryption = {
    sign: "rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
}
  , sha256WithRSAEncryption = {
    sign: "rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
}
  , sha384WithRSAEncryption = {
    sign: "rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
}
  , sha512WithRSAEncryption = {
    sign: "rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
}
  , sha256$4 = {
    sign: "ecdsa",
    hash: "sha256",
    id: ""
}
  , sha224 = {
    sign: "ecdsa",
    hash: "sha224",
    id: ""
}
  , sha384 = {
    sign: "ecdsa",
    hash: "sha384",
    id: ""
}
  , sha512 = {
    sign: "ecdsa",
    hash: "sha512",
    id: ""
}
  , DSA = {
    sign: "dsa",
    hash: "sha1",
    id: ""
}
  , ripemd160WithRSA = {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
}
  , md5WithRSAEncryption = {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
}
  , require$$6$1 = {
    sha224WithRSAEncryption,
    "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption,
    "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption,
    "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption,
    "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
    },
    sha256: sha256$4,
    sha224,
    sha384,
    sha512,
    "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
    },
    DSA,
    "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
    },
    "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
    },
    "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
    },
    "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
    },
    "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
    },
    ripemd160WithRSA,
    "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption,
    "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
    }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
    return hasRequiredAlgos || (hasRequiredAlgos = 1,
    algos = require$$6$1),
    algos
}
var browser$9 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
    if (hasRequiredPrecondition)
        return precondition;
    hasRequiredPrecondition = 1;
    var C = Math.pow(2, 30) - 1;
    return precondition = function(S, E) {
        if (typeof S != "number")
            throw new TypeError("Iterations not a number");
        if (S < 0)
            throw new TypeError("Bad iterations");
        if (typeof E != "number")
            throw new TypeError("Key length not a number");
        if (E < 0 || E > C || E !== E)
            throw new TypeError("Bad key length")
    }
    ,
    precondition
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
    if (hasRequiredDefaultEncoding)
        return defaultEncoding_1;
    hasRequiredDefaultEncoding = 1;
    var C;
    if (commonjsGlobal.process && commonjsGlobal.process.browser)
        C = "utf-8";
    else if (commonjsGlobal.process && commonjsGlobal.process.version) {
        var S = parseInt(process$1.version.split(".")[0].slice(1), 10);
        C = S >= 6 ? "utf-8" : "binary"
    } else
        C = "utf-8";
    return defaultEncoding_1 = C,
    defaultEncoding_1
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
    if (hasRequiredToBuffer)
        return toBuffer;
    hasRequiredToBuffer = 1;
    var C = requireSafeBuffer$1().Buffer;
    return toBuffer = function(S, E, M) {
        if (C.isBuffer(S))
            return S;
        if (typeof S == "string")
            return C.from(S, E);
        if (ArrayBuffer.isView(S))
            return C.from(S.buffer);
        throw new TypeError(M + " must be a string, a Buffer, a typed array or a DataView")
    }
    ,
    toBuffer
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
    if (hasRequiredSyncBrowser)
        return syncBrowser;
    hasRequiredSyncBrowser = 1;
    var C = requireMd5()
      , S = requireRipemd160()
      , E = requireSha_js()
      , M = requireSafeBuffer$1().Buffer
      , T = requirePrecondition()
      , $ = requireDefaultEncoding()
      , B = requireToBuffer()
      , O = M.alloc(128)
      , F = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function N(Z, J, ie) {
        var oe = U(Z)
          , ae = Z === "sha512" || Z === "sha384" ? 128 : 64;
        J.length > ae ? J = oe(J) : J.length < ae && (J = M.concat([J, O], ae));
        for (var se = M.allocUnsafe(ae + F[Z]), le = M.allocUnsafe(ae + F[Z]), de = 0; de < ae; de++)
            se[de] = J[de] ^ 54,
            le[de] = J[de] ^ 92;
        var fe = M.allocUnsafe(ae + ie + 4);
        se.copy(fe, 0, 0, ae),
        this.ipad1 = fe,
        this.ipad2 = se,
        this.opad = le,
        this.alg = Z,
        this.blocksize = ae,
        this.hash = oe,
        this.size = F[Z]
    }
    N.prototype.run = function(Z, J) {
        Z.copy(J, this.blocksize);
        var ie = this.hash(J);
        return ie.copy(this.opad, this.blocksize),
        this.hash(this.opad)
    }
    ;
    function U(Z) {
        function J(oe) {
            return E(Z).update(oe).digest()
        }
        function ie(oe) {
            return new S().update(oe).digest()
        }
        return Z === "rmd160" || Z === "ripemd160" ? ie : Z === "md5" ? C : J
    }
    function H(Z, J, ie, oe, ae) {
        T(ie, oe),
        Z = B(Z, $, "Password"),
        J = B(J, $, "Salt"),
        ae = ae || "sha1";
        var se = new N(ae,Z,J.length)
          , le = M.allocUnsafe(oe)
          , de = M.allocUnsafe(J.length + 4);
        J.copy(de, 0, 0, J.length);
        for (var fe = 0, pe = F[ae], ge = Math.ceil(oe / pe), we = 1; we <= ge; we++) {
            de.writeUInt32BE(we, J.length);
            for (var Ae = se.run(de, se.ipad1), Se = Ae, ue = 1; ue < ie; ue++) {
                Se = se.run(Se, se.ipad2);
                for (var V = 0; V < pe; V++)
                    Ae[V] ^= Se[V]
            }
            Ae.copy(le, fe),
            fe += pe
        }
        return le
    }
    return syncBrowser = H,
    syncBrowser
}
var async$1, hasRequiredAsync;
function requireAsync() {
    if (hasRequiredAsync)
        return async$1;
    hasRequiredAsync = 1;
    var C = requireSafeBuffer$1().Buffer, S = requirePrecondition(), E = requireDefaultEncoding(), M = requireSyncBrowser(), T = requireToBuffer(), $, B = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, O = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, F = [];
    function N(ie) {
        if (commonjsGlobal.process && !commonjsGlobal.process.browser || !B || !B.importKey || !B.deriveBits)
            return Promise.resolve(!1);
        if (F[ie] !== void 0)
            return F[ie];
        $ = $ || C.alloc(8);
        var oe = Z($, $, 10, 128, ie).then(function() {
            return !0
        }).catch(function() {
            return !1
        });
        return F[ie] = oe,
        oe
    }
    var U;
    function H() {
        return U || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? U = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? U = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? U = commonjsGlobal.setImmediate : U = commonjsGlobal.setTimeout,
        U)
    }
    function Z(ie, oe, ae, se, le) {
        return B.importKey("raw", ie, {
            name: "PBKDF2"
        }, !1, ["deriveBits"]).then(function(de) {
            return B.deriveBits({
                name: "PBKDF2",
                salt: oe,
                iterations: ae,
                hash: {
                    name: le
                }
            }, de, se << 3)
        }).then(function(de) {
            return C.from(de)
        })
    }
    function J(ie, oe) {
        ie.then(function(ae) {
            H()(function() {
                oe(null, ae)
            })
        }, function(ae) {
            H()(function() {
                oe(ae)
            })
        })
    }
    return async$1 = function(ie, oe, ae, se, le, de) {
        typeof le == "function" && (de = le,
        le = void 0),
        le = le || "sha1";
        var fe = O[le.toLowerCase()];
        if (!fe || typeof commonjsGlobal.Promise != "function") {
            H()(function() {
                var pe;
                try {
                    pe = M(ie, oe, ae, se, le)
                } catch (ge) {
                    return de(ge)
                }
                de(null, pe)
            });
            return
        }
        if (S(ae, se),
        ie = T(ie, E, "Password"),
        oe = T(oe, E, "Salt"),
        typeof de != "function")
            throw new Error("No callback provided to pbkdf2");
        J(N(fe).then(function(pe) {
            return pe ? Z(ie, oe, ae, se, fe) : M(ie, oe, ae, se, le)
        }), de)
    }
    ,
    async$1
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
    return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1,
    browser$9.pbkdf2 = requireAsync(),
    browser$9.pbkdf2Sync = requireSyncBrowser()),
    browser$9
}
var browser$8 = {}, des$1 = {}, utils$6 = {}, hasRequiredUtils$3;
function requireUtils$3() {
    if (hasRequiredUtils$3)
        return utils$6;
    hasRequiredUtils$3 = 1,
    utils$6.readUInt32BE = function(T, $) {
        var B = T[0 + $] << 24 | T[1 + $] << 16 | T[2 + $] << 8 | T[3 + $];
        return B >>> 0
    }
    ,
    utils$6.writeUInt32BE = function(T, $, B) {
        T[0 + B] = $ >>> 24,
        T[1 + B] = $ >>> 16 & 255,
        T[2 + B] = $ >>> 8 & 255,
        T[3 + B] = $ & 255
    }
    ,
    utils$6.ip = function(T, $, B, O) {
        for (var F = 0, N = 0, U = 6; U >= 0; U -= 2) {
            for (var H = 0; H <= 24; H += 8)
                F <<= 1,
                F |= $ >>> H + U & 1;
            for (var H = 0; H <= 24; H += 8)
                F <<= 1,
                F |= T >>> H + U & 1
        }
        for (var U = 6; U >= 0; U -= 2) {
            for (var H = 1; H <= 25; H += 8)
                N <<= 1,
                N |= $ >>> H + U & 1;
            for (var H = 1; H <= 25; H += 8)
                N <<= 1,
                N |= T >>> H + U & 1
        }
        B[O + 0] = F >>> 0,
        B[O + 1] = N >>> 0
    }
    ,
    utils$6.rip = function(T, $, B, O) {
        for (var F = 0, N = 0, U = 0; U < 4; U++)
            for (var H = 24; H >= 0; H -= 8)
                F <<= 1,
                F |= $ >>> H + U & 1,
                F <<= 1,
                F |= T >>> H + U & 1;
        for (var U = 4; U < 8; U++)
            for (var H = 24; H >= 0; H -= 8)
                N <<= 1,
                N |= $ >>> H + U & 1,
                N <<= 1,
                N |= T >>> H + U & 1;
        B[O + 0] = F >>> 0,
        B[O + 1] = N >>> 0
    }
    ,
    utils$6.pc1 = function(T, $, B, O) {
        for (var F = 0, N = 0, U = 7; U >= 5; U--) {
            for (var H = 0; H <= 24; H += 8)
                F <<= 1,
                F |= $ >> H + U & 1;
            for (var H = 0; H <= 24; H += 8)
                F <<= 1,
                F |= T >> H + U & 1
        }
        for (var H = 0; H <= 24; H += 8)
            F <<= 1,
            F |= $ >> H + U & 1;
        for (var U = 1; U <= 3; U++) {
            for (var H = 0; H <= 24; H += 8)
                N <<= 1,
                N |= $ >> H + U & 1;
            for (var H = 0; H <= 24; H += 8)
                N <<= 1,
                N |= T >> H + U & 1
        }
        for (var H = 0; H <= 24; H += 8)
            N <<= 1,
            N |= T >> H + U & 1;
        B[O + 0] = F >>> 0,
        B[O + 1] = N >>> 0
    }
    ,
    utils$6.r28shl = function(T, $) {
        return T << $ & 268435455 | T >>> 28 - $
    }
    ;
    var C = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    utils$6.pc2 = function(T, $, B, O) {
        for (var F = 0, N = 0, U = C.length >>> 1, H = 0; H < U; H++)
            F <<= 1,
            F |= T >>> C[H] & 1;
        for (var H = U; H < C.length; H++)
            N <<= 1,
            N |= $ >>> C[H] & 1;
        B[O + 0] = F >>> 0,
        B[O + 1] = N >>> 0
    }
    ,
    utils$6.expand = function(T, $, B) {
        var O = 0
          , F = 0;
        O = (T & 1) << 5 | T >>> 27;
        for (var N = 23; N >= 15; N -= 4)
            O <<= 6,
            O |= T >>> N & 63;
        for (var N = 11; N >= 3; N -= 4)
            F |= T >>> N & 63,
            F <<= 6;
        F |= (T & 31) << 1 | T >>> 31,
        $[B + 0] = O >>> 0,
        $[B + 1] = F >>> 0
    }
    ;
    var S = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    utils$6.substitute = function(T, $) {
        for (var B = 0, O = 0; O < 4; O++) {
            var F = T >>> 18 - O * 6 & 63
              , N = S[O * 64 + F];
            B <<= 4,
            B |= N
        }
        for (var O = 0; O < 4; O++) {
            var F = $ >>> 18 - O * 6 & 63
              , N = S[4 * 64 + O * 64 + F];
            B <<= 4,
            B |= N
        }
        return B >>> 0
    }
    ;
    var E = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    return utils$6.permute = function(T) {
        for (var $ = 0, B = 0; B < E.length; B++)
            $ <<= 1,
            $ |= T >>> E[B] & 1;
        return $ >>> 0
    }
    ,
    utils$6.padSplit = function(T, $, B) {
        for (var O = T.toString(2); O.length < $; )
            O = "0" + O;
        for (var F = [], N = 0; N < $; N += B)
            F.push(O.slice(N, N + B));
        return F.join(" ")
    }
    ,
    utils$6
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
    if (hasRequiredMinimalisticAssert)
        return minimalisticAssert;
    hasRequiredMinimalisticAssert = 1,
    minimalisticAssert = C;
    function C(S, E) {
        if (!S)
            throw new Error(E || "Assertion failed")
    }
    return C.equal = function(E, M, T) {
        if (E != M)
            throw new Error(T || "Assertion failed: " + E + " != " + M)
    }
    ,
    minimalisticAssert
}
var cipher, hasRequiredCipher;
function requireCipher() {
    if (hasRequiredCipher)
        return cipher;
    hasRequiredCipher = 1;
    var C = requireMinimalisticAssert();
    function S(E) {
        this.options = E,
        this.type = this.options.type,
        this.blockSize = 8,
        this._init(),
        this.buffer = new Array(this.blockSize),
        this.bufferOff = 0,
        this.padding = E.padding !== !1
    }
    return cipher = S,
    S.prototype._init = function() {}
    ,
    S.prototype.update = function(M) {
        return M.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(M) : this._updateEncrypt(M)
    }
    ,
    S.prototype._buffer = function(M, T) {
        for (var $ = Math.min(this.buffer.length - this.bufferOff, M.length - T), B = 0; B < $; B++)
            this.buffer[this.bufferOff + B] = M[T + B];
        return this.bufferOff += $,
        $
    }
    ,
    S.prototype._flushBuffer = function(M, T) {
        return this._update(this.buffer, 0, M, T),
        this.bufferOff = 0,
        this.blockSize
    }
    ,
    S.prototype._updateEncrypt = function(M) {
        var T = 0
          , $ = 0
          , B = (this.bufferOff + M.length) / this.blockSize | 0
          , O = new Array(B * this.blockSize);
        this.bufferOff !== 0 && (T += this._buffer(M, T),
        this.bufferOff === this.buffer.length && ($ += this._flushBuffer(O, $)));
        for (var F = M.length - (M.length - T) % this.blockSize; T < F; T += this.blockSize)
            this._update(M, T, O, $),
            $ += this.blockSize;
        for (; T < M.length; T++,
        this.bufferOff++)
            this.buffer[this.bufferOff] = M[T];
        return O
    }
    ,
    S.prototype._updateDecrypt = function(M) {
        for (var T = 0, $ = 0, B = Math.ceil((this.bufferOff + M.length) / this.blockSize) - 1, O = new Array(B * this.blockSize); B > 0; B--)
            T += this._buffer(M, T),
            $ += this._flushBuffer(O, $);
        return T += this._buffer(M, T),
        O
    }
    ,
    S.prototype.final = function(M) {
        var T;
        M && (T = this.update(M));
        var $;
        return this.type === "encrypt" ? $ = this._finalEncrypt() : $ = this._finalDecrypt(),
        T ? T.concat($) : $
    }
    ,
    S.prototype._pad = function(M, T) {
        if (T === 0)
            return !1;
        for (; T < M.length; )
            M[T++] = 0;
        return !0
    }
    ,
    S.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff))
            return [];
        var M = new Array(this.blockSize);
        return this._update(this.buffer, 0, M, 0),
        M
    }
    ,
    S.prototype._unpad = function(M) {
        return M
    }
    ,
    S.prototype._finalDecrypt = function() {
        C.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var M = new Array(this.blockSize);
        return this._flushBuffer(M, 0),
        this._unpad(M)
    }
    ,
    cipher
}
var des, hasRequiredDes$1;
function requireDes$1() {
    if (hasRequiredDes$1)
        return des;
    hasRequiredDes$1 = 1;
    var C = requireMinimalisticAssert()
      , S = requireInherits_browser()
      , E = requireUtils$3()
      , M = requireCipher();
    function T() {
        this.tmp = new Array(2),
        this.keys = null
    }
    function $(O) {
        M.call(this, O);
        var F = new T;
        this._desState = F,
        this.deriveKeys(F, O.key)
    }
    S($, M),
    des = $,
    $.create = function(F) {
        return new $(F)
    }
    ;
    var B = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    return $.prototype.deriveKeys = function(F, N) {
        F.keys = new Array(16 * 2),
        C.equal(N.length, this.blockSize, "Invalid key length");
        var U = E.readUInt32BE(N, 0)
          , H = E.readUInt32BE(N, 4);
        E.pc1(U, H, F.tmp, 0),
        U = F.tmp[0],
        H = F.tmp[1];
        for (var Z = 0; Z < F.keys.length; Z += 2) {
            var J = B[Z >>> 1];
            U = E.r28shl(U, J),
            H = E.r28shl(H, J),
            E.pc2(U, H, F.keys, Z)
        }
    }
    ,
    $.prototype._update = function(F, N, U, H) {
        var Z = this._desState
          , J = E.readUInt32BE(F, N)
          , ie = E.readUInt32BE(F, N + 4);
        E.ip(J, ie, Z.tmp, 0),
        J = Z.tmp[0],
        ie = Z.tmp[1],
        this.type === "encrypt" ? this._encrypt(Z, J, ie, Z.tmp, 0) : this._decrypt(Z, J, ie, Z.tmp, 0),
        J = Z.tmp[0],
        ie = Z.tmp[1],
        E.writeUInt32BE(U, J, H),
        E.writeUInt32BE(U, ie, H + 4)
    }
    ,
    $.prototype._pad = function(F, N) {
        if (this.padding === !1)
            return !1;
        for (var U = F.length - N, H = N; H < F.length; H++)
            F[H] = U;
        return !0
    }
    ,
    $.prototype._unpad = function(F) {
        if (this.padding === !1)
            return F;
        for (var N = F[F.length - 1], U = F.length - N; U < F.length; U++)
            C.equal(F[U], N);
        return F.slice(0, F.length - N)
    }
    ,
    $.prototype._encrypt = function(F, N, U, H, Z) {
        for (var J = N, ie = U, oe = 0; oe < F.keys.length; oe += 2) {
            var ae = F.keys[oe]
              , se = F.keys[oe + 1];
            E.expand(ie, F.tmp, 0),
            ae ^= F.tmp[0],
            se ^= F.tmp[1];
            var le = E.substitute(ae, se)
              , de = E.permute(le)
              , fe = ie;
            ie = (J ^ de) >>> 0,
            J = fe
        }
        E.rip(ie, J, H, Z)
    }
    ,
    $.prototype._decrypt = function(F, N, U, H, Z) {
        for (var J = U, ie = N, oe = F.keys.length - 2; oe >= 0; oe -= 2) {
            var ae = F.keys[oe]
              , se = F.keys[oe + 1];
            E.expand(J, F.tmp, 0),
            ae ^= F.tmp[0],
            se ^= F.tmp[1];
            var le = E.substitute(ae, se)
              , de = E.permute(le)
              , fe = J;
            J = (ie ^ de) >>> 0,
            ie = fe
        }
        E.rip(J, ie, H, Z)
    }
    ,
    des
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
    if (hasRequiredCbc$1)
        return cbc$1;
    hasRequiredCbc$1 = 1;
    var C = requireMinimalisticAssert()
      , S = requireInherits_browser()
      , E = {};
    function M($) {
        C.equal($.length, 8, "Invalid IV length"),
        this.iv = new Array(8);
        for (var B = 0; B < this.iv.length; B++)
            this.iv[B] = $[B]
    }
    function T($) {
        function B(U) {
            $.call(this, U),
            this._cbcInit()
        }
        S(B, $);
        for (var O = Object.keys(E), F = 0; F < O.length; F++) {
            var N = O[F];
            B.prototype[N] = E[N]
        }
        return B.create = function(H) {
            return new B(H)
        }
        ,
        B
    }
    return cbc$1.instantiate = T,
    E._cbcInit = function() {
        var B = new M(this.options.iv);
        this._cbcState = B
    }
    ,
    E._update = function(B, O, F, N) {
        var U = this._cbcState
          , H = this.constructor.super_.prototype
          , Z = U.iv;
        if (this.type === "encrypt") {
            for (var J = 0; J < this.blockSize; J++)
                Z[J] ^= B[O + J];
            H._update.call(this, Z, 0, F, N);
            for (var J = 0; J < this.blockSize; J++)
                Z[J] = F[N + J]
        } else {
            H._update.call(this, B, O, F, N);
            for (var J = 0; J < this.blockSize; J++)
                F[N + J] ^= Z[J];
            for (var J = 0; J < this.blockSize; J++)
                Z[J] = B[O + J]
        }
    }
    ,
    cbc$1
}
var ede, hasRequiredEde;
function requireEde() {
    if (hasRequiredEde)
        return ede;
    hasRequiredEde = 1;
    var C = requireMinimalisticAssert()
      , S = requireInherits_browser()
      , E = requireCipher()
      , M = requireDes$1();
    function T(B, O) {
        C.equal(O.length, 24, "Invalid key length");
        var F = O.slice(0, 8)
          , N = O.slice(8, 16)
          , U = O.slice(16, 24);
        B === "encrypt" ? this.ciphers = [M.create({
            type: "encrypt",
            key: F
        }), M.create({
            type: "decrypt",
            key: N
        }), M.create({
            type: "encrypt",
            key: U
        })] : this.ciphers = [M.create({
            type: "decrypt",
            key: U
        }), M.create({
            type: "encrypt",
            key: N
        }), M.create({
            type: "decrypt",
            key: F
        })]
    }
    function $(B) {
        E.call(this, B);
        var O = new T(this.type,this.options.key);
        this._edeState = O
    }
    return S($, E),
    ede = $,
    $.create = function(O) {
        return new $(O)
    }
    ,
    $.prototype._update = function(O, F, N, U) {
        var H = this._edeState;
        H.ciphers[0]._update(O, F, N, U),
        H.ciphers[1]._update(N, U, N, U),
        H.ciphers[2]._update(N, U, N, U)
    }
    ,
    $.prototype._pad = M.prototype._pad,
    $.prototype._unpad = M.prototype._unpad,
    ede
}
var hasRequiredDes;
function requireDes() {
    return hasRequiredDes || (hasRequiredDes = 1,
    des$1.utils = requireUtils$3(),
    des$1.Cipher = requireCipher(),
    des$1.DES = requireDes$1(),
    des$1.CBC = requireCbc$1(),
    des$1.EDE = requireEde()),
    des$1
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
    if (hasRequiredBrowserifyDes)
        return browserifyDes;
    hasRequiredBrowserifyDes = 1;
    var C = requireCipherBase()
      , S = requireDes()
      , E = requireInherits_browser()
      , M = requireSafeBuffer$1().Buffer
      , T = {
        "des-ede3-cbc": S.CBC.instantiate(S.EDE),
        "des-ede3": S.EDE,
        "des-ede-cbc": S.CBC.instantiate(S.EDE),
        "des-ede": S.EDE,
        "des-cbc": S.CBC.instantiate(S.DES),
        "des-ecb": S.DES
    };
    T.des = T["des-cbc"],
    T.des3 = T["des-ede3-cbc"],
    browserifyDes = $,
    E($, C);
    function $(B) {
        C.call(this);
        var O = B.mode.toLowerCase(), F = T[O], N;
        B.decrypt ? N = "decrypt" : N = "encrypt";
        var U = B.key;
        M.isBuffer(U) || (U = M.from(U)),
        (O === "des-ede" || O === "des-ede-cbc") && (U = M.concat([U, U.slice(0, 8)]));
        var H = B.iv;
        M.isBuffer(H) || (H = M.from(H)),
        this._des = F.create({
            key: U,
            iv: H,
            type: N
        })
    }
    return $.prototype._update = function(B) {
        return M.from(this._des.update(B))
    }
    ,
    $.prototype._final = function() {
        return M.from(this._des.final())
    }
    ,
    browserifyDes
}
var browser$7 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
    return hasRequiredEcb || (hasRequiredEcb = 1,
    ecb.encrypt = function(C, S) {
        return C._cipher.encryptBlock(S)
    }
    ,
    ecb.decrypt = function(C, S) {
        return C._cipher.decryptBlock(S)
    }
    ),
    ecb
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
    return hasRequiredBufferXor || (hasRequiredBufferXor = 1,
    bufferXor = function(S, E) {
        for (var M = Math.min(S.length, E.length), T = new Buffer(M), $ = 0; $ < M; ++$)
            T[$] = S[$] ^ E[$];
        return T
    }
    ),
    bufferXor
}
var hasRequiredCbc;
function requireCbc() {
    if (hasRequiredCbc)
        return cbc;
    hasRequiredCbc = 1;
    var C = requireBufferXor();
    return cbc.encrypt = function(S, E) {
        var M = C(E, S._prev);
        return S._prev = S._cipher.encryptBlock(M),
        S._prev
    }
    ,
    cbc.decrypt = function(S, E) {
        var M = S._prev;
        S._prev = E;
        var T = S._cipher.decryptBlock(E);
        return C(T, M)
    }
    ,
    cbc
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
    if (hasRequiredCfb)
        return cfb;
    hasRequiredCfb = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireBufferXor();
    function E(M, T, $) {
        var B = T.length
          , O = S(T, M._cache);
        return M._cache = M._cache.slice(B),
        M._prev = C.concat([M._prev, $ ? T : O]),
        O
    }
    return cfb.encrypt = function(M, T, $) {
        for (var B = C.allocUnsafe(0), O; T.length; )
            if (M._cache.length === 0 && (M._cache = M._cipher.encryptBlock(M._prev),
            M._prev = C.allocUnsafe(0)),
            M._cache.length <= T.length)
                O = M._cache.length,
                B = C.concat([B, E(M, T.slice(0, O), $)]),
                T = T.slice(O);
            else {
                B = C.concat([B, E(M, T, $)]);
                break
            }
        return B
    }
    ,
    cfb
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
    if (hasRequiredCfb8)
        return cfb8;
    hasRequiredCfb8 = 1;
    var C = requireSafeBuffer$1().Buffer;
    function S(E, M, T) {
        var $ = E._cipher.encryptBlock(E._prev)
          , B = $[0] ^ M;
        return E._prev = C.concat([E._prev.slice(1), C.from([T ? M : B])]),
        B
    }
    return cfb8.encrypt = function(E, M, T) {
        for (var $ = M.length, B = C.allocUnsafe($), O = -1; ++O < $; )
            B[O] = S(E, M[O], T);
        return B
    }
    ,
    cfb8
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
    if (hasRequiredCfb1)
        return cfb1;
    hasRequiredCfb1 = 1;
    var C = requireSafeBuffer$1().Buffer;
    function S(M, T, $) {
        for (var B, O = -1, F = 8, N = 0, U, H; ++O < F; )
            B = M._cipher.encryptBlock(M._prev),
            U = T & 1 << 7 - O ? 128 : 0,
            H = B[0] ^ U,
            N += (H & 128) >> O % 8,
            M._prev = E(M._prev, $ ? U : H);
        return N
    }
    function E(M, T) {
        var $ = M.length
          , B = -1
          , O = C.allocUnsafe(M.length);
        for (M = C.concat([M, C.from([T])]); ++B < $; )
            O[B] = M[B] << 1 | M[B + 1] >> 7;
        return O
    }
    return cfb1.encrypt = function(M, T, $) {
        for (var B = T.length, O = C.allocUnsafe(B), F = -1; ++F < B; )
            O[F] = S(M, T[F], $);
        return O
    }
    ,
    cfb1
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
    if (hasRequiredOfb)
        return ofb;
    hasRequiredOfb = 1;
    var C = requireBufferXor();
    function S(E) {
        return E._prev = E._cipher.encryptBlock(E._prev),
        E._prev
    }
    return ofb.encrypt = function(E, M) {
        for (; E._cache.length < M.length; )
            E._cache = Buffer.concat([E._cache, S(E)]);
        var T = E._cache.slice(0, M.length);
        return E._cache = E._cache.slice(M.length),
        C(M, T)
    }
    ,
    ofb
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
    if (hasRequiredIncr32)
        return incr32_1;
    hasRequiredIncr32 = 1;
    function C(S) {
        for (var E = S.length, M; E--; )
            if (M = S.readUInt8(E),
            M === 255)
                S.writeUInt8(0, E);
            else {
                M++,
                S.writeUInt8(M, E);
                break
            }
    }
    return incr32_1 = C,
    incr32_1
}
var hasRequiredCtr;
function requireCtr() {
    if (hasRequiredCtr)
        return ctr;
    hasRequiredCtr = 1;
    var C = requireBufferXor()
      , S = requireSafeBuffer$1().Buffer
      , E = requireIncr32();
    function M($) {
        var B = $._cipher.encryptBlockRaw($._prev);
        return E($._prev),
        B
    }
    var T = 16;
    return ctr.encrypt = function($, B) {
        var O = Math.ceil(B.length / T)
          , F = $._cache.length;
        $._cache = S.concat([$._cache, S.allocUnsafe(O * T)]);
        for (var N = 0; N < O; N++) {
            var U = M($)
              , H = F + N * T;
            $._cache.writeUInt32BE(U[0], H + 0),
            $._cache.writeUInt32BE(U[1], H + 4),
            $._cache.writeUInt32BE(U[2], H + 8),
            $._cache.writeUInt32BE(U[3], H + 12)
        }
        var Z = $._cache.slice(0, B.length);
        return $._cache = $._cache.slice(B.length),
        C(B, Z)
    }
    ,
    ctr
}
const aes128 = {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes192 = {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , aes256 = {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
}
  , require$$2$2 = {
    "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
    },
    "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
    },
    aes128,
    aes192,
    aes256,
    "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
    },
    "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
    },
    "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
    },
    "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
    },
    "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
    },
    "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
    },
    "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
    }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
    if (hasRequiredModes$1)
        return modes_1;
    hasRequiredModes$1 = 1;
    var C = {
        ECB: requireEcb(),
        CBC: requireCbc(),
        CFB: requireCfb(),
        CFB8: requireCfb8(),
        CFB1: requireCfb1(),
        OFB: requireOfb(),
        CTR: requireCtr(),
        GCM: requireCtr()
    }
      , S = require$$2$2;
    for (var E in S)
        S[E].module = C[S[E].mode];
    return modes_1 = S,
    modes_1
}
var aes = {}, hasRequiredAes;
function requireAes() {
    if (hasRequiredAes)
        return aes;
    hasRequiredAes = 1;
    var C = requireSafeBuffer$1().Buffer;
    function S(O) {
        C.isBuffer(O) || (O = C.from(O));
        for (var F = O.length / 4 | 0, N = new Array(F), U = 0; U < F; U++)
            N[U] = O.readUInt32BE(U * 4);
        return N
    }
    function E(O) {
        for (var F = 0; F < O.length; O++)
            O[F] = 0
    }
    function M(O, F, N, U, H) {
        for (var Z = N[0], J = N[1], ie = N[2], oe = N[3], ae = O[0] ^ F[0], se = O[1] ^ F[1], le = O[2] ^ F[2], de = O[3] ^ F[3], fe, pe, ge, we, Ae = 4, Se = 1; Se < H; Se++)
            fe = Z[ae >>> 24] ^ J[se >>> 16 & 255] ^ ie[le >>> 8 & 255] ^ oe[de & 255] ^ F[Ae++],
            pe = Z[se >>> 24] ^ J[le >>> 16 & 255] ^ ie[de >>> 8 & 255] ^ oe[ae & 255] ^ F[Ae++],
            ge = Z[le >>> 24] ^ J[de >>> 16 & 255] ^ ie[ae >>> 8 & 255] ^ oe[se & 255] ^ F[Ae++],
            we = Z[de >>> 24] ^ J[ae >>> 16 & 255] ^ ie[se >>> 8 & 255] ^ oe[le & 255] ^ F[Ae++],
            ae = fe,
            se = pe,
            le = ge,
            de = we;
        return fe = (U[ae >>> 24] << 24 | U[se >>> 16 & 255] << 16 | U[le >>> 8 & 255] << 8 | U[de & 255]) ^ F[Ae++],
        pe = (U[se >>> 24] << 24 | U[le >>> 16 & 255] << 16 | U[de >>> 8 & 255] << 8 | U[ae & 255]) ^ F[Ae++],
        ge = (U[le >>> 24] << 24 | U[de >>> 16 & 255] << 16 | U[ae >>> 8 & 255] << 8 | U[se & 255]) ^ F[Ae++],
        we = (U[de >>> 24] << 24 | U[ae >>> 16 & 255] << 16 | U[se >>> 8 & 255] << 8 | U[le & 255]) ^ F[Ae++],
        fe = fe >>> 0,
        pe = pe >>> 0,
        ge = ge >>> 0,
        we = we >>> 0,
        [fe, pe, ge, we]
    }
    var T = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
      , $ = function() {
        for (var O = new Array(256), F = 0; F < 256; F++)
            F < 128 ? O[F] = F << 1 : O[F] = F << 1 ^ 283;
        for (var N = [], U = [], H = [[], [], [], []], Z = [[], [], [], []], J = 0, ie = 0, oe = 0; oe < 256; ++oe) {
            var ae = ie ^ ie << 1 ^ ie << 2 ^ ie << 3 ^ ie << 4;
            ae = ae >>> 8 ^ ae & 255 ^ 99,
            N[J] = ae,
            U[ae] = J;
            var se = O[J]
              , le = O[se]
              , de = O[le]
              , fe = O[ae] * 257 ^ ae * 16843008;
            H[0][J] = fe << 24 | fe >>> 8,
            H[1][J] = fe << 16 | fe >>> 16,
            H[2][J] = fe << 8 | fe >>> 24,
            H[3][J] = fe,
            fe = de * 16843009 ^ le * 65537 ^ se * 257 ^ J * 16843008,
            Z[0][ae] = fe << 24 | fe >>> 8,
            Z[1][ae] = fe << 16 | fe >>> 16,
            Z[2][ae] = fe << 8 | fe >>> 24,
            Z[3][ae] = fe,
            J === 0 ? J = ie = 1 : (J = se ^ O[O[O[de ^ se]]],
            ie ^= O[O[ie]])
        }
        return {
            SBOX: N,
            INV_SBOX: U,
            SUB_MIX: H,
            INV_SUB_MIX: Z
        }
    }();
    function B(O) {
        this._key = S(O),
        this._reset()
    }
    return B.blockSize = 4 * 4,
    B.keySize = 256 / 8,
    B.prototype.blockSize = B.blockSize,
    B.prototype.keySize = B.keySize,
    B.prototype._reset = function() {
        for (var O = this._key, F = O.length, N = F + 6, U = (N + 1) * 4, H = [], Z = 0; Z < F; Z++)
            H[Z] = O[Z];
        for (Z = F; Z < U; Z++) {
            var J = H[Z - 1];
            Z % F === 0 ? (J = J << 8 | J >>> 24,
            J = $.SBOX[J >>> 24] << 24 | $.SBOX[J >>> 16 & 255] << 16 | $.SBOX[J >>> 8 & 255] << 8 | $.SBOX[J & 255],
            J ^= T[Z / F | 0] << 24) : F > 6 && Z % F === 4 && (J = $.SBOX[J >>> 24] << 24 | $.SBOX[J >>> 16 & 255] << 16 | $.SBOX[J >>> 8 & 255] << 8 | $.SBOX[J & 255]),
            H[Z] = H[Z - F] ^ J
        }
        for (var ie = [], oe = 0; oe < U; oe++) {
            var ae = U - oe
              , se = H[ae - (oe % 4 ? 0 : 4)];
            oe < 4 || ae <= 4 ? ie[oe] = se : ie[oe] = $.INV_SUB_MIX[0][$.SBOX[se >>> 24]] ^ $.INV_SUB_MIX[1][$.SBOX[se >>> 16 & 255]] ^ $.INV_SUB_MIX[2][$.SBOX[se >>> 8 & 255]] ^ $.INV_SUB_MIX[3][$.SBOX[se & 255]]
        }
        this._nRounds = N,
        this._keySchedule = H,
        this._invKeySchedule = ie
    }
    ,
    B.prototype.encryptBlockRaw = function(O) {
        return O = S(O),
        M(O, this._keySchedule, $.SUB_MIX, $.SBOX, this._nRounds)
    }
    ,
    B.prototype.encryptBlock = function(O) {
        var F = this.encryptBlockRaw(O)
          , N = C.allocUnsafe(16);
        return N.writeUInt32BE(F[0], 0),
        N.writeUInt32BE(F[1], 4),
        N.writeUInt32BE(F[2], 8),
        N.writeUInt32BE(F[3], 12),
        N
    }
    ,
    B.prototype.decryptBlock = function(O) {
        O = S(O);
        var F = O[1];
        O[1] = O[3],
        O[3] = F;
        var N = M(O, this._invKeySchedule, $.INV_SUB_MIX, $.INV_SBOX, this._nRounds)
          , U = C.allocUnsafe(16);
        return U.writeUInt32BE(N[0], 0),
        U.writeUInt32BE(N[3], 4),
        U.writeUInt32BE(N[2], 8),
        U.writeUInt32BE(N[1], 12),
        U
    }
    ,
    B.prototype.scrub = function() {
        E(this._keySchedule),
        E(this._invKeySchedule),
        E(this._key)
    }
    ,
    aes.AES = B,
    aes
}
var ghash, hasRequiredGhash;
function requireGhash() {
    if (hasRequiredGhash)
        return ghash;
    hasRequiredGhash = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = C.alloc(16, 0);
    function E($) {
        return [$.readUInt32BE(0), $.readUInt32BE(4), $.readUInt32BE(8), $.readUInt32BE(12)]
    }
    function M($) {
        var B = C.allocUnsafe(16);
        return B.writeUInt32BE($[0] >>> 0, 0),
        B.writeUInt32BE($[1] >>> 0, 4),
        B.writeUInt32BE($[2] >>> 0, 8),
        B.writeUInt32BE($[3] >>> 0, 12),
        B
    }
    function T($) {
        this.h = $,
        this.state = C.alloc(16, 0),
        this.cache = C.allocUnsafe(0)
    }
    return T.prototype.ghash = function($) {
        for (var B = -1; ++B < $.length; )
            this.state[B] ^= $[B];
        this._multiply()
    }
    ,
    T.prototype._multiply = function() {
        for (var $ = E(this.h), B = [0, 0, 0, 0], O, F, N, U = -1; ++U < 128; ) {
            for (F = (this.state[~~(U / 8)] & 1 << 7 - U % 8) !== 0,
            F && (B[0] ^= $[0],
            B[1] ^= $[1],
            B[2] ^= $[2],
            B[3] ^= $[3]),
            N = ($[3] & 1) !== 0,
            O = 3; O > 0; O--)
                $[O] = $[O] >>> 1 | ($[O - 1] & 1) << 31;
            $[0] = $[0] >>> 1,
            N && ($[0] = $[0] ^ 225 << 24)
        }
        this.state = M(B)
    }
    ,
    T.prototype.update = function($) {
        this.cache = C.concat([this.cache, $]);
        for (var B; this.cache.length >= 16; )
            B = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            this.ghash(B)
    }
    ,
    T.prototype.final = function($, B) {
        return this.cache.length && this.ghash(C.concat([this.cache, S], 16)),
        this.ghash(M([0, $, 0, B])),
        this.state
    }
    ,
    ghash = T,
    ghash
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
    if (hasRequiredAuthCipher)
        return authCipher;
    hasRequiredAuthCipher = 1;
    var C = requireAes()
      , S = requireSafeBuffer$1().Buffer
      , E = requireCipherBase()
      , M = requireInherits_browser()
      , T = requireGhash()
      , $ = requireBufferXor()
      , B = requireIncr32();
    function O(U, H) {
        var Z = 0;
        U.length !== H.length && Z++;
        for (var J = Math.min(U.length, H.length), ie = 0; ie < J; ++ie)
            Z += U[ie] ^ H[ie];
        return Z
    }
    function F(U, H, Z) {
        if (H.length === 12)
            return U._finID = S.concat([H, S.from([0, 0, 0, 1])]),
            S.concat([H, S.from([0, 0, 0, 2])]);
        var J = new T(Z)
          , ie = H.length
          , oe = ie % 16;
        J.update(H),
        oe && (oe = 16 - oe,
        J.update(S.alloc(oe, 0))),
        J.update(S.alloc(8, 0));
        var ae = ie * 8
          , se = S.alloc(8);
        se.writeUIntBE(ae, 0, 8),
        J.update(se),
        U._finID = J.state;
        var le = S.from(U._finID);
        return B(le),
        le
    }
    function N(U, H, Z, J) {
        E.call(this);
        var ie = S.alloc(4, 0);
        this._cipher = new C.AES(H);
        var oe = this._cipher.encryptBlock(ie);
        this._ghash = new T(oe),
        Z = F(this, Z, oe),
        this._prev = S.from(Z),
        this._cache = S.allocUnsafe(0),
        this._secCache = S.allocUnsafe(0),
        this._decrypt = J,
        this._alen = 0,
        this._len = 0,
        this._mode = U,
        this._authTag = null,
        this._called = !1
    }
    return M(N, E),
    N.prototype._update = function(U) {
        if (!this._called && this._alen) {
            var H = 16 - this._alen % 16;
            H < 16 && (H = S.alloc(H, 0),
            this._ghash.update(H))
        }
        this._called = !0;
        var Z = this._mode.encrypt(this, U);
        return this._decrypt ? this._ghash.update(U) : this._ghash.update(Z),
        this._len += U.length,
        Z
    }
    ,
    N.prototype._final = function() {
        if (this._decrypt && !this._authTag)
            throw new Error("Unsupported state or unable to authenticate data");
        var U = $(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && O(U, this._authTag))
            throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = U,
        this._cipher.scrub()
    }
    ,
    N.prototype.getAuthTag = function() {
        if (this._decrypt || !S.isBuffer(this._authTag))
            throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag
    }
    ,
    N.prototype.setAuthTag = function(H) {
        if (!this._decrypt)
            throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = H
    }
    ,
    N.prototype.setAAD = function(H) {
        if (this._called)
            throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(H),
        this._alen += H.length
    }
    ,
    authCipher = N,
    authCipher
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
    if (hasRequiredStreamCipher)
        return streamCipher;
    hasRequiredStreamCipher = 1;
    var C = requireAes()
      , S = requireSafeBuffer$1().Buffer
      , E = requireCipherBase()
      , M = requireInherits_browser();
    function T($, B, O, F) {
        E.call(this),
        this._cipher = new C.AES(B),
        this._prev = S.from(O),
        this._cache = S.allocUnsafe(0),
        this._secCache = S.allocUnsafe(0),
        this._decrypt = F,
        this._mode = $
    }
    return M(T, E),
    T.prototype._update = function($) {
        return this._mode.encrypt(this, $, this._decrypt)
    }
    ,
    T.prototype._final = function() {
        this._cipher.scrub()
    }
    ,
    streamCipher = T,
    streamCipher
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
    if (hasRequiredEvp_bytestokey)
        return evp_bytestokey;
    hasRequiredEvp_bytestokey = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireMd5_js();
    function E(M, T, $, B) {
        if (C.isBuffer(M) || (M = C.from(M, "binary")),
        T && (C.isBuffer(T) || (T = C.from(T, "binary")),
        T.length !== 8))
            throw new RangeError("salt should be Buffer with 8 byte length");
        for (var O = $ / 8, F = C.alloc(O), N = C.alloc(B || 0), U = C.alloc(0); O > 0 || B > 0; ) {
            var H = new S;
            H.update(U),
            H.update(M),
            T && H.update(T),
            U = H.digest();
            var Z = 0;
            if (O > 0) {
                var J = F.length - O;
                Z = Math.min(O, U.length),
                U.copy(F, J, 0, Z),
                O -= Z
            }
            if (Z < U.length && B > 0) {
                var ie = N.length - B
                  , oe = Math.min(B, U.length - Z);
                U.copy(N, ie, Z, Z + oe),
                B -= oe
            }
        }
        return U.fill(0),
        {
            key: F,
            iv: N
        }
    }
    return evp_bytestokey = E,
    evp_bytestokey
}
var hasRequiredEncrypter;
function requireEncrypter() {
    if (hasRequiredEncrypter)
        return encrypter;
    hasRequiredEncrypter = 1;
    var C = requireModes$1()
      , S = requireAuthCipher()
      , E = requireSafeBuffer$1().Buffer
      , M = requireStreamCipher()
      , T = requireCipherBase()
      , $ = requireAes()
      , B = requireEvp_bytestokey()
      , O = requireInherits_browser();
    function F(J, ie, oe) {
        T.call(this),
        this._cache = new U,
        this._cipher = new $.AES(ie),
        this._prev = E.from(oe),
        this._mode = J,
        this._autopadding = !0
    }
    O(F, T),
    F.prototype._update = function(J) {
        this._cache.add(J);
        for (var ie, oe, ae = []; ie = this._cache.get(); )
            oe = this._mode.encrypt(this, ie),
            ae.push(oe);
        return E.concat(ae)
    }
    ;
    var N = E.alloc(16, 16);
    F.prototype._final = function() {
        var J = this._cache.flush();
        if (this._autopadding)
            return J = this._mode.encrypt(this, J),
            this._cipher.scrub(),
            J;
        if (!J.equals(N))
            throw this._cipher.scrub(),
            new Error("data not multiple of block length")
    }
    ,
    F.prototype.setAutoPadding = function(J) {
        return this._autopadding = !!J,
        this
    }
    ;
    function U() {
        this.cache = E.allocUnsafe(0)
    }
    U.prototype.add = function(J) {
        this.cache = E.concat([this.cache, J])
    }
    ,
    U.prototype.get = function() {
        if (this.cache.length > 15) {
            var J = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16),
            J
        }
        return null
    }
    ,
    U.prototype.flush = function() {
        for (var J = 16 - this.cache.length, ie = E.allocUnsafe(J), oe = -1; ++oe < J; )
            ie.writeUInt8(J, oe);
        return E.concat([this.cache, ie])
    }
    ;
    function H(J, ie, oe) {
        var ae = C[J.toLowerCase()];
        if (!ae)
            throw new TypeError("invalid suite type");
        if (typeof ie == "string" && (ie = E.from(ie)),
        ie.length !== ae.key / 8)
            throw new TypeError("invalid key length " + ie.length);
        if (typeof oe == "string" && (oe = E.from(oe)),
        ae.mode !== "GCM" && oe.length !== ae.iv)
            throw new TypeError("invalid iv length " + oe.length);
        return ae.type === "stream" ? new M(ae.module,ie,oe) : ae.type === "auth" ? new S(ae.module,ie,oe) : new F(ae.module,ie,oe)
    }
    function Z(J, ie) {
        var oe = C[J.toLowerCase()];
        if (!oe)
            throw new TypeError("invalid suite type");
        var ae = B(ie, !1, oe.key, oe.iv);
        return H(J, ae.key, ae.iv)
    }
    return encrypter.createCipheriv = H,
    encrypter.createCipher = Z,
    encrypter
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
    if (hasRequiredDecrypter)
        return decrypter;
    hasRequiredDecrypter = 1;
    var C = requireAuthCipher()
      , S = requireSafeBuffer$1().Buffer
      , E = requireModes$1()
      , M = requireStreamCipher()
      , T = requireCipherBase()
      , $ = requireAes()
      , B = requireEvp_bytestokey()
      , O = requireInherits_browser();
    function F(J, ie, oe) {
        T.call(this),
        this._cache = new N,
        this._last = void 0,
        this._cipher = new $.AES(ie),
        this._prev = S.from(oe),
        this._mode = J,
        this._autopadding = !0
    }
    O(F, T),
    F.prototype._update = function(J) {
        this._cache.add(J);
        for (var ie, oe, ae = []; ie = this._cache.get(this._autopadding); )
            oe = this._mode.decrypt(this, ie),
            ae.push(oe);
        return S.concat(ae)
    }
    ,
    F.prototype._final = function() {
        var J = this._cache.flush();
        if (this._autopadding)
            return U(this._mode.decrypt(this, J));
        if (J)
            throw new Error("data not multiple of block length")
    }
    ,
    F.prototype.setAutoPadding = function(J) {
        return this._autopadding = !!J,
        this
    }
    ;
    function N() {
        this.cache = S.allocUnsafe(0)
    }
    N.prototype.add = function(J) {
        this.cache = S.concat([this.cache, J])
    }
    ,
    N.prototype.get = function(J) {
        var ie;
        if (J) {
            if (this.cache.length > 16)
                return ie = this.cache.slice(0, 16),
                this.cache = this.cache.slice(16),
                ie
        } else if (this.cache.length >= 16)
            return ie = this.cache.slice(0, 16),
            this.cache = this.cache.slice(16),
            ie;
        return null
    }
    ,
    N.prototype.flush = function() {
        if (this.cache.length)
            return this.cache
    }
    ;
    function U(J) {
        var ie = J[15];
        if (ie < 1 || ie > 16)
            throw new Error("unable to decrypt data");
        for (var oe = -1; ++oe < ie; )
            if (J[oe + (16 - ie)] !== ie)
                throw new Error("unable to decrypt data");
        if (ie !== 16)
            return J.slice(0, 16 - ie)
    }
    function H(J, ie, oe) {
        var ae = E[J.toLowerCase()];
        if (!ae)
            throw new TypeError("invalid suite type");
        if (typeof oe == "string" && (oe = S.from(oe)),
        ae.mode !== "GCM" && oe.length !== ae.iv)
            throw new TypeError("invalid iv length " + oe.length);
        if (typeof ie == "string" && (ie = S.from(ie)),
        ie.length !== ae.key / 8)
            throw new TypeError("invalid key length " + ie.length);
        return ae.type === "stream" ? new M(ae.module,ie,oe,!0) : ae.type === "auth" ? new C(ae.module,ie,oe,!0) : new F(ae.module,ie,oe)
    }
    function Z(J, ie) {
        var oe = E[J.toLowerCase()];
        if (!oe)
            throw new TypeError("invalid suite type");
        var ae = B(ie, !1, oe.key, oe.iv);
        return H(J, ae.key, ae.iv)
    }
    return decrypter.createDecipher = Z,
    decrypter.createDecipheriv = H,
    decrypter
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
    if (hasRequiredBrowser$6)
        return browser$7;
    hasRequiredBrowser$6 = 1;
    var C = requireEncrypter()
      , S = requireDecrypter()
      , E = require$$2$2;
    function M() {
        return Object.keys(E)
    }
    return browser$7.createCipher = browser$7.Cipher = C.createCipher,
    browser$7.createCipheriv = browser$7.Cipheriv = C.createCipheriv,
    browser$7.createDecipher = browser$7.Decipher = S.createDecipher,
    browser$7.createDecipheriv = browser$7.Decipheriv = S.createDecipheriv,
    browser$7.listCiphers = browser$7.getCiphers = M,
    browser$7
}
var modes = {}, hasRequiredModes;
function requireModes() {
    return hasRequiredModes || (hasRequiredModes = 1,
    function(C) {
        C["des-ecb"] = {
            key: 8,
            iv: 0
        },
        C["des-cbc"] = C.des = {
            key: 8,
            iv: 8
        },
        C["des-ede3-cbc"] = C.des3 = {
            key: 24,
            iv: 8
        },
        C["des-ede3"] = {
            key: 24,
            iv: 0
        },
        C["des-ede-cbc"] = {
            key: 16,
            iv: 8
        },
        C["des-ede"] = {
            key: 16,
            iv: 0
        }
    }(modes)),
    modes
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
    if (hasRequiredBrowser$5)
        return browser$8;
    hasRequiredBrowser$5 = 1;
    var C = requireBrowserifyDes()
      , S = requireBrowser$6()
      , E = requireModes$1()
      , M = requireModes()
      , T = requireEvp_bytestokey();
    function $(U, H) {
        U = U.toLowerCase();
        var Z, J;
        if (E[U])
            Z = E[U].key,
            J = E[U].iv;
        else if (M[U])
            Z = M[U].key * 8,
            J = M[U].iv;
        else
            throw new TypeError("invalid suite type");
        var ie = T(H, !1, Z, J);
        return O(U, ie.key, ie.iv)
    }
    function B(U, H) {
        U = U.toLowerCase();
        var Z, J;
        if (E[U])
            Z = E[U].key,
            J = E[U].iv;
        else if (M[U])
            Z = M[U].key * 8,
            J = M[U].iv;
        else
            throw new TypeError("invalid suite type");
        var ie = T(H, !1, Z, J);
        return F(U, ie.key, ie.iv)
    }
    function O(U, H, Z) {
        if (U = U.toLowerCase(),
        E[U])
            return S.createCipheriv(U, H, Z);
        if (M[U])
            return new C({
                key: H,
                iv: Z,
                mode: U
            });
        throw new TypeError("invalid suite type")
    }
    function F(U, H, Z) {
        if (U = U.toLowerCase(),
        E[U])
            return S.createDecipheriv(U, H, Z);
        if (M[U])
            return new C({
                key: H,
                iv: Z,
                mode: U,
                decrypt: !0
            });
        throw new TypeError("invalid suite type")
    }
    function N() {
        return Object.keys(M).concat(S.getCiphers())
    }
    return browser$8.createCipher = browser$8.Cipher = $,
    browser$8.createCipheriv = browser$8.Cipheriv = O,
    browser$8.createDecipher = browser$8.Decipher = B,
    browser$8.createDecipheriv = browser$8.Decipheriv = F,
    browser$8.listCiphers = browser$8.getCiphers = N,
    browser$8
}
var browser$6 = {}
  , bn$5 = {
    exports: {}
};
bn$5.exports;
var hasRequiredBn$2;
function requireBn$2() {
    return hasRequiredBn$2 || (hasRequiredBn$2 = 1,
    function(C) {
        (function(S, E) {
            function M(V, W) {
                if (!V)
                    throw new Error(W || "Assertion failed")
            }
            function T(V, W) {
                V.super_ = W;
                var D = function() {};
                D.prototype = W.prototype,
                V.prototype = new D,
                V.prototype.constructor = V
            }
            function $(V, W, D) {
                if ($.isBN(V))
                    return V;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                V !== null && ((W === "le" || W === "be") && (D = W,
                W = 10),
                this._init(V || 0, W || 10, D || "be"))
            }
            typeof S == "object" ? S.exports = $ : E.BN = $,
            $.BN = $,
            $.wordSize = 26;
            var B;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = require$$0$2.Buffer
            } catch {}
            $.isBN = function(W) {
                return W instanceof $ ? !0 : W !== null && typeof W == "object" && W.constructor.wordSize === $.wordSize && Array.isArray(W.words)
            }
            ,
            $.max = function(W, D) {
                return W.cmp(D) > 0 ? W : D
            }
            ,
            $.min = function(W, D) {
                return W.cmp(D) < 0 ? W : D
            }
            ,
            $.prototype._init = function(W, D, I) {
                if (typeof W == "number")
                    return this._initNumber(W, D, I);
                if (typeof W == "object")
                    return this._initArray(W, D, I);
                D === "hex" && (D = 16),
                M(D === (D | 0) && D >= 2 && D <= 36),
                W = W.toString().replace(/\s+/g, "");
                var L = 0;
                W[0] === "-" && (L++,
                this.negative = 1),
                L < W.length && (D === 16 ? this._parseHex(W, L, I) : (this._parseBase(W, D, L),
                I === "le" && this._initArray(this.toArray(), D, I)))
            }
            ,
            $.prototype._initNumber = function(W, D, I) {
                W < 0 && (this.negative = 1,
                W = -W),
                W < 67108864 ? (this.words = [W & 67108863],
                this.length = 1) : W < 4503599627370496 ? (this.words = [W & 67108863, W / 67108864 & 67108863],
                this.length = 2) : (M(W < 9007199254740992),
                this.words = [W & 67108863, W / 67108864 & 67108863, 1],
                this.length = 3),
                I === "le" && this._initArray(this.toArray(), D, I)
            }
            ,
            $.prototype._initArray = function(W, D, I) {
                if (M(typeof W.length == "number"),
                W.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(W.length / 3),
                this.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    this.words[L] = 0;
                var K, X, Y = 0;
                if (I === "be")
                    for (L = W.length - 1,
                    K = 0; L >= 0; L -= 3)
                        X = W[L] | W[L - 1] << 8 | W[L - 2] << 16,
                        this.words[K] |= X << Y & 67108863,
                        this.words[K + 1] = X >>> 26 - Y & 67108863,
                        Y += 24,
                        Y >= 26 && (Y -= 26,
                        K++);
                else if (I === "le")
                    for (L = 0,
                    K = 0; L < W.length; L += 3)
                        X = W[L] | W[L + 1] << 8 | W[L + 2] << 16,
                        this.words[K] |= X << Y & 67108863,
                        this.words[K + 1] = X >>> 26 - Y & 67108863,
                        Y += 24,
                        Y >= 26 && (Y -= 26,
                        K++);
                return this.strip()
            }
            ;
            function O(V, W) {
                var D = V.charCodeAt(W);
                return D >= 65 && D <= 70 ? D - 55 : D >= 97 && D <= 102 ? D - 87 : D - 48 & 15
            }
            function F(V, W, D) {
                var I = O(V, D);
                return D - 1 >= W && (I |= O(V, D - 1) << 4),
                I
            }
            $.prototype._parseHex = function(W, D, I) {
                this.length = Math.ceil((W.length - D) / 6),
                this.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    this.words[L] = 0;
                var K = 0, X = 0, Y;
                if (I === "be")
                    for (L = W.length - 1; L >= D; L -= 2)
                        Y = F(W, D, L) << K,
                        this.words[X] |= Y & 67108863,
                        K >= 18 ? (K -= 18,
                        X += 1,
                        this.words[X] |= Y >>> 26) : K += 8;
                else {
                    var j = W.length - D;
                    for (L = j % 2 === 0 ? D + 1 : D; L < W.length; L += 2)
                        Y = F(W, D, L) << K,
                        this.words[X] |= Y & 67108863,
                        K >= 18 ? (K -= 18,
                        X += 1,
                        this.words[X] |= Y >>> 26) : K += 8
                }
                this.strip()
            }
            ;
            function N(V, W, D, I) {
                for (var L = 0, K = Math.min(V.length, D), X = W; X < K; X++) {
                    var Y = V.charCodeAt(X) - 48;
                    L *= I,
                    Y >= 49 ? L += Y - 49 + 10 : Y >= 17 ? L += Y - 17 + 10 : L += Y
                }
                return L
            }
            $.prototype._parseBase = function(W, D, I) {
                this.words = [0],
                this.length = 1;
                for (var L = 0, K = 1; K <= 67108863; K *= D)
                    L++;
                L--,
                K = K / D | 0;
                for (var X = W.length - I, Y = X % L, j = Math.min(X, X - Y) + I, G = 0, ne = I; ne < j; ne += L)
                    G = N(W, ne, ne + L, D),
                    this.imuln(K),
                    this.words[0] + G < 67108864 ? this.words[0] += G : this._iaddn(G);
                if (Y !== 0) {
                    var te = 1;
                    for (G = N(W, ne, W.length, D),
                    ne = 0; ne < Y; ne++)
                        te *= D;
                    this.imuln(te),
                    this.words[0] + G < 67108864 ? this.words[0] += G : this._iaddn(G)
                }
                this.strip()
            }
            ,
            $.prototype.copy = function(W) {
                W.words = new Array(this.length);
                for (var D = 0; D < this.length; D++)
                    W.words[D] = this.words[D];
                W.length = this.length,
                W.negative = this.negative,
                W.red = this.red
            }
            ,
            $.prototype.clone = function() {
                var W = new $(null);
                return this.copy(W),
                W
            }
            ,
            $.prototype._expand = function(W) {
                for (; this.length < W; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            $.prototype.strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            $.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            $.prototype.inspect = function() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            ;
            var U = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , H = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , Z = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            $.prototype.toString = function(W, D) {
                W = W || 10,
                D = D | 0 || 1;
                var I;
                if (W === 16 || W === "hex") {
                    I = "";
                    for (var L = 0, K = 0, X = 0; X < this.length; X++) {
                        var Y = this.words[X]
                          , j = ((Y << L | K) & 16777215).toString(16);
                        K = Y >>> 24 - L & 16777215,
                        K !== 0 || X !== this.length - 1 ? I = U[6 - j.length] + j + I : I = j + I,
                        L += 2,
                        L >= 26 && (L -= 26,
                        X--)
                    }
                    for (K !== 0 && (I = K.toString(16) + I); I.length % D !== 0; )
                        I = "0" + I;
                    return this.negative !== 0 && (I = "-" + I),
                    I
                }
                if (W === (W | 0) && W >= 2 && W <= 36) {
                    var G = H[W]
                      , ne = Z[W];
                    I = "";
                    var te = this.clone();
                    for (te.negative = 0; !te.isZero(); ) {
                        var ce = te.modn(ne).toString(W);
                        te = te.idivn(ne),
                        te.isZero() ? I = ce + I : I = U[G - ce.length] + ce + I
                    }
                    for (this.isZero() && (I = "0" + I); I.length % D !== 0; )
                        I = "0" + I;
                    return this.negative !== 0 && (I = "-" + I),
                    I
                }
                M(!1, "Base should be between 2 and 36")
            }
            ,
            $.prototype.toNumber = function() {
                var W = this.words[0];
                return this.length === 2 ? W += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? W += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -W : W
            }
            ,
            $.prototype.toJSON = function() {
                return this.toString(16)
            }
            ,
            $.prototype.toBuffer = function(W, D) {
                return M(typeof B < "u"),
                this.toArrayLike(B, W, D)
            }
            ,
            $.prototype.toArray = function(W, D) {
                return this.toArrayLike(Array, W, D)
            }
            ,
            $.prototype.toArrayLike = function(W, D, I) {
                var L = this.byteLength()
                  , K = I || Math.max(1, L);
                M(L <= K, "byte array longer than desired length"),
                M(K > 0, "Requested array length <= 0"),
                this.strip();
                var X = D === "le", Y = new W(K), j, G, ne = this.clone();
                if (X) {
                    for (G = 0; !ne.isZero(); G++)
                        j = ne.andln(255),
                        ne.iushrn(8),
                        Y[G] = j;
                    for (; G < K; G++)
                        Y[G] = 0
                } else {
                    for (G = 0; G < K - L; G++)
                        Y[G] = 0;
                    for (G = 0; !ne.isZero(); G++)
                        j = ne.andln(255),
                        ne.iushrn(8),
                        Y[K - G - 1] = j
                }
                return Y
            }
            ,
            Math.clz32 ? $.prototype._countBits = function(W) {
                return 32 - Math.clz32(W)
            }
            : $.prototype._countBits = function(W) {
                var D = W
                  , I = 0;
                return D >= 4096 && (I += 13,
                D >>>= 13),
                D >= 64 && (I += 7,
                D >>>= 7),
                D >= 8 && (I += 4,
                D >>>= 4),
                D >= 2 && (I += 2,
                D >>>= 2),
                I + D
            }
            ,
            $.prototype._zeroBits = function(W) {
                if (W === 0)
                    return 26;
                var D = W
                  , I = 0;
                return D & 8191 || (I += 13,
                D >>>= 13),
                D & 127 || (I += 7,
                D >>>= 7),
                D & 15 || (I += 4,
                D >>>= 4),
                D & 3 || (I += 2,
                D >>>= 2),
                D & 1 || I++,
                I
            }
            ,
            $.prototype.bitLength = function() {
                var W = this.words[this.length - 1]
                  , D = this._countBits(W);
                return (this.length - 1) * 26 + D
            }
            ;
            function J(V) {
                for (var W = new Array(V.bitLength()), D = 0; D < W.length; D++) {
                    var I = D / 26 | 0
                      , L = D % 26;
                    W[D] = (V.words[I] & 1 << L) >>> L
                }
                return W
            }
            $.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var W = 0, D = 0; D < this.length; D++) {
                    var I = this._zeroBits(this.words[D]);
                    if (W += I,
                    I !== 26)
                        break
                }
                return W
            }
            ,
            $.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            $.prototype.toTwos = function(W) {
                return this.negative !== 0 ? this.abs().inotn(W).iaddn(1) : this.clone()
            }
            ,
            $.prototype.fromTwos = function(W) {
                return this.testn(W - 1) ? this.notn(W).iaddn(1).ineg() : this.clone()
            }
            ,
            $.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            $.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            $.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            $.prototype.iuor = function(W) {
                for (; this.length < W.length; )
                    this.words[this.length++] = 0;
                for (var D = 0; D < W.length; D++)
                    this.words[D] = this.words[D] | W.words[D];
                return this.strip()
            }
            ,
            $.prototype.ior = function(W) {
                return M((this.negative | W.negative) === 0),
                this.iuor(W)
            }
            ,
            $.prototype.or = function(W) {
                return this.length > W.length ? this.clone().ior(W) : W.clone().ior(this)
            }
            ,
            $.prototype.uor = function(W) {
                return this.length > W.length ? this.clone().iuor(W) : W.clone().iuor(this)
            }
            ,
            $.prototype.iuand = function(W) {
                var D;
                this.length > W.length ? D = W : D = this;
                for (var I = 0; I < D.length; I++)
                    this.words[I] = this.words[I] & W.words[I];
                return this.length = D.length,
                this.strip()
            }
            ,
            $.prototype.iand = function(W) {
                return M((this.negative | W.negative) === 0),
                this.iuand(W)
            }
            ,
            $.prototype.and = function(W) {
                return this.length > W.length ? this.clone().iand(W) : W.clone().iand(this)
            }
            ,
            $.prototype.uand = function(W) {
                return this.length > W.length ? this.clone().iuand(W) : W.clone().iuand(this)
            }
            ,
            $.prototype.iuxor = function(W) {
                var D, I;
                this.length > W.length ? (D = this,
                I = W) : (D = W,
                I = this);
                for (var L = 0; L < I.length; L++)
                    this.words[L] = D.words[L] ^ I.words[L];
                if (this !== D)
                    for (; L < D.length; L++)
                        this.words[L] = D.words[L];
                return this.length = D.length,
                this.strip()
            }
            ,
            $.prototype.ixor = function(W) {
                return M((this.negative | W.negative) === 0),
                this.iuxor(W)
            }
            ,
            $.prototype.xor = function(W) {
                return this.length > W.length ? this.clone().ixor(W) : W.clone().ixor(this)
            }
            ,
            $.prototype.uxor = function(W) {
                return this.length > W.length ? this.clone().iuxor(W) : W.clone().iuxor(this)
            }
            ,
            $.prototype.inotn = function(W) {
                M(typeof W == "number" && W >= 0);
                var D = Math.ceil(W / 26) | 0
                  , I = W % 26;
                this._expand(D),
                I > 0 && D--;
                for (var L = 0; L < D; L++)
                    this.words[L] = ~this.words[L] & 67108863;
                return I > 0 && (this.words[L] = ~this.words[L] & 67108863 >> 26 - I),
                this.strip()
            }
            ,
            $.prototype.notn = function(W) {
                return this.clone().inotn(W)
            }
            ,
            $.prototype.setn = function(W, D) {
                M(typeof W == "number" && W >= 0);
                var I = W / 26 | 0
                  , L = W % 26;
                return this._expand(I + 1),
                D ? this.words[I] = this.words[I] | 1 << L : this.words[I] = this.words[I] & ~(1 << L),
                this.strip()
            }
            ,
            $.prototype.iadd = function(W) {
                var D;
                if (this.negative !== 0 && W.negative === 0)
                    return this.negative = 0,
                    D = this.isub(W),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && W.negative !== 0)
                    return W.negative = 0,
                    D = this.isub(W),
                    W.negative = 1,
                    D._normSign();
                var I, L;
                this.length > W.length ? (I = this,
                L = W) : (I = W,
                L = this);
                for (var K = 0, X = 0; X < L.length; X++)
                    D = (I.words[X] | 0) + (L.words[X] | 0) + K,
                    this.words[X] = D & 67108863,
                    K = D >>> 26;
                for (; K !== 0 && X < I.length; X++)
                    D = (I.words[X] | 0) + K,
                    this.words[X] = D & 67108863,
                    K = D >>> 26;
                if (this.length = I.length,
                K !== 0)
                    this.words[this.length] = K,
                    this.length++;
                else if (I !== this)
                    for (; X < I.length; X++)
                        this.words[X] = I.words[X];
                return this
            }
            ,
            $.prototype.add = function(W) {
                var D;
                return W.negative !== 0 && this.negative === 0 ? (W.negative = 0,
                D = this.sub(W),
                W.negative ^= 1,
                D) : W.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                D = W.sub(this),
                this.negative = 1,
                D) : this.length > W.length ? this.clone().iadd(W) : W.clone().iadd(this)
            }
            ,
            $.prototype.isub = function(W) {
                if (W.negative !== 0) {
                    W.negative = 0;
                    var D = this.iadd(W);
                    return W.negative = 1,
                    D._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(W),
                    this.negative = 1,
                    this._normSign();
                var I = this.cmp(W);
                if (I === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var L, K;
                I > 0 ? (L = this,
                K = W) : (L = W,
                K = this);
                for (var X = 0, Y = 0; Y < K.length; Y++)
                    D = (L.words[Y] | 0) - (K.words[Y] | 0) + X,
                    X = D >> 26,
                    this.words[Y] = D & 67108863;
                for (; X !== 0 && Y < L.length; Y++)
                    D = (L.words[Y] | 0) + X,
                    X = D >> 26,
                    this.words[Y] = D & 67108863;
                if (X === 0 && Y < L.length && L !== this)
                    for (; Y < L.length; Y++)
                        this.words[Y] = L.words[Y];
                return this.length = Math.max(this.length, Y),
                L !== this && (this.negative = 1),
                this.strip()
            }
            ,
            $.prototype.sub = function(W) {
                return this.clone().isub(W)
            }
            ;
            function ie(V, W, D) {
                D.negative = W.negative ^ V.negative;
                var I = V.length + W.length | 0;
                D.length = I,
                I = I - 1 | 0;
                var L = V.words[0] | 0
                  , K = W.words[0] | 0
                  , X = L * K
                  , Y = X & 67108863
                  , j = X / 67108864 | 0;
                D.words[0] = Y;
                for (var G = 1; G < I; G++) {
                    for (var ne = j >>> 26, te = j & 67108863, ce = Math.min(G, W.length - 1), Ee = Math.max(0, G - V.length + 1); Ee <= ce; Ee++) {
                        var Re = G - Ee | 0;
                        L = V.words[Re] | 0,
                        K = W.words[Ee] | 0,
                        X = L * K + te,
                        ne += X / 67108864 | 0,
                        te = X & 67108863
                    }
                    D.words[G] = te | 0,
                    j = ne | 0
                }
                return j !== 0 ? D.words[G] = j | 0 : D.length--,
                D.strip()
            }
            var oe = function(W, D, I) {
                var L = W.words, K = D.words, X = I.words, Y = 0, j, G, ne, te = L[0] | 0, ce = te & 8191, Ee = te >>> 13, Re = L[1] | 0, Te = Re & 8191, xe = Re >>> 13, ve = L[2] | 0, Me = ve & 8191, Fe = ve >>> 13, be = L[3] | 0, Ce = be & 8191, ze = be >>> 13, Ge = L[4] | 0, nt = Ge & 8191, bt = Ge >>> 13, ct = L[5] | 0, De = ct & 8191, Ue = ct >>> 13, We = L[6] | 0, Xe = We & 8191, ht = We >>> 13, Je = L[7] | 0, ot = Je & 8191, je = Je >>> 13, $e = L[8] | 0, Ie = $e & 8191, He = $e >>> 13, qe = L[9] | 0, Ne = qe & 8191, at = qe >>> 13, Ye = K[0] | 0, it = Ye & 8191, At = Ye >>> 13, pt = K[1] | 0, ut = pt & 8191, Rt = pt >>> 13, yt = K[2] | 0, st = yt & 8191, Wt = yt >>> 13, Ct = K[3] | 0, Mt = Ct & 8191, Kt = Ct >>> 13, Pt = K[4] | 0, St = Pt & 8191, Zt = Pt >>> 13, Nt = K[5] | 0, $t = Nt & 8191, Gt = Nt >>> 13, Ot = K[6] | 0, Bt = Ot & 8191, Yt = Ot >>> 13, ye = K[7] | 0, Be = ye & 8191, Oe = ye >>> 13, he = K[8] | 0, Pe = he & 8191, rt = he >>> 13, Ze = K[9] | 0, tt = Ze & 8191, Et = Ze >>> 13;
                I.negative = W.negative ^ D.negative,
                I.length = 19,
                j = Math.imul(ce, it),
                G = Math.imul(ce, At),
                G = G + Math.imul(Ee, it) | 0,
                ne = Math.imul(Ee, At);
                var Tt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Tt >>> 26) | 0,
                Tt &= 67108863,
                j = Math.imul(Te, it),
                G = Math.imul(Te, At),
                G = G + Math.imul(xe, it) | 0,
                ne = Math.imul(xe, At),
                j = j + Math.imul(ce, ut) | 0,
                G = G + Math.imul(ce, Rt) | 0,
                G = G + Math.imul(Ee, ut) | 0,
                ne = ne + Math.imul(Ee, Rt) | 0;
                var kt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (kt >>> 26) | 0,
                kt &= 67108863,
                j = Math.imul(Me, it),
                G = Math.imul(Me, At),
                G = G + Math.imul(Fe, it) | 0,
                ne = Math.imul(Fe, At),
                j = j + Math.imul(Te, ut) | 0,
                G = G + Math.imul(Te, Rt) | 0,
                G = G + Math.imul(xe, ut) | 0,
                ne = ne + Math.imul(xe, Rt) | 0,
                j = j + Math.imul(ce, st) | 0,
                G = G + Math.imul(ce, Wt) | 0,
                G = G + Math.imul(Ee, st) | 0,
                ne = ne + Math.imul(Ee, Wt) | 0;
                var Qt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                j = Math.imul(Ce, it),
                G = Math.imul(Ce, At),
                G = G + Math.imul(ze, it) | 0,
                ne = Math.imul(ze, At),
                j = j + Math.imul(Me, ut) | 0,
                G = G + Math.imul(Me, Rt) | 0,
                G = G + Math.imul(Fe, ut) | 0,
                ne = ne + Math.imul(Fe, Rt) | 0,
                j = j + Math.imul(Te, st) | 0,
                G = G + Math.imul(Te, Wt) | 0,
                G = G + Math.imul(xe, st) | 0,
                ne = ne + Math.imul(xe, Wt) | 0,
                j = j + Math.imul(ce, Mt) | 0,
                G = G + Math.imul(ce, Kt) | 0,
                G = G + Math.imul(Ee, Mt) | 0,
                ne = ne + Math.imul(Ee, Kt) | 0;
                var Vt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Vt >>> 26) | 0,
                Vt &= 67108863,
                j = Math.imul(nt, it),
                G = Math.imul(nt, At),
                G = G + Math.imul(bt, it) | 0,
                ne = Math.imul(bt, At),
                j = j + Math.imul(Ce, ut) | 0,
                G = G + Math.imul(Ce, Rt) | 0,
                G = G + Math.imul(ze, ut) | 0,
                ne = ne + Math.imul(ze, Rt) | 0,
                j = j + Math.imul(Me, st) | 0,
                G = G + Math.imul(Me, Wt) | 0,
                G = G + Math.imul(Fe, st) | 0,
                ne = ne + Math.imul(Fe, Wt) | 0,
                j = j + Math.imul(Te, Mt) | 0,
                G = G + Math.imul(Te, Kt) | 0,
                G = G + Math.imul(xe, Mt) | 0,
                ne = ne + Math.imul(xe, Kt) | 0,
                j = j + Math.imul(ce, St) | 0,
                G = G + Math.imul(ce, Zt) | 0,
                G = G + Math.imul(Ee, St) | 0,
                ne = ne + Math.imul(Ee, Zt) | 0;
                var Ve = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Ve >>> 26) | 0,
                Ve &= 67108863,
                j = Math.imul(De, it),
                G = Math.imul(De, At),
                G = G + Math.imul(Ue, it) | 0,
                ne = Math.imul(Ue, At),
                j = j + Math.imul(nt, ut) | 0,
                G = G + Math.imul(nt, Rt) | 0,
                G = G + Math.imul(bt, ut) | 0,
                ne = ne + Math.imul(bt, Rt) | 0,
                j = j + Math.imul(Ce, st) | 0,
                G = G + Math.imul(Ce, Wt) | 0,
                G = G + Math.imul(ze, st) | 0,
                ne = ne + Math.imul(ze, Wt) | 0,
                j = j + Math.imul(Me, Mt) | 0,
                G = G + Math.imul(Me, Kt) | 0,
                G = G + Math.imul(Fe, Mt) | 0,
                ne = ne + Math.imul(Fe, Kt) | 0,
                j = j + Math.imul(Te, St) | 0,
                G = G + Math.imul(Te, Zt) | 0,
                G = G + Math.imul(xe, St) | 0,
                ne = ne + Math.imul(xe, Zt) | 0,
                j = j + Math.imul(ce, $t) | 0,
                G = G + Math.imul(ce, Gt) | 0,
                G = G + Math.imul(Ee, $t) | 0,
                ne = ne + Math.imul(Ee, Gt) | 0;
                var me = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (me >>> 26) | 0,
                me &= 67108863,
                j = Math.imul(Xe, it),
                G = Math.imul(Xe, At),
                G = G + Math.imul(ht, it) | 0,
                ne = Math.imul(ht, At),
                j = j + Math.imul(De, ut) | 0,
                G = G + Math.imul(De, Rt) | 0,
                G = G + Math.imul(Ue, ut) | 0,
                ne = ne + Math.imul(Ue, Rt) | 0,
                j = j + Math.imul(nt, st) | 0,
                G = G + Math.imul(nt, Wt) | 0,
                G = G + Math.imul(bt, st) | 0,
                ne = ne + Math.imul(bt, Wt) | 0,
                j = j + Math.imul(Ce, Mt) | 0,
                G = G + Math.imul(Ce, Kt) | 0,
                G = G + Math.imul(ze, Mt) | 0,
                ne = ne + Math.imul(ze, Kt) | 0,
                j = j + Math.imul(Me, St) | 0,
                G = G + Math.imul(Me, Zt) | 0,
                G = G + Math.imul(Fe, St) | 0,
                ne = ne + Math.imul(Fe, Zt) | 0,
                j = j + Math.imul(Te, $t) | 0,
                G = G + Math.imul(Te, Gt) | 0,
                G = G + Math.imul(xe, $t) | 0,
                ne = ne + Math.imul(xe, Gt) | 0,
                j = j + Math.imul(ce, Bt) | 0,
                G = G + Math.imul(ce, Yt) | 0,
                G = G + Math.imul(Ee, Bt) | 0,
                ne = ne + Math.imul(Ee, Yt) | 0;
                var ke = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (ke >>> 26) | 0,
                ke &= 67108863,
                j = Math.imul(ot, it),
                G = Math.imul(ot, At),
                G = G + Math.imul(je, it) | 0,
                ne = Math.imul(je, At),
                j = j + Math.imul(Xe, ut) | 0,
                G = G + Math.imul(Xe, Rt) | 0,
                G = G + Math.imul(ht, ut) | 0,
                ne = ne + Math.imul(ht, Rt) | 0,
                j = j + Math.imul(De, st) | 0,
                G = G + Math.imul(De, Wt) | 0,
                G = G + Math.imul(Ue, st) | 0,
                ne = ne + Math.imul(Ue, Wt) | 0,
                j = j + Math.imul(nt, Mt) | 0,
                G = G + Math.imul(nt, Kt) | 0,
                G = G + Math.imul(bt, Mt) | 0,
                ne = ne + Math.imul(bt, Kt) | 0,
                j = j + Math.imul(Ce, St) | 0,
                G = G + Math.imul(Ce, Zt) | 0,
                G = G + Math.imul(ze, St) | 0,
                ne = ne + Math.imul(ze, Zt) | 0,
                j = j + Math.imul(Me, $t) | 0,
                G = G + Math.imul(Me, Gt) | 0,
                G = G + Math.imul(Fe, $t) | 0,
                ne = ne + Math.imul(Fe, Gt) | 0,
                j = j + Math.imul(Te, Bt) | 0,
                G = G + Math.imul(Te, Yt) | 0,
                G = G + Math.imul(xe, Bt) | 0,
                ne = ne + Math.imul(xe, Yt) | 0,
                j = j + Math.imul(ce, Be) | 0,
                G = G + Math.imul(ce, Oe) | 0,
                G = G + Math.imul(Ee, Be) | 0,
                ne = ne + Math.imul(Ee, Oe) | 0;
                var Le = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Le >>> 26) | 0,
                Le &= 67108863,
                j = Math.imul(Ie, it),
                G = Math.imul(Ie, At),
                G = G + Math.imul(He, it) | 0,
                ne = Math.imul(He, At),
                j = j + Math.imul(ot, ut) | 0,
                G = G + Math.imul(ot, Rt) | 0,
                G = G + Math.imul(je, ut) | 0,
                ne = ne + Math.imul(je, Rt) | 0,
                j = j + Math.imul(Xe, st) | 0,
                G = G + Math.imul(Xe, Wt) | 0,
                G = G + Math.imul(ht, st) | 0,
                ne = ne + Math.imul(ht, Wt) | 0,
                j = j + Math.imul(De, Mt) | 0,
                G = G + Math.imul(De, Kt) | 0,
                G = G + Math.imul(Ue, Mt) | 0,
                ne = ne + Math.imul(Ue, Kt) | 0,
                j = j + Math.imul(nt, St) | 0,
                G = G + Math.imul(nt, Zt) | 0,
                G = G + Math.imul(bt, St) | 0,
                ne = ne + Math.imul(bt, Zt) | 0,
                j = j + Math.imul(Ce, $t) | 0,
                G = G + Math.imul(Ce, Gt) | 0,
                G = G + Math.imul(ze, $t) | 0,
                ne = ne + Math.imul(ze, Gt) | 0,
                j = j + Math.imul(Me, Bt) | 0,
                G = G + Math.imul(Me, Yt) | 0,
                G = G + Math.imul(Fe, Bt) | 0,
                ne = ne + Math.imul(Fe, Yt) | 0,
                j = j + Math.imul(Te, Be) | 0,
                G = G + Math.imul(Te, Oe) | 0,
                G = G + Math.imul(xe, Be) | 0,
                ne = ne + Math.imul(xe, Oe) | 0,
                j = j + Math.imul(ce, Pe) | 0,
                G = G + Math.imul(ce, rt) | 0,
                G = G + Math.imul(Ee, Pe) | 0,
                ne = ne + Math.imul(Ee, rt) | 0;
                var Qe = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Qe >>> 26) | 0,
                Qe &= 67108863,
                j = Math.imul(Ne, it),
                G = Math.imul(Ne, At),
                G = G + Math.imul(at, it) | 0,
                ne = Math.imul(at, At),
                j = j + Math.imul(Ie, ut) | 0,
                G = G + Math.imul(Ie, Rt) | 0,
                G = G + Math.imul(He, ut) | 0,
                ne = ne + Math.imul(He, Rt) | 0,
                j = j + Math.imul(ot, st) | 0,
                G = G + Math.imul(ot, Wt) | 0,
                G = G + Math.imul(je, st) | 0,
                ne = ne + Math.imul(je, Wt) | 0,
                j = j + Math.imul(Xe, Mt) | 0,
                G = G + Math.imul(Xe, Kt) | 0,
                G = G + Math.imul(ht, Mt) | 0,
                ne = ne + Math.imul(ht, Kt) | 0,
                j = j + Math.imul(De, St) | 0,
                G = G + Math.imul(De, Zt) | 0,
                G = G + Math.imul(Ue, St) | 0,
                ne = ne + Math.imul(Ue, Zt) | 0,
                j = j + Math.imul(nt, $t) | 0,
                G = G + Math.imul(nt, Gt) | 0,
                G = G + Math.imul(bt, $t) | 0,
                ne = ne + Math.imul(bt, Gt) | 0,
                j = j + Math.imul(Ce, Bt) | 0,
                G = G + Math.imul(Ce, Yt) | 0,
                G = G + Math.imul(ze, Bt) | 0,
                ne = ne + Math.imul(ze, Yt) | 0,
                j = j + Math.imul(Me, Be) | 0,
                G = G + Math.imul(Me, Oe) | 0,
                G = G + Math.imul(Fe, Be) | 0,
                ne = ne + Math.imul(Fe, Oe) | 0,
                j = j + Math.imul(Te, Pe) | 0,
                G = G + Math.imul(Te, rt) | 0,
                G = G + Math.imul(xe, Pe) | 0,
                ne = ne + Math.imul(xe, rt) | 0,
                j = j + Math.imul(ce, tt) | 0,
                G = G + Math.imul(ce, Et) | 0,
                G = G + Math.imul(Ee, tt) | 0,
                ne = ne + Math.imul(Ee, Et) | 0;
                var Ke = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Ke >>> 26) | 0,
                Ke &= 67108863,
                j = Math.imul(Ne, ut),
                G = Math.imul(Ne, Rt),
                G = G + Math.imul(at, ut) | 0,
                ne = Math.imul(at, Rt),
                j = j + Math.imul(Ie, st) | 0,
                G = G + Math.imul(Ie, Wt) | 0,
                G = G + Math.imul(He, st) | 0,
                ne = ne + Math.imul(He, Wt) | 0,
                j = j + Math.imul(ot, Mt) | 0,
                G = G + Math.imul(ot, Kt) | 0,
                G = G + Math.imul(je, Mt) | 0,
                ne = ne + Math.imul(je, Kt) | 0,
                j = j + Math.imul(Xe, St) | 0,
                G = G + Math.imul(Xe, Zt) | 0,
                G = G + Math.imul(ht, St) | 0,
                ne = ne + Math.imul(ht, Zt) | 0,
                j = j + Math.imul(De, $t) | 0,
                G = G + Math.imul(De, Gt) | 0,
                G = G + Math.imul(Ue, $t) | 0,
                ne = ne + Math.imul(Ue, Gt) | 0,
                j = j + Math.imul(nt, Bt) | 0,
                G = G + Math.imul(nt, Yt) | 0,
                G = G + Math.imul(bt, Bt) | 0,
                ne = ne + Math.imul(bt, Yt) | 0,
                j = j + Math.imul(Ce, Be) | 0,
                G = G + Math.imul(Ce, Oe) | 0,
                G = G + Math.imul(ze, Be) | 0,
                ne = ne + Math.imul(ze, Oe) | 0,
                j = j + Math.imul(Me, Pe) | 0,
                G = G + Math.imul(Me, rt) | 0,
                G = G + Math.imul(Fe, Pe) | 0,
                ne = ne + Math.imul(Fe, rt) | 0,
                j = j + Math.imul(Te, tt) | 0,
                G = G + Math.imul(Te, Et) | 0,
                G = G + Math.imul(xe, tt) | 0,
                ne = ne + Math.imul(xe, Et) | 0;
                var vt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (vt >>> 26) | 0,
                vt &= 67108863,
                j = Math.imul(Ne, st),
                G = Math.imul(Ne, Wt),
                G = G + Math.imul(at, st) | 0,
                ne = Math.imul(at, Wt),
                j = j + Math.imul(Ie, Mt) | 0,
                G = G + Math.imul(Ie, Kt) | 0,
                G = G + Math.imul(He, Mt) | 0,
                ne = ne + Math.imul(He, Kt) | 0,
                j = j + Math.imul(ot, St) | 0,
                G = G + Math.imul(ot, Zt) | 0,
                G = G + Math.imul(je, St) | 0,
                ne = ne + Math.imul(je, Zt) | 0,
                j = j + Math.imul(Xe, $t) | 0,
                G = G + Math.imul(Xe, Gt) | 0,
                G = G + Math.imul(ht, $t) | 0,
                ne = ne + Math.imul(ht, Gt) | 0,
                j = j + Math.imul(De, Bt) | 0,
                G = G + Math.imul(De, Yt) | 0,
                G = G + Math.imul(Ue, Bt) | 0,
                ne = ne + Math.imul(Ue, Yt) | 0,
                j = j + Math.imul(nt, Be) | 0,
                G = G + Math.imul(nt, Oe) | 0,
                G = G + Math.imul(bt, Be) | 0,
                ne = ne + Math.imul(bt, Oe) | 0,
                j = j + Math.imul(Ce, Pe) | 0,
                G = G + Math.imul(Ce, rt) | 0,
                G = G + Math.imul(ze, Pe) | 0,
                ne = ne + Math.imul(ze, rt) | 0,
                j = j + Math.imul(Me, tt) | 0,
                G = G + Math.imul(Me, Et) | 0,
                G = G + Math.imul(Fe, tt) | 0,
                ne = ne + Math.imul(Fe, Et) | 0;
                var dt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (dt >>> 26) | 0,
                dt &= 67108863,
                j = Math.imul(Ne, Mt),
                G = Math.imul(Ne, Kt),
                G = G + Math.imul(at, Mt) | 0,
                ne = Math.imul(at, Kt),
                j = j + Math.imul(Ie, St) | 0,
                G = G + Math.imul(Ie, Zt) | 0,
                G = G + Math.imul(He, St) | 0,
                ne = ne + Math.imul(He, Zt) | 0,
                j = j + Math.imul(ot, $t) | 0,
                G = G + Math.imul(ot, Gt) | 0,
                G = G + Math.imul(je, $t) | 0,
                ne = ne + Math.imul(je, Gt) | 0,
                j = j + Math.imul(Xe, Bt) | 0,
                G = G + Math.imul(Xe, Yt) | 0,
                G = G + Math.imul(ht, Bt) | 0,
                ne = ne + Math.imul(ht, Yt) | 0,
                j = j + Math.imul(De, Be) | 0,
                G = G + Math.imul(De, Oe) | 0,
                G = G + Math.imul(Ue, Be) | 0,
                ne = ne + Math.imul(Ue, Oe) | 0,
                j = j + Math.imul(nt, Pe) | 0,
                G = G + Math.imul(nt, rt) | 0,
                G = G + Math.imul(bt, Pe) | 0,
                ne = ne + Math.imul(bt, rt) | 0,
                j = j + Math.imul(Ce, tt) | 0,
                G = G + Math.imul(Ce, Et) | 0,
                G = G + Math.imul(ze, tt) | 0,
                ne = ne + Math.imul(ze, Et) | 0;
                var It = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (It >>> 26) | 0,
                It &= 67108863,
                j = Math.imul(Ne, St),
                G = Math.imul(Ne, Zt),
                G = G + Math.imul(at, St) | 0,
                ne = Math.imul(at, Zt),
                j = j + Math.imul(Ie, $t) | 0,
                G = G + Math.imul(Ie, Gt) | 0,
                G = G + Math.imul(He, $t) | 0,
                ne = ne + Math.imul(He, Gt) | 0,
                j = j + Math.imul(ot, Bt) | 0,
                G = G + Math.imul(ot, Yt) | 0,
                G = G + Math.imul(je, Bt) | 0,
                ne = ne + Math.imul(je, Yt) | 0,
                j = j + Math.imul(Xe, Be) | 0,
                G = G + Math.imul(Xe, Oe) | 0,
                G = G + Math.imul(ht, Be) | 0,
                ne = ne + Math.imul(ht, Oe) | 0,
                j = j + Math.imul(De, Pe) | 0,
                G = G + Math.imul(De, rt) | 0,
                G = G + Math.imul(Ue, Pe) | 0,
                ne = ne + Math.imul(Ue, rt) | 0,
                j = j + Math.imul(nt, tt) | 0,
                G = G + Math.imul(nt, Et) | 0,
                G = G + Math.imul(bt, tt) | 0,
                ne = ne + Math.imul(bt, Et) | 0;
                var xt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (xt >>> 26) | 0,
                xt &= 67108863,
                j = Math.imul(Ne, $t),
                G = Math.imul(Ne, Gt),
                G = G + Math.imul(at, $t) | 0,
                ne = Math.imul(at, Gt),
                j = j + Math.imul(Ie, Bt) | 0,
                G = G + Math.imul(Ie, Yt) | 0,
                G = G + Math.imul(He, Bt) | 0,
                ne = ne + Math.imul(He, Yt) | 0,
                j = j + Math.imul(ot, Be) | 0,
                G = G + Math.imul(ot, Oe) | 0,
                G = G + Math.imul(je, Be) | 0,
                ne = ne + Math.imul(je, Oe) | 0,
                j = j + Math.imul(Xe, Pe) | 0,
                G = G + Math.imul(Xe, rt) | 0,
                G = G + Math.imul(ht, Pe) | 0,
                ne = ne + Math.imul(ht, rt) | 0,
                j = j + Math.imul(De, tt) | 0,
                G = G + Math.imul(De, Et) | 0,
                G = G + Math.imul(Ue, tt) | 0,
                ne = ne + Math.imul(Ue, Et) | 0;
                var Dt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (Dt >>> 26) | 0,
                Dt &= 67108863,
                j = Math.imul(Ne, Bt),
                G = Math.imul(Ne, Yt),
                G = G + Math.imul(at, Bt) | 0,
                ne = Math.imul(at, Yt),
                j = j + Math.imul(Ie, Be) | 0,
                G = G + Math.imul(Ie, Oe) | 0,
                G = G + Math.imul(He, Be) | 0,
                ne = ne + Math.imul(He, Oe) | 0,
                j = j + Math.imul(ot, Pe) | 0,
                G = G + Math.imul(ot, rt) | 0,
                G = G + Math.imul(je, Pe) | 0,
                ne = ne + Math.imul(je, rt) | 0,
                j = j + Math.imul(Xe, tt) | 0,
                G = G + Math.imul(Xe, Et) | 0,
                G = G + Math.imul(ht, tt) | 0,
                ne = ne + Math.imul(ht, Et) | 0;
                var qt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (qt >>> 26) | 0,
                qt &= 67108863,
                j = Math.imul(Ne, Be),
                G = Math.imul(Ne, Oe),
                G = G + Math.imul(at, Be) | 0,
                ne = Math.imul(at, Oe),
                j = j + Math.imul(Ie, Pe) | 0,
                G = G + Math.imul(Ie, rt) | 0,
                G = G + Math.imul(He, Pe) | 0,
                ne = ne + Math.imul(He, rt) | 0,
                j = j + Math.imul(ot, tt) | 0,
                G = G + Math.imul(ot, Et) | 0,
                G = G + Math.imul(je, tt) | 0,
                ne = ne + Math.imul(je, Et) | 0;
                var zt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (zt >>> 26) | 0,
                zt &= 67108863,
                j = Math.imul(Ne, Pe),
                G = Math.imul(Ne, rt),
                G = G + Math.imul(at, Pe) | 0,
                ne = Math.imul(at, rt),
                j = j + Math.imul(Ie, tt) | 0,
                G = G + Math.imul(Ie, Et) | 0,
                G = G + Math.imul(He, tt) | 0,
                ne = ne + Math.imul(He, Et) | 0;
                var mt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                Y = (ne + (G >>> 13) | 0) + (mt >>> 26) | 0,
                mt &= 67108863,
                j = Math.imul(Ne, tt),
                G = Math.imul(Ne, Et),
                G = G + Math.imul(at, tt) | 0,
                ne = Math.imul(at, Et);
                var wt = (Y + j | 0) + ((G & 8191) << 13) | 0;
                return Y = (ne + (G >>> 13) | 0) + (wt >>> 26) | 0,
                wt &= 67108863,
                X[0] = Tt,
                X[1] = kt,
                X[2] = Qt,
                X[3] = Vt,
                X[4] = Ve,
                X[5] = me,
                X[6] = ke,
                X[7] = Le,
                X[8] = Qe,
                X[9] = Ke,
                X[10] = vt,
                X[11] = dt,
                X[12] = It,
                X[13] = xt,
                X[14] = Dt,
                X[15] = qt,
                X[16] = zt,
                X[17] = mt,
                X[18] = wt,
                Y !== 0 && (X[19] = Y,
                I.length++),
                I
            };
            Math.imul || (oe = ie);
            function ae(V, W, D) {
                D.negative = W.negative ^ V.negative,
                D.length = V.length + W.length;
                for (var I = 0, L = 0, K = 0; K < D.length - 1; K++) {
                    var X = L;
                    L = 0;
                    for (var Y = I & 67108863, j = Math.min(K, W.length - 1), G = Math.max(0, K - V.length + 1); G <= j; G++) {
                        var ne = K - G
                          , te = V.words[ne] | 0
                          , ce = W.words[G] | 0
                          , Ee = te * ce
                          , Re = Ee & 67108863;
                        X = X + (Ee / 67108864 | 0) | 0,
                        Re = Re + Y | 0,
                        Y = Re & 67108863,
                        X = X + (Re >>> 26) | 0,
                        L += X >>> 26,
                        X &= 67108863
                    }
                    D.words[K] = Y,
                    I = X,
                    X = L
                }
                return I !== 0 ? D.words[K] = I : D.length--,
                D.strip()
            }
            function se(V, W, D) {
                var I = new le;
                return I.mulp(V, W, D)
            }
            $.prototype.mulTo = function(W, D) {
                var I, L = this.length + W.length;
                return this.length === 10 && W.length === 10 ? I = oe(this, W, D) : L < 63 ? I = ie(this, W, D) : L < 1024 ? I = ae(this, W, D) : I = se(this, W, D),
                I
            }
            ;
            function le(V, W) {
                this.x = V,
                this.y = W
            }
            le.prototype.makeRBT = function(W) {
                for (var D = new Array(W), I = $.prototype._countBits(W) - 1, L = 0; L < W; L++)
                    D[L] = this.revBin(L, I, W);
                return D
            }
            ,
            le.prototype.revBin = function(W, D, I) {
                if (W === 0 || W === I - 1)
                    return W;
                for (var L = 0, K = 0; K < D; K++)
                    L |= (W & 1) << D - K - 1,
                    W >>= 1;
                return L
            }
            ,
            le.prototype.permute = function(W, D, I, L, K, X) {
                for (var Y = 0; Y < X; Y++)
                    L[Y] = D[W[Y]],
                    K[Y] = I[W[Y]]
            }
            ,
            le.prototype.transform = function(W, D, I, L, K, X) {
                this.permute(X, W, D, I, L, K);
                for (var Y = 1; Y < K; Y <<= 1)
                    for (var j = Y << 1, G = Math.cos(2 * Math.PI / j), ne = Math.sin(2 * Math.PI / j), te = 0; te < K; te += j)
                        for (var ce = G, Ee = ne, Re = 0; Re < Y; Re++) {
                            var Te = I[te + Re]
                              , xe = L[te + Re]
                              , ve = I[te + Re + Y]
                              , Me = L[te + Re + Y]
                              , Fe = ce * ve - Ee * Me;
                            Me = ce * Me + Ee * ve,
                            ve = Fe,
                            I[te + Re] = Te + ve,
                            L[te + Re] = xe + Me,
                            I[te + Re + Y] = Te - ve,
                            L[te + Re + Y] = xe - Me,
                            Re !== j && (Fe = G * ce - ne * Ee,
                            Ee = G * Ee + ne * ce,
                            ce = Fe)
                        }
            }
            ,
            le.prototype.guessLen13b = function(W, D) {
                var I = Math.max(D, W) | 1
                  , L = I & 1
                  , K = 0;
                for (I = I / 2 | 0; I; I = I >>> 1)
                    K++;
                return 1 << K + 1 + L
            }
            ,
            le.prototype.conjugate = function(W, D, I) {
                if (!(I <= 1))
                    for (var L = 0; L < I / 2; L++) {
                        var K = W[L];
                        W[L] = W[I - L - 1],
                        W[I - L - 1] = K,
                        K = D[L],
                        D[L] = -D[I - L - 1],
                        D[I - L - 1] = -K
                    }
            }
            ,
            le.prototype.normalize13b = function(W, D) {
                for (var I = 0, L = 0; L < D / 2; L++) {
                    var K = Math.round(W[2 * L + 1] / D) * 8192 + Math.round(W[2 * L] / D) + I;
                    W[L] = K & 67108863,
                    K < 67108864 ? I = 0 : I = K / 67108864 | 0
                }
                return W
            }
            ,
            le.prototype.convert13b = function(W, D, I, L) {
                for (var K = 0, X = 0; X < D; X++)
                    K = K + (W[X] | 0),
                    I[2 * X] = K & 8191,
                    K = K >>> 13,
                    I[2 * X + 1] = K & 8191,
                    K = K >>> 13;
                for (X = 2 * D; X < L; ++X)
                    I[X] = 0;
                M(K === 0),
                M((K & -8192) === 0)
            }
            ,
            le.prototype.stub = function(W) {
                for (var D = new Array(W), I = 0; I < W; I++)
                    D[I] = 0;
                return D
            }
            ,
            le.prototype.mulp = function(W, D, I) {
                var L = 2 * this.guessLen13b(W.length, D.length)
                  , K = this.makeRBT(L)
                  , X = this.stub(L)
                  , Y = new Array(L)
                  , j = new Array(L)
                  , G = new Array(L)
                  , ne = new Array(L)
                  , te = new Array(L)
                  , ce = new Array(L)
                  , Ee = I.words;
                Ee.length = L,
                this.convert13b(W.words, W.length, Y, L),
                this.convert13b(D.words, D.length, ne, L),
                this.transform(Y, X, j, G, L, K),
                this.transform(ne, X, te, ce, L, K);
                for (var Re = 0; Re < L; Re++) {
                    var Te = j[Re] * te[Re] - G[Re] * ce[Re];
                    G[Re] = j[Re] * ce[Re] + G[Re] * te[Re],
                    j[Re] = Te
                }
                return this.conjugate(j, G, L),
                this.transform(j, G, Ee, X, L, K),
                this.conjugate(Ee, X, L),
                this.normalize13b(Ee, L),
                I.negative = W.negative ^ D.negative,
                I.length = W.length + D.length,
                I.strip()
            }
            ,
            $.prototype.mul = function(W) {
                var D = new $(null);
                return D.words = new Array(this.length + W.length),
                this.mulTo(W, D)
            }
            ,
            $.prototype.mulf = function(W) {
                var D = new $(null);
                return D.words = new Array(this.length + W.length),
                se(this, W, D)
            }
            ,
            $.prototype.imul = function(W) {
                return this.clone().mulTo(W, this)
            }
            ,
            $.prototype.imuln = function(W) {
                M(typeof W == "number"),
                M(W < 67108864);
                for (var D = 0, I = 0; I < this.length; I++) {
                    var L = (this.words[I] | 0) * W
                      , K = (L & 67108863) + (D & 67108863);
                    D >>= 26,
                    D += L / 67108864 | 0,
                    D += K >>> 26,
                    this.words[I] = K & 67108863
                }
                return D !== 0 && (this.words[I] = D,
                this.length++),
                this
            }
            ,
            $.prototype.muln = function(W) {
                return this.clone().imuln(W)
            }
            ,
            $.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            $.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            $.prototype.pow = function(W) {
                var D = J(W);
                if (D.length === 0)
                    return new $(1);
                for (var I = this, L = 0; L < D.length && D[L] === 0; L++,
                I = I.sqr())
                    ;
                if (++L < D.length)
                    for (var K = I.sqr(); L < D.length; L++,
                    K = K.sqr())
                        D[L] !== 0 && (I = I.mul(K));
                return I
            }
            ,
            $.prototype.iushln = function(W) {
                M(typeof W == "number" && W >= 0);
                var D = W % 26, I = (W - D) / 26, L = 67108863 >>> 26 - D << 26 - D, K;
                if (D !== 0) {
                    var X = 0;
                    for (K = 0; K < this.length; K++) {
                        var Y = this.words[K] & L
                          , j = (this.words[K] | 0) - Y << D;
                        this.words[K] = j | X,
                        X = Y >>> 26 - D
                    }
                    X && (this.words[K] = X,
                    this.length++)
                }
                if (I !== 0) {
                    for (K = this.length - 1; K >= 0; K--)
                        this.words[K + I] = this.words[K];
                    for (K = 0; K < I; K++)
                        this.words[K] = 0;
                    this.length += I
                }
                return this.strip()
            }
            ,
            $.prototype.ishln = function(W) {
                return M(this.negative === 0),
                this.iushln(W)
            }
            ,
            $.prototype.iushrn = function(W, D, I) {
                M(typeof W == "number" && W >= 0);
                var L;
                D ? L = (D - D % 26) / 26 : L = 0;
                var K = W % 26
                  , X = Math.min((W - K) / 26, this.length)
                  , Y = 67108863 ^ 67108863 >>> K << K
                  , j = I;
                if (L -= X,
                L = Math.max(0, L),
                j) {
                    for (var G = 0; G < X; G++)
                        j.words[G] = this.words[G];
                    j.length = X
                }
                if (X !== 0)
                    if (this.length > X)
                        for (this.length -= X,
                        G = 0; G < this.length; G++)
                            this.words[G] = this.words[G + X];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ne = 0;
                for (G = this.length - 1; G >= 0 && (ne !== 0 || G >= L); G--) {
                    var te = this.words[G] | 0;
                    this.words[G] = ne << 26 - K | te >>> K,
                    ne = te & Y
                }
                return j && ne !== 0 && (j.words[j.length++] = ne),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this.strip()
            }
            ,
            $.prototype.ishrn = function(W, D, I) {
                return M(this.negative === 0),
                this.iushrn(W, D, I)
            }
            ,
            $.prototype.shln = function(W) {
                return this.clone().ishln(W)
            }
            ,
            $.prototype.ushln = function(W) {
                return this.clone().iushln(W)
            }
            ,
            $.prototype.shrn = function(W) {
                return this.clone().ishrn(W)
            }
            ,
            $.prototype.ushrn = function(W) {
                return this.clone().iushrn(W)
            }
            ,
            $.prototype.testn = function(W) {
                M(typeof W == "number" && W >= 0);
                var D = W % 26
                  , I = (W - D) / 26
                  , L = 1 << D;
                if (this.length <= I)
                    return !1;
                var K = this.words[I];
                return !!(K & L)
            }
            ,
            $.prototype.imaskn = function(W) {
                M(typeof W == "number" && W >= 0);
                var D = W % 26
                  , I = (W - D) / 26;
                if (M(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= I)
                    return this;
                if (D !== 0 && I++,
                this.length = Math.min(I, this.length),
                D !== 0) {
                    var L = 67108863 ^ 67108863 >>> D << D;
                    this.words[this.length - 1] &= L
                }
                return this.strip()
            }
            ,
            $.prototype.maskn = function(W) {
                return this.clone().imaskn(W)
            }
            ,
            $.prototype.iaddn = function(W) {
                return M(typeof W == "number"),
                M(W < 67108864),
                W < 0 ? this.isubn(-W) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < W ? (this.words[0] = W - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(W),
                this.negative = 1,
                this) : this._iaddn(W)
            }
            ,
            $.prototype._iaddn = function(W) {
                this.words[0] += W;
                for (var D = 0; D < this.length && this.words[D] >= 67108864; D++)
                    this.words[D] -= 67108864,
                    D === this.length - 1 ? this.words[D + 1] = 1 : this.words[D + 1]++;
                return this.length = Math.max(this.length, D + 1),
                this
            }
            ,
            $.prototype.isubn = function(W) {
                if (M(typeof W == "number"),
                M(W < 67108864),
                W < 0)
                    return this.iaddn(-W);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(W),
                    this.negative = 1,
                    this;
                if (this.words[0] -= W,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var D = 0; D < this.length && this.words[D] < 0; D++)
                        this.words[D] += 67108864,
                        this.words[D + 1] -= 1;
                return this.strip()
            }
            ,
            $.prototype.addn = function(W) {
                return this.clone().iaddn(W)
            }
            ,
            $.prototype.subn = function(W) {
                return this.clone().isubn(W)
            }
            ,
            $.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            $.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            $.prototype._ishlnsubmul = function(W, D, I) {
                var L = W.length + I, K;
                this._expand(L);
                var X, Y = 0;
                for (K = 0; K < W.length; K++) {
                    X = (this.words[K + I] | 0) + Y;
                    var j = (W.words[K] | 0) * D;
                    X -= j & 67108863,
                    Y = (X >> 26) - (j / 67108864 | 0),
                    this.words[K + I] = X & 67108863
                }
                for (; K < this.length - I; K++)
                    X = (this.words[K + I] | 0) + Y,
                    Y = X >> 26,
                    this.words[K + I] = X & 67108863;
                if (Y === 0)
                    return this.strip();
                for (M(Y === -1),
                Y = 0,
                K = 0; K < this.length; K++)
                    X = -(this.words[K] | 0) + Y,
                    Y = X >> 26,
                    this.words[K] = X & 67108863;
                return this.negative = 1,
                this.strip()
            }
            ,
            $.prototype._wordDiv = function(W, D) {
                var I = this.length - W.length
                  , L = this.clone()
                  , K = W
                  , X = K.words[K.length - 1] | 0
                  , Y = this._countBits(X);
                I = 26 - Y,
                I !== 0 && (K = K.ushln(I),
                L.iushln(I),
                X = K.words[K.length - 1] | 0);
                var j = L.length - K.length, G;
                if (D !== "mod") {
                    G = new $(null),
                    G.length = j + 1,
                    G.words = new Array(G.length);
                    for (var ne = 0; ne < G.length; ne++)
                        G.words[ne] = 0
                }
                var te = L.clone()._ishlnsubmul(K, 1, j);
                te.negative === 0 && (L = te,
                G && (G.words[j] = 1));
                for (var ce = j - 1; ce >= 0; ce--) {
                    var Ee = (L.words[K.length + ce] | 0) * 67108864 + (L.words[K.length + ce - 1] | 0);
                    for (Ee = Math.min(Ee / X | 0, 67108863),
                    L._ishlnsubmul(K, Ee, ce); L.negative !== 0; )
                        Ee--,
                        L.negative = 0,
                        L._ishlnsubmul(K, 1, ce),
                        L.isZero() || (L.negative ^= 1);
                    G && (G.words[ce] = Ee)
                }
                return G && G.strip(),
                L.strip(),
                D !== "div" && I !== 0 && L.iushrn(I),
                {
                    div: G || null,
                    mod: L
                }
            }
            ,
            $.prototype.divmod = function(W, D, I) {
                if (M(!W.isZero()),
                this.isZero())
                    return {
                        div: new $(0),
                        mod: new $(0)
                    };
                var L, K, X;
                return this.negative !== 0 && W.negative === 0 ? (X = this.neg().divmod(W, D),
                D !== "mod" && (L = X.div.neg()),
                D !== "div" && (K = X.mod.neg(),
                I && K.negative !== 0 && K.iadd(W)),
                {
                    div: L,
                    mod: K
                }) : this.negative === 0 && W.negative !== 0 ? (X = this.divmod(W.neg(), D),
                D !== "mod" && (L = X.div.neg()),
                {
                    div: L,
                    mod: X.mod
                }) : this.negative & W.negative ? (X = this.neg().divmod(W.neg(), D),
                D !== "div" && (K = X.mod.neg(),
                I && K.negative !== 0 && K.isub(W)),
                {
                    div: X.div,
                    mod: K
                }) : W.length > this.length || this.cmp(W) < 0 ? {
                    div: new $(0),
                    mod: this
                } : W.length === 1 ? D === "div" ? {
                    div: this.divn(W.words[0]),
                    mod: null
                } : D === "mod" ? {
                    div: null,
                    mod: new $(this.modn(W.words[0]))
                } : {
                    div: this.divn(W.words[0]),
                    mod: new $(this.modn(W.words[0]))
                } : this._wordDiv(W, D)
            }
            ,
            $.prototype.div = function(W) {
                return this.divmod(W, "div", !1).div
            }
            ,
            $.prototype.mod = function(W) {
                return this.divmod(W, "mod", !1).mod
            }
            ,
            $.prototype.umod = function(W) {
                return this.divmod(W, "mod", !0).mod
            }
            ,
            $.prototype.divRound = function(W) {
                var D = this.divmod(W);
                if (D.mod.isZero())
                    return D.div;
                var I = D.div.negative !== 0 ? D.mod.isub(W) : D.mod
                  , L = W.ushrn(1)
                  , K = W.andln(1)
                  , X = I.cmp(L);
                return X < 0 || K === 1 && X === 0 ? D.div : D.div.negative !== 0 ? D.div.isubn(1) : D.div.iaddn(1)
            }
            ,
            $.prototype.modn = function(W) {
                M(W <= 67108863);
                for (var D = (1 << 26) % W, I = 0, L = this.length - 1; L >= 0; L--)
                    I = (D * I + (this.words[L] | 0)) % W;
                return I
            }
            ,
            $.prototype.idivn = function(W) {
                M(W <= 67108863);
                for (var D = 0, I = this.length - 1; I >= 0; I--) {
                    var L = (this.words[I] | 0) + D * 67108864;
                    this.words[I] = L / W | 0,
                    D = L % W
                }
                return this.strip()
            }
            ,
            $.prototype.divn = function(W) {
                return this.clone().idivn(W)
            }
            ,
            $.prototype.egcd = function(W) {
                M(W.negative === 0),
                M(!W.isZero());
                var D = this
                  , I = W.clone();
                D.negative !== 0 ? D = D.umod(W) : D = D.clone();
                for (var L = new $(1), K = new $(0), X = new $(0), Y = new $(1), j = 0; D.isEven() && I.isEven(); )
                    D.iushrn(1),
                    I.iushrn(1),
                    ++j;
                for (var G = I.clone(), ne = D.clone(); !D.isZero(); ) {
                    for (var te = 0, ce = 1; !(D.words[0] & ce) && te < 26; ++te,
                    ce <<= 1)
                        ;
                    if (te > 0)
                        for (D.iushrn(te); te-- > 0; )
                            (L.isOdd() || K.isOdd()) && (L.iadd(G),
                            K.isub(ne)),
                            L.iushrn(1),
                            K.iushrn(1);
                    for (var Ee = 0, Re = 1; !(I.words[0] & Re) && Ee < 26; ++Ee,
                    Re <<= 1)
                        ;
                    if (Ee > 0)
                        for (I.iushrn(Ee); Ee-- > 0; )
                            (X.isOdd() || Y.isOdd()) && (X.iadd(G),
                            Y.isub(ne)),
                            X.iushrn(1),
                            Y.iushrn(1);
                    D.cmp(I) >= 0 ? (D.isub(I),
                    L.isub(X),
                    K.isub(Y)) : (I.isub(D),
                    X.isub(L),
                    Y.isub(K))
                }
                return {
                    a: X,
                    b: Y,
                    gcd: I.iushln(j)
                }
            }
            ,
            $.prototype._invmp = function(W) {
                M(W.negative === 0),
                M(!W.isZero());
                var D = this
                  , I = W.clone();
                D.negative !== 0 ? D = D.umod(W) : D = D.clone();
                for (var L = new $(1), K = new $(0), X = I.clone(); D.cmpn(1) > 0 && I.cmpn(1) > 0; ) {
                    for (var Y = 0, j = 1; !(D.words[0] & j) && Y < 26; ++Y,
                    j <<= 1)
                        ;
                    if (Y > 0)
                        for (D.iushrn(Y); Y-- > 0; )
                            L.isOdd() && L.iadd(X),
                            L.iushrn(1);
                    for (var G = 0, ne = 1; !(I.words[0] & ne) && G < 26; ++G,
                    ne <<= 1)
                        ;
                    if (G > 0)
                        for (I.iushrn(G); G-- > 0; )
                            K.isOdd() && K.iadd(X),
                            K.iushrn(1);
                    D.cmp(I) >= 0 ? (D.isub(I),
                    L.isub(K)) : (I.isub(D),
                    K.isub(L))
                }
                var te;
                return D.cmpn(1) === 0 ? te = L : te = K,
                te.cmpn(0) < 0 && te.iadd(W),
                te
            }
            ,
            $.prototype.gcd = function(W) {
                if (this.isZero())
                    return W.abs();
                if (W.isZero())
                    return this.abs();
                var D = this.clone()
                  , I = W.clone();
                D.negative = 0,
                I.negative = 0;
                for (var L = 0; D.isEven() && I.isEven(); L++)
                    D.iushrn(1),
                    I.iushrn(1);
                do {
                    for (; D.isEven(); )
                        D.iushrn(1);
                    for (; I.isEven(); )
                        I.iushrn(1);
                    var K = D.cmp(I);
                    if (K < 0) {
                        var X = D;
                        D = I,
                        I = X
                    } else if (K === 0 || I.cmpn(1) === 0)
                        break;
                    D.isub(I)
                } while (!0);
                return I.iushln(L)
            }
            ,
            $.prototype.invm = function(W) {
                return this.egcd(W).a.umod(W)
            }
            ,
            $.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            $.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            $.prototype.andln = function(W) {
                return this.words[0] & W
            }
            ,
            $.prototype.bincn = function(W) {
                M(typeof W == "number");
                var D = W % 26
                  , I = (W - D) / 26
                  , L = 1 << D;
                if (this.length <= I)
                    return this._expand(I + 1),
                    this.words[I] |= L,
                    this;
                for (var K = L, X = I; K !== 0 && X < this.length; X++) {
                    var Y = this.words[X] | 0;
                    Y += K,
                    K = Y >>> 26,
                    Y &= 67108863,
                    this.words[X] = Y
                }
                return K !== 0 && (this.words[X] = K,
                this.length++),
                this
            }
            ,
            $.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            $.prototype.cmpn = function(W) {
                var D = W < 0;
                if (this.negative !== 0 && !D)
                    return -1;
                if (this.negative === 0 && D)
                    return 1;
                this.strip();
                var I;
                if (this.length > 1)
                    I = 1;
                else {
                    D && (W = -W),
                    M(W <= 67108863, "Number is too big");
                    var L = this.words[0] | 0;
                    I = L === W ? 0 : L < W ? -1 : 1
                }
                return this.negative !== 0 ? -I | 0 : I
            }
            ,
            $.prototype.cmp = function(W) {
                if (this.negative !== 0 && W.negative === 0)
                    return -1;
                if (this.negative === 0 && W.negative !== 0)
                    return 1;
                var D = this.ucmp(W);
                return this.negative !== 0 ? -D | 0 : D
            }
            ,
            $.prototype.ucmp = function(W) {
                if (this.length > W.length)
                    return 1;
                if (this.length < W.length)
                    return -1;
                for (var D = 0, I = this.length - 1; I >= 0; I--) {
                    var L = this.words[I] | 0
                      , K = W.words[I] | 0;
                    if (L !== K) {
                        L < K ? D = -1 : L > K && (D = 1);
                        break
                    }
                }
                return D
            }
            ,
            $.prototype.gtn = function(W) {
                return this.cmpn(W) === 1
            }
            ,
            $.prototype.gt = function(W) {
                return this.cmp(W) === 1
            }
            ,
            $.prototype.gten = function(W) {
                return this.cmpn(W) >= 0
            }
            ,
            $.prototype.gte = function(W) {
                return this.cmp(W) >= 0
            }
            ,
            $.prototype.ltn = function(W) {
                return this.cmpn(W) === -1
            }
            ,
            $.prototype.lt = function(W) {
                return this.cmp(W) === -1
            }
            ,
            $.prototype.lten = function(W) {
                return this.cmpn(W) <= 0
            }
            ,
            $.prototype.lte = function(W) {
                return this.cmp(W) <= 0
            }
            ,
            $.prototype.eqn = function(W) {
                return this.cmpn(W) === 0
            }
            ,
            $.prototype.eq = function(W) {
                return this.cmp(W) === 0
            }
            ,
            $.red = function(W) {
                return new Se(W)
            }
            ,
            $.prototype.toRed = function(W) {
                return M(!this.red, "Already a number in reduction context"),
                M(this.negative === 0, "red works only with positives"),
                W.convertTo(this)._forceRed(W)
            }
            ,
            $.prototype.fromRed = function() {
                return M(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            $.prototype._forceRed = function(W) {
                return this.red = W,
                this
            }
            ,
            $.prototype.forceRed = function(W) {
                return M(!this.red, "Already a number in reduction context"),
                this._forceRed(W)
            }
            ,
            $.prototype.redAdd = function(W) {
                return M(this.red, "redAdd works only with red numbers"),
                this.red.add(this, W)
            }
            ,
            $.prototype.redIAdd = function(W) {
                return M(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, W)
            }
            ,
            $.prototype.redSub = function(W) {
                return M(this.red, "redSub works only with red numbers"),
                this.red.sub(this, W)
            }
            ,
            $.prototype.redISub = function(W) {
                return M(this.red, "redISub works only with red numbers"),
                this.red.isub(this, W)
            }
            ,
            $.prototype.redShl = function(W) {
                return M(this.red, "redShl works only with red numbers"),
                this.red.shl(this, W)
            }
            ,
            $.prototype.redMul = function(W) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, W),
                this.red.mul(this, W)
            }
            ,
            $.prototype.redIMul = function(W) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, W),
                this.red.imul(this, W)
            }
            ,
            $.prototype.redSqr = function() {
                return M(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            $.prototype.redISqr = function() {
                return M(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            $.prototype.redSqrt = function() {
                return M(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            $.prototype.redInvm = function() {
                return M(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            $.prototype.redNeg = function() {
                return M(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            $.prototype.redPow = function(W) {
                return M(this.red && !W.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, W)
            }
            ;
            var de = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function fe(V, W) {
                this.name = V,
                this.p = new $(W,16),
                this.n = this.p.bitLength(),
                this.k = new $(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            fe.prototype._tmp = function() {
                var W = new $(null);
                return W.words = new Array(Math.ceil(this.n / 13)),
                W
            }
            ,
            fe.prototype.ireduce = function(W) {
                var D = W, I;
                do
                    this.split(D, this.tmp),
                    D = this.imulK(D),
                    D = D.iadd(this.tmp),
                    I = D.bitLength();
                while (I > this.n);
                var L = I < this.n ? -1 : D.ucmp(this.p);
                return L === 0 ? (D.words[0] = 0,
                D.length = 1) : L > 0 ? D.isub(this.p) : D.strip !== void 0 ? D.strip() : D._strip(),
                D
            }
            ,
            fe.prototype.split = function(W, D) {
                W.iushrn(this.n, 0, D)
            }
            ,
            fe.prototype.imulK = function(W) {
                return W.imul(this.k)
            }
            ;
            function pe() {
                fe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            T(pe, fe),
            pe.prototype.split = function(W, D) {
                for (var I = 4194303, L = Math.min(W.length, 9), K = 0; K < L; K++)
                    D.words[K] = W.words[K];
                if (D.length = L,
                W.length <= 9) {
                    W.words[0] = 0,
                    W.length = 1;
                    return
                }
                var X = W.words[9];
                for (D.words[D.length++] = X & I,
                K = 10; K < W.length; K++) {
                    var Y = W.words[K] | 0;
                    W.words[K - 10] = (Y & I) << 4 | X >>> 22,
                    X = Y
                }
                X >>>= 22,
                W.words[K - 10] = X,
                X === 0 && W.length > 10 ? W.length -= 10 : W.length -= 9
            }
            ,
            pe.prototype.imulK = function(W) {
                W.words[W.length] = 0,
                W.words[W.length + 1] = 0,
                W.length += 2;
                for (var D = 0, I = 0; I < W.length; I++) {
                    var L = W.words[I] | 0;
                    D += L * 977,
                    W.words[I] = D & 67108863,
                    D = L * 64 + (D / 67108864 | 0)
                }
                return W.words[W.length - 1] === 0 && (W.length--,
                W.words[W.length - 1] === 0 && W.length--),
                W
            }
            ;
            function ge() {
                fe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            T(ge, fe);
            function we() {
                fe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            T(we, fe);
            function Ae() {
                fe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            T(Ae, fe),
            Ae.prototype.imulK = function(W) {
                for (var D = 0, I = 0; I < W.length; I++) {
                    var L = (W.words[I] | 0) * 19 + D
                      , K = L & 67108863;
                    L >>>= 26,
                    W.words[I] = K,
                    D = L
                }
                return D !== 0 && (W.words[W.length++] = D),
                W
            }
            ,
            $._prime = function(W) {
                if (de[W])
                    return de[W];
                var D;
                if (W === "k256")
                    D = new pe;
                else if (W === "p224")
                    D = new ge;
                else if (W === "p192")
                    D = new we;
                else if (W === "p25519")
                    D = new Ae;
                else
                    throw new Error("Unknown prime " + W);
                return de[W] = D,
                D
            }
            ;
            function Se(V) {
                if (typeof V == "string") {
                    var W = $._prime(V);
                    this.m = W.p,
                    this.prime = W
                } else
                    M(V.gtn(1), "modulus must be greater than 1"),
                    this.m = V,
                    this.prime = null
            }
            Se.prototype._verify1 = function(W) {
                M(W.negative === 0, "red works only with positives"),
                M(W.red, "red works only with red numbers")
            }
            ,
            Se.prototype._verify2 = function(W, D) {
                M((W.negative | D.negative) === 0, "red works only with positives"),
                M(W.red && W.red === D.red, "red works only with red numbers")
            }
            ,
            Se.prototype.imod = function(W) {
                return this.prime ? this.prime.ireduce(W)._forceRed(this) : W.umod(this.m)._forceRed(this)
            }
            ,
            Se.prototype.neg = function(W) {
                return W.isZero() ? W.clone() : this.m.sub(W)._forceRed(this)
            }
            ,
            Se.prototype.add = function(W, D) {
                this._verify2(W, D);
                var I = W.add(D);
                return I.cmp(this.m) >= 0 && I.isub(this.m),
                I._forceRed(this)
            }
            ,
            Se.prototype.iadd = function(W, D) {
                this._verify2(W, D);
                var I = W.iadd(D);
                return I.cmp(this.m) >= 0 && I.isub(this.m),
                I
            }
            ,
            Se.prototype.sub = function(W, D) {
                this._verify2(W, D);
                var I = W.sub(D);
                return I.cmpn(0) < 0 && I.iadd(this.m),
                I._forceRed(this)
            }
            ,
            Se.prototype.isub = function(W, D) {
                this._verify2(W, D);
                var I = W.isub(D);
                return I.cmpn(0) < 0 && I.iadd(this.m),
                I
            }
            ,
            Se.prototype.shl = function(W, D) {
                return this._verify1(W),
                this.imod(W.ushln(D))
            }
            ,
            Se.prototype.imul = function(W, D) {
                return this._verify2(W, D),
                this.imod(W.imul(D))
            }
            ,
            Se.prototype.mul = function(W, D) {
                return this._verify2(W, D),
                this.imod(W.mul(D))
            }
            ,
            Se.prototype.isqr = function(W) {
                return this.imul(W, W.clone())
            }
            ,
            Se.prototype.sqr = function(W) {
                return this.mul(W, W)
            }
            ,
            Se.prototype.sqrt = function(W) {
                if (W.isZero())
                    return W.clone();
                var D = this.m.andln(3);
                if (M(D % 2 === 1),
                D === 3) {
                    var I = this.m.add(new $(1)).iushrn(2);
                    return this.pow(W, I)
                }
                for (var L = this.m.subn(1), K = 0; !L.isZero() && L.andln(1) === 0; )
                    K++,
                    L.iushrn(1);
                M(!L.isZero());
                var X = new $(1).toRed(this)
                  , Y = X.redNeg()
                  , j = this.m.subn(1).iushrn(1)
                  , G = this.m.bitLength();
                for (G = new $(2 * G * G).toRed(this); this.pow(G, j).cmp(Y) !== 0; )
                    G.redIAdd(Y);
                for (var ne = this.pow(G, L), te = this.pow(W, L.addn(1).iushrn(1)), ce = this.pow(W, L), Ee = K; ce.cmp(X) !== 0; ) {
                    for (var Re = ce, Te = 0; Re.cmp(X) !== 0; Te++)
                        Re = Re.redSqr();
                    M(Te < Ee);
                    var xe = this.pow(ne, new $(1).iushln(Ee - Te - 1));
                    te = te.redMul(xe),
                    ne = xe.redSqr(),
                    ce = ce.redMul(ne),
                    Ee = Te
                }
                return te
            }
            ,
            Se.prototype.invm = function(W) {
                var D = W._invmp(this.m);
                return D.negative !== 0 ? (D.negative = 0,
                this.imod(D).redNeg()) : this.imod(D)
            }
            ,
            Se.prototype.pow = function(W, D) {
                if (D.isZero())
                    return new $(1).toRed(this);
                if (D.cmpn(1) === 0)
                    return W.clone();
                var I = 4
                  , L = new Array(1 << I);
                L[0] = new $(1).toRed(this),
                L[1] = W;
                for (var K = 2; K < L.length; K++)
                    L[K] = this.mul(L[K - 1], W);
                var X = L[0]
                  , Y = 0
                  , j = 0
                  , G = D.bitLength() % 26;
                for (G === 0 && (G = 26),
                K = D.length - 1; K >= 0; K--) {
                    for (var ne = D.words[K], te = G - 1; te >= 0; te--) {
                        var ce = ne >> te & 1;
                        if (X !== L[0] && (X = this.sqr(X)),
                        ce === 0 && Y === 0) {
                            j = 0;
                            continue
                        }
                        Y <<= 1,
                        Y |= ce,
                        j++,
                        !(j !== I && (K !== 0 || te !== 0)) && (X = this.mul(X, L[Y]),
                        j = 0,
                        Y = 0)
                    }
                    G = 26
                }
                return X
            }
            ,
            Se.prototype.convertTo = function(W) {
                var D = W.umod(this.m);
                return D === W ? D.clone() : D
            }
            ,
            Se.prototype.convertFrom = function(W) {
                var D = W.clone();
                return D.red = null,
                D
            }
            ,
            $.mont = function(W) {
                return new ue(W)
            }
            ;
            function ue(V) {
                Se.call(this, V),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new $(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            T(ue, Se),
            ue.prototype.convertTo = function(W) {
                return this.imod(W.ushln(this.shift))
            }
            ,
            ue.prototype.convertFrom = function(W) {
                var D = this.imod(W.mul(this.rinv));
                return D.red = null,
                D
            }
            ,
            ue.prototype.imul = function(W, D) {
                if (W.isZero() || D.isZero())
                    return W.words[0] = 0,
                    W.length = 1,
                    W;
                var I = W.imul(D)
                  , L = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , K = I.isub(L).iushrn(this.shift)
                  , X = K;
                return K.cmp(this.m) >= 0 ? X = K.isub(this.m) : K.cmpn(0) < 0 && (X = K.iadd(this.m)),
                X._forceRed(this)
            }
            ,
            ue.prototype.mul = function(W, D) {
                if (W.isZero() || D.isZero())
                    return new $(0)._forceRed(this);
                var I = W.mul(D)
                  , L = I.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , K = I.isub(L).iushrn(this.shift)
                  , X = K;
                return K.cmp(this.m) >= 0 ? X = K.isub(this.m) : K.cmpn(0) < 0 && (X = K.iadd(this.m)),
                X._forceRed(this)
            }
            ,
            ue.prototype.invm = function(W) {
                var D = this.imod(W._invmp(this.m).mul(this.r2));
                return D._forceRed(this)
            }
        }
        )(C, commonjsGlobal)
    }(bn$5)),
    bn$5.exports
}
var brorand = {
    exports: {}
}, hasRequiredBrorand;
function requireBrorand() {
    if (hasRequiredBrorand)
        return brorand.exports;
    hasRequiredBrorand = 1;
    var C;
    brorand.exports = function(T) {
        return C || (C = new S(null)),
        C.generate(T)
    }
    ;
    function S(M) {
        this.rand = M
    }
    if (brorand.exports.Rand = S,
    S.prototype.generate = function(T) {
        return this._rand(T)
    }
    ,
    S.prototype._rand = function(T) {
        if (this.rand.getBytes)
            return this.rand.getBytes(T);
        for (var $ = new Uint8Array(T), B = 0; B < $.length; B++)
            $[B] = this.rand.getByte();
        return $
    }
    ,
    typeof self == "object")
        self.crypto && self.crypto.getRandomValues ? S.prototype._rand = function(T) {
            var $ = new Uint8Array(T);
            return self.crypto.getRandomValues($),
            $
        }
        : self.msCrypto && self.msCrypto.getRandomValues ? S.prototype._rand = function(T) {
            var $ = new Uint8Array(T);
            return self.msCrypto.getRandomValues($),
            $
        }
        : typeof window == "object" && (S.prototype._rand = function() {
            throw new Error("Not implemented yet")
        }
        );
    else
        try {
            var E = requireCryptoBrowserify();
            if (typeof E.randomBytes != "function")
                throw new Error("Not supported");
            S.prototype._rand = function(T) {
                return E.randomBytes(T)
            }
        } catch {}
    return brorand.exports
}
var mr, hasRequiredMr;
function requireMr() {
    if (hasRequiredMr)
        return mr;
    hasRequiredMr = 1;
    var C = requireBn$2()
      , S = requireBrorand();
    function E(M) {
        this.rand = M || new S.Rand
    }
    return mr = E,
    E.create = function(T) {
        return new E(T)
    }
    ,
    E.prototype._randbelow = function(T) {
        var $ = T.bitLength()
          , B = Math.ceil($ / 8);
        do
            var O = new C(this.rand.generate(B));
        while (O.cmp(T) >= 0);
        return O
    }
    ,
    E.prototype._randrange = function(T, $) {
        var B = $.sub(T);
        return T.add(this._randbelow(B))
    }
    ,
    E.prototype.test = function(T, $, B) {
        var O = T.bitLength()
          , F = C.mont(T)
          , N = new C(1).toRed(F);
        $ || ($ = Math.max(1, O / 48 | 0));
        for (var U = T.subn(1), H = 0; !U.testn(H); H++)
            ;
        for (var Z = T.shrn(H), J = U.toRed(F), ie = !0; $ > 0; $--) {
            var oe = this._randrange(new C(2), U);
            B && B(oe);
            var ae = oe.toRed(F).redPow(Z);
            if (!(ae.cmp(N) === 0 || ae.cmp(J) === 0)) {
                for (var se = 1; se < H; se++) {
                    if (ae = ae.redSqr(),
                    ae.cmp(N) === 0)
                        return !1;
                    if (ae.cmp(J) === 0)
                        break
                }
                if (se === H)
                    return !1
            }
        }
        return ie
    }
    ,
    E.prototype.getDivisor = function(T, $) {
        var B = T.bitLength()
          , O = C.mont(T)
          , F = new C(1).toRed(O);
        $ || ($ = Math.max(1, B / 48 | 0));
        for (var N = T.subn(1), U = 0; !N.testn(U); U++)
            ;
        for (var H = T.shrn(U), Z = N.toRed(O); $ > 0; $--) {
            var J = this._randrange(new C(2), N)
              , ie = T.gcd(J);
            if (ie.cmpn(1) !== 0)
                return ie;
            var oe = J.toRed(O).redPow(H);
            if (!(oe.cmp(F) === 0 || oe.cmp(Z) === 0)) {
                for (var ae = 1; ae < U; ae++) {
                    if (oe = oe.redSqr(),
                    oe.cmp(F) === 0)
                        return oe.fromRed().subn(1).gcd(T);
                    if (oe.cmp(Z) === 0)
                        break
                }
                if (ae === U)
                    return oe = oe.redSqr(),
                    oe.fromRed().subn(1).gcd(T)
            }
        }
        return !1
    }
    ,
    mr
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
    if (hasRequiredGeneratePrime)
        return generatePrime;
    hasRequiredGeneratePrime = 1;
    var C = requireBrowser$b();
    generatePrime = ae,
    ae.simpleSieve = ie,
    ae.fermatTest = oe;
    var S = requireBn$2()
      , E = new S(24)
      , M = requireMr()
      , T = new M
      , $ = new S(1)
      , B = new S(2)
      , O = new S(5);
    new S(16),
    new S(8);
    var F = new S(10)
      , N = new S(3);
    new S(7);
    var U = new S(11)
      , H = new S(4);
    new S(12);
    var Z = null;
    function J() {
        if (Z !== null)
            return Z;
        var se = 1048576
          , le = [];
        le[0] = 2;
        for (var de = 1, fe = 3; fe < se; fe += 2) {
            for (var pe = Math.ceil(Math.sqrt(fe)), ge = 0; ge < de && le[ge] <= pe && fe % le[ge] !== 0; ge++)
                ;
            de !== ge && le[ge] <= pe || (le[de++] = fe)
        }
        return Z = le,
        le
    }
    function ie(se) {
        for (var le = J(), de = 0; de < le.length; de++)
            if (se.modn(le[de]) === 0)
                return se.cmpn(le[de]) === 0;
        return !0
    }
    function oe(se) {
        var le = S.mont(se);
        return B.toRed(le).redPow(se.subn(1)).fromRed().cmpn(1) === 0
    }
    function ae(se, le) {
        if (se < 16)
            return le === 2 || le === 5 ? new S([140, 123]) : new S([140, 39]);
        le = new S(le);
        for (var de, fe; ; ) {
            for (de = new S(C(Math.ceil(se / 8))); de.bitLength() > se; )
                de.ishrn(1);
            if (de.isEven() && de.iadd($),
            de.testn(1) || de.iadd(B),
            le.cmp(B)) {
                if (!le.cmp(O))
                    for (; de.mod(F).cmp(N); )
                        de.iadd(H)
            } else
                for (; de.mod(E).cmp(U); )
                    de.iadd(H);
            if (fe = de.shrn(1),
            ie(fe) && ie(de) && oe(fe) && oe(de) && T.test(fe) && T.test(de))
                return de
        }
    }
    return generatePrime
}
const modp1 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}
  , modp2 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}
  , modp5 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}
  , modp14 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}
  , modp15 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}
  , modp16 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}
  , modp17 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}
  , modp18 = {
    gen: "02",
    prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}
  , require$$1$6 = {
    modp1,
    modp2,
    modp5,
    modp14,
    modp15,
    modp16,
    modp17,
    modp18
};
var dh, hasRequiredDh;
function requireDh() {
    if (hasRequiredDh)
        return dh;
    hasRequiredDh = 1;
    var C = requireBn$2()
      , S = requireMr()
      , E = new S
      , M = new C(24)
      , T = new C(11)
      , $ = new C(10)
      , B = new C(3)
      , O = new C(7)
      , F = requireGeneratePrime()
      , N = requireBrowser$b();
    dh = ie;
    function U(ae, se) {
        return se = se || "utf8",
        Buffer.isBuffer(ae) || (ae = new Buffer(ae,se)),
        this._pub = new C(ae),
        this
    }
    function H(ae, se) {
        return se = se || "utf8",
        Buffer.isBuffer(ae) || (ae = new Buffer(ae,se)),
        this._priv = new C(ae),
        this
    }
    var Z = {};
    function J(ae, se) {
        var le = se.toString("hex")
          , de = [le, ae.toString(16)].join("_");
        if (de in Z)
            return Z[de];
        var fe = 0;
        if (ae.isEven() || !F.simpleSieve || !F.fermatTest(ae) || !E.test(ae))
            return fe += 1,
            le === "02" || le === "05" ? fe += 8 : fe += 4,
            Z[de] = fe,
            fe;
        E.test(ae.shrn(1)) || (fe += 2);
        var pe;
        switch (le) {
        case "02":
            ae.mod(M).cmp(T) && (fe += 8);
            break;
        case "05":
            pe = ae.mod($),
            pe.cmp(B) && pe.cmp(O) && (fe += 8);
            break;
        default:
            fe += 4
        }
        return Z[de] = fe,
        fe
    }
    function ie(ae, se, le) {
        this.setGenerator(se),
        this.__prime = new C(ae),
        this._prime = C.mont(this.__prime),
        this._primeLen = ae.length,
        this._pub = void 0,
        this._priv = void 0,
        this._primeCode = void 0,
        le ? (this.setPublicKey = U,
        this.setPrivateKey = H) : this._primeCode = 8
    }
    Object.defineProperty(ie.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = J(this.__prime, this.__gen)),
            this._primeCode
        }
    }),
    ie.prototype.generateKeys = function() {
        return this._priv || (this._priv = new C(N(this._primeLen))),
        this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(),
        this.getPublicKey()
    }
    ,
    ie.prototype.computeSecret = function(ae) {
        ae = new C(ae),
        ae = ae.toRed(this._prime);
        var se = ae.redPow(this._priv).fromRed()
          , le = new Buffer(se.toArray())
          , de = this.getPrime();
        if (le.length < de.length) {
            var fe = new Buffer(de.length - le.length);
            fe.fill(0),
            le = Buffer.concat([fe, le])
        }
        return le
    }
    ,
    ie.prototype.getPublicKey = function(se) {
        return oe(this._pub, se)
    }
    ,
    ie.prototype.getPrivateKey = function(se) {
        return oe(this._priv, se)
    }
    ,
    ie.prototype.getPrime = function(ae) {
        return oe(this.__prime, ae)
    }
    ,
    ie.prototype.getGenerator = function(ae) {
        return oe(this._gen, ae)
    }
    ,
    ie.prototype.setGenerator = function(ae, se) {
        return se = se || "utf8",
        Buffer.isBuffer(ae) || (ae = new Buffer(ae,se)),
        this.__gen = ae,
        this._gen = new C(ae),
        this
    }
    ;
    function oe(ae, se) {
        var le = new Buffer(ae.toArray());
        return se ? le.toString(se) : le
    }
    return dh
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
    if (hasRequiredBrowser$4)
        return browser$6;
    hasRequiredBrowser$4 = 1;
    var C = requireGeneratePrime()
      , S = require$$1$6
      , E = requireDh();
    function M(B) {
        var O = new Buffer(S[B].prime,"hex")
          , F = new Buffer(S[B].gen,"hex");
        return new E(O,F)
    }
    var T = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function $(B, O, F, N) {
        return Buffer.isBuffer(O) || T[O] === void 0 ? $(B, "binary", O, F) : (O = O || "binary",
        N = N || "binary",
        F = F || new Buffer([2]),
        Buffer.isBuffer(F) || (F = new Buffer(F,N)),
        typeof B == "number" ? new E(C(B, F),F,!0) : (Buffer.isBuffer(B) || (B = new Buffer(B,O)),
        new E(B,F,!0)))
    }
    return browser$6.DiffieHellmanGroup = browser$6.createDiffieHellmanGroup = browser$6.getDiffieHellman = M,
    browser$6.createDiffieHellman = browser$6.DiffieHellman = $,
    browser$6
}
var readableBrowser = {
    exports: {}
}, processNextickArgs = {
    exports: {}
}, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
    if (hasRequiredProcessNextickArgs)
        return processNextickArgs.exports;
    hasRequiredProcessNextickArgs = 1,
    typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = {
        nextTick: C
    } : processNextickArgs.exports = process$1;
    function C(S, E, M, T) {
        if (typeof S != "function")
            throw new TypeError('"callback" argument must be a function');
        var $ = arguments.length, B, O;
        switch ($) {
        case 0:
        case 1:
            return process$1.nextTick(S);
        case 2:
            return process$1.nextTick(function() {
                S.call(null, E)
            });
        case 3:
            return process$1.nextTick(function() {
                S.call(null, E, M)
            });
        case 4:
            return process$1.nextTick(function() {
                S.call(null, E, M, T)
            });
        default:
            for (B = new Array($ - 1),
            O = 0; O < B.length; )
                B[O++] = arguments[O];
            return process$1.nextTick(function() {
                S.apply(null, B)
            })
        }
    }
    return processNextickArgs.exports
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
    if (hasRequiredIsarray)
        return isarray;
    hasRequiredIsarray = 1;
    var C = {}.toString;
    return isarray = Array.isArray || function(S) {
        return C.call(S) == "[object Array]"
    }
    ,
    isarray
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
    return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1,
    streamBrowser = eventsExports.EventEmitter),
    streamBrowser
}
var safeBuffer = {
    exports: {}
}, hasRequiredSafeBuffer;
function requireSafeBuffer() {
    return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1,
    function(C, S) {
        var E = require$$0$2
          , M = E.Buffer;
        function T(B, O) {
            for (var F in B)
                O[F] = B[F]
        }
        M.from && M.alloc && M.allocUnsafe && M.allocUnsafeSlow ? C.exports = E : (T(E, S),
        S.Buffer = $);
        function $(B, O, F) {
            return M(B, O, F)
        }
        T(M, $),
        $.from = function(B, O, F) {
            if (typeof B == "number")
                throw new TypeError("Argument must not be a number");
            return M(B, O, F)
        }
        ,
        $.alloc = function(B, O, F) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            var N = M(B);
            return O !== void 0 ? typeof F == "string" ? N.fill(O, F) : N.fill(O) : N.fill(0),
            N
        }
        ,
        $.allocUnsafe = function(B) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            return M(B)
        }
        ,
        $.allocUnsafeSlow = function(B) {
            if (typeof B != "number")
                throw new TypeError("Argument must be a number");
            return E.SlowBuffer(B)
        }
    }(safeBuffer, safeBuffer.exports)),
    safeBuffer.exports
}
var util$1 = {}, hasRequiredUtil;
function requireUtil() {
    if (hasRequiredUtil)
        return util$1;
    hasRequiredUtil = 1;
    function C(oe) {
        return Array.isArray ? Array.isArray(oe) : ie(oe) === "[object Array]"
    }
    util$1.isArray = C;
    function S(oe) {
        return typeof oe == "boolean"
    }
    util$1.isBoolean = S;
    function E(oe) {
        return oe === null
    }
    util$1.isNull = E;
    function M(oe) {
        return oe == null
    }
    util$1.isNullOrUndefined = M;
    function T(oe) {
        return typeof oe == "number"
    }
    util$1.isNumber = T;
    function $(oe) {
        return typeof oe == "string"
    }
    util$1.isString = $;
    function B(oe) {
        return typeof oe == "symbol"
    }
    util$1.isSymbol = B;
    function O(oe) {
        return oe === void 0
    }
    util$1.isUndefined = O;
    function F(oe) {
        return ie(oe) === "[object RegExp]"
    }
    util$1.isRegExp = F;
    function N(oe) {
        return typeof oe == "object" && oe !== null
    }
    util$1.isObject = N;
    function U(oe) {
        return ie(oe) === "[object Date]"
    }
    util$1.isDate = U;
    function H(oe) {
        return ie(oe) === "[object Error]" || oe instanceof Error
    }
    util$1.isError = H;
    function Z(oe) {
        return typeof oe == "function"
    }
    util$1.isFunction = Z;
    function J(oe) {
        return oe === null || typeof oe == "boolean" || typeof oe == "number" || typeof oe == "string" || typeof oe == "symbol" || typeof oe > "u"
    }
    util$1.isPrimitive = J,
    util$1.isBuffer = require$$0$2.Buffer.isBuffer;
    function ie(oe) {
        return Object.prototype.toString.call(oe)
    }
    return util$1
}
var BufferList = {
    exports: {}
}, hasRequiredBufferList;
function requireBufferList() {
    return hasRequiredBufferList || (hasRequiredBufferList = 1,
    function(C) {
        function S($, B) {
            if (!($ instanceof B))
                throw new TypeError("Cannot call a class as a function")
        }
        var E = requireSafeBuffer().Buffer
          , M = requireUtil$1();
        function T($, B, O) {
            $.copy(B, O)
        }
        C.exports = function() {
            function $() {
                S(this, $),
                this.head = null,
                this.tail = null,
                this.length = 0
            }
            return $.prototype.push = function(O) {
                var F = {
                    data: O,
                    next: null
                };
                this.length > 0 ? this.tail.next = F : this.head = F,
                this.tail = F,
                ++this.length
            }
            ,
            $.prototype.unshift = function(O) {
                var F = {
                    data: O,
                    next: this.head
                };
                this.length === 0 && (this.tail = F),
                this.head = F,
                ++this.length
            }
            ,
            $.prototype.shift = function() {
                if (this.length !== 0) {
                    var O = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
                    --this.length,
                    O
                }
            }
            ,
            $.prototype.clear = function() {
                this.head = this.tail = null,
                this.length = 0
            }
            ,
            $.prototype.join = function(O) {
                if (this.length === 0)
                    return "";
                for (var F = this.head, N = "" + F.data; F = F.next; )
                    N += O + F.data;
                return N
            }
            ,
            $.prototype.concat = function(O) {
                if (this.length === 0)
                    return E.alloc(0);
                for (var F = E.allocUnsafe(O >>> 0), N = this.head, U = 0; N; )
                    T(N.data, F, U),
                    U += N.data.length,
                    N = N.next;
                return F
            }
            ,
            $
        }(),
        M && M.inspect && M.inspect.custom && (C.exports.prototype[M.inspect.custom] = function() {
            var $ = M.inspect({
                length: this.length
            });
            return this.constructor.name + " " + $
        }
        )
    }(BufferList)),
    BufferList.exports
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
    if (hasRequiredDestroy)
        return destroy_1;
    hasRequiredDestroy = 1;
    var C = requireProcessNextickArgs();
    function S(T, $) {
        var B = this
          , O = this._readableState && this._readableState.destroyed
          , F = this._writableState && this._writableState.destroyed;
        return O || F ? ($ ? $(T) : T && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
        C.nextTick(M, this, T)) : C.nextTick(M, this, T)),
        this) : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(T || null, function(N) {
            !$ && N ? B._writableState ? B._writableState.errorEmitted || (B._writableState.errorEmitted = !0,
            C.nextTick(M, B, N)) : C.nextTick(M, B, N) : $ && $(N)
        }),
        this)
    }
    function E() {
        this._readableState && (this._readableState.destroyed = !1,
        this._readableState.reading = !1,
        this._readableState.ended = !1,
        this._readableState.endEmitted = !1),
        this._writableState && (this._writableState.destroyed = !1,
        this._writableState.ended = !1,
        this._writableState.ending = !1,
        this._writableState.finalCalled = !1,
        this._writableState.prefinished = !1,
        this._writableState.finished = !1,
        this._writableState.errorEmitted = !1)
    }
    function M(T, $) {
        T.emit("error", $)
    }
    return destroy_1 = {
        destroy: S,
        undestroy: E
    },
    destroy_1
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
    if (hasRequired_stream_writable)
        return _stream_writable;
    hasRequired_stream_writable = 1;
    var C = requireProcessNextickArgs();
    _stream_writable = oe;
    function S(X) {
        var Y = this;
        this.next = null,
        this.entry = null,
        this.finish = function() {
            K(Y, X)
        }
    }
    var E = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : C.nextTick, M;
    oe.WritableState = J;
    var T = Object.create(requireUtil());
    T.inherits = requireInherits_browser();
    var $ = {
        deprecate: requireBrowser$a()
    }
      , B = requireStreamBrowser()
      , O = requireSafeBuffer().Buffer
      , F = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function N(X) {
        return O.from(X)
    }
    function U(X) {
        return O.isBuffer(X) || X instanceof F
    }
    var H = requireDestroy();
    T.inherits(oe, B);
    function Z() {}
    function J(X, Y) {
        M = M || require_stream_duplex(),
        X = X || {};
        var j = Y instanceof M;
        this.objectMode = !!X.objectMode,
        j && (this.objectMode = this.objectMode || !!X.writableObjectMode);
        var G = X.highWaterMark
          , ne = X.writableHighWaterMark
          , te = this.objectMode ? 16 : 16 * 1024;
        G || G === 0 ? this.highWaterMark = G : j && (ne || ne === 0) ? this.highWaterMark = ne : this.highWaterMark = te,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        var ce = X.decodeStrings === !1;
        this.decodeStrings = !ce,
        this.defaultEncoding = X.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function(Ee) {
            we(Y, Ee)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new S(this)
    }
    J.prototype.getBuffer = function() {
        for (var Y = this.bufferedRequest, j = []; Y; )
            j.push(Y),
            Y = Y.next;
        return j
    }
    ,
    function() {
        try {
            Object.defineProperty(J.prototype, "buffer", {
                get: $.deprecate(function() {
                    return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            })
        } catch {}
    }();
    var ie;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ie = Function.prototype[Symbol.hasInstance],
    Object.defineProperty(oe, Symbol.hasInstance, {
        value: function(X) {
            return ie.call(this, X) ? !0 : this !== oe ? !1 : X && X._writableState instanceof J
        }
    })) : ie = function(X) {
        return X instanceof this
    }
    ;
    function oe(X) {
        if (M = M || require_stream_duplex(),
        !ie.call(oe, this) && !(this instanceof M))
            return new oe(X);
        this._writableState = new J(X,this),
        this.writable = !0,
        X && (typeof X.write == "function" && (this._write = X.write),
        typeof X.writev == "function" && (this._writev = X.writev),
        typeof X.destroy == "function" && (this._destroy = X.destroy),
        typeof X.final == "function" && (this._final = X.final)),
        B.call(this)
    }
    oe.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"))
    }
    ;
    function ae(X, Y) {
        var j = new Error("write after end");
        X.emit("error", j),
        C.nextTick(Y, j)
    }
    function se(X, Y, j, G) {
        var ne = !0
          , te = !1;
        return j === null ? te = new TypeError("May not write null values to stream") : typeof j != "string" && j !== void 0 && !Y.objectMode && (te = new TypeError("Invalid non-string/buffer chunk")),
        te && (X.emit("error", te),
        C.nextTick(G, te),
        ne = !1),
        ne
    }
    oe.prototype.write = function(X, Y, j) {
        var G = this._writableState
          , ne = !1
          , te = !G.objectMode && U(X);
        return te && !O.isBuffer(X) && (X = N(X)),
        typeof Y == "function" && (j = Y,
        Y = null),
        te ? Y = "buffer" : Y || (Y = G.defaultEncoding),
        typeof j != "function" && (j = Z),
        G.ended ? ae(this, j) : (te || se(this, G, X, j)) && (G.pendingcb++,
        ne = de(this, G, te, X, Y, j)),
        ne
    }
    ,
    oe.prototype.cork = function() {
        var X = this._writableState;
        X.corked++
    }
    ,
    oe.prototype.uncork = function() {
        var X = this._writableState;
        X.corked && (X.corked--,
        !X.writing && !X.corked && !X.bufferProcessing && X.bufferedRequest && ue(this, X))
    }
    ,
    oe.prototype.setDefaultEncoding = function(Y) {
        if (typeof Y == "string" && (Y = Y.toLowerCase()),
        !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Y + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + Y);
        return this._writableState.defaultEncoding = Y,
        this
    }
    ;
    function le(X, Y, j) {
        return !X.objectMode && X.decodeStrings !== !1 && typeof Y == "string" && (Y = O.from(Y, j)),
        Y
    }
    Object.defineProperty(oe.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function de(X, Y, j, G, ne, te) {
        if (!j) {
            var ce = le(Y, G, ne);
            G !== ce && (j = !0,
            ne = "buffer",
            G = ce)
        }
        var Ee = Y.objectMode ? 1 : G.length;
        Y.length += Ee;
        var Re = Y.length < Y.highWaterMark;
        if (Re || (Y.needDrain = !0),
        Y.writing || Y.corked) {
            var Te = Y.lastBufferedRequest;
            Y.lastBufferedRequest = {
                chunk: G,
                encoding: ne,
                isBuf: j,
                callback: te,
                next: null
            },
            Te ? Te.next = Y.lastBufferedRequest : Y.bufferedRequest = Y.lastBufferedRequest,
            Y.bufferedRequestCount += 1
        } else
            fe(X, Y, !1, Ee, G, ne, te);
        return Re
    }
    function fe(X, Y, j, G, ne, te, ce) {
        Y.writelen = G,
        Y.writecb = ce,
        Y.writing = !0,
        Y.sync = !0,
        j ? X._writev(ne, Y.onwrite) : X._write(ne, te, Y.onwrite),
        Y.sync = !1
    }
    function pe(X, Y, j, G, ne) {
        --Y.pendingcb,
        j ? (C.nextTick(ne, G),
        C.nextTick(I, X, Y),
        X._writableState.errorEmitted = !0,
        X.emit("error", G)) : (ne(G),
        X._writableState.errorEmitted = !0,
        X.emit("error", G),
        I(X, Y))
    }
    function ge(X) {
        X.writing = !1,
        X.writecb = null,
        X.length -= X.writelen,
        X.writelen = 0
    }
    function we(X, Y) {
        var j = X._writableState
          , G = j.sync
          , ne = j.writecb;
        if (ge(j),
        Y)
            pe(X, j, G, Y, ne);
        else {
            var te = V(j);
            !te && !j.corked && !j.bufferProcessing && j.bufferedRequest && ue(X, j),
            G ? E(Ae, X, j, te, ne) : Ae(X, j, te, ne)
        }
    }
    function Ae(X, Y, j, G) {
        j || Se(X, Y),
        Y.pendingcb--,
        G(),
        I(X, Y)
    }
    function Se(X, Y) {
        Y.length === 0 && Y.needDrain && (Y.needDrain = !1,
        X.emit("drain"))
    }
    function ue(X, Y) {
        Y.bufferProcessing = !0;
        var j = Y.bufferedRequest;
        if (X._writev && j && j.next) {
            var G = Y.bufferedRequestCount
              , ne = new Array(G)
              , te = Y.corkedRequestsFree;
            te.entry = j;
            for (var ce = 0, Ee = !0; j; )
                ne[ce] = j,
                j.isBuf || (Ee = !1),
                j = j.next,
                ce += 1;
            ne.allBuffers = Ee,
            fe(X, Y, !0, Y.length, ne, "", te.finish),
            Y.pendingcb++,
            Y.lastBufferedRequest = null,
            te.next ? (Y.corkedRequestsFree = te.next,
            te.next = null) : Y.corkedRequestsFree = new S(Y),
            Y.bufferedRequestCount = 0
        } else {
            for (; j; ) {
                var Re = j.chunk
                  , Te = j.encoding
                  , xe = j.callback
                  , ve = Y.objectMode ? 1 : Re.length;
                if (fe(X, Y, !1, ve, Re, Te, xe),
                j = j.next,
                Y.bufferedRequestCount--,
                Y.writing)
                    break
            }
            j === null && (Y.lastBufferedRequest = null)
        }
        Y.bufferedRequest = j,
        Y.bufferProcessing = !1
    }
    oe.prototype._write = function(X, Y, j) {
        j(new Error("_write() is not implemented"))
    }
    ,
    oe.prototype._writev = null,
    oe.prototype.end = function(X, Y, j) {
        var G = this._writableState;
        typeof X == "function" ? (j = X,
        X = null,
        Y = null) : typeof Y == "function" && (j = Y,
        Y = null),
        X != null && this.write(X, Y),
        G.corked && (G.corked = 1,
        this.uncork()),
        G.ending || L(this, G, j)
    }
    ;
    function V(X) {
        return X.ending && X.length === 0 && X.bufferedRequest === null && !X.finished && !X.writing
    }
    function W(X, Y) {
        X._final(function(j) {
            Y.pendingcb--,
            j && X.emit("error", j),
            Y.prefinished = !0,
            X.emit("prefinish"),
            I(X, Y)
        })
    }
    function D(X, Y) {
        !Y.prefinished && !Y.finalCalled && (typeof X._final == "function" ? (Y.pendingcb++,
        Y.finalCalled = !0,
        C.nextTick(W, X, Y)) : (Y.prefinished = !0,
        X.emit("prefinish")))
    }
    function I(X, Y) {
        var j = V(Y);
        return j && (D(X, Y),
        Y.pendingcb === 0 && (Y.finished = !0,
        X.emit("finish"))),
        j
    }
    function L(X, Y, j) {
        Y.ending = !0,
        I(X, Y),
        j && (Y.finished ? C.nextTick(j) : X.once("finish", j)),
        Y.ended = !0,
        X.writable = !1
    }
    function K(X, Y, j) {
        var G = X.entry;
        for (X.entry = null; G; ) {
            var ne = G.callback;
            Y.pendingcb--,
            ne(j),
            G = G.next
        }
        Y.corkedRequestsFree.next = X
    }
    return Object.defineProperty(oe.prototype, "destroyed", {
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(X) {
            this._writableState && (this._writableState.destroyed = X)
        }
    }),
    oe.prototype.destroy = H.destroy,
    oe.prototype._undestroy = H.undestroy,
    oe.prototype._destroy = function(X, Y) {
        this.end(),
        Y(X)
    }
    ,
    _stream_writable
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
    if (hasRequired_stream_duplex)
        return _stream_duplex;
    hasRequired_stream_duplex = 1;
    var C = requireProcessNextickArgs()
      , S = Object.keys || function(H) {
        var Z = [];
        for (var J in H)
            Z.push(J);
        return Z
    }
    ;
    _stream_duplex = F;
    var E = Object.create(requireUtil());
    E.inherits = requireInherits_browser();
    var M = require_stream_readable()
      , T = require_stream_writable();
    E.inherits(F, M);
    for (var $ = S(T.prototype), B = 0; B < $.length; B++) {
        var O = $[B];
        F.prototype[O] || (F.prototype[O] = T.prototype[O])
    }
    function F(H) {
        if (!(this instanceof F))
            return new F(H);
        M.call(this, H),
        T.call(this, H),
        H && H.readable === !1 && (this.readable = !1),
        H && H.writable === !1 && (this.writable = !1),
        this.allowHalfOpen = !0,
        H && H.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
        this.once("end", N)
    }
    Object.defineProperty(F.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });
    function N() {
        this.allowHalfOpen || this._writableState.ended || C.nextTick(U, this)
    }
    function U(H) {
        H.end()
    }
    return Object.defineProperty(F.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(H) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = H,
            this._writableState.destroyed = H)
        }
    }),
    F.prototype._destroy = function(H, Z) {
        this.push(null),
        this.end(),
        C.nextTick(Z, H)
    }
    ,
    _stream_duplex
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
    if (hasRequired_stream_readable)
        return _stream_readable;
    hasRequired_stream_readable = 1;
    var C = requireProcessNextickArgs();
    _stream_readable = le;
    var S = requireIsarray(), E;
    le.ReadableState = se,
    eventsExports.EventEmitter;
    var M = function(xe, ve) {
        return xe.listeners(ve).length
    }
      , T = requireStreamBrowser()
      , $ = requireSafeBuffer().Buffer
      , B = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {}
    ;
    function O(xe) {
        return $.from(xe)
    }
    function F(xe) {
        return $.isBuffer(xe) || xe instanceof B
    }
    var N = Object.create(requireUtil());
    N.inherits = requireInherits_browser();
    var U = requireUtil$1()
      , H = void 0;
    U && U.debuglog ? H = U.debuglog("stream") : H = function() {}
    ;
    var Z = requireBufferList(), J = requireDestroy(), ie;
    N.inherits(le, T);
    var oe = ["error", "close", "destroy", "pause", "resume"];
    function ae(xe, ve, Me) {
        if (typeof xe.prependListener == "function")
            return xe.prependListener(ve, Me);
        !xe._events || !xe._events[ve] ? xe.on(ve, Me) : S(xe._events[ve]) ? xe._events[ve].unshift(Me) : xe._events[ve] = [Me, xe._events[ve]]
    }
    function se(xe, ve) {
        E = E || require_stream_duplex(),
        xe = xe || {};
        var Me = ve instanceof E;
        this.objectMode = !!xe.objectMode,
        Me && (this.objectMode = this.objectMode || !!xe.readableObjectMode);
        var Fe = xe.highWaterMark
          , be = xe.readableHighWaterMark
          , Ce = this.objectMode ? 16 : 16 * 1024;
        Fe || Fe === 0 ? this.highWaterMark = Fe : Me && (be || be === 0) ? this.highWaterMark = be : this.highWaterMark = Ce,
        this.highWaterMark = Math.floor(this.highWaterMark),
        this.buffer = new Z,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.destroyed = !1,
        this.defaultEncoding = xe.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        xe.encoding && (ie || (ie = requireString_decoder().StringDecoder),
        this.decoder = new ie(xe.encoding),
        this.encoding = xe.encoding)
    }
    function le(xe) {
        if (E = E || require_stream_duplex(),
        !(this instanceof le))
            return new le(xe);
        this._readableState = new se(xe,this),
        this.readable = !0,
        xe && (typeof xe.read == "function" && (this._read = xe.read),
        typeof xe.destroy == "function" && (this._destroy = xe.destroy)),
        T.call(this)
    }
    Object.defineProperty(le.prototype, "destroyed", {
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(xe) {
            this._readableState && (this._readableState.destroyed = xe)
        }
    }),
    le.prototype.destroy = J.destroy,
    le.prototype._undestroy = J.undestroy,
    le.prototype._destroy = function(xe, ve) {
        this.push(null),
        ve(xe)
    }
    ,
    le.prototype.push = function(xe, ve) {
        var Me = this._readableState, Fe;
        return Me.objectMode ? Fe = !0 : typeof xe == "string" && (ve = ve || Me.defaultEncoding,
        ve !== Me.encoding && (xe = $.from(xe, ve),
        ve = ""),
        Fe = !0),
        de(this, xe, ve, !1, Fe)
    }
    ,
    le.prototype.unshift = function(xe) {
        return de(this, xe, null, !0, !1)
    }
    ;
    function de(xe, ve, Me, Fe, be) {
        var Ce = xe._readableState;
        if (ve === null)
            Ce.reading = !1,
            ue(xe, Ce);
        else {
            var ze;
            be || (ze = pe(Ce, ve)),
            ze ? xe.emit("error", ze) : Ce.objectMode || ve && ve.length > 0 ? (typeof ve != "string" && !Ce.objectMode && Object.getPrototypeOf(ve) !== $.prototype && (ve = O(ve)),
            Fe ? Ce.endEmitted ? xe.emit("error", new Error("stream.unshift() after end event")) : fe(xe, Ce, ve, !0) : Ce.ended ? xe.emit("error", new Error("stream.push() after EOF")) : (Ce.reading = !1,
            Ce.decoder && !Me ? (ve = Ce.decoder.write(ve),
            Ce.objectMode || ve.length !== 0 ? fe(xe, Ce, ve, !1) : D(xe, Ce)) : fe(xe, Ce, ve, !1))) : Fe || (Ce.reading = !1)
        }
        return ge(Ce)
    }
    function fe(xe, ve, Me, Fe) {
        ve.flowing && ve.length === 0 && !ve.sync ? (xe.emit("data", Me),
        xe.read(0)) : (ve.length += ve.objectMode ? 1 : Me.length,
        Fe ? ve.buffer.unshift(Me) : ve.buffer.push(Me),
        ve.needReadable && V(xe)),
        D(xe, ve)
    }
    function pe(xe, ve) {
        var Me;
        return !F(ve) && typeof ve != "string" && ve !== void 0 && !xe.objectMode && (Me = new TypeError("Invalid non-string/buffer chunk")),
        Me
    }
    function ge(xe) {
        return !xe.ended && (xe.needReadable || xe.length < xe.highWaterMark || xe.length === 0)
    }
    le.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }
    ,
    le.prototype.setEncoding = function(xe) {
        return ie || (ie = requireString_decoder().StringDecoder),
        this._readableState.decoder = new ie(xe),
        this._readableState.encoding = xe,
        this
    }
    ;
    var we = 8388608;
    function Ae(xe) {
        return xe >= we ? xe = we : (xe--,
        xe |= xe >>> 1,
        xe |= xe >>> 2,
        xe |= xe >>> 4,
        xe |= xe >>> 8,
        xe |= xe >>> 16,
        xe++),
        xe
    }
    function Se(xe, ve) {
        return xe <= 0 || ve.length === 0 && ve.ended ? 0 : ve.objectMode ? 1 : xe !== xe ? ve.flowing && ve.length ? ve.buffer.head.data.length : ve.length : (xe > ve.highWaterMark && (ve.highWaterMark = Ae(xe)),
        xe <= ve.length ? xe : ve.ended ? ve.length : (ve.needReadable = !0,
        0))
    }
    le.prototype.read = function(xe) {
        H("read", xe),
        xe = parseInt(xe, 10);
        var ve = this._readableState
          , Me = xe;
        if (xe !== 0 && (ve.emittedReadable = !1),
        xe === 0 && ve.needReadable && (ve.length >= ve.highWaterMark || ve.ended))
            return H("read: emitReadable", ve.length, ve.ended),
            ve.length === 0 && ve.ended ? Ee(this) : V(this),
            null;
        if (xe = Se(xe, ve),
        xe === 0 && ve.ended)
            return ve.length === 0 && Ee(this),
            null;
        var Fe = ve.needReadable;
        H("need readable", Fe),
        (ve.length === 0 || ve.length - xe < ve.highWaterMark) && (Fe = !0,
        H("length less than watermark", Fe)),
        ve.ended || ve.reading ? (Fe = !1,
        H("reading or ended", Fe)) : Fe && (H("do read"),
        ve.reading = !0,
        ve.sync = !0,
        ve.length === 0 && (ve.needReadable = !0),
        this._read(ve.highWaterMark),
        ve.sync = !1,
        ve.reading || (xe = Se(Me, ve)));
        var be;
        return xe > 0 ? be = G(xe, ve) : be = null,
        be === null ? (ve.needReadable = !0,
        xe = 0) : ve.length -= xe,
        ve.length === 0 && (ve.ended || (ve.needReadable = !0),
        Me !== xe && ve.ended && Ee(this)),
        be !== null && this.emit("data", be),
        be
    }
    ;
    function ue(xe, ve) {
        if (!ve.ended) {
            if (ve.decoder) {
                var Me = ve.decoder.end();
                Me && Me.length && (ve.buffer.push(Me),
                ve.length += ve.objectMode ? 1 : Me.length)
            }
            ve.ended = !0,
            V(xe)
        }
    }
    function V(xe) {
        var ve = xe._readableState;
        ve.needReadable = !1,
        ve.emittedReadable || (H("emitReadable", ve.flowing),
        ve.emittedReadable = !0,
        ve.sync ? C.nextTick(W, xe) : W(xe))
    }
    function W(xe) {
        H("emit readable"),
        xe.emit("readable"),
        j(xe)
    }
    function D(xe, ve) {
        ve.readingMore || (ve.readingMore = !0,
        C.nextTick(I, xe, ve))
    }
    function I(xe, ve) {
        for (var Me = ve.length; !ve.reading && !ve.flowing && !ve.ended && ve.length < ve.highWaterMark && (H("maybeReadMore read 0"),
        xe.read(0),
        Me !== ve.length); )
            Me = ve.length;
        ve.readingMore = !1
    }
    le.prototype._read = function(xe) {
        this.emit("error", new Error("_read() is not implemented"))
    }
    ,
    le.prototype.pipe = function(xe, ve) {
        var Me = this
          , Fe = this._readableState;
        switch (Fe.pipesCount) {
        case 0:
            Fe.pipes = xe;
            break;
        case 1:
            Fe.pipes = [Fe.pipes, xe];
            break;
        default:
            Fe.pipes.push(xe);
            break
        }
        Fe.pipesCount += 1,
        H("pipe count=%d opts=%j", Fe.pipesCount, ve);
        var be = (!ve || ve.end !== !1) && xe !== process$1.stdout && xe !== process$1.stderr
          , Ce = be ? Ge : Je;
        Fe.endEmitted ? C.nextTick(Ce) : Me.once("end", Ce),
        xe.on("unpipe", ze);
        function ze(ot, je) {
            H("onunpipe"),
            ot === Me && je && je.hasUnpiped === !1 && (je.hasUnpiped = !0,
            ct())
        }
        function Ge() {
            H("onend"),
            xe.end()
        }
        var nt = L(Me);
        xe.on("drain", nt);
        var bt = !1;
        function ct() {
            H("cleanup"),
            xe.removeListener("close", Xe),
            xe.removeListener("finish", ht),
            xe.removeListener("drain", nt),
            xe.removeListener("error", We),
            xe.removeListener("unpipe", ze),
            Me.removeListener("end", Ge),
            Me.removeListener("end", Je),
            Me.removeListener("data", Ue),
            bt = !0,
            Fe.awaitDrain && (!xe._writableState || xe._writableState.needDrain) && nt()
        }
        var De = !1;
        Me.on("data", Ue);
        function Ue(ot) {
            H("ondata"),
            De = !1;
            var je = xe.write(ot);
            je === !1 && !De && ((Fe.pipesCount === 1 && Fe.pipes === xe || Fe.pipesCount > 1 && Te(Fe.pipes, xe) !== -1) && !bt && (H("false write response, pause", Fe.awaitDrain),
            Fe.awaitDrain++,
            De = !0),
            Me.pause())
        }
        function We(ot) {
            H("onerror", ot),
            Je(),
            xe.removeListener("error", We),
            M(xe, "error") === 0 && xe.emit("error", ot)
        }
        ae(xe, "error", We);
        function Xe() {
            xe.removeListener("finish", ht),
            Je()
        }
        xe.once("close", Xe);
        function ht() {
            H("onfinish"),
            xe.removeListener("close", Xe),
            Je()
        }
        xe.once("finish", ht);
        function Je() {
            H("unpipe"),
            Me.unpipe(xe)
        }
        return xe.emit("pipe", Me),
        Fe.flowing || (H("pipe resume"),
        Me.resume()),
        xe
    }
    ;
    function L(xe) {
        return function() {
            var ve = xe._readableState;
            H("pipeOnDrain", ve.awaitDrain),
            ve.awaitDrain && ve.awaitDrain--,
            ve.awaitDrain === 0 && M(xe, "data") && (ve.flowing = !0,
            j(xe))
        }
    }
    le.prototype.unpipe = function(xe) {
        var ve = this._readableState
          , Me = {
            hasUnpiped: !1
        };
        if (ve.pipesCount === 0)
            return this;
        if (ve.pipesCount === 1)
            return xe && xe !== ve.pipes ? this : (xe || (xe = ve.pipes),
            ve.pipes = null,
            ve.pipesCount = 0,
            ve.flowing = !1,
            xe && xe.emit("unpipe", this, Me),
            this);
        if (!xe) {
            var Fe = ve.pipes
              , be = ve.pipesCount;
            ve.pipes = null,
            ve.pipesCount = 0,
            ve.flowing = !1;
            for (var Ce = 0; Ce < be; Ce++)
                Fe[Ce].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        var ze = Te(ve.pipes, xe);
        return ze === -1 ? this : (ve.pipes.splice(ze, 1),
        ve.pipesCount -= 1,
        ve.pipesCount === 1 && (ve.pipes = ve.pipes[0]),
        xe.emit("unpipe", this, Me),
        this)
    }
    ,
    le.prototype.on = function(xe, ve) {
        var Me = T.prototype.on.call(this, xe, ve);
        if (xe === "data")
            this._readableState.flowing !== !1 && this.resume();
        else if (xe === "readable") {
            var Fe = this._readableState;
            !Fe.endEmitted && !Fe.readableListening && (Fe.readableListening = Fe.needReadable = !0,
            Fe.emittedReadable = !1,
            Fe.reading ? Fe.length && V(this) : C.nextTick(K, this))
        }
        return Me
    }
    ,
    le.prototype.addListener = le.prototype.on;
    function K(xe) {
        H("readable nexttick read 0"),
        xe.read(0)
    }
    le.prototype.resume = function() {
        var xe = this._readableState;
        return xe.flowing || (H("resume"),
        xe.flowing = !0,
        X(this, xe)),
        this
    }
    ;
    function X(xe, ve) {
        ve.resumeScheduled || (ve.resumeScheduled = !0,
        C.nextTick(Y, xe, ve))
    }
    function Y(xe, ve) {
        ve.reading || (H("resume read 0"),
        xe.read(0)),
        ve.resumeScheduled = !1,
        ve.awaitDrain = 0,
        xe.emit("resume"),
        j(xe),
        ve.flowing && !ve.reading && xe.read(0)
    }
    le.prototype.pause = function() {
        return H("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (H("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this
    }
    ;
    function j(xe) {
        var ve = xe._readableState;
        for (H("flow", ve.flowing); ve.flowing && xe.read() !== null; )
            ;
    }
    le.prototype.wrap = function(xe) {
        var ve = this
          , Me = this._readableState
          , Fe = !1;
        xe.on("end", function() {
            if (H("wrapped end"),
            Me.decoder && !Me.ended) {
                var ze = Me.decoder.end();
                ze && ze.length && ve.push(ze)
            }
            ve.push(null)
        }),
        xe.on("data", function(ze) {
            if (H("wrapped data"),
            Me.decoder && (ze = Me.decoder.write(ze)),
            !(Me.objectMode && ze == null) && !(!Me.objectMode && (!ze || !ze.length))) {
                var Ge = ve.push(ze);
                Ge || (Fe = !0,
                xe.pause())
            }
        });
        for (var be in xe)
            this[be] === void 0 && typeof xe[be] == "function" && (this[be] = function(ze) {
                return function() {
                    return xe[ze].apply(xe, arguments)
                }
            }(be));
        for (var Ce = 0; Ce < oe.length; Ce++)
            xe.on(oe[Ce], this.emit.bind(this, oe[Ce]));
        return this._read = function(ze) {
            H("wrapped _read", ze),
            Fe && (Fe = !1,
            xe.resume())
        }
        ,
        this
    }
    ,
    Object.defineProperty(le.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }),
    le._fromList = G;
    function G(xe, ve) {
        if (ve.length === 0)
            return null;
        var Me;
        return ve.objectMode ? Me = ve.buffer.shift() : !xe || xe >= ve.length ? (ve.decoder ? Me = ve.buffer.join("") : ve.buffer.length === 1 ? Me = ve.buffer.head.data : Me = ve.buffer.concat(ve.length),
        ve.buffer.clear()) : Me = ne(xe, ve.buffer, ve.decoder),
        Me
    }
    function ne(xe, ve, Me) {
        var Fe;
        return xe < ve.head.data.length ? (Fe = ve.head.data.slice(0, xe),
        ve.head.data = ve.head.data.slice(xe)) : xe === ve.head.data.length ? Fe = ve.shift() : Fe = Me ? te(xe, ve) : ce(xe, ve),
        Fe
    }
    function te(xe, ve) {
        var Me = ve.head
          , Fe = 1
          , be = Me.data;
        for (xe -= be.length; Me = Me.next; ) {
            var Ce = Me.data
              , ze = xe > Ce.length ? Ce.length : xe;
            if (ze === Ce.length ? be += Ce : be += Ce.slice(0, xe),
            xe -= ze,
            xe === 0) {
                ze === Ce.length ? (++Fe,
                Me.next ? ve.head = Me.next : ve.head = ve.tail = null) : (ve.head = Me,
                Me.data = Ce.slice(ze));
                break
            }
            ++Fe
        }
        return ve.length -= Fe,
        be
    }
    function ce(xe, ve) {
        var Me = $.allocUnsafe(xe)
          , Fe = ve.head
          , be = 1;
        for (Fe.data.copy(Me),
        xe -= Fe.data.length; Fe = Fe.next; ) {
            var Ce = Fe.data
              , ze = xe > Ce.length ? Ce.length : xe;
            if (Ce.copy(Me, Me.length - xe, 0, ze),
            xe -= ze,
            xe === 0) {
                ze === Ce.length ? (++be,
                Fe.next ? ve.head = Fe.next : ve.head = ve.tail = null) : (ve.head = Fe,
                Fe.data = Ce.slice(ze));
                break
            }
            ++be
        }
        return ve.length -= be,
        Me
    }
    function Ee(xe) {
        var ve = xe._readableState;
        if (ve.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
        ve.endEmitted || (ve.ended = !0,
        C.nextTick(Re, ve, xe))
    }
    function Re(xe, ve) {
        !xe.endEmitted && xe.length === 0 && (xe.endEmitted = !0,
        ve.readable = !1,
        ve.emit("end"))
    }
    function Te(xe, ve) {
        for (var Me = 0, Fe = xe.length; Me < Fe; Me++)
            if (xe[Me] === ve)
                return Me;
        return -1
    }
    return _stream_readable
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
    if (hasRequired_stream_transform)
        return _stream_transform;
    hasRequired_stream_transform = 1,
    _stream_transform = M;
    var C = require_stream_duplex()
      , S = Object.create(requireUtil());
    S.inherits = requireInherits_browser(),
    S.inherits(M, C);
    function E(B, O) {
        var F = this._transformState;
        F.transforming = !1;
        var N = F.writecb;
        if (!N)
            return this.emit("error", new Error("write callback called multiple times"));
        F.writechunk = null,
        F.writecb = null,
        O != null && this.push(O),
        N(B);
        var U = this._readableState;
        U.reading = !1,
        (U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark)
    }
    function M(B) {
        if (!(this instanceof M))
            return new M(B);
        C.call(this, B),
        this._transformState = {
            afterTransform: E.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        B && (typeof B.transform == "function" && (this._transform = B.transform),
        typeof B.flush == "function" && (this._flush = B.flush)),
        this.on("prefinish", T)
    }
    function T() {
        var B = this;
        typeof this._flush == "function" ? this._flush(function(O, F) {
            $(B, O, F)
        }) : $(this, null, null)
    }
    M.prototype.push = function(B, O) {
        return this._transformState.needTransform = !1,
        C.prototype.push.call(this, B, O)
    }
    ,
    M.prototype._transform = function(B, O, F) {
        throw new Error("_transform() is not implemented")
    }
    ,
    M.prototype._write = function(B, O, F) {
        var N = this._transformState;
        if (N.writecb = F,
        N.writechunk = B,
        N.writeencoding = O,
        !N.transforming) {
            var U = this._readableState;
            (N.needTransform || U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark)
        }
    }
    ,
    M.prototype._read = function(B) {
        var O = this._transformState;
        O.writechunk !== null && O.writecb && !O.transforming ? (O.transforming = !0,
        this._transform(O.writechunk, O.writeencoding, O.afterTransform)) : O.needTransform = !0
    }
    ,
    M.prototype._destroy = function(B, O) {
        var F = this;
        C.prototype._destroy.call(this, B, function(N) {
            O(N),
            F.emit("close")
        })
    }
    ;
    function $(B, O, F) {
        if (O)
            return B.emit("error", O);
        if (F != null && B.push(F),
        B._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
        if (B._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
        return B.push(null)
    }
    return _stream_transform
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
    if (hasRequired_stream_passthrough)
        return _stream_passthrough;
    hasRequired_stream_passthrough = 1,
    _stream_passthrough = E;
    var C = require_stream_transform()
      , S = Object.create(requireUtil());
    S.inherits = requireInherits_browser(),
    S.inherits(E, C);
    function E(M) {
        if (!(this instanceof E))
            return new E(M);
        C.call(this, M)
    }
    return E.prototype._transform = function(M, T, $) {
        $(null, M)
    }
    ,
    _stream_passthrough
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
    return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1,
    function(C, S) {
        S = C.exports = require_stream_readable(),
        S.Stream = S,
        S.Readable = S,
        S.Writable = require_stream_writable(),
        S.Duplex = require_stream_duplex(),
        S.Transform = require_stream_transform(),
        S.PassThrough = require_stream_passthrough()
    }(readableBrowser, readableBrowser.exports)),
    readableBrowser.exports
}
var sign$1 = {
    exports: {}
}
  , bn$4 = {
    exports: {}
};
bn$4.exports;
var hasRequiredBn$1;
function requireBn$1() {
    return hasRequiredBn$1 || (hasRequiredBn$1 = 1,
    function(C) {
        (function(S, E) {
            function M(D, I) {
                if (!D)
                    throw new Error(I || "Assertion failed")
            }
            function T(D, I) {
                D.super_ = I;
                var L = function() {};
                L.prototype = I.prototype,
                D.prototype = new L,
                D.prototype.constructor = D
            }
            function $(D, I, L) {
                if ($.isBN(D))
                    return D;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                D !== null && ((I === "le" || I === "be") && (L = I,
                I = 10),
                this._init(D || 0, I || 10, L || "be"))
            }
            typeof S == "object" ? S.exports = $ : E.BN = $,
            $.BN = $,
            $.wordSize = 26;
            var B;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = require$$0$2.Buffer
            } catch {}
            $.isBN = function(I) {
                return I instanceof $ ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === $.wordSize && Array.isArray(I.words)
            }
            ,
            $.max = function(I, L) {
                return I.cmp(L) > 0 ? I : L
            }
            ,
            $.min = function(I, L) {
                return I.cmp(L) < 0 ? I : L
            }
            ,
            $.prototype._init = function(I, L, K) {
                if (typeof I == "number")
                    return this._initNumber(I, L, K);
                if (typeof I == "object")
                    return this._initArray(I, L, K);
                L === "hex" && (L = 16),
                M(L === (L | 0) && L >= 2 && L <= 36),
                I = I.toString().replace(/\s+/g, "");
                var X = 0;
                I[0] === "-" && (X++,
                this.negative = 1),
                X < I.length && (L === 16 ? this._parseHex(I, X, K) : (this._parseBase(I, L, X),
                K === "le" && this._initArray(this.toArray(), L, K)))
            }
            ,
            $.prototype._initNumber = function(I, L, K) {
                I < 0 && (this.negative = 1,
                I = -I),
                I < 67108864 ? (this.words = [I & 67108863],
                this.length = 1) : I < 4503599627370496 ? (this.words = [I & 67108863, I / 67108864 & 67108863],
                this.length = 2) : (M(I < 9007199254740992),
                this.words = [I & 67108863, I / 67108864 & 67108863, 1],
                this.length = 3),
                K === "le" && this._initArray(this.toArray(), L, K)
            }
            ,
            $.prototype._initArray = function(I, L, K) {
                if (M(typeof I.length == "number"),
                I.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(I.length / 3),
                this.words = new Array(this.length);
                for (var X = 0; X < this.length; X++)
                    this.words[X] = 0;
                var Y, j, G = 0;
                if (K === "be")
                    for (X = I.length - 1,
                    Y = 0; X >= 0; X -= 3)
                        j = I[X] | I[X - 1] << 8 | I[X - 2] << 16,
                        this.words[Y] |= j << G & 67108863,
                        this.words[Y + 1] = j >>> 26 - G & 67108863,
                        G += 24,
                        G >= 26 && (G -= 26,
                        Y++);
                else if (K === "le")
                    for (X = 0,
                    Y = 0; X < I.length; X += 3)
                        j = I[X] | I[X + 1] << 8 | I[X + 2] << 16,
                        this.words[Y] |= j << G & 67108863,
                        this.words[Y + 1] = j >>> 26 - G & 67108863,
                        G += 24,
                        G >= 26 && (G -= 26,
                        Y++);
                return this._strip()
            }
            ;
            function O(D, I) {
                var L = D.charCodeAt(I);
                if (L >= 48 && L <= 57)
                    return L - 48;
                if (L >= 65 && L <= 70)
                    return L - 55;
                if (L >= 97 && L <= 102)
                    return L - 87;
                M(!1, "Invalid character in " + D)
            }
            function F(D, I, L) {
                var K = O(D, L);
                return L - 1 >= I && (K |= O(D, L - 1) << 4),
                K
            }
            $.prototype._parseHex = function(I, L, K) {
                this.length = Math.ceil((I.length - L) / 6),
                this.words = new Array(this.length);
                for (var X = 0; X < this.length; X++)
                    this.words[X] = 0;
                var Y = 0, j = 0, G;
                if (K === "be")
                    for (X = I.length - 1; X >= L; X -= 2)
                        G = F(I, L, X) << Y,
                        this.words[j] |= G & 67108863,
                        Y >= 18 ? (Y -= 18,
                        j += 1,
                        this.words[j] |= G >>> 26) : Y += 8;
                else {
                    var ne = I.length - L;
                    for (X = ne % 2 === 0 ? L + 1 : L; X < I.length; X += 2)
                        G = F(I, L, X) << Y,
                        this.words[j] |= G & 67108863,
                        Y >= 18 ? (Y -= 18,
                        j += 1,
                        this.words[j] |= G >>> 26) : Y += 8
                }
                this._strip()
            }
            ;
            function N(D, I, L, K) {
                for (var X = 0, Y = 0, j = Math.min(D.length, L), G = I; G < j; G++) {
                    var ne = D.charCodeAt(G) - 48;
                    X *= K,
                    ne >= 49 ? Y = ne - 49 + 10 : ne >= 17 ? Y = ne - 17 + 10 : Y = ne,
                    M(ne >= 0 && Y < K, "Invalid character"),
                    X += Y
                }
                return X
            }
            $.prototype._parseBase = function(I, L, K) {
                this.words = [0],
                this.length = 1;
                for (var X = 0, Y = 1; Y <= 67108863; Y *= L)
                    X++;
                X--,
                Y = Y / L | 0;
                for (var j = I.length - K, G = j % X, ne = Math.min(j, j - G) + K, te = 0, ce = K; ce < ne; ce += X)
                    te = N(I, ce, ce + X, L),
                    this.imuln(Y),
                    this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
                if (G !== 0) {
                    var Ee = 1;
                    for (te = N(I, ce, I.length, L),
                    ce = 0; ce < G; ce++)
                        Ee *= L;
                    this.imuln(Ee),
                    this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te)
                }
                this._strip()
            }
            ,
            $.prototype.copy = function(I) {
                I.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    I.words[L] = this.words[L];
                I.length = this.length,
                I.negative = this.negative,
                I.red = this.red
            }
            ;
            function U(D, I) {
                D.words = I.words,
                D.length = I.length,
                D.negative = I.negative,
                D.red = I.red
            }
            if ($.prototype._move = function(I) {
                U(I, this)
            }
            ,
            $.prototype.clone = function() {
                var I = new $(null);
                return this.copy(I),
                I
            }
            ,
            $.prototype._expand = function(I) {
                for (; this.length < I; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            $.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            $.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    $.prototype[Symbol.for("nodejs.util.inspect.custom")] = H
                } catch {
                    $.prototype.inspect = H
                }
            else
                $.prototype.inspect = H;
            function H() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var Z = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , J = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , ie = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            $.prototype.toString = function(I, L) {
                I = I || 10,
                L = L | 0 || 1;
                var K;
                if (I === 16 || I === "hex") {
                    K = "";
                    for (var X = 0, Y = 0, j = 0; j < this.length; j++) {
                        var G = this.words[j]
                          , ne = ((G << X | Y) & 16777215).toString(16);
                        Y = G >>> 24 - X & 16777215,
                        X += 2,
                        X >= 26 && (X -= 26,
                        j--),
                        Y !== 0 || j !== this.length - 1 ? K = Z[6 - ne.length] + ne + K : K = ne + K
                    }
                    for (Y !== 0 && (K = Y.toString(16) + K); K.length % L !== 0; )
                        K = "0" + K;
                    return this.negative !== 0 && (K = "-" + K),
                    K
                }
                if (I === (I | 0) && I >= 2 && I <= 36) {
                    var te = J[I]
                      , ce = ie[I];
                    K = "";
                    var Ee = this.clone();
                    for (Ee.negative = 0; !Ee.isZero(); ) {
                        var Re = Ee.modrn(ce).toString(I);
                        Ee = Ee.idivn(ce),
                        Ee.isZero() ? K = Re + K : K = Z[te - Re.length] + Re + K
                    }
                    for (this.isZero() && (K = "0" + K); K.length % L !== 0; )
                        K = "0" + K;
                    return this.negative !== 0 && (K = "-" + K),
                    K
                }
                M(!1, "Base should be between 2 and 36")
            }
            ,
            $.prototype.toNumber = function() {
                var I = this.words[0];
                return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -I : I
            }
            ,
            $.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            B && ($.prototype.toBuffer = function(I, L) {
                return this.toArrayLike(B, I, L)
            }
            ),
            $.prototype.toArray = function(I, L) {
                return this.toArrayLike(Array, I, L)
            }
            ;
            var oe = function(I, L) {
                return I.allocUnsafe ? I.allocUnsafe(L) : new I(L)
            };
            $.prototype.toArrayLike = function(I, L, K) {
                this._strip();
                var X = this.byteLength()
                  , Y = K || Math.max(1, X);
                M(X <= Y, "byte array longer than desired length"),
                M(Y > 0, "Requested array length <= 0");
                var j = oe(I, Y)
                  , G = L === "le" ? "LE" : "BE";
                return this["_toArrayLike" + G](j, X),
                j
            }
            ,
            $.prototype._toArrayLikeLE = function(I, L) {
                for (var K = 0, X = 0, Y = 0, j = 0; Y < this.length; Y++) {
                    var G = this.words[Y] << j | X;
                    I[K++] = G & 255,
                    K < I.length && (I[K++] = G >> 8 & 255),
                    K < I.length && (I[K++] = G >> 16 & 255),
                    j === 6 ? (K < I.length && (I[K++] = G >> 24 & 255),
                    X = 0,
                    j = 0) : (X = G >>> 24,
                    j += 2)
                }
                if (K < I.length)
                    for (I[K++] = X; K < I.length; )
                        I[K++] = 0
            }
            ,
            $.prototype._toArrayLikeBE = function(I, L) {
                for (var K = I.length - 1, X = 0, Y = 0, j = 0; Y < this.length; Y++) {
                    var G = this.words[Y] << j | X;
                    I[K--] = G & 255,
                    K >= 0 && (I[K--] = G >> 8 & 255),
                    K >= 0 && (I[K--] = G >> 16 & 255),
                    j === 6 ? (K >= 0 && (I[K--] = G >> 24 & 255),
                    X = 0,
                    j = 0) : (X = G >>> 24,
                    j += 2)
                }
                if (K >= 0)
                    for (I[K--] = X; K >= 0; )
                        I[K--] = 0
            }
            ,
            Math.clz32 ? $.prototype._countBits = function(I) {
                return 32 - Math.clz32(I)
            }
            : $.prototype._countBits = function(I) {
                var L = I
                  , K = 0;
                return L >= 4096 && (K += 13,
                L >>>= 13),
                L >= 64 && (K += 7,
                L >>>= 7),
                L >= 8 && (K += 4,
                L >>>= 4),
                L >= 2 && (K += 2,
                L >>>= 2),
                K + L
            }
            ,
            $.prototype._zeroBits = function(I) {
                if (I === 0)
                    return 26;
                var L = I
                  , K = 0;
                return L & 8191 || (K += 13,
                L >>>= 13),
                L & 127 || (K += 7,
                L >>>= 7),
                L & 15 || (K += 4,
                L >>>= 4),
                L & 3 || (K += 2,
                L >>>= 2),
                L & 1 || K++,
                K
            }
            ,
            $.prototype.bitLength = function() {
                var I = this.words[this.length - 1]
                  , L = this._countBits(I);
                return (this.length - 1) * 26 + L
            }
            ;
            function ae(D) {
                for (var I = new Array(D.bitLength()), L = 0; L < I.length; L++) {
                    var K = L / 26 | 0
                      , X = L % 26;
                    I[L] = D.words[K] >>> X & 1
                }
                return I
            }
            $.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var I = 0, L = 0; L < this.length; L++) {
                    var K = this._zeroBits(this.words[L]);
                    if (I += K,
                    K !== 26)
                        break
                }
                return I
            }
            ,
            $.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            $.prototype.toTwos = function(I) {
                return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone()
            }
            ,
            $.prototype.fromTwos = function(I) {
                return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone()
            }
            ,
            $.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            $.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            $.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            $.prototype.iuor = function(I) {
                for (; this.length < I.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < I.length; L++)
                    this.words[L] = this.words[L] | I.words[L];
                return this._strip()
            }
            ,
            $.prototype.ior = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuor(I)
            }
            ,
            $.prototype.or = function(I) {
                return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this)
            }
            ,
            $.prototype.uor = function(I) {
                return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this)
            }
            ,
            $.prototype.iuand = function(I) {
                var L;
                this.length > I.length ? L = I : L = this;
                for (var K = 0; K < L.length; K++)
                    this.words[K] = this.words[K] & I.words[K];
                return this.length = L.length,
                this._strip()
            }
            ,
            $.prototype.iand = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuand(I)
            }
            ,
            $.prototype.and = function(I) {
                return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this)
            }
            ,
            $.prototype.uand = function(I) {
                return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this)
            }
            ,
            $.prototype.iuxor = function(I) {
                var L, K;
                this.length > I.length ? (L = this,
                K = I) : (L = I,
                K = this);
                for (var X = 0; X < K.length; X++)
                    this.words[X] = L.words[X] ^ K.words[X];
                if (this !== L)
                    for (; X < L.length; X++)
                        this.words[X] = L.words[X];
                return this.length = L.length,
                this._strip()
            }
            ,
            $.prototype.ixor = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuxor(I)
            }
            ,
            $.prototype.xor = function(I) {
                return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this)
            }
            ,
            $.prototype.uxor = function(I) {
                return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this)
            }
            ,
            $.prototype.inotn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = Math.ceil(I / 26) | 0
                  , K = I % 26;
                this._expand(L),
                K > 0 && L--;
                for (var X = 0; X < L; X++)
                    this.words[X] = ~this.words[X] & 67108863;
                return K > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - K),
                this._strip()
            }
            ,
            $.prototype.notn = function(I) {
                return this.clone().inotn(I)
            }
            ,
            $.prototype.setn = function(I, L) {
                M(typeof I == "number" && I >= 0);
                var K = I / 26 | 0
                  , X = I % 26;
                return this._expand(K + 1),
                L ? this.words[K] = this.words[K] | 1 << X : this.words[K] = this.words[K] & ~(1 << X),
                this._strip()
            }
            ,
            $.prototype.iadd = function(I) {
                var L;
                if (this.negative !== 0 && I.negative === 0)
                    return this.negative = 0,
                    L = this.isub(I),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && I.negative !== 0)
                    return I.negative = 0,
                    L = this.isub(I),
                    I.negative = 1,
                    L._normSign();
                var K, X;
                this.length > I.length ? (K = this,
                X = I) : (K = I,
                X = this);
                for (var Y = 0, j = 0; j < X.length; j++)
                    L = (K.words[j] | 0) + (X.words[j] | 0) + Y,
                    this.words[j] = L & 67108863,
                    Y = L >>> 26;
                for (; Y !== 0 && j < K.length; j++)
                    L = (K.words[j] | 0) + Y,
                    this.words[j] = L & 67108863,
                    Y = L >>> 26;
                if (this.length = K.length,
                Y !== 0)
                    this.words[this.length] = Y,
                    this.length++;
                else if (K !== this)
                    for (; j < K.length; j++)
                        this.words[j] = K.words[j];
                return this
            }
            ,
            $.prototype.add = function(I) {
                var L;
                return I.negative !== 0 && this.negative === 0 ? (I.negative = 0,
                L = this.sub(I),
                I.negative ^= 1,
                L) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = I.sub(this),
                this.negative = 1,
                L) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this)
            }
            ,
            $.prototype.isub = function(I) {
                if (I.negative !== 0) {
                    I.negative = 0;
                    var L = this.iadd(I);
                    return I.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(I),
                    this.negative = 1,
                    this._normSign();
                var K = this.cmp(I);
                if (K === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var X, Y;
                K > 0 ? (X = this,
                Y = I) : (X = I,
                Y = this);
                for (var j = 0, G = 0; G < Y.length; G++)
                    L = (X.words[G] | 0) - (Y.words[G] | 0) + j,
                    j = L >> 26,
                    this.words[G] = L & 67108863;
                for (; j !== 0 && G < X.length; G++)
                    L = (X.words[G] | 0) + j,
                    j = L >> 26,
                    this.words[G] = L & 67108863;
                if (j === 0 && G < X.length && X !== this)
                    for (; G < X.length; G++)
                        this.words[G] = X.words[G];
                return this.length = Math.max(this.length, G),
                X !== this && (this.negative = 1),
                this._strip()
            }
            ,
            $.prototype.sub = function(I) {
                return this.clone().isub(I)
            }
            ;
            function se(D, I, L) {
                L.negative = I.negative ^ D.negative;
                var K = D.length + I.length | 0;
                L.length = K,
                K = K - 1 | 0;
                var X = D.words[0] | 0
                  , Y = I.words[0] | 0
                  , j = X * Y
                  , G = j & 67108863
                  , ne = j / 67108864 | 0;
                L.words[0] = G;
                for (var te = 1; te < K; te++) {
                    for (var ce = ne >>> 26, Ee = ne & 67108863, Re = Math.min(te, I.length - 1), Te = Math.max(0, te - D.length + 1); Te <= Re; Te++) {
                        var xe = te - Te | 0;
                        X = D.words[xe] | 0,
                        Y = I.words[Te] | 0,
                        j = X * Y + Ee,
                        ce += j / 67108864 | 0,
                        Ee = j & 67108863
                    }
                    L.words[te] = Ee | 0,
                    ne = ce | 0
                }
                return ne !== 0 ? L.words[te] = ne | 0 : L.length--,
                L._strip()
            }
            var le = function(I, L, K) {
                var X = I.words, Y = L.words, j = K.words, G = 0, ne, te, ce, Ee = X[0] | 0, Re = Ee & 8191, Te = Ee >>> 13, xe = X[1] | 0, ve = xe & 8191, Me = xe >>> 13, Fe = X[2] | 0, be = Fe & 8191, Ce = Fe >>> 13, ze = X[3] | 0, Ge = ze & 8191, nt = ze >>> 13, bt = X[4] | 0, ct = bt & 8191, De = bt >>> 13, Ue = X[5] | 0, We = Ue & 8191, Xe = Ue >>> 13, ht = X[6] | 0, Je = ht & 8191, ot = ht >>> 13, je = X[7] | 0, $e = je & 8191, Ie = je >>> 13, He = X[8] | 0, qe = He & 8191, Ne = He >>> 13, at = X[9] | 0, Ye = at & 8191, it = at >>> 13, At = Y[0] | 0, pt = At & 8191, ut = At >>> 13, Rt = Y[1] | 0, yt = Rt & 8191, st = Rt >>> 13, Wt = Y[2] | 0, Ct = Wt & 8191, Mt = Wt >>> 13, Kt = Y[3] | 0, Pt = Kt & 8191, St = Kt >>> 13, Zt = Y[4] | 0, Nt = Zt & 8191, $t = Zt >>> 13, Gt = Y[5] | 0, Ot = Gt & 8191, Bt = Gt >>> 13, Yt = Y[6] | 0, ye = Yt & 8191, Be = Yt >>> 13, Oe = Y[7] | 0, he = Oe & 8191, Pe = Oe >>> 13, rt = Y[8] | 0, Ze = rt & 8191, tt = rt >>> 13, Et = Y[9] | 0, Tt = Et & 8191, kt = Et >>> 13;
                K.negative = I.negative ^ L.negative,
                K.length = 19,
                ne = Math.imul(Re, pt),
                te = Math.imul(Re, ut),
                te = te + Math.imul(Te, pt) | 0,
                ce = Math.imul(Te, ut);
                var Qt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                ne = Math.imul(ve, pt),
                te = Math.imul(ve, ut),
                te = te + Math.imul(Me, pt) | 0,
                ce = Math.imul(Me, ut),
                ne = ne + Math.imul(Re, yt) | 0,
                te = te + Math.imul(Re, st) | 0,
                te = te + Math.imul(Te, yt) | 0,
                ce = ce + Math.imul(Te, st) | 0;
                var Vt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Vt >>> 26) | 0,
                Vt &= 67108863,
                ne = Math.imul(be, pt),
                te = Math.imul(be, ut),
                te = te + Math.imul(Ce, pt) | 0,
                ce = Math.imul(Ce, ut),
                ne = ne + Math.imul(ve, yt) | 0,
                te = te + Math.imul(ve, st) | 0,
                te = te + Math.imul(Me, yt) | 0,
                ce = ce + Math.imul(Me, st) | 0,
                ne = ne + Math.imul(Re, Ct) | 0,
                te = te + Math.imul(Re, Mt) | 0,
                te = te + Math.imul(Te, Ct) | 0,
                ce = ce + Math.imul(Te, Mt) | 0;
                var Ve = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ve >>> 26) | 0,
                Ve &= 67108863,
                ne = Math.imul(Ge, pt),
                te = Math.imul(Ge, ut),
                te = te + Math.imul(nt, pt) | 0,
                ce = Math.imul(nt, ut),
                ne = ne + Math.imul(be, yt) | 0,
                te = te + Math.imul(be, st) | 0,
                te = te + Math.imul(Ce, yt) | 0,
                ce = ce + Math.imul(Ce, st) | 0,
                ne = ne + Math.imul(ve, Ct) | 0,
                te = te + Math.imul(ve, Mt) | 0,
                te = te + Math.imul(Me, Ct) | 0,
                ce = ce + Math.imul(Me, Mt) | 0,
                ne = ne + Math.imul(Re, Pt) | 0,
                te = te + Math.imul(Re, St) | 0,
                te = te + Math.imul(Te, Pt) | 0,
                ce = ce + Math.imul(Te, St) | 0;
                var me = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (me >>> 26) | 0,
                me &= 67108863,
                ne = Math.imul(ct, pt),
                te = Math.imul(ct, ut),
                te = te + Math.imul(De, pt) | 0,
                ce = Math.imul(De, ut),
                ne = ne + Math.imul(Ge, yt) | 0,
                te = te + Math.imul(Ge, st) | 0,
                te = te + Math.imul(nt, yt) | 0,
                ce = ce + Math.imul(nt, st) | 0,
                ne = ne + Math.imul(be, Ct) | 0,
                te = te + Math.imul(be, Mt) | 0,
                te = te + Math.imul(Ce, Ct) | 0,
                ce = ce + Math.imul(Ce, Mt) | 0,
                ne = ne + Math.imul(ve, Pt) | 0,
                te = te + Math.imul(ve, St) | 0,
                te = te + Math.imul(Me, Pt) | 0,
                ce = ce + Math.imul(Me, St) | 0,
                ne = ne + Math.imul(Re, Nt) | 0,
                te = te + Math.imul(Re, $t) | 0,
                te = te + Math.imul(Te, Nt) | 0,
                ce = ce + Math.imul(Te, $t) | 0;
                var ke = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (ke >>> 26) | 0,
                ke &= 67108863,
                ne = Math.imul(We, pt),
                te = Math.imul(We, ut),
                te = te + Math.imul(Xe, pt) | 0,
                ce = Math.imul(Xe, ut),
                ne = ne + Math.imul(ct, yt) | 0,
                te = te + Math.imul(ct, st) | 0,
                te = te + Math.imul(De, yt) | 0,
                ce = ce + Math.imul(De, st) | 0,
                ne = ne + Math.imul(Ge, Ct) | 0,
                te = te + Math.imul(Ge, Mt) | 0,
                te = te + Math.imul(nt, Ct) | 0,
                ce = ce + Math.imul(nt, Mt) | 0,
                ne = ne + Math.imul(be, Pt) | 0,
                te = te + Math.imul(be, St) | 0,
                te = te + Math.imul(Ce, Pt) | 0,
                ce = ce + Math.imul(Ce, St) | 0,
                ne = ne + Math.imul(ve, Nt) | 0,
                te = te + Math.imul(ve, $t) | 0,
                te = te + Math.imul(Me, Nt) | 0,
                ce = ce + Math.imul(Me, $t) | 0,
                ne = ne + Math.imul(Re, Ot) | 0,
                te = te + Math.imul(Re, Bt) | 0,
                te = te + Math.imul(Te, Ot) | 0,
                ce = ce + Math.imul(Te, Bt) | 0;
                var Le = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Le >>> 26) | 0,
                Le &= 67108863,
                ne = Math.imul(Je, pt),
                te = Math.imul(Je, ut),
                te = te + Math.imul(ot, pt) | 0,
                ce = Math.imul(ot, ut),
                ne = ne + Math.imul(We, yt) | 0,
                te = te + Math.imul(We, st) | 0,
                te = te + Math.imul(Xe, yt) | 0,
                ce = ce + Math.imul(Xe, st) | 0,
                ne = ne + Math.imul(ct, Ct) | 0,
                te = te + Math.imul(ct, Mt) | 0,
                te = te + Math.imul(De, Ct) | 0,
                ce = ce + Math.imul(De, Mt) | 0,
                ne = ne + Math.imul(Ge, Pt) | 0,
                te = te + Math.imul(Ge, St) | 0,
                te = te + Math.imul(nt, Pt) | 0,
                ce = ce + Math.imul(nt, St) | 0,
                ne = ne + Math.imul(be, Nt) | 0,
                te = te + Math.imul(be, $t) | 0,
                te = te + Math.imul(Ce, Nt) | 0,
                ce = ce + Math.imul(Ce, $t) | 0,
                ne = ne + Math.imul(ve, Ot) | 0,
                te = te + Math.imul(ve, Bt) | 0,
                te = te + Math.imul(Me, Ot) | 0,
                ce = ce + Math.imul(Me, Bt) | 0,
                ne = ne + Math.imul(Re, ye) | 0,
                te = te + Math.imul(Re, Be) | 0,
                te = te + Math.imul(Te, ye) | 0,
                ce = ce + Math.imul(Te, Be) | 0;
                var Qe = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Qe >>> 26) | 0,
                Qe &= 67108863,
                ne = Math.imul($e, pt),
                te = Math.imul($e, ut),
                te = te + Math.imul(Ie, pt) | 0,
                ce = Math.imul(Ie, ut),
                ne = ne + Math.imul(Je, yt) | 0,
                te = te + Math.imul(Je, st) | 0,
                te = te + Math.imul(ot, yt) | 0,
                ce = ce + Math.imul(ot, st) | 0,
                ne = ne + Math.imul(We, Ct) | 0,
                te = te + Math.imul(We, Mt) | 0,
                te = te + Math.imul(Xe, Ct) | 0,
                ce = ce + Math.imul(Xe, Mt) | 0,
                ne = ne + Math.imul(ct, Pt) | 0,
                te = te + Math.imul(ct, St) | 0,
                te = te + Math.imul(De, Pt) | 0,
                ce = ce + Math.imul(De, St) | 0,
                ne = ne + Math.imul(Ge, Nt) | 0,
                te = te + Math.imul(Ge, $t) | 0,
                te = te + Math.imul(nt, Nt) | 0,
                ce = ce + Math.imul(nt, $t) | 0,
                ne = ne + Math.imul(be, Ot) | 0,
                te = te + Math.imul(be, Bt) | 0,
                te = te + Math.imul(Ce, Ot) | 0,
                ce = ce + Math.imul(Ce, Bt) | 0,
                ne = ne + Math.imul(ve, ye) | 0,
                te = te + Math.imul(ve, Be) | 0,
                te = te + Math.imul(Me, ye) | 0,
                ce = ce + Math.imul(Me, Be) | 0,
                ne = ne + Math.imul(Re, he) | 0,
                te = te + Math.imul(Re, Pe) | 0,
                te = te + Math.imul(Te, he) | 0,
                ce = ce + Math.imul(Te, Pe) | 0;
                var Ke = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ke >>> 26) | 0,
                Ke &= 67108863,
                ne = Math.imul(qe, pt),
                te = Math.imul(qe, ut),
                te = te + Math.imul(Ne, pt) | 0,
                ce = Math.imul(Ne, ut),
                ne = ne + Math.imul($e, yt) | 0,
                te = te + Math.imul($e, st) | 0,
                te = te + Math.imul(Ie, yt) | 0,
                ce = ce + Math.imul(Ie, st) | 0,
                ne = ne + Math.imul(Je, Ct) | 0,
                te = te + Math.imul(Je, Mt) | 0,
                te = te + Math.imul(ot, Ct) | 0,
                ce = ce + Math.imul(ot, Mt) | 0,
                ne = ne + Math.imul(We, Pt) | 0,
                te = te + Math.imul(We, St) | 0,
                te = te + Math.imul(Xe, Pt) | 0,
                ce = ce + Math.imul(Xe, St) | 0,
                ne = ne + Math.imul(ct, Nt) | 0,
                te = te + Math.imul(ct, $t) | 0,
                te = te + Math.imul(De, Nt) | 0,
                ce = ce + Math.imul(De, $t) | 0,
                ne = ne + Math.imul(Ge, Ot) | 0,
                te = te + Math.imul(Ge, Bt) | 0,
                te = te + Math.imul(nt, Ot) | 0,
                ce = ce + Math.imul(nt, Bt) | 0,
                ne = ne + Math.imul(be, ye) | 0,
                te = te + Math.imul(be, Be) | 0,
                te = te + Math.imul(Ce, ye) | 0,
                ce = ce + Math.imul(Ce, Be) | 0,
                ne = ne + Math.imul(ve, he) | 0,
                te = te + Math.imul(ve, Pe) | 0,
                te = te + Math.imul(Me, he) | 0,
                ce = ce + Math.imul(Me, Pe) | 0,
                ne = ne + Math.imul(Re, Ze) | 0,
                te = te + Math.imul(Re, tt) | 0,
                te = te + Math.imul(Te, Ze) | 0,
                ce = ce + Math.imul(Te, tt) | 0;
                var vt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (vt >>> 26) | 0,
                vt &= 67108863,
                ne = Math.imul(Ye, pt),
                te = Math.imul(Ye, ut),
                te = te + Math.imul(it, pt) | 0,
                ce = Math.imul(it, ut),
                ne = ne + Math.imul(qe, yt) | 0,
                te = te + Math.imul(qe, st) | 0,
                te = te + Math.imul(Ne, yt) | 0,
                ce = ce + Math.imul(Ne, st) | 0,
                ne = ne + Math.imul($e, Ct) | 0,
                te = te + Math.imul($e, Mt) | 0,
                te = te + Math.imul(Ie, Ct) | 0,
                ce = ce + Math.imul(Ie, Mt) | 0,
                ne = ne + Math.imul(Je, Pt) | 0,
                te = te + Math.imul(Je, St) | 0,
                te = te + Math.imul(ot, Pt) | 0,
                ce = ce + Math.imul(ot, St) | 0,
                ne = ne + Math.imul(We, Nt) | 0,
                te = te + Math.imul(We, $t) | 0,
                te = te + Math.imul(Xe, Nt) | 0,
                ce = ce + Math.imul(Xe, $t) | 0,
                ne = ne + Math.imul(ct, Ot) | 0,
                te = te + Math.imul(ct, Bt) | 0,
                te = te + Math.imul(De, Ot) | 0,
                ce = ce + Math.imul(De, Bt) | 0,
                ne = ne + Math.imul(Ge, ye) | 0,
                te = te + Math.imul(Ge, Be) | 0,
                te = te + Math.imul(nt, ye) | 0,
                ce = ce + Math.imul(nt, Be) | 0,
                ne = ne + Math.imul(be, he) | 0,
                te = te + Math.imul(be, Pe) | 0,
                te = te + Math.imul(Ce, he) | 0,
                ce = ce + Math.imul(Ce, Pe) | 0,
                ne = ne + Math.imul(ve, Ze) | 0,
                te = te + Math.imul(ve, tt) | 0,
                te = te + Math.imul(Me, Ze) | 0,
                ce = ce + Math.imul(Me, tt) | 0,
                ne = ne + Math.imul(Re, Tt) | 0,
                te = te + Math.imul(Re, kt) | 0,
                te = te + Math.imul(Te, Tt) | 0,
                ce = ce + Math.imul(Te, kt) | 0;
                var dt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (dt >>> 26) | 0,
                dt &= 67108863,
                ne = Math.imul(Ye, yt),
                te = Math.imul(Ye, st),
                te = te + Math.imul(it, yt) | 0,
                ce = Math.imul(it, st),
                ne = ne + Math.imul(qe, Ct) | 0,
                te = te + Math.imul(qe, Mt) | 0,
                te = te + Math.imul(Ne, Ct) | 0,
                ce = ce + Math.imul(Ne, Mt) | 0,
                ne = ne + Math.imul($e, Pt) | 0,
                te = te + Math.imul($e, St) | 0,
                te = te + Math.imul(Ie, Pt) | 0,
                ce = ce + Math.imul(Ie, St) | 0,
                ne = ne + Math.imul(Je, Nt) | 0,
                te = te + Math.imul(Je, $t) | 0,
                te = te + Math.imul(ot, Nt) | 0,
                ce = ce + Math.imul(ot, $t) | 0,
                ne = ne + Math.imul(We, Ot) | 0,
                te = te + Math.imul(We, Bt) | 0,
                te = te + Math.imul(Xe, Ot) | 0,
                ce = ce + Math.imul(Xe, Bt) | 0,
                ne = ne + Math.imul(ct, ye) | 0,
                te = te + Math.imul(ct, Be) | 0,
                te = te + Math.imul(De, ye) | 0,
                ce = ce + Math.imul(De, Be) | 0,
                ne = ne + Math.imul(Ge, he) | 0,
                te = te + Math.imul(Ge, Pe) | 0,
                te = te + Math.imul(nt, he) | 0,
                ce = ce + Math.imul(nt, Pe) | 0,
                ne = ne + Math.imul(be, Ze) | 0,
                te = te + Math.imul(be, tt) | 0,
                te = te + Math.imul(Ce, Ze) | 0,
                ce = ce + Math.imul(Ce, tt) | 0,
                ne = ne + Math.imul(ve, Tt) | 0,
                te = te + Math.imul(ve, kt) | 0,
                te = te + Math.imul(Me, Tt) | 0,
                ce = ce + Math.imul(Me, kt) | 0;
                var It = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (It >>> 26) | 0,
                It &= 67108863,
                ne = Math.imul(Ye, Ct),
                te = Math.imul(Ye, Mt),
                te = te + Math.imul(it, Ct) | 0,
                ce = Math.imul(it, Mt),
                ne = ne + Math.imul(qe, Pt) | 0,
                te = te + Math.imul(qe, St) | 0,
                te = te + Math.imul(Ne, Pt) | 0,
                ce = ce + Math.imul(Ne, St) | 0,
                ne = ne + Math.imul($e, Nt) | 0,
                te = te + Math.imul($e, $t) | 0,
                te = te + Math.imul(Ie, Nt) | 0,
                ce = ce + Math.imul(Ie, $t) | 0,
                ne = ne + Math.imul(Je, Ot) | 0,
                te = te + Math.imul(Je, Bt) | 0,
                te = te + Math.imul(ot, Ot) | 0,
                ce = ce + Math.imul(ot, Bt) | 0,
                ne = ne + Math.imul(We, ye) | 0,
                te = te + Math.imul(We, Be) | 0,
                te = te + Math.imul(Xe, ye) | 0,
                ce = ce + Math.imul(Xe, Be) | 0,
                ne = ne + Math.imul(ct, he) | 0,
                te = te + Math.imul(ct, Pe) | 0,
                te = te + Math.imul(De, he) | 0,
                ce = ce + Math.imul(De, Pe) | 0,
                ne = ne + Math.imul(Ge, Ze) | 0,
                te = te + Math.imul(Ge, tt) | 0,
                te = te + Math.imul(nt, Ze) | 0,
                ce = ce + Math.imul(nt, tt) | 0,
                ne = ne + Math.imul(be, Tt) | 0,
                te = te + Math.imul(be, kt) | 0,
                te = te + Math.imul(Ce, Tt) | 0,
                ce = ce + Math.imul(Ce, kt) | 0;
                var xt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (xt >>> 26) | 0,
                xt &= 67108863,
                ne = Math.imul(Ye, Pt),
                te = Math.imul(Ye, St),
                te = te + Math.imul(it, Pt) | 0,
                ce = Math.imul(it, St),
                ne = ne + Math.imul(qe, Nt) | 0,
                te = te + Math.imul(qe, $t) | 0,
                te = te + Math.imul(Ne, Nt) | 0,
                ce = ce + Math.imul(Ne, $t) | 0,
                ne = ne + Math.imul($e, Ot) | 0,
                te = te + Math.imul($e, Bt) | 0,
                te = te + Math.imul(Ie, Ot) | 0,
                ce = ce + Math.imul(Ie, Bt) | 0,
                ne = ne + Math.imul(Je, ye) | 0,
                te = te + Math.imul(Je, Be) | 0,
                te = te + Math.imul(ot, ye) | 0,
                ce = ce + Math.imul(ot, Be) | 0,
                ne = ne + Math.imul(We, he) | 0,
                te = te + Math.imul(We, Pe) | 0,
                te = te + Math.imul(Xe, he) | 0,
                ce = ce + Math.imul(Xe, Pe) | 0,
                ne = ne + Math.imul(ct, Ze) | 0,
                te = te + Math.imul(ct, tt) | 0,
                te = te + Math.imul(De, Ze) | 0,
                ce = ce + Math.imul(De, tt) | 0,
                ne = ne + Math.imul(Ge, Tt) | 0,
                te = te + Math.imul(Ge, kt) | 0,
                te = te + Math.imul(nt, Tt) | 0,
                ce = ce + Math.imul(nt, kt) | 0;
                var Dt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Dt >>> 26) | 0,
                Dt &= 67108863,
                ne = Math.imul(Ye, Nt),
                te = Math.imul(Ye, $t),
                te = te + Math.imul(it, Nt) | 0,
                ce = Math.imul(it, $t),
                ne = ne + Math.imul(qe, Ot) | 0,
                te = te + Math.imul(qe, Bt) | 0,
                te = te + Math.imul(Ne, Ot) | 0,
                ce = ce + Math.imul(Ne, Bt) | 0,
                ne = ne + Math.imul($e, ye) | 0,
                te = te + Math.imul($e, Be) | 0,
                te = te + Math.imul(Ie, ye) | 0,
                ce = ce + Math.imul(Ie, Be) | 0,
                ne = ne + Math.imul(Je, he) | 0,
                te = te + Math.imul(Je, Pe) | 0,
                te = te + Math.imul(ot, he) | 0,
                ce = ce + Math.imul(ot, Pe) | 0,
                ne = ne + Math.imul(We, Ze) | 0,
                te = te + Math.imul(We, tt) | 0,
                te = te + Math.imul(Xe, Ze) | 0,
                ce = ce + Math.imul(Xe, tt) | 0,
                ne = ne + Math.imul(ct, Tt) | 0,
                te = te + Math.imul(ct, kt) | 0,
                te = te + Math.imul(De, Tt) | 0,
                ce = ce + Math.imul(De, kt) | 0;
                var qt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (qt >>> 26) | 0,
                qt &= 67108863,
                ne = Math.imul(Ye, Ot),
                te = Math.imul(Ye, Bt),
                te = te + Math.imul(it, Ot) | 0,
                ce = Math.imul(it, Bt),
                ne = ne + Math.imul(qe, ye) | 0,
                te = te + Math.imul(qe, Be) | 0,
                te = te + Math.imul(Ne, ye) | 0,
                ce = ce + Math.imul(Ne, Be) | 0,
                ne = ne + Math.imul($e, he) | 0,
                te = te + Math.imul($e, Pe) | 0,
                te = te + Math.imul(Ie, he) | 0,
                ce = ce + Math.imul(Ie, Pe) | 0,
                ne = ne + Math.imul(Je, Ze) | 0,
                te = te + Math.imul(Je, tt) | 0,
                te = te + Math.imul(ot, Ze) | 0,
                ce = ce + Math.imul(ot, tt) | 0,
                ne = ne + Math.imul(We, Tt) | 0,
                te = te + Math.imul(We, kt) | 0,
                te = te + Math.imul(Xe, Tt) | 0,
                ce = ce + Math.imul(Xe, kt) | 0;
                var zt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (zt >>> 26) | 0,
                zt &= 67108863,
                ne = Math.imul(Ye, ye),
                te = Math.imul(Ye, Be),
                te = te + Math.imul(it, ye) | 0,
                ce = Math.imul(it, Be),
                ne = ne + Math.imul(qe, he) | 0,
                te = te + Math.imul(qe, Pe) | 0,
                te = te + Math.imul(Ne, he) | 0,
                ce = ce + Math.imul(Ne, Pe) | 0,
                ne = ne + Math.imul($e, Ze) | 0,
                te = te + Math.imul($e, tt) | 0,
                te = te + Math.imul(Ie, Ze) | 0,
                ce = ce + Math.imul(Ie, tt) | 0,
                ne = ne + Math.imul(Je, Tt) | 0,
                te = te + Math.imul(Je, kt) | 0,
                te = te + Math.imul(ot, Tt) | 0,
                ce = ce + Math.imul(ot, kt) | 0;
                var mt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (mt >>> 26) | 0,
                mt &= 67108863,
                ne = Math.imul(Ye, he),
                te = Math.imul(Ye, Pe),
                te = te + Math.imul(it, he) | 0,
                ce = Math.imul(it, Pe),
                ne = ne + Math.imul(qe, Ze) | 0,
                te = te + Math.imul(qe, tt) | 0,
                te = te + Math.imul(Ne, Ze) | 0,
                ce = ce + Math.imul(Ne, tt) | 0,
                ne = ne + Math.imul($e, Tt) | 0,
                te = te + Math.imul($e, kt) | 0,
                te = te + Math.imul(Ie, Tt) | 0,
                ce = ce + Math.imul(Ie, kt) | 0;
                var wt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (wt >>> 26) | 0,
                wt &= 67108863,
                ne = Math.imul(Ye, Ze),
                te = Math.imul(Ye, tt),
                te = te + Math.imul(it, Ze) | 0,
                ce = Math.imul(it, tt),
                ne = ne + Math.imul(qe, Tt) | 0,
                te = te + Math.imul(qe, kt) | 0,
                te = te + Math.imul(Ne, Tt) | 0,
                ce = ce + Math.imul(Ne, kt) | 0;
                var Ut = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ut >>> 26) | 0,
                Ut &= 67108863,
                ne = Math.imul(Ye, Tt),
                te = Math.imul(Ye, kt),
                te = te + Math.imul(it, Tt) | 0,
                ce = Math.imul(it, kt);
                var Ft = (G + ne | 0) + ((te & 8191) << 13) | 0;
                return G = (ce + (te >>> 13) | 0) + (Ft >>> 26) | 0,
                Ft &= 67108863,
                j[0] = Qt,
                j[1] = Vt,
                j[2] = Ve,
                j[3] = me,
                j[4] = ke,
                j[5] = Le,
                j[6] = Qe,
                j[7] = Ke,
                j[8] = vt,
                j[9] = dt,
                j[10] = It,
                j[11] = xt,
                j[12] = Dt,
                j[13] = qt,
                j[14] = zt,
                j[15] = mt,
                j[16] = wt,
                j[17] = Ut,
                j[18] = Ft,
                G !== 0 && (j[19] = G,
                K.length++),
                K
            };
            Math.imul || (le = se);
            function de(D, I, L) {
                L.negative = I.negative ^ D.negative,
                L.length = D.length + I.length;
                for (var K = 0, X = 0, Y = 0; Y < L.length - 1; Y++) {
                    var j = X;
                    X = 0;
                    for (var G = K & 67108863, ne = Math.min(Y, I.length - 1), te = Math.max(0, Y - D.length + 1); te <= ne; te++) {
                        var ce = Y - te
                          , Ee = D.words[ce] | 0
                          , Re = I.words[te] | 0
                          , Te = Ee * Re
                          , xe = Te & 67108863;
                        j = j + (Te / 67108864 | 0) | 0,
                        xe = xe + G | 0,
                        G = xe & 67108863,
                        j = j + (xe >>> 26) | 0,
                        X += j >>> 26,
                        j &= 67108863
                    }
                    L.words[Y] = G,
                    K = j,
                    j = X
                }
                return K !== 0 ? L.words[Y] = K : L.length--,
                L._strip()
            }
            function fe(D, I, L) {
                return de(D, I, L)
            }
            $.prototype.mulTo = function(I, L) {
                var K, X = this.length + I.length;
                return this.length === 10 && I.length === 10 ? K = le(this, I, L) : X < 63 ? K = se(this, I, L) : X < 1024 ? K = de(this, I, L) : K = fe(this, I, L),
                K
            }
            ,
            $.prototype.mul = function(I) {
                var L = new $(null);
                return L.words = new Array(this.length + I.length),
                this.mulTo(I, L)
            }
            ,
            $.prototype.mulf = function(I) {
                var L = new $(null);
                return L.words = new Array(this.length + I.length),
                fe(this, I, L)
            }
            ,
            $.prototype.imul = function(I) {
                return this.clone().mulTo(I, this)
            }
            ,
            $.prototype.imuln = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(typeof I == "number"),
                M(I < 67108864);
                for (var K = 0, X = 0; X < this.length; X++) {
                    var Y = (this.words[X] | 0) * I
                      , j = (Y & 67108863) + (K & 67108863);
                    K >>= 26,
                    K += Y / 67108864 | 0,
                    K += j >>> 26,
                    this.words[X] = j & 67108863
                }
                return K !== 0 && (this.words[X] = K,
                this.length++),
                L ? this.ineg() : this
            }
            ,
            $.prototype.muln = function(I) {
                return this.clone().imuln(I)
            }
            ,
            $.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            $.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            $.prototype.pow = function(I) {
                var L = ae(I);
                if (L.length === 0)
                    return new $(1);
                for (var K = this, X = 0; X < L.length && L[X] === 0; X++,
                K = K.sqr())
                    ;
                if (++X < L.length)
                    for (var Y = K.sqr(); X < L.length; X++,
                    Y = Y.sqr())
                        L[X] !== 0 && (K = K.mul(Y));
                return K
            }
            ,
            $.prototype.iushln = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26, K = (I - L) / 26, X = 67108863 >>> 26 - L << 26 - L, Y;
                if (L !== 0) {
                    var j = 0;
                    for (Y = 0; Y < this.length; Y++) {
                        var G = this.words[Y] & X
                          , ne = (this.words[Y] | 0) - G << L;
                        this.words[Y] = ne | j,
                        j = G >>> 26 - L
                    }
                    j && (this.words[Y] = j,
                    this.length++)
                }
                if (K !== 0) {
                    for (Y = this.length - 1; Y >= 0; Y--)
                        this.words[Y + K] = this.words[Y];
                    for (Y = 0; Y < K; Y++)
                        this.words[Y] = 0;
                    this.length += K
                }
                return this._strip()
            }
            ,
            $.prototype.ishln = function(I) {
                return M(this.negative === 0),
                this.iushln(I)
            }
            ,
            $.prototype.iushrn = function(I, L, K) {
                M(typeof I == "number" && I >= 0);
                var X;
                L ? X = (L - L % 26) / 26 : X = 0;
                var Y = I % 26
                  , j = Math.min((I - Y) / 26, this.length)
                  , G = 67108863 ^ 67108863 >>> Y << Y
                  , ne = K;
                if (X -= j,
                X = Math.max(0, X),
                ne) {
                    for (var te = 0; te < j; te++)
                        ne.words[te] = this.words[te];
                    ne.length = j
                }
                if (j !== 0)
                    if (this.length > j)
                        for (this.length -= j,
                        te = 0; te < this.length; te++)
                            this.words[te] = this.words[te + j];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ce = 0;
                for (te = this.length - 1; te >= 0 && (ce !== 0 || te >= X); te--) {
                    var Ee = this.words[te] | 0;
                    this.words[te] = ce << 26 - Y | Ee >>> Y,
                    ce = Ee & G
                }
                return ne && ce !== 0 && (ne.words[ne.length++] = ce),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            $.prototype.ishrn = function(I, L, K) {
                return M(this.negative === 0),
                this.iushrn(I, L, K)
            }
            ,
            $.prototype.shln = function(I) {
                return this.clone().ishln(I)
            }
            ,
            $.prototype.ushln = function(I) {
                return this.clone().iushln(I)
            }
            ,
            $.prototype.shrn = function(I) {
                return this.clone().ishrn(I)
            }
            ,
            $.prototype.ushrn = function(I) {
                return this.clone().iushrn(I)
            }
            ,
            $.prototype.testn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26
                  , K = (I - L) / 26
                  , X = 1 << L;
                if (this.length <= K)
                    return !1;
                var Y = this.words[K];
                return !!(Y & X)
            }
            ,
            $.prototype.imaskn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26
                  , K = (I - L) / 26;
                if (M(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= K)
                    return this;
                if (L !== 0 && K++,
                this.length = Math.min(K, this.length),
                L !== 0) {
                    var X = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= X
                }
                return this._strip()
            }
            ,
            $.prototype.maskn = function(I) {
                return this.clone().imaskn(I)
            }
            ,
            $.prototype.iaddn = function(I) {
                return M(typeof I == "number"),
                M(I < 67108864),
                I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= I ? (this.words[0] = I - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(I),
                this.negative = 1,
                this) : this._iaddn(I)
            }
            ,
            $.prototype._iaddn = function(I) {
                this.words[0] += I;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            $.prototype.isubn = function(I) {
                if (M(typeof I == "number"),
                M(I < 67108864),
                I < 0)
                    return this.iaddn(-I);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(I),
                    this.negative = 1,
                    this;
                if (this.words[0] -= I,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this._strip()
            }
            ,
            $.prototype.addn = function(I) {
                return this.clone().iaddn(I)
            }
            ,
            $.prototype.subn = function(I) {
                return this.clone().isubn(I)
            }
            ,
            $.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            $.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            $.prototype._ishlnsubmul = function(I, L, K) {
                var X = I.length + K, Y;
                this._expand(X);
                var j, G = 0;
                for (Y = 0; Y < I.length; Y++) {
                    j = (this.words[Y + K] | 0) + G;
                    var ne = (I.words[Y] | 0) * L;
                    j -= ne & 67108863,
                    G = (j >> 26) - (ne / 67108864 | 0),
                    this.words[Y + K] = j & 67108863
                }
                for (; Y < this.length - K; Y++)
                    j = (this.words[Y + K] | 0) + G,
                    G = j >> 26,
                    this.words[Y + K] = j & 67108863;
                if (G === 0)
                    return this._strip();
                for (M(G === -1),
                G = 0,
                Y = 0; Y < this.length; Y++)
                    j = -(this.words[Y] | 0) + G,
                    G = j >> 26,
                    this.words[Y] = j & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            $.prototype._wordDiv = function(I, L) {
                var K = this.length - I.length
                  , X = this.clone()
                  , Y = I
                  , j = Y.words[Y.length - 1] | 0
                  , G = this._countBits(j);
                K = 26 - G,
                K !== 0 && (Y = Y.ushln(K),
                X.iushln(K),
                j = Y.words[Y.length - 1] | 0);
                var ne = X.length - Y.length, te;
                if (L !== "mod") {
                    te = new $(null),
                    te.length = ne + 1,
                    te.words = new Array(te.length);
                    for (var ce = 0; ce < te.length; ce++)
                        te.words[ce] = 0
                }
                var Ee = X.clone()._ishlnsubmul(Y, 1, ne);
                Ee.negative === 0 && (X = Ee,
                te && (te.words[ne] = 1));
                for (var Re = ne - 1; Re >= 0; Re--) {
                    var Te = (X.words[Y.length + Re] | 0) * 67108864 + (X.words[Y.length + Re - 1] | 0);
                    for (Te = Math.min(Te / j | 0, 67108863),
                    X._ishlnsubmul(Y, Te, Re); X.negative !== 0; )
                        Te--,
                        X.negative = 0,
                        X._ishlnsubmul(Y, 1, Re),
                        X.isZero() || (X.negative ^= 1);
                    te && (te.words[Re] = Te)
                }
                return te && te._strip(),
                X._strip(),
                L !== "div" && K !== 0 && X.iushrn(K),
                {
                    div: te || null,
                    mod: X
                }
            }
            ,
            $.prototype.divmod = function(I, L, K) {
                if (M(!I.isZero()),
                this.isZero())
                    return {
                        div: new $(0),
                        mod: new $(0)
                    };
                var X, Y, j;
                return this.negative !== 0 && I.negative === 0 ? (j = this.neg().divmod(I, L),
                L !== "mod" && (X = j.div.neg()),
                L !== "div" && (Y = j.mod.neg(),
                K && Y.negative !== 0 && Y.iadd(I)),
                {
                    div: X,
                    mod: Y
                }) : this.negative === 0 && I.negative !== 0 ? (j = this.divmod(I.neg(), L),
                L !== "mod" && (X = j.div.neg()),
                {
                    div: X,
                    mod: j.mod
                }) : this.negative & I.negative ? (j = this.neg().divmod(I.neg(), L),
                L !== "div" && (Y = j.mod.neg(),
                K && Y.negative !== 0 && Y.isub(I)),
                {
                    div: j.div,
                    mod: Y
                }) : I.length > this.length || this.cmp(I) < 0 ? {
                    div: new $(0),
                    mod: this
                } : I.length === 1 ? L === "div" ? {
                    div: this.divn(I.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new $(this.modrn(I.words[0]))
                } : {
                    div: this.divn(I.words[0]),
                    mod: new $(this.modrn(I.words[0]))
                } : this._wordDiv(I, L)
            }
            ,
            $.prototype.div = function(I) {
                return this.divmod(I, "div", !1).div
            }
            ,
            $.prototype.mod = function(I) {
                return this.divmod(I, "mod", !1).mod
            }
            ,
            $.prototype.umod = function(I) {
                return this.divmod(I, "mod", !0).mod
            }
            ,
            $.prototype.divRound = function(I) {
                var L = this.divmod(I);
                if (L.mod.isZero())
                    return L.div;
                var K = L.div.negative !== 0 ? L.mod.isub(I) : L.mod
                  , X = I.ushrn(1)
                  , Y = I.andln(1)
                  , j = K.cmp(X);
                return j < 0 || Y === 1 && j === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            $.prototype.modrn = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(I <= 67108863);
                for (var K = (1 << 26) % I, X = 0, Y = this.length - 1; Y >= 0; Y--)
                    X = (K * X + (this.words[Y] | 0)) % I;
                return L ? -X : X
            }
            ,
            $.prototype.modn = function(I) {
                return this.modrn(I)
            }
            ,
            $.prototype.idivn = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(I <= 67108863);
                for (var K = 0, X = this.length - 1; X >= 0; X--) {
                    var Y = (this.words[X] | 0) + K * 67108864;
                    this.words[X] = Y / I | 0,
                    K = Y % I
                }
                return this._strip(),
                L ? this.ineg() : this
            }
            ,
            $.prototype.divn = function(I) {
                return this.clone().idivn(I)
            }
            ,
            $.prototype.egcd = function(I) {
                M(I.negative === 0),
                M(!I.isZero());
                var L = this
                  , K = I.clone();
                L.negative !== 0 ? L = L.umod(I) : L = L.clone();
                for (var X = new $(1), Y = new $(0), j = new $(0), G = new $(1), ne = 0; L.isEven() && K.isEven(); )
                    L.iushrn(1),
                    K.iushrn(1),
                    ++ne;
                for (var te = K.clone(), ce = L.clone(); !L.isZero(); ) {
                    for (var Ee = 0, Re = 1; !(L.words[0] & Re) && Ee < 26; ++Ee,
                    Re <<= 1)
                        ;
                    if (Ee > 0)
                        for (L.iushrn(Ee); Ee-- > 0; )
                            (X.isOdd() || Y.isOdd()) && (X.iadd(te),
                            Y.isub(ce)),
                            X.iushrn(1),
                            Y.iushrn(1);
                    for (var Te = 0, xe = 1; !(K.words[0] & xe) && Te < 26; ++Te,
                    xe <<= 1)
                        ;
                    if (Te > 0)
                        for (K.iushrn(Te); Te-- > 0; )
                            (j.isOdd() || G.isOdd()) && (j.iadd(te),
                            G.isub(ce)),
                            j.iushrn(1),
                            G.iushrn(1);
                    L.cmp(K) >= 0 ? (L.isub(K),
                    X.isub(j),
                    Y.isub(G)) : (K.isub(L),
                    j.isub(X),
                    G.isub(Y))
                }
                return {
                    a: j,
                    b: G,
                    gcd: K.iushln(ne)
                }
            }
            ,
            $.prototype._invmp = function(I) {
                M(I.negative === 0),
                M(!I.isZero());
                var L = this
                  , K = I.clone();
                L.negative !== 0 ? L = L.umod(I) : L = L.clone();
                for (var X = new $(1), Y = new $(0), j = K.clone(); L.cmpn(1) > 0 && K.cmpn(1) > 0; ) {
                    for (var G = 0, ne = 1; !(L.words[0] & ne) && G < 26; ++G,
                    ne <<= 1)
                        ;
                    if (G > 0)
                        for (L.iushrn(G); G-- > 0; )
                            X.isOdd() && X.iadd(j),
                            X.iushrn(1);
                    for (var te = 0, ce = 1; !(K.words[0] & ce) && te < 26; ++te,
                    ce <<= 1)
                        ;
                    if (te > 0)
                        for (K.iushrn(te); te-- > 0; )
                            Y.isOdd() && Y.iadd(j),
                            Y.iushrn(1);
                    L.cmp(K) >= 0 ? (L.isub(K),
                    X.isub(Y)) : (K.isub(L),
                    Y.isub(X))
                }
                var Ee;
                return L.cmpn(1) === 0 ? Ee = X : Ee = Y,
                Ee.cmpn(0) < 0 && Ee.iadd(I),
                Ee
            }
            ,
            $.prototype.gcd = function(I) {
                if (this.isZero())
                    return I.abs();
                if (I.isZero())
                    return this.abs();
                var L = this.clone()
                  , K = I.clone();
                L.negative = 0,
                K.negative = 0;
                for (var X = 0; L.isEven() && K.isEven(); X++)
                    L.iushrn(1),
                    K.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; K.isEven(); )
                        K.iushrn(1);
                    var Y = L.cmp(K);
                    if (Y < 0) {
                        var j = L;
                        L = K,
                        K = j
                    } else if (Y === 0 || K.cmpn(1) === 0)
                        break;
                    L.isub(K)
                } while (!0);
                return K.iushln(X)
            }
            ,
            $.prototype.invm = function(I) {
                return this.egcd(I).a.umod(I)
            }
            ,
            $.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            $.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            $.prototype.andln = function(I) {
                return this.words[0] & I
            }
            ,
            $.prototype.bincn = function(I) {
                M(typeof I == "number");
                var L = I % 26
                  , K = (I - L) / 26
                  , X = 1 << L;
                if (this.length <= K)
                    return this._expand(K + 1),
                    this.words[K] |= X,
                    this;
                for (var Y = X, j = K; Y !== 0 && j < this.length; j++) {
                    var G = this.words[j] | 0;
                    G += Y,
                    Y = G >>> 26,
                    G &= 67108863,
                    this.words[j] = G
                }
                return Y !== 0 && (this.words[j] = Y,
                this.length++),
                this
            }
            ,
            $.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            $.prototype.cmpn = function(I) {
                var L = I < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this._strip();
                var K;
                if (this.length > 1)
                    K = 1;
                else {
                    L && (I = -I),
                    M(I <= 67108863, "Number is too big");
                    var X = this.words[0] | 0;
                    K = X === I ? 0 : X < I ? -1 : 1
                }
                return this.negative !== 0 ? -K | 0 : K
            }
            ,
            $.prototype.cmp = function(I) {
                if (this.negative !== 0 && I.negative === 0)
                    return -1;
                if (this.negative === 0 && I.negative !== 0)
                    return 1;
                var L = this.ucmp(I);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            $.prototype.ucmp = function(I) {
                if (this.length > I.length)
                    return 1;
                if (this.length < I.length)
                    return -1;
                for (var L = 0, K = this.length - 1; K >= 0; K--) {
                    var X = this.words[K] | 0
                      , Y = I.words[K] | 0;
                    if (X !== Y) {
                        X < Y ? L = -1 : X > Y && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            $.prototype.gtn = function(I) {
                return this.cmpn(I) === 1
            }
            ,
            $.prototype.gt = function(I) {
                return this.cmp(I) === 1
            }
            ,
            $.prototype.gten = function(I) {
                return this.cmpn(I) >= 0
            }
            ,
            $.prototype.gte = function(I) {
                return this.cmp(I) >= 0
            }
            ,
            $.prototype.ltn = function(I) {
                return this.cmpn(I) === -1
            }
            ,
            $.prototype.lt = function(I) {
                return this.cmp(I) === -1
            }
            ,
            $.prototype.lten = function(I) {
                return this.cmpn(I) <= 0
            }
            ,
            $.prototype.lte = function(I) {
                return this.cmp(I) <= 0
            }
            ,
            $.prototype.eqn = function(I) {
                return this.cmpn(I) === 0
            }
            ,
            $.prototype.eq = function(I) {
                return this.cmp(I) === 0
            }
            ,
            $.red = function(I) {
                return new V(I)
            }
            ,
            $.prototype.toRed = function(I) {
                return M(!this.red, "Already a number in reduction context"),
                M(this.negative === 0, "red works only with positives"),
                I.convertTo(this)._forceRed(I)
            }
            ,
            $.prototype.fromRed = function() {
                return M(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            $.prototype._forceRed = function(I) {
                return this.red = I,
                this
            }
            ,
            $.prototype.forceRed = function(I) {
                return M(!this.red, "Already a number in reduction context"),
                this._forceRed(I)
            }
            ,
            $.prototype.redAdd = function(I) {
                return M(this.red, "redAdd works only with red numbers"),
                this.red.add(this, I)
            }
            ,
            $.prototype.redIAdd = function(I) {
                return M(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, I)
            }
            ,
            $.prototype.redSub = function(I) {
                return M(this.red, "redSub works only with red numbers"),
                this.red.sub(this, I)
            }
            ,
            $.prototype.redISub = function(I) {
                return M(this.red, "redISub works only with red numbers"),
                this.red.isub(this, I)
            }
            ,
            $.prototype.redShl = function(I) {
                return M(this.red, "redShl works only with red numbers"),
                this.red.shl(this, I)
            }
            ,
            $.prototype.redMul = function(I) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, I),
                this.red.mul(this, I)
            }
            ,
            $.prototype.redIMul = function(I) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, I),
                this.red.imul(this, I)
            }
            ,
            $.prototype.redSqr = function() {
                return M(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            $.prototype.redISqr = function() {
                return M(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            $.prototype.redSqrt = function() {
                return M(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            $.prototype.redInvm = function() {
                return M(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            $.prototype.redNeg = function() {
                return M(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            $.prototype.redPow = function(I) {
                return M(this.red && !I.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, I)
            }
            ;
            var pe = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function ge(D, I) {
                this.name = D,
                this.p = new $(I,16),
                this.n = this.p.bitLength(),
                this.k = new $(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            ge.prototype._tmp = function() {
                var I = new $(null);
                return I.words = new Array(Math.ceil(this.n / 13)),
                I
            }
            ,
            ge.prototype.ireduce = function(I) {
                var L = I, K;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    K = L.bitLength();
                while (K > this.n);
                var X = K < this.n ? -1 : L.ucmp(this.p);
                return X === 0 ? (L.words[0] = 0,
                L.length = 1) : X > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            ge.prototype.split = function(I, L) {
                I.iushrn(this.n, 0, L)
            }
            ,
            ge.prototype.imulK = function(I) {
                return I.imul(this.k)
            }
            ;
            function we() {
                ge.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            T(we, ge),
            we.prototype.split = function(I, L) {
                for (var K = 4194303, X = Math.min(I.length, 9), Y = 0; Y < X; Y++)
                    L.words[Y] = I.words[Y];
                if (L.length = X,
                I.length <= 9) {
                    I.words[0] = 0,
                    I.length = 1;
                    return
                }
                var j = I.words[9];
                for (L.words[L.length++] = j & K,
                Y = 10; Y < I.length; Y++) {
                    var G = I.words[Y] | 0;
                    I.words[Y - 10] = (G & K) << 4 | j >>> 22,
                    j = G
                }
                j >>>= 22,
                I.words[Y - 10] = j,
                j === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9
            }
            ,
            we.prototype.imulK = function(I) {
                I.words[I.length] = 0,
                I.words[I.length + 1] = 0,
                I.length += 2;
                for (var L = 0, K = 0; K < I.length; K++) {
                    var X = I.words[K] | 0;
                    L += X * 977,
                    I.words[K] = L & 67108863,
                    L = X * 64 + (L / 67108864 | 0)
                }
                return I.words[I.length - 1] === 0 && (I.length--,
                I.words[I.length - 1] === 0 && I.length--),
                I
            }
            ;
            function Ae() {
                ge.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            T(Ae, ge);
            function Se() {
                ge.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            T(Se, ge);
            function ue() {
                ge.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            T(ue, ge),
            ue.prototype.imulK = function(I) {
                for (var L = 0, K = 0; K < I.length; K++) {
                    var X = (I.words[K] | 0) * 19 + L
                      , Y = X & 67108863;
                    X >>>= 26,
                    I.words[K] = Y,
                    L = X
                }
                return L !== 0 && (I.words[I.length++] = L),
                I
            }
            ,
            $._prime = function(I) {
                if (pe[I])
                    return pe[I];
                var L;
                if (I === "k256")
                    L = new we;
                else if (I === "p224")
                    L = new Ae;
                else if (I === "p192")
                    L = new Se;
                else if (I === "p25519")
                    L = new ue;
                else
                    throw new Error("Unknown prime " + I);
                return pe[I] = L,
                L
            }
            ;
            function V(D) {
                if (typeof D == "string") {
                    var I = $._prime(D);
                    this.m = I.p,
                    this.prime = I
                } else
                    M(D.gtn(1), "modulus must be greater than 1"),
                    this.m = D,
                    this.prime = null
            }
            V.prototype._verify1 = function(I) {
                M(I.negative === 0, "red works only with positives"),
                M(I.red, "red works only with red numbers")
            }
            ,
            V.prototype._verify2 = function(I, L) {
                M((I.negative | L.negative) === 0, "red works only with positives"),
                M(I.red && I.red === L.red, "red works only with red numbers")
            }
            ,
            V.prototype.imod = function(I) {
                return this.prime ? this.prime.ireduce(I)._forceRed(this) : (U(I, I.umod(this.m)._forceRed(this)),
                I)
            }
            ,
            V.prototype.neg = function(I) {
                return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this)
            }
            ,
            V.prototype.add = function(I, L) {
                this._verify2(I, L);
                var K = I.add(L);
                return K.cmp(this.m) >= 0 && K.isub(this.m),
                K._forceRed(this)
            }
            ,
            V.prototype.iadd = function(I, L) {
                this._verify2(I, L);
                var K = I.iadd(L);
                return K.cmp(this.m) >= 0 && K.isub(this.m),
                K
            }
            ,
            V.prototype.sub = function(I, L) {
                this._verify2(I, L);
                var K = I.sub(L);
                return K.cmpn(0) < 0 && K.iadd(this.m),
                K._forceRed(this)
            }
            ,
            V.prototype.isub = function(I, L) {
                this._verify2(I, L);
                var K = I.isub(L);
                return K.cmpn(0) < 0 && K.iadd(this.m),
                K
            }
            ,
            V.prototype.shl = function(I, L) {
                return this._verify1(I),
                this.imod(I.ushln(L))
            }
            ,
            V.prototype.imul = function(I, L) {
                return this._verify2(I, L),
                this.imod(I.imul(L))
            }
            ,
            V.prototype.mul = function(I, L) {
                return this._verify2(I, L),
                this.imod(I.mul(L))
            }
            ,
            V.prototype.isqr = function(I) {
                return this.imul(I, I.clone())
            }
            ,
            V.prototype.sqr = function(I) {
                return this.mul(I, I)
            }
            ,
            V.prototype.sqrt = function(I) {
                if (I.isZero())
                    return I.clone();
                var L = this.m.andln(3);
                if (M(L % 2 === 1),
                L === 3) {
                    var K = this.m.add(new $(1)).iushrn(2);
                    return this.pow(I, K)
                }
                for (var X = this.m.subn(1), Y = 0; !X.isZero() && X.andln(1) === 0; )
                    Y++,
                    X.iushrn(1);
                M(!X.isZero());
                var j = new $(1).toRed(this)
                  , G = j.redNeg()
                  , ne = this.m.subn(1).iushrn(1)
                  , te = this.m.bitLength();
                for (te = new $(2 * te * te).toRed(this); this.pow(te, ne).cmp(G) !== 0; )
                    te.redIAdd(G);
                for (var ce = this.pow(te, X), Ee = this.pow(I, X.addn(1).iushrn(1)), Re = this.pow(I, X), Te = Y; Re.cmp(j) !== 0; ) {
                    for (var xe = Re, ve = 0; xe.cmp(j) !== 0; ve++)
                        xe = xe.redSqr();
                    M(ve < Te);
                    var Me = this.pow(ce, new $(1).iushln(Te - ve - 1));
                    Ee = Ee.redMul(Me),
                    ce = Me.redSqr(),
                    Re = Re.redMul(ce),
                    Te = ve
                }
                return Ee
            }
            ,
            V.prototype.invm = function(I) {
                var L = I._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            V.prototype.pow = function(I, L) {
                if (L.isZero())
                    return new $(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return I.clone();
                var K = 4
                  , X = new Array(1 << K);
                X[0] = new $(1).toRed(this),
                X[1] = I;
                for (var Y = 2; Y < X.length; Y++)
                    X[Y] = this.mul(X[Y - 1], I);
                var j = X[0]
                  , G = 0
                  , ne = 0
                  , te = L.bitLength() % 26;
                for (te === 0 && (te = 26),
                Y = L.length - 1; Y >= 0; Y--) {
                    for (var ce = L.words[Y], Ee = te - 1; Ee >= 0; Ee--) {
                        var Re = ce >> Ee & 1;
                        if (j !== X[0] && (j = this.sqr(j)),
                        Re === 0 && G === 0) {
                            ne = 0;
                            continue
                        }
                        G <<= 1,
                        G |= Re,
                        ne++,
                        !(ne !== K && (Y !== 0 || Ee !== 0)) && (j = this.mul(j, X[G]),
                        ne = 0,
                        G = 0)
                    }
                    te = 26
                }
                return j
            }
            ,
            V.prototype.convertTo = function(I) {
                var L = I.umod(this.m);
                return L === I ? L.clone() : L
            }
            ,
            V.prototype.convertFrom = function(I) {
                var L = I.clone();
                return L.red = null,
                L
            }
            ,
            $.mont = function(I) {
                return new W(I)
            }
            ;
            function W(D) {
                V.call(this, D),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new $(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            T(W, V),
            W.prototype.convertTo = function(I) {
                return this.imod(I.ushln(this.shift))
            }
            ,
            W.prototype.convertFrom = function(I) {
                var L = this.imod(I.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            W.prototype.imul = function(I, L) {
                if (I.isZero() || L.isZero())
                    return I.words[0] = 0,
                    I.length = 1,
                    I;
                var K = I.imul(L)
                  , X = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Y = K.isub(X).iushrn(this.shift)
                  , j = Y;
                return Y.cmp(this.m) >= 0 ? j = Y.isub(this.m) : Y.cmpn(0) < 0 && (j = Y.iadd(this.m)),
                j._forceRed(this)
            }
            ,
            W.prototype.mul = function(I, L) {
                if (I.isZero() || L.isZero())
                    return new $(0)._forceRed(this);
                var K = I.mul(L)
                  , X = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Y = K.isub(X).iushrn(this.shift)
                  , j = Y;
                return Y.cmp(this.m) >= 0 ? j = Y.isub(this.m) : Y.cmpn(0) < 0 && (j = Y.iadd(this.m)),
                j._forceRed(this)
            }
            ,
            W.prototype.invm = function(I) {
                var L = this.imod(I._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(C, commonjsGlobal)
    }(bn$4)),
    bn$4.exports
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
    if (hasRequiredBrowserifyRsa)
        return browserifyRsa;
    hasRequiredBrowserifyRsa = 1;
    var C = requireBn$1()
      , S = requireBrowser$b();
    function E($) {
        var B = M($)
          , O = B.toRed(C.mont($.modulus)).redPow(new C($.publicExponent)).fromRed();
        return {
            blinder: O,
            unblinder: B.invm($.modulus)
        }
    }
    function M($) {
        var B = $.modulus.byteLength(), O;
        do
            O = new C(S(B));
        while (O.cmp($.modulus) >= 0 || !O.umod($.prime1) || !O.umod($.prime2));
        return O
    }
    function T($, B) {
        var O = E(B)
          , F = B.modulus.byteLength()
          , N = new C($).mul(O.blinder).umod(B.modulus)
          , U = N.toRed(C.mont(B.prime1))
          , H = N.toRed(C.mont(B.prime2))
          , Z = B.coefficient
          , J = B.prime1
          , ie = B.prime2
          , oe = U.redPow(B.exponent1).fromRed()
          , ae = H.redPow(B.exponent2).fromRed()
          , se = oe.isub(ae).imul(Z).umod(J).imul(ie);
        return ae.iadd(se).imul(O.unblinder).umod(B.modulus).toArrayLike(Buffer, "be", F)
    }
    return T.getr = M,
    browserifyRsa = T,
    browserifyRsa
}
var elliptic = {};
const name$2 = "elliptic"
  , version$6 = "6.5.5"
  , description$1 = "EC cryptography"
  , main$2 = "lib/elliptic.js"
  , files$2 = ["lib"]
  , scripts$2 = {
    lint: "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    unit: "istanbul test _mocha --reporter=spec test/index.js",
    test: "npm run lint && npm run unit",
    version: "grunt dist && git add dist/"
}
  , repository$2 = {
    type: "git",
    url: "git@github.com:indutny/elliptic"
}
  , keywords = ["EC", "Elliptic", "curve", "Cryptography"]
  , author$2 = "Fedor Indutny <fedor@indutny.com>"
  , license$2 = "MIT"
  , bugs$1 = {
    url: "https://github.com/indutny/elliptic/issues"
}
  , homepage$1 = "https://github.com/indutny/elliptic"
  , devDependencies$2 = {
    brfs: "^2.0.2",
    coveralls: "^3.1.0",
    eslint: "^7.6.0",
    grunt: "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    istanbul: "^0.4.5",
    mocha: "^8.0.1"
}
  , dependencies$2 = {
    "bn.js": "^4.11.9",
    brorand: "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    inherits: "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
}
  , require$$0$1 = {
    name: name$2,
    version: version$6,
    description: description$1,
    main: main$2,
    files: files$2,
    scripts: scripts$2,
    repository: repository$2,
    keywords,
    author: author$2,
    license: license$2,
    bugs: bugs$1,
    homepage: homepage$1,
    devDependencies: devDependencies$2,
    dependencies: dependencies$2
};
var utils$5 = {}, utils$4 = {}, hasRequiredUtils$2;
function requireUtils$2() {
    return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1,
    function(C) {
        var S = C;
        function E($, B) {
            if (Array.isArray($))
                return $.slice();
            if (!$)
                return [];
            var O = [];
            if (typeof $ != "string") {
                for (var F = 0; F < $.length; F++)
                    O[F] = $[F] | 0;
                return O
            }
            if (B === "hex") {
                $ = $.replace(/[^a-z0-9]+/ig, ""),
                $.length % 2 !== 0 && ($ = "0" + $);
                for (var F = 0; F < $.length; F += 2)
                    O.push(parseInt($[F] + $[F + 1], 16))
            } else
                for (var F = 0; F < $.length; F++) {
                    var N = $.charCodeAt(F)
                      , U = N >> 8
                      , H = N & 255;
                    U ? O.push(U, H) : O.push(H)
                }
            return O
        }
        S.toArray = E;
        function M($) {
            return $.length === 1 ? "0" + $ : $
        }
        S.zero2 = M;
        function T($) {
            for (var B = "", O = 0; O < $.length; O++)
                B += M($[O].toString(16));
            return B
        }
        S.toHex = T,
        S.encode = function(B, O) {
            return O === "hex" ? T(B) : B
        }
    }(utils$4)),
    utils$4
}
var hasRequiredUtils$1;
function requireUtils$1() {
    return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1,
    function(C) {
        var S = C
          , E = requireBn$2()
          , M = requireMinimalisticAssert()
          , T = requireUtils$2();
        S.assert = M,
        S.toArray = T.toArray,
        S.zero2 = T.zero2,
        S.toHex = T.toHex,
        S.encode = T.encode;
        function $(U, H, Z) {
            var J = new Array(Math.max(U.bitLength(), Z) + 1), ie;
            for (ie = 0; ie < J.length; ie += 1)
                J[ie] = 0;
            var oe = 1 << H + 1
              , ae = U.clone();
            for (ie = 0; ie < J.length; ie++) {
                var se, le = ae.andln(oe - 1);
                ae.isOdd() ? (le > (oe >> 1) - 1 ? se = (oe >> 1) - le : se = le,
                ae.isubn(se)) : se = 0,
                J[ie] = se,
                ae.iushrn(1)
            }
            return J
        }
        S.getNAF = $;
        function B(U, H) {
            var Z = [[], []];
            U = U.clone(),
            H = H.clone();
            for (var J = 0, ie = 0, oe; U.cmpn(-J) > 0 || H.cmpn(-ie) > 0; ) {
                var ae = U.andln(3) + J & 3
                  , se = H.andln(3) + ie & 3;
                ae === 3 && (ae = -1),
                se === 3 && (se = -1);
                var le;
                ae & 1 ? (oe = U.andln(7) + J & 7,
                (oe === 3 || oe === 5) && se === 2 ? le = -ae : le = ae) : le = 0,
                Z[0].push(le);
                var de;
                se & 1 ? (oe = H.andln(7) + ie & 7,
                (oe === 3 || oe === 5) && ae === 2 ? de = -se : de = se) : de = 0,
                Z[1].push(de),
                2 * J === le + 1 && (J = 1 - J),
                2 * ie === de + 1 && (ie = 1 - ie),
                U.iushrn(1),
                H.iushrn(1)
            }
            return Z
        }
        S.getJSF = B;
        function O(U, H, Z) {
            var J = "_" + H;
            U.prototype[H] = function() {
                return this[J] !== void 0 ? this[J] : this[J] = Z.call(this)
            }
        }
        S.cachedProperty = O;
        function F(U) {
            return typeof U == "string" ? S.toArray(U, "hex") : U
        }
        S.parseBytes = F;
        function N(U) {
            return new E(U,"hex","le")
        }
        S.intFromLE = N
    }(utils$5)),
    utils$5
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
    if (hasRequiredBase$1)
        return base$1;
    hasRequiredBase$1 = 1;
    var C = requireBn$2()
      , S = requireUtils$1()
      , E = S.getNAF
      , M = S.getJSF
      , T = S.assert;
    function $(O, F) {
        this.type = O,
        this.p = new C(F.p,16),
        this.red = F.prime ? C.red(F.prime) : C.mont(this.p),
        this.zero = new C(0).toRed(this.red),
        this.one = new C(1).toRed(this.red),
        this.two = new C(2).toRed(this.red),
        this.n = F.n && new C(F.n,16),
        this.g = F.g && this.pointFromJSON(F.g, F.gRed),
        this._wnafT1 = new Array(4),
        this._wnafT2 = new Array(4),
        this._wnafT3 = new Array(4),
        this._wnafT4 = new Array(4),
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var N = this.n && this.p.div(this.n);
        !N || N.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0,
        this.redN = this.n.toRed(this.red))
    }
    base$1 = $,
    $.prototype.point = function() {
        throw new Error("Not implemented")
    }
    ,
    $.prototype.validate = function() {
        throw new Error("Not implemented")
    }
    ,
    $.prototype._fixedNafMul = function(F, N) {
        T(F.precomputed);
        var U = F._getDoubles()
          , H = E(N, 1, this._bitLength)
          , Z = (1 << U.step + 1) - (U.step % 2 === 0 ? 2 : 1);
        Z /= 3;
        var J = [], ie, oe;
        for (ie = 0; ie < H.length; ie += U.step) {
            oe = 0;
            for (var ae = ie + U.step - 1; ae >= ie; ae--)
                oe = (oe << 1) + H[ae];
            J.push(oe)
        }
        for (var se = this.jpoint(null, null, null), le = this.jpoint(null, null, null), de = Z; de > 0; de--) {
            for (ie = 0; ie < J.length; ie++)
                oe = J[ie],
                oe === de ? le = le.mixedAdd(U.points[ie]) : oe === -de && (le = le.mixedAdd(U.points[ie].neg()));
            se = se.add(le)
        }
        return se.toP()
    }
    ,
    $.prototype._wnafMul = function(F, N) {
        var U = 4
          , H = F._getNAFPoints(U);
        U = H.wnd;
        for (var Z = H.points, J = E(N, U, this._bitLength), ie = this.jpoint(null, null, null), oe = J.length - 1; oe >= 0; oe--) {
            for (var ae = 0; oe >= 0 && J[oe] === 0; oe--)
                ae++;
            if (oe >= 0 && ae++,
            ie = ie.dblp(ae),
            oe < 0)
                break;
            var se = J[oe];
            T(se !== 0),
            F.type === "affine" ? se > 0 ? ie = ie.mixedAdd(Z[se - 1 >> 1]) : ie = ie.mixedAdd(Z[-se - 1 >> 1].neg()) : se > 0 ? ie = ie.add(Z[se - 1 >> 1]) : ie = ie.add(Z[-se - 1 >> 1].neg())
        }
        return F.type === "affine" ? ie.toP() : ie
    }
    ,
    $.prototype._wnafMulAdd = function(F, N, U, H, Z) {
        var J = this._wnafT1, ie = this._wnafT2, oe = this._wnafT3, ae = 0, se, le, de;
        for (se = 0; se < H; se++) {
            de = N[se];
            var fe = de._getNAFPoints(F);
            J[se] = fe.wnd,
            ie[se] = fe.points
        }
        for (se = H - 1; se >= 1; se -= 2) {
            var pe = se - 1
              , ge = se;
            if (J[pe] !== 1 || J[ge] !== 1) {
                oe[pe] = E(U[pe], J[pe], this._bitLength),
                oe[ge] = E(U[ge], J[ge], this._bitLength),
                ae = Math.max(oe[pe].length, ae),
                ae = Math.max(oe[ge].length, ae);
                continue
            }
            var we = [N[pe], null, null, N[ge]];
            N[pe].y.cmp(N[ge].y) === 0 ? (we[1] = N[pe].add(N[ge]),
            we[2] = N[pe].toJ().mixedAdd(N[ge].neg())) : N[pe].y.cmp(N[ge].y.redNeg()) === 0 ? (we[1] = N[pe].toJ().mixedAdd(N[ge]),
            we[2] = N[pe].add(N[ge].neg())) : (we[1] = N[pe].toJ().mixedAdd(N[ge]),
            we[2] = N[pe].toJ().mixedAdd(N[ge].neg()));
            var Ae = [-3, -1, -5, -7, 0, 7, 5, 1, 3]
              , Se = M(U[pe], U[ge]);
            for (ae = Math.max(Se[0].length, ae),
            oe[pe] = new Array(ae),
            oe[ge] = new Array(ae),
            le = 0; le < ae; le++) {
                var ue = Se[0][le] | 0
                  , V = Se[1][le] | 0;
                oe[pe][le] = Ae[(ue + 1) * 3 + (V + 1)],
                oe[ge][le] = 0,
                ie[pe] = we
            }
        }
        var W = this.jpoint(null, null, null)
          , D = this._wnafT4;
        for (se = ae; se >= 0; se--) {
            for (var I = 0; se >= 0; ) {
                var L = !0;
                for (le = 0; le < H; le++)
                    D[le] = oe[le][se] | 0,
                    D[le] !== 0 && (L = !1);
                if (!L)
                    break;
                I++,
                se--
            }
            if (se >= 0 && I++,
            W = W.dblp(I),
            se < 0)
                break;
            for (le = 0; le < H; le++) {
                var K = D[le];
                K !== 0 && (K > 0 ? de = ie[le][K - 1 >> 1] : K < 0 && (de = ie[le][-K - 1 >> 1].neg()),
                de.type === "affine" ? W = W.mixedAdd(de) : W = W.add(de))
            }
        }
        for (se = 0; se < H; se++)
            ie[se] = null;
        return Z ? W : W.toP()
    }
    ;
    function B(O, F) {
        this.curve = O,
        this.type = F,
        this.precomputed = null
    }
    return $.BasePoint = B,
    B.prototype.eq = function() {
        throw new Error("Not implemented")
    }
    ,
    B.prototype.validate = function() {
        return this.curve.validate(this)
    }
    ,
    $.prototype.decodePoint = function(F, N) {
        F = S.toArray(F, N);
        var U = this.p.byteLength();
        if ((F[0] === 4 || F[0] === 6 || F[0] === 7) && F.length - 1 === 2 * U) {
            F[0] === 6 ? T(F[F.length - 1] % 2 === 0) : F[0] === 7 && T(F[F.length - 1] % 2 === 1);
            var H = this.point(F.slice(1, 1 + U), F.slice(1 + U, 1 + 2 * U));
            return H
        } else if ((F[0] === 2 || F[0] === 3) && F.length - 1 === U)
            return this.pointFromX(F.slice(1, 1 + U), F[0] === 3);
        throw new Error("Unknown point format")
    }
    ,
    B.prototype.encodeCompressed = function(F) {
        return this.encode(F, !0)
    }
    ,
    B.prototype._encode = function(F) {
        var N = this.curve.p.byteLength()
          , U = this.getX().toArray("be", N);
        return F ? [this.getY().isEven() ? 2 : 3].concat(U) : [4].concat(U, this.getY().toArray("be", N))
    }
    ,
    B.prototype.encode = function(F, N) {
        return S.encode(this._encode(N), F)
    }
    ,
    B.prototype.precompute = function(F) {
        if (this.precomputed)
            return this;
        var N = {
            doubles: null,
            naf: null,
            beta: null
        };
        return N.naf = this._getNAFPoints(8),
        N.doubles = this._getDoubles(4, F),
        N.beta = this._getBeta(),
        this.precomputed = N,
        this
    }
    ,
    B.prototype._hasDoubles = function(F) {
        if (!this.precomputed)
            return !1;
        var N = this.precomputed.doubles;
        return N ? N.points.length >= Math.ceil((F.bitLength() + 1) / N.step) : !1
    }
    ,
    B.prototype._getDoubles = function(F, N) {
        if (this.precomputed && this.precomputed.doubles)
            return this.precomputed.doubles;
        for (var U = [this], H = this, Z = 0; Z < N; Z += F) {
            for (var J = 0; J < F; J++)
                H = H.dbl();
            U.push(H)
        }
        return {
            step: F,
            points: U
        }
    }
    ,
    B.prototype._getNAFPoints = function(F) {
        if (this.precomputed && this.precomputed.naf)
            return this.precomputed.naf;
        for (var N = [this], U = (1 << F) - 1, H = U === 1 ? null : this.dbl(), Z = 1; Z < U; Z++)
            N[Z] = N[Z - 1].add(H);
        return {
            wnd: F,
            points: N
        }
    }
    ,
    B.prototype._getBeta = function() {
        return null
    }
    ,
    B.prototype.dblp = function(F) {
        for (var N = this, U = 0; U < F; U++)
            N = N.dbl();
        return N
    }
    ,
    base$1
}
var short, hasRequiredShort;
function requireShort() {
    if (hasRequiredShort)
        return short;
    hasRequiredShort = 1;
    var C = requireUtils$1()
      , S = requireBn$2()
      , E = requireInherits_browser()
      , M = requireBase$1()
      , T = C.assert;
    function $(F) {
        M.call(this, "short", F),
        this.a = new S(F.a,16).toRed(this.red),
        this.b = new S(F.b,16).toRed(this.red),
        this.tinv = this.two.redInvm(),
        this.zeroA = this.a.fromRed().cmpn(0) === 0,
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0,
        this.endo = this._getEndomorphism(F),
        this._endoWnafT1 = new Array(4),
        this._endoWnafT2 = new Array(4)
    }
    E($, M),
    short = $,
    $.prototype._getEndomorphism = function(N) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var U, H;
            if (N.beta)
                U = new S(N.beta,16).toRed(this.red);
            else {
                var Z = this._getEndoRoots(this.p);
                U = Z[0].cmp(Z[1]) < 0 ? Z[0] : Z[1],
                U = U.toRed(this.red)
            }
            if (N.lambda)
                H = new S(N.lambda,16);
            else {
                var J = this._getEndoRoots(this.n);
                this.g.mul(J[0]).x.cmp(this.g.x.redMul(U)) === 0 ? H = J[0] : (H = J[1],
                T(this.g.mul(H).x.cmp(this.g.x.redMul(U)) === 0))
            }
            var ie;
            return N.basis ? ie = N.basis.map(function(oe) {
                return {
                    a: new S(oe.a,16),
                    b: new S(oe.b,16)
                }
            }) : ie = this._getEndoBasis(H),
            {
                beta: U,
                lambda: H,
                basis: ie
            }
        }
    }
    ,
    $.prototype._getEndoRoots = function(N) {
        var U = N === this.p ? this.red : S.mont(N)
          , H = new S(2).toRed(U).redInvm()
          , Z = H.redNeg()
          , J = new S(3).toRed(U).redNeg().redSqrt().redMul(H)
          , ie = Z.redAdd(J).fromRed()
          , oe = Z.redSub(J).fromRed();
        return [ie, oe]
    }
    ,
    $.prototype._getEndoBasis = function(N) {
        for (var U = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), H = N, Z = this.n.clone(), J = new S(1), ie = new S(0), oe = new S(0), ae = new S(1), se, le, de, fe, pe, ge, we, Ae = 0, Se, ue; H.cmpn(0) !== 0; ) {
            var V = Z.div(H);
            Se = Z.sub(V.mul(H)),
            ue = oe.sub(V.mul(J));
            var W = ae.sub(V.mul(ie));
            if (!de && Se.cmp(U) < 0)
                se = we.neg(),
                le = J,
                de = Se.neg(),
                fe = ue;
            else if (de && ++Ae === 2)
                break;
            we = Se,
            Z = H,
            H = Se,
            oe = J,
            J = ue,
            ae = ie,
            ie = W
        }
        pe = Se.neg(),
        ge = ue;
        var D = de.sqr().add(fe.sqr())
          , I = pe.sqr().add(ge.sqr());
        return I.cmp(D) >= 0 && (pe = se,
        ge = le),
        de.negative && (de = de.neg(),
        fe = fe.neg()),
        pe.negative && (pe = pe.neg(),
        ge = ge.neg()),
        [{
            a: de,
            b: fe
        }, {
            a: pe,
            b: ge
        }]
    }
    ,
    $.prototype._endoSplit = function(N) {
        var U = this.endo.basis
          , H = U[0]
          , Z = U[1]
          , J = Z.b.mul(N).divRound(this.n)
          , ie = H.b.neg().mul(N).divRound(this.n)
          , oe = J.mul(H.a)
          , ae = ie.mul(Z.a)
          , se = J.mul(H.b)
          , le = ie.mul(Z.b)
          , de = N.sub(oe).sub(ae)
          , fe = se.add(le).neg();
        return {
            k1: de,
            k2: fe
        }
    }
    ,
    $.prototype.pointFromX = function(N, U) {
        N = new S(N,16),
        N.red || (N = N.toRed(this.red));
        var H = N.redSqr().redMul(N).redIAdd(N.redMul(this.a)).redIAdd(this.b)
          , Z = H.redSqrt();
        if (Z.redSqr().redSub(H).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var J = Z.fromRed().isOdd();
        return (U && !J || !U && J) && (Z = Z.redNeg()),
        this.point(N, Z)
    }
    ,
    $.prototype.validate = function(N) {
        if (N.inf)
            return !0;
        var U = N.x
          , H = N.y
          , Z = this.a.redMul(U)
          , J = U.redSqr().redMul(U).redIAdd(Z).redIAdd(this.b);
        return H.redSqr().redISub(J).cmpn(0) === 0
    }
    ,
    $.prototype._endoWnafMulAdd = function(N, U, H) {
        for (var Z = this._endoWnafT1, J = this._endoWnafT2, ie = 0; ie < N.length; ie++) {
            var oe = this._endoSplit(U[ie])
              , ae = N[ie]
              , se = ae._getBeta();
            oe.k1.negative && (oe.k1.ineg(),
            ae = ae.neg(!0)),
            oe.k2.negative && (oe.k2.ineg(),
            se = se.neg(!0)),
            Z[ie * 2] = ae,
            Z[ie * 2 + 1] = se,
            J[ie * 2] = oe.k1,
            J[ie * 2 + 1] = oe.k2
        }
        for (var le = this._wnafMulAdd(1, Z, J, ie * 2, H), de = 0; de < ie * 2; de++)
            Z[de] = null,
            J[de] = null;
        return le
    }
    ;
    function B(F, N, U, H) {
        M.BasePoint.call(this, F, "affine"),
        N === null && U === null ? (this.x = null,
        this.y = null,
        this.inf = !0) : (this.x = new S(N,16),
        this.y = new S(U,16),
        H && (this.x.forceRed(this.curve.red),
        this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.inf = !1)
    }
    E(B, M.BasePoint),
    $.prototype.point = function(N, U, H) {
        return new B(this,N,U,H)
    }
    ,
    $.prototype.pointFromJSON = function(N, U) {
        return B.fromJSON(this, N, U)
    }
    ,
    B.prototype._getBeta = function() {
        if (this.curve.endo) {
            var N = this.precomputed;
            if (N && N.beta)
                return N.beta;
            var U = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (N) {
                var H = this.curve
                  , Z = function(J) {
                    return H.point(J.x.redMul(H.endo.beta), J.y)
                };
                N.beta = U,
                U.precomputed = {
                    beta: null,
                    naf: N.naf && {
                        wnd: N.naf.wnd,
                        points: N.naf.points.map(Z)
                    },
                    doubles: N.doubles && {
                        step: N.doubles.step,
                        points: N.doubles.points.map(Z)
                    }
                }
            }
            return U
        }
    }
    ,
    B.prototype.toJSON = function() {
        return this.precomputed ? [this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }] : [this.x, this.y]
    }
    ,
    B.fromJSON = function(N, U, H) {
        typeof U == "string" && (U = JSON.parse(U));
        var Z = N.point(U[0], U[1], H);
        if (!U[2])
            return Z;
        function J(oe) {
            return N.point(oe[0], oe[1], H)
        }
        var ie = U[2];
        return Z.precomputed = {
            beta: null,
            doubles: ie.doubles && {
                step: ie.doubles.step,
                points: [Z].concat(ie.doubles.points.map(J))
            },
            naf: ie.naf && {
                wnd: ie.naf.wnd,
                points: [Z].concat(ie.naf.points.map(J))
            }
        },
        Z
    }
    ,
    B.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
    }
    ,
    B.prototype.isInfinity = function() {
        return this.inf
    }
    ,
    B.prototype.add = function(N) {
        if (this.inf)
            return N;
        if (N.inf)
            return this;
        if (this.eq(N))
            return this.dbl();
        if (this.neg().eq(N))
            return this.curve.point(null, null);
        if (this.x.cmp(N.x) === 0)
            return this.curve.point(null, null);
        var U = this.y.redSub(N.y);
        U.cmpn(0) !== 0 && (U = U.redMul(this.x.redSub(N.x).redInvm()));
        var H = U.redSqr().redISub(this.x).redISub(N.x)
          , Z = U.redMul(this.x.redSub(H)).redISub(this.y);
        return this.curve.point(H, Z)
    }
    ,
    B.prototype.dbl = function() {
        if (this.inf)
            return this;
        var N = this.y.redAdd(this.y);
        if (N.cmpn(0) === 0)
            return this.curve.point(null, null);
        var U = this.curve.a
          , H = this.x.redSqr()
          , Z = N.redInvm()
          , J = H.redAdd(H).redIAdd(H).redIAdd(U).redMul(Z)
          , ie = J.redSqr().redISub(this.x.redAdd(this.x))
          , oe = J.redMul(this.x.redSub(ie)).redISub(this.y);
        return this.curve.point(ie, oe)
    }
    ,
    B.prototype.getX = function() {
        return this.x.fromRed()
    }
    ,
    B.prototype.getY = function() {
        return this.y.fromRed()
    }
    ,
    B.prototype.mul = function(N) {
        return N = new S(N,16),
        this.isInfinity() ? this : this._hasDoubles(N) ? this.curve._fixedNafMul(this, N) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [N]) : this.curve._wnafMul(this, N)
    }
    ,
    B.prototype.mulAdd = function(N, U, H) {
        var Z = [this, U]
          , J = [N, H];
        return this.curve.endo ? this.curve._endoWnafMulAdd(Z, J) : this.curve._wnafMulAdd(1, Z, J, 2)
    }
    ,
    B.prototype.jmulAdd = function(N, U, H) {
        var Z = [this, U]
          , J = [N, H];
        return this.curve.endo ? this.curve._endoWnafMulAdd(Z, J, !0) : this.curve._wnafMulAdd(1, Z, J, 2, !0)
    }
    ,
    B.prototype.eq = function(N) {
        return this === N || this.inf === N.inf && (this.inf || this.x.cmp(N.x) === 0 && this.y.cmp(N.y) === 0)
    }
    ,
    B.prototype.neg = function(N) {
        if (this.inf)
            return this;
        var U = this.curve.point(this.x, this.y.redNeg());
        if (N && this.precomputed) {
            var H = this.precomputed
              , Z = function(J) {
                return J.neg()
            };
            U.precomputed = {
                naf: H.naf && {
                    wnd: H.naf.wnd,
                    points: H.naf.points.map(Z)
                },
                doubles: H.doubles && {
                    step: H.doubles.step,
                    points: H.doubles.points.map(Z)
                }
            }
        }
        return U
    }
    ,
    B.prototype.toJ = function() {
        if (this.inf)
            return this.curve.jpoint(null, null, null);
        var N = this.curve.jpoint(this.x, this.y, this.curve.one);
        return N
    }
    ;
    function O(F, N, U, H) {
        M.BasePoint.call(this, F, "jacobian"),
        N === null && U === null && H === null ? (this.x = this.curve.one,
        this.y = this.curve.one,
        this.z = new S(0)) : (this.x = new S(N,16),
        this.y = new S(U,16),
        this.z = new S(H,16)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one
    }
    return E(O, M.BasePoint),
    $.prototype.jpoint = function(N, U, H) {
        return new O(this,N,U,H)
    }
    ,
    O.prototype.toP = function() {
        if (this.isInfinity())
            return this.curve.point(null, null);
        var N = this.z.redInvm()
          , U = N.redSqr()
          , H = this.x.redMul(U)
          , Z = this.y.redMul(U).redMul(N);
        return this.curve.point(H, Z)
    }
    ,
    O.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }
    ,
    O.prototype.add = function(N) {
        if (this.isInfinity())
            return N;
        if (N.isInfinity())
            return this;
        var U = N.z.redSqr()
          , H = this.z.redSqr()
          , Z = this.x.redMul(U)
          , J = N.x.redMul(H)
          , ie = this.y.redMul(U.redMul(N.z))
          , oe = N.y.redMul(H.redMul(this.z))
          , ae = Z.redSub(J)
          , se = ie.redSub(oe);
        if (ae.cmpn(0) === 0)
            return se.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var le = ae.redSqr()
          , de = le.redMul(ae)
          , fe = Z.redMul(le)
          , pe = se.redSqr().redIAdd(de).redISub(fe).redISub(fe)
          , ge = se.redMul(fe.redISub(pe)).redISub(ie.redMul(de))
          , we = this.z.redMul(N.z).redMul(ae);
        return this.curve.jpoint(pe, ge, we)
    }
    ,
    O.prototype.mixedAdd = function(N) {
        if (this.isInfinity())
            return N.toJ();
        if (N.isInfinity())
            return this;
        var U = this.z.redSqr()
          , H = this.x
          , Z = N.x.redMul(U)
          , J = this.y
          , ie = N.y.redMul(U).redMul(this.z)
          , oe = H.redSub(Z)
          , ae = J.redSub(ie);
        if (oe.cmpn(0) === 0)
            return ae.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var se = oe.redSqr()
          , le = se.redMul(oe)
          , de = H.redMul(se)
          , fe = ae.redSqr().redIAdd(le).redISub(de).redISub(de)
          , pe = ae.redMul(de.redISub(fe)).redISub(J.redMul(le))
          , ge = this.z.redMul(oe);
        return this.curve.jpoint(fe, pe, ge)
    }
    ,
    O.prototype.dblp = function(N) {
        if (N === 0)
            return this;
        if (this.isInfinity())
            return this;
        if (!N)
            return this.dbl();
        var U;
        if (this.curve.zeroA || this.curve.threeA) {
            var H = this;
            for (U = 0; U < N; U++)
                H = H.dbl();
            return H
        }
        var Z = this.curve.a
          , J = this.curve.tinv
          , ie = this.x
          , oe = this.y
          , ae = this.z
          , se = ae.redSqr().redSqr()
          , le = oe.redAdd(oe);
        for (U = 0; U < N; U++) {
            var de = ie.redSqr()
              , fe = le.redSqr()
              , pe = fe.redSqr()
              , ge = de.redAdd(de).redIAdd(de).redIAdd(Z.redMul(se))
              , we = ie.redMul(fe)
              , Ae = ge.redSqr().redISub(we.redAdd(we))
              , Se = we.redISub(Ae)
              , ue = ge.redMul(Se);
            ue = ue.redIAdd(ue).redISub(pe);
            var V = le.redMul(ae);
            U + 1 < N && (se = se.redMul(pe)),
            ie = Ae,
            ae = V,
            le = ue
        }
        return this.curve.jpoint(ie, le.redMul(J), ae)
    }
    ,
    O.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
    }
    ,
    O.prototype._zeroDbl = function() {
        var N, U, H;
        if (this.zOne) {
            var Z = this.x.redSqr()
              , J = this.y.redSqr()
              , ie = J.redSqr()
              , oe = this.x.redAdd(J).redSqr().redISub(Z).redISub(ie);
            oe = oe.redIAdd(oe);
            var ae = Z.redAdd(Z).redIAdd(Z)
              , se = ae.redSqr().redISub(oe).redISub(oe)
              , le = ie.redIAdd(ie);
            le = le.redIAdd(le),
            le = le.redIAdd(le),
            N = se,
            U = ae.redMul(oe.redISub(se)).redISub(le),
            H = this.y.redAdd(this.y)
        } else {
            var de = this.x.redSqr()
              , fe = this.y.redSqr()
              , pe = fe.redSqr()
              , ge = this.x.redAdd(fe).redSqr().redISub(de).redISub(pe);
            ge = ge.redIAdd(ge);
            var we = de.redAdd(de).redIAdd(de)
              , Ae = we.redSqr()
              , Se = pe.redIAdd(pe);
            Se = Se.redIAdd(Se),
            Se = Se.redIAdd(Se),
            N = Ae.redISub(ge).redISub(ge),
            U = we.redMul(ge.redISub(N)).redISub(Se),
            H = this.y.redMul(this.z),
            H = H.redIAdd(H)
        }
        return this.curve.jpoint(N, U, H)
    }
    ,
    O.prototype._threeDbl = function() {
        var N, U, H;
        if (this.zOne) {
            var Z = this.x.redSqr()
              , J = this.y.redSqr()
              , ie = J.redSqr()
              , oe = this.x.redAdd(J).redSqr().redISub(Z).redISub(ie);
            oe = oe.redIAdd(oe);
            var ae = Z.redAdd(Z).redIAdd(Z).redIAdd(this.curve.a)
              , se = ae.redSqr().redISub(oe).redISub(oe);
            N = se;
            var le = ie.redIAdd(ie);
            le = le.redIAdd(le),
            le = le.redIAdd(le),
            U = ae.redMul(oe.redISub(se)).redISub(le),
            H = this.y.redAdd(this.y)
        } else {
            var de = this.z.redSqr()
              , fe = this.y.redSqr()
              , pe = this.x.redMul(fe)
              , ge = this.x.redSub(de).redMul(this.x.redAdd(de));
            ge = ge.redAdd(ge).redIAdd(ge);
            var we = pe.redIAdd(pe);
            we = we.redIAdd(we);
            var Ae = we.redAdd(we);
            N = ge.redSqr().redISub(Ae),
            H = this.y.redAdd(this.z).redSqr().redISub(fe).redISub(de);
            var Se = fe.redSqr();
            Se = Se.redIAdd(Se),
            Se = Se.redIAdd(Se),
            Se = Se.redIAdd(Se),
            U = ge.redMul(we.redISub(N)).redISub(Se)
        }
        return this.curve.jpoint(N, U, H)
    }
    ,
    O.prototype._dbl = function() {
        var N = this.curve.a
          , U = this.x
          , H = this.y
          , Z = this.z
          , J = Z.redSqr().redSqr()
          , ie = U.redSqr()
          , oe = H.redSqr()
          , ae = ie.redAdd(ie).redIAdd(ie).redIAdd(N.redMul(J))
          , se = U.redAdd(U);
        se = se.redIAdd(se);
        var le = se.redMul(oe)
          , de = ae.redSqr().redISub(le.redAdd(le))
          , fe = le.redISub(de)
          , pe = oe.redSqr();
        pe = pe.redIAdd(pe),
        pe = pe.redIAdd(pe),
        pe = pe.redIAdd(pe);
        var ge = ae.redMul(fe).redISub(pe)
          , we = H.redAdd(H).redMul(Z);
        return this.curve.jpoint(de, ge, we)
    }
    ,
    O.prototype.trpl = function() {
        if (!this.curve.zeroA)
            return this.dbl().add(this);
        var N = this.x.redSqr()
          , U = this.y.redSqr()
          , H = this.z.redSqr()
          , Z = U.redSqr()
          , J = N.redAdd(N).redIAdd(N)
          , ie = J.redSqr()
          , oe = this.x.redAdd(U).redSqr().redISub(N).redISub(Z);
        oe = oe.redIAdd(oe),
        oe = oe.redAdd(oe).redIAdd(oe),
        oe = oe.redISub(ie);
        var ae = oe.redSqr()
          , se = Z.redIAdd(Z);
        se = se.redIAdd(se),
        se = se.redIAdd(se),
        se = se.redIAdd(se);
        var le = J.redIAdd(oe).redSqr().redISub(ie).redISub(ae).redISub(se)
          , de = U.redMul(le);
        de = de.redIAdd(de),
        de = de.redIAdd(de);
        var fe = this.x.redMul(ae).redISub(de);
        fe = fe.redIAdd(fe),
        fe = fe.redIAdd(fe);
        var pe = this.y.redMul(le.redMul(se.redISub(le)).redISub(oe.redMul(ae)));
        pe = pe.redIAdd(pe),
        pe = pe.redIAdd(pe),
        pe = pe.redIAdd(pe);
        var ge = this.z.redAdd(oe).redSqr().redISub(H).redISub(ae);
        return this.curve.jpoint(fe, pe, ge)
    }
    ,
    O.prototype.mul = function(N, U) {
        return N = new S(N,U),
        this.curve._wnafMul(this, N)
    }
    ,
    O.prototype.eq = function(N) {
        if (N.type === "affine")
            return this.eq(N.toJ());
        if (this === N)
            return !0;
        var U = this.z.redSqr()
          , H = N.z.redSqr();
        if (this.x.redMul(H).redISub(N.x.redMul(U)).cmpn(0) !== 0)
            return !1;
        var Z = U.redMul(this.z)
          , J = H.redMul(N.z);
        return this.y.redMul(J).redISub(N.y.redMul(Z)).cmpn(0) === 0
    }
    ,
    O.prototype.eqXToP = function(N) {
        var U = this.z.redSqr()
          , H = N.toRed(this.curve.red).redMul(U);
        if (this.x.cmp(H) === 0)
            return !0;
        for (var Z = N.clone(), J = this.curve.redN.redMul(U); ; ) {
            if (Z.iadd(this.curve.n),
            Z.cmp(this.curve.p) >= 0)
                return !1;
            if (H.redIAdd(J),
            this.x.cmp(H) === 0)
                return !0
        }
    }
    ,
    O.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
    }
    ,
    O.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    short
}
var mont, hasRequiredMont;
function requireMont() {
    if (hasRequiredMont)
        return mont;
    hasRequiredMont = 1;
    var C = requireBn$2()
      , S = requireInherits_browser()
      , E = requireBase$1()
      , M = requireUtils$1();
    function T(B) {
        E.call(this, "mont", B),
        this.a = new C(B.a,16).toRed(this.red),
        this.b = new C(B.b,16).toRed(this.red),
        this.i4 = new C(4).toRed(this.red).redInvm(),
        this.two = new C(2).toRed(this.red),
        this.a24 = this.i4.redMul(this.a.redAdd(this.two))
    }
    S(T, E),
    mont = T,
    T.prototype.validate = function(O) {
        var F = O.normalize().x
          , N = F.redSqr()
          , U = N.redMul(F).redAdd(N.redMul(this.a)).redAdd(F)
          , H = U.redSqrt();
        return H.redSqr().cmp(U) === 0
    }
    ;
    function $(B, O, F) {
        E.BasePoint.call(this, B, "projective"),
        O === null && F === null ? (this.x = this.curve.one,
        this.z = this.curve.zero) : (this.x = new C(O,16),
        this.z = new C(F,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)))
    }
    return S($, E.BasePoint),
    T.prototype.decodePoint = function(O, F) {
        return this.point(M.toArray(O, F), 1)
    }
    ,
    T.prototype.point = function(O, F) {
        return new $(this,O,F)
    }
    ,
    T.prototype.pointFromJSON = function(O) {
        return $.fromJSON(this, O)
    }
    ,
    $.prototype.precompute = function() {}
    ,
    $.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength())
    }
    ,
    $.fromJSON = function(O, F) {
        return new $(O,F[0],F[1] || O.one)
    }
    ,
    $.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    $.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0
    }
    ,
    $.prototype.dbl = function() {
        var O = this.x.redAdd(this.z)
          , F = O.redSqr()
          , N = this.x.redSub(this.z)
          , U = N.redSqr()
          , H = F.redSub(U)
          , Z = F.redMul(U)
          , J = H.redMul(U.redAdd(this.curve.a24.redMul(H)));
        return this.curve.point(Z, J)
    }
    ,
    $.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    $.prototype.diffAdd = function(O, F) {
        var N = this.x.redAdd(this.z)
          , U = this.x.redSub(this.z)
          , H = O.x.redAdd(O.z)
          , Z = O.x.redSub(O.z)
          , J = Z.redMul(N)
          , ie = H.redMul(U)
          , oe = F.z.redMul(J.redAdd(ie).redSqr())
          , ae = F.x.redMul(J.redISub(ie).redSqr());
        return this.curve.point(oe, ae)
    }
    ,
    $.prototype.mul = function(O) {
        for (var F = O.clone(), N = this, U = this.curve.point(null, null), H = this, Z = []; F.cmpn(0) !== 0; F.iushrn(1))
            Z.push(F.andln(1));
        for (var J = Z.length - 1; J >= 0; J--)
            Z[J] === 0 ? (N = N.diffAdd(U, H),
            U = U.dbl()) : (U = N.diffAdd(U, H),
            N = N.dbl());
        return U
    }
    ,
    $.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    $.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve")
    }
    ,
    $.prototype.eq = function(O) {
        return this.getX().cmp(O.getX()) === 0
    }
    ,
    $.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()),
        this.z = this.curve.one,
        this
    }
    ,
    $.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    mont
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
    if (hasRequiredEdwards)
        return edwards;
    hasRequiredEdwards = 1;
    var C = requireUtils$1()
      , S = requireBn$2()
      , E = requireInherits_browser()
      , M = requireBase$1()
      , T = C.assert;
    function $(O) {
        this.twisted = (O.a | 0) !== 1,
        this.mOneA = this.twisted && (O.a | 0) === -1,
        this.extended = this.mOneA,
        M.call(this, "edwards", O),
        this.a = new S(O.a,16).umod(this.red.m),
        this.a = this.a.toRed(this.red),
        this.c = new S(O.c,16).toRed(this.red),
        this.c2 = this.c.redSqr(),
        this.d = new S(O.d,16).toRed(this.red),
        this.dd = this.d.redAdd(this.d),
        T(!this.twisted || this.c.fromRed().cmpn(1) === 0),
        this.oneC = (O.c | 0) === 1
    }
    E($, M),
    edwards = $,
    $.prototype._mulA = function(F) {
        return this.mOneA ? F.redNeg() : this.a.redMul(F)
    }
    ,
    $.prototype._mulC = function(F) {
        return this.oneC ? F : this.c.redMul(F)
    }
    ,
    $.prototype.jpoint = function(F, N, U, H) {
        return this.point(F, N, U, H)
    }
    ,
    $.prototype.pointFromX = function(F, N) {
        F = new S(F,16),
        F.red || (F = F.toRed(this.red));
        var U = F.redSqr()
          , H = this.c2.redSub(this.a.redMul(U))
          , Z = this.one.redSub(this.c2.redMul(this.d).redMul(U))
          , J = H.redMul(Z.redInvm())
          , ie = J.redSqrt();
        if (ie.redSqr().redSub(J).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        var oe = ie.fromRed().isOdd();
        return (N && !oe || !N && oe) && (ie = ie.redNeg()),
        this.point(F, ie)
    }
    ,
    $.prototype.pointFromY = function(F, N) {
        F = new S(F,16),
        F.red || (F = F.toRed(this.red));
        var U = F.redSqr()
          , H = U.redSub(this.c2)
          , Z = U.redMul(this.d).redMul(this.c2).redSub(this.a)
          , J = H.redMul(Z.redInvm());
        if (J.cmp(this.zero) === 0) {
            if (N)
                throw new Error("invalid point");
            return this.point(this.zero, F)
        }
        var ie = J.redSqrt();
        if (ie.redSqr().redSub(J).cmp(this.zero) !== 0)
            throw new Error("invalid point");
        return ie.fromRed().isOdd() !== N && (ie = ie.redNeg()),
        this.point(ie, F)
    }
    ,
    $.prototype.validate = function(F) {
        if (F.isInfinity())
            return !0;
        F.normalize();
        var N = F.x.redSqr()
          , U = F.y.redSqr()
          , H = N.redMul(this.a).redAdd(U)
          , Z = this.c2.redMul(this.one.redAdd(this.d.redMul(N).redMul(U)));
        return H.cmp(Z) === 0
    }
    ;
    function B(O, F, N, U, H) {
        M.BasePoint.call(this, O, "projective"),
        F === null && N === null && U === null ? (this.x = this.curve.zero,
        this.y = this.curve.one,
        this.z = this.curve.one,
        this.t = this.curve.zero,
        this.zOne = !0) : (this.x = new S(F,16),
        this.y = new S(N,16),
        this.z = U ? new S(U,16) : this.curve.one,
        this.t = H && new S(H,16),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
        this.zOne = this.z === this.curve.one,
        this.curve.extended && !this.t && (this.t = this.x.redMul(this.y),
        this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
    }
    return E(B, M.BasePoint),
    $.prototype.pointFromJSON = function(F) {
        return B.fromJSON(this, F)
    }
    ,
    $.prototype.point = function(F, N, U, H) {
        return new B(this,F,N,U,H)
    }
    ,
    B.fromJSON = function(F, N) {
        return new B(F,N[0],N[1],N[2])
    }
    ,
    B.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }
    ,
    B.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
    }
    ,
    B.prototype._extDbl = function() {
        var F = this.x.redSqr()
          , N = this.y.redSqr()
          , U = this.z.redSqr();
        U = U.redIAdd(U);
        var H = this.curve._mulA(F)
          , Z = this.x.redAdd(this.y).redSqr().redISub(F).redISub(N)
          , J = H.redAdd(N)
          , ie = J.redSub(U)
          , oe = H.redSub(N)
          , ae = Z.redMul(ie)
          , se = J.redMul(oe)
          , le = Z.redMul(oe)
          , de = ie.redMul(J);
        return this.curve.point(ae, se, de, le)
    }
    ,
    B.prototype._projDbl = function() {
        var F = this.x.redAdd(this.y).redSqr(), N = this.x.redSqr(), U = this.y.redSqr(), H, Z, J, ie, oe, ae;
        if (this.curve.twisted) {
            ie = this.curve._mulA(N);
            var se = ie.redAdd(U);
            this.zOne ? (H = F.redSub(N).redSub(U).redMul(se.redSub(this.curve.two)),
            Z = se.redMul(ie.redSub(U)),
            J = se.redSqr().redSub(se).redSub(se)) : (oe = this.z.redSqr(),
            ae = se.redSub(oe).redISub(oe),
            H = F.redSub(N).redISub(U).redMul(ae),
            Z = se.redMul(ie.redSub(U)),
            J = se.redMul(ae))
        } else
            ie = N.redAdd(U),
            oe = this.curve._mulC(this.z).redSqr(),
            ae = ie.redSub(oe).redSub(oe),
            H = this.curve._mulC(F.redISub(ie)).redMul(ae),
            Z = this.curve._mulC(ie).redMul(N.redISub(U)),
            J = ie.redMul(ae);
        return this.curve.point(H, Z, J)
    }
    ,
    B.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
    }
    ,
    B.prototype._extAdd = function(F) {
        var N = this.y.redSub(this.x).redMul(F.y.redSub(F.x))
          , U = this.y.redAdd(this.x).redMul(F.y.redAdd(F.x))
          , H = this.t.redMul(this.curve.dd).redMul(F.t)
          , Z = this.z.redMul(F.z.redAdd(F.z))
          , J = U.redSub(N)
          , ie = Z.redSub(H)
          , oe = Z.redAdd(H)
          , ae = U.redAdd(N)
          , se = J.redMul(ie)
          , le = oe.redMul(ae)
          , de = J.redMul(ae)
          , fe = ie.redMul(oe);
        return this.curve.point(se, le, fe, de)
    }
    ,
    B.prototype._projAdd = function(F) {
        var N = this.z.redMul(F.z), U = N.redSqr(), H = this.x.redMul(F.x), Z = this.y.redMul(F.y), J = this.curve.d.redMul(H).redMul(Z), ie = U.redSub(J), oe = U.redAdd(J), ae = this.x.redAdd(this.y).redMul(F.x.redAdd(F.y)).redISub(H).redISub(Z), se = N.redMul(ie).redMul(ae), le, de;
        return this.curve.twisted ? (le = N.redMul(oe).redMul(Z.redSub(this.curve._mulA(H))),
        de = ie.redMul(oe)) : (le = N.redMul(oe).redMul(Z.redSub(H)),
        de = this.curve._mulC(ie).redMul(oe)),
        this.curve.point(se, le, de)
    }
    ,
    B.prototype.add = function(F) {
        return this.isInfinity() ? F : F.isInfinity() ? this : this.curve.extended ? this._extAdd(F) : this._projAdd(F)
    }
    ,
    B.prototype.mul = function(F) {
        return this._hasDoubles(F) ? this.curve._fixedNafMul(this, F) : this.curve._wnafMul(this, F)
    }
    ,
    B.prototype.mulAdd = function(F, N, U) {
        return this.curve._wnafMulAdd(1, [this, N], [F, U], 2, !1)
    }
    ,
    B.prototype.jmulAdd = function(F, N, U) {
        return this.curve._wnafMulAdd(1, [this, N], [F, U], 2, !0)
    }
    ,
    B.prototype.normalize = function() {
        if (this.zOne)
            return this;
        var F = this.z.redInvm();
        return this.x = this.x.redMul(F),
        this.y = this.y.redMul(F),
        this.t && (this.t = this.t.redMul(F)),
        this.z = this.curve.one,
        this.zOne = !0,
        this
    }
    ,
    B.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
    }
    ,
    B.prototype.getX = function() {
        return this.normalize(),
        this.x.fromRed()
    }
    ,
    B.prototype.getY = function() {
        return this.normalize(),
        this.y.fromRed()
    }
    ,
    B.prototype.eq = function(F) {
        return this === F || this.getX().cmp(F.getX()) === 0 && this.getY().cmp(F.getY()) === 0
    }
    ,
    B.prototype.eqXToP = function(F) {
        var N = F.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(N) === 0)
            return !0;
        for (var U = F.clone(), H = this.curve.redN.redMul(this.z); ; ) {
            if (U.iadd(this.curve.n),
            U.cmp(this.curve.p) >= 0)
                return !1;
            if (N.redIAdd(H),
            this.x.cmp(N) === 0)
                return !0
        }
    }
    ,
    B.prototype.toP = B.prototype.normalize,
    B.prototype.mixedAdd = B.prototype.add,
    edwards
}
var hasRequiredCurve;
function requireCurve() {
    return hasRequiredCurve || (hasRequiredCurve = 1,
    function(C) {
        var S = C;
        S.base = requireBase$1(),
        S.short = requireShort(),
        S.mont = requireMont(),
        S.edwards = requireEdwards()
    }(curve)),
    curve
}
var curves = {}, hash$1 = {}, utils$3 = {}, hasRequiredUtils;
function requireUtils() {
    if (hasRequiredUtils)
        return utils$3;
    hasRequiredUtils = 1;
    var C = requireMinimalisticAssert()
      , S = requireInherits_browser();
    utils$3.inherits = S;
    function E(W, D) {
        return (W.charCodeAt(D) & 64512) !== 55296 || D < 0 || D + 1 >= W.length ? !1 : (W.charCodeAt(D + 1) & 64512) === 56320
    }
    function M(W, D) {
        if (Array.isArray(W))
            return W.slice();
        if (!W)
            return [];
        var I = [];
        if (typeof W == "string")
            if (D) {
                if (D === "hex")
                    for (W = W.replace(/[^a-z0-9]+/ig, ""),
                    W.length % 2 !== 0 && (W = "0" + W),
                    K = 0; K < W.length; K += 2)
                        I.push(parseInt(W[K] + W[K + 1], 16))
            } else
                for (var L = 0, K = 0; K < W.length; K++) {
                    var X = W.charCodeAt(K);
                    X < 128 ? I[L++] = X : X < 2048 ? (I[L++] = X >> 6 | 192,
                    I[L++] = X & 63 | 128) : E(W, K) ? (X = 65536 + ((X & 1023) << 10) + (W.charCodeAt(++K) & 1023),
                    I[L++] = X >> 18 | 240,
                    I[L++] = X >> 12 & 63 | 128,
                    I[L++] = X >> 6 & 63 | 128,
                    I[L++] = X & 63 | 128) : (I[L++] = X >> 12 | 224,
                    I[L++] = X >> 6 & 63 | 128,
                    I[L++] = X & 63 | 128)
                }
        else
            for (K = 0; K < W.length; K++)
                I[K] = W[K] | 0;
        return I
    }
    utils$3.toArray = M;
    function T(W) {
        for (var D = "", I = 0; I < W.length; I++)
            D += O(W[I].toString(16));
        return D
    }
    utils$3.toHex = T;
    function $(W) {
        var D = W >>> 24 | W >>> 8 & 65280 | W << 8 & 16711680 | (W & 255) << 24;
        return D >>> 0
    }
    utils$3.htonl = $;
    function B(W, D) {
        for (var I = "", L = 0; L < W.length; L++) {
            var K = W[L];
            D === "little" && (K = $(K)),
            I += F(K.toString(16))
        }
        return I
    }
    utils$3.toHex32 = B;
    function O(W) {
        return W.length === 1 ? "0" + W : W
    }
    utils$3.zero2 = O;
    function F(W) {
        return W.length === 7 ? "0" + W : W.length === 6 ? "00" + W : W.length === 5 ? "000" + W : W.length === 4 ? "0000" + W : W.length === 3 ? "00000" + W : W.length === 2 ? "000000" + W : W.length === 1 ? "0000000" + W : W
    }
    utils$3.zero8 = F;
    function N(W, D, I, L) {
        var K = I - D;
        C(K % 4 === 0);
        for (var X = new Array(K / 4), Y = 0, j = D; Y < X.length; Y++,
        j += 4) {
            var G;
            L === "big" ? G = W[j] << 24 | W[j + 1] << 16 | W[j + 2] << 8 | W[j + 3] : G = W[j + 3] << 24 | W[j + 2] << 16 | W[j + 1] << 8 | W[j],
            X[Y] = G >>> 0
        }
        return X
    }
    utils$3.join32 = N;
    function U(W, D) {
        for (var I = new Array(W.length * 4), L = 0, K = 0; L < W.length; L++,
        K += 4) {
            var X = W[L];
            D === "big" ? (I[K] = X >>> 24,
            I[K + 1] = X >>> 16 & 255,
            I[K + 2] = X >>> 8 & 255,
            I[K + 3] = X & 255) : (I[K + 3] = X >>> 24,
            I[K + 2] = X >>> 16 & 255,
            I[K + 1] = X >>> 8 & 255,
            I[K] = X & 255)
        }
        return I
    }
    utils$3.split32 = U;
    function H(W, D) {
        return W >>> D | W << 32 - D
    }
    utils$3.rotr32 = H;
    function Z(W, D) {
        return W << D | W >>> 32 - D
    }
    utils$3.rotl32 = Z;
    function J(W, D) {
        return W + D >>> 0
    }
    utils$3.sum32 = J;
    function ie(W, D, I) {
        return W + D + I >>> 0
    }
    utils$3.sum32_3 = ie;
    function oe(W, D, I, L) {
        return W + D + I + L >>> 0
    }
    utils$3.sum32_4 = oe;
    function ae(W, D, I, L, K) {
        return W + D + I + L + K >>> 0
    }
    utils$3.sum32_5 = ae;
    function se(W, D, I, L) {
        var K = W[D]
          , X = W[D + 1]
          , Y = L + X >>> 0
          , j = (Y < L ? 1 : 0) + I + K;
        W[D] = j >>> 0,
        W[D + 1] = Y
    }
    utils$3.sum64 = se;
    function le(W, D, I, L) {
        var K = D + L >>> 0
          , X = (K < D ? 1 : 0) + W + I;
        return X >>> 0
    }
    utils$3.sum64_hi = le;
    function de(W, D, I, L) {
        var K = D + L;
        return K >>> 0
    }
    utils$3.sum64_lo = de;
    function fe(W, D, I, L, K, X, Y, j) {
        var G = 0
          , ne = D;
        ne = ne + L >>> 0,
        G += ne < D ? 1 : 0,
        ne = ne + X >>> 0,
        G += ne < X ? 1 : 0,
        ne = ne + j >>> 0,
        G += ne < j ? 1 : 0;
        var te = W + I + K + Y + G;
        return te >>> 0
    }
    utils$3.sum64_4_hi = fe;
    function pe(W, D, I, L, K, X, Y, j) {
        var G = D + L + X + j;
        return G >>> 0
    }
    utils$3.sum64_4_lo = pe;
    function ge(W, D, I, L, K, X, Y, j, G, ne) {
        var te = 0
          , ce = D;
        ce = ce + L >>> 0,
        te += ce < D ? 1 : 0,
        ce = ce + X >>> 0,
        te += ce < X ? 1 : 0,
        ce = ce + j >>> 0,
        te += ce < j ? 1 : 0,
        ce = ce + ne >>> 0,
        te += ce < ne ? 1 : 0;
        var Ee = W + I + K + Y + G + te;
        return Ee >>> 0
    }
    utils$3.sum64_5_hi = ge;
    function we(W, D, I, L, K, X, Y, j, G, ne) {
        var te = D + L + X + j + ne;
        return te >>> 0
    }
    utils$3.sum64_5_lo = we;
    function Ae(W, D, I) {
        var L = D << 32 - I | W >>> I;
        return L >>> 0
    }
    utils$3.rotr64_hi = Ae;
    function Se(W, D, I) {
        var L = W << 32 - I | D >>> I;
        return L >>> 0
    }
    utils$3.rotr64_lo = Se;
    function ue(W, D, I) {
        return W >>> I
    }
    utils$3.shr64_hi = ue;
    function V(W, D, I) {
        var L = W << 32 - I | D >>> I;
        return L >>> 0
    }
    return utils$3.shr64_lo = V,
    utils$3
}
var common$4 = {}, hasRequiredCommon$1;
function requireCommon$1() {
    if (hasRequiredCommon$1)
        return common$4;
    hasRequiredCommon$1 = 1;
    var C = requireUtils()
      , S = requireMinimalisticAssert();
    function E() {
        this.pending = null,
        this.pendingTotal = 0,
        this.blockSize = this.constructor.blockSize,
        this.outSize = this.constructor.outSize,
        this.hmacStrength = this.constructor.hmacStrength,
        this.padLength = this.constructor.padLength / 8,
        this.endian = "big",
        this._delta8 = this.blockSize / 8,
        this._delta32 = this.blockSize / 32
    }
    return common$4.BlockHash = E,
    E.prototype.update = function(T, $) {
        if (T = C.toArray(T, $),
        this.pending ? this.pending = this.pending.concat(T) : this.pending = T,
        this.pendingTotal += T.length,
        this.pending.length >= this._delta8) {
            T = this.pending;
            var B = T.length % this._delta8;
            this.pending = T.slice(T.length - B, T.length),
            this.pending.length === 0 && (this.pending = null),
            T = C.join32(T, 0, T.length - B, this.endian);
            for (var O = 0; O < T.length; O += this._delta32)
                this._update(T, O, O + this._delta32)
        }
        return this
    }
    ,
    E.prototype.digest = function(T) {
        return this.update(this._pad()),
        S(this.pending === null),
        this._digest(T)
    }
    ,
    E.prototype._pad = function() {
        var T = this.pendingTotal
          , $ = this._delta8
          , B = $ - (T + this.padLength) % $
          , O = new Array(B + this.padLength);
        O[0] = 128;
        for (var F = 1; F < B; F++)
            O[F] = 0;
        if (T <<= 3,
        this.endian === "big") {
            for (var N = 8; N < this.padLength; N++)
                O[F++] = 0;
            O[F++] = 0,
            O[F++] = 0,
            O[F++] = 0,
            O[F++] = 0,
            O[F++] = T >>> 24 & 255,
            O[F++] = T >>> 16 & 255,
            O[F++] = T >>> 8 & 255,
            O[F++] = T & 255
        } else
            for (O[F++] = T & 255,
            O[F++] = T >>> 8 & 255,
            O[F++] = T >>> 16 & 255,
            O[F++] = T >>> 24 & 255,
            O[F++] = 0,
            O[F++] = 0,
            O[F++] = 0,
            O[F++] = 0,
            N = 8; N < this.padLength; N++)
                O[F++] = 0;
        return O
    }
    ,
    common$4
}
var sha = {}, common$3 = {}, hasRequiredCommon;
function requireCommon() {
    if (hasRequiredCommon)
        return common$3;
    hasRequiredCommon = 1;
    var C = requireUtils()
      , S = C.rotr32;
    function E(U, H, Z, J) {
        if (U === 0)
            return M(H, Z, J);
        if (U === 1 || U === 3)
            return $(H, Z, J);
        if (U === 2)
            return T(H, Z, J)
    }
    common$3.ft_1 = E;
    function M(U, H, Z) {
        return U & H ^ ~U & Z
    }
    common$3.ch32 = M;
    function T(U, H, Z) {
        return U & H ^ U & Z ^ H & Z
    }
    common$3.maj32 = T;
    function $(U, H, Z) {
        return U ^ H ^ Z
    }
    common$3.p32 = $;
    function B(U) {
        return S(U, 2) ^ S(U, 13) ^ S(U, 22)
    }
    common$3.s0_256 = B;
    function O(U) {
        return S(U, 6) ^ S(U, 11) ^ S(U, 25)
    }
    common$3.s1_256 = O;
    function F(U) {
        return S(U, 7) ^ S(U, 18) ^ U >>> 3
    }
    common$3.g0_256 = F;
    function N(U) {
        return S(U, 17) ^ S(U, 19) ^ U >>> 10
    }
    return common$3.g1_256 = N,
    common$3
}
var _1, hasRequired_1;
function require_1() {
    if (hasRequired_1)
        return _1;
    hasRequired_1 = 1;
    var C = requireUtils()
      , S = requireCommon$1()
      , E = requireCommon()
      , M = C.rotl32
      , T = C.sum32
      , $ = C.sum32_5
      , B = E.ft_1
      , O = S.BlockHash
      , F = [1518500249, 1859775393, 2400959708, 3395469782];
    function N() {
        if (!(this instanceof N))
            return new N;
        O.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.W = new Array(80)
    }
    return C.inherits(N, O),
    _1 = N,
    N.blockSize = 512,
    N.outSize = 160,
    N.hmacStrength = 80,
    N.padLength = 64,
    N.prototype._update = function(H, Z) {
        for (var J = this.W, ie = 0; ie < 16; ie++)
            J[ie] = H[Z + ie];
        for (; ie < J.length; ie++)
            J[ie] = M(J[ie - 3] ^ J[ie - 8] ^ J[ie - 14] ^ J[ie - 16], 1);
        var oe = this.h[0]
          , ae = this.h[1]
          , se = this.h[2]
          , le = this.h[3]
          , de = this.h[4];
        for (ie = 0; ie < J.length; ie++) {
            var fe = ~~(ie / 20)
              , pe = $(M(oe, 5), B(fe, ae, se, le), de, J[ie], F[fe]);
            de = le,
            le = se,
            se = M(ae, 30),
            ae = oe,
            oe = pe
        }
        this.h[0] = T(this.h[0], oe),
        this.h[1] = T(this.h[1], ae),
        this.h[2] = T(this.h[2], se),
        this.h[3] = T(this.h[3], le),
        this.h[4] = T(this.h[4], de)
    }
    ,
    N.prototype._digest = function(H) {
        return H === "hex" ? C.toHex32(this.h, "big") : C.split32(this.h, "big")
    }
    ,
    _1
}
var _256, hasRequired_256;
function require_256() {
    if (hasRequired_256)
        return _256;
    hasRequired_256 = 1;
    var C = requireUtils()
      , S = requireCommon$1()
      , E = requireCommon()
      , M = requireMinimalisticAssert()
      , T = C.sum32
      , $ = C.sum32_4
      , B = C.sum32_5
      , O = E.ch32
      , F = E.maj32
      , N = E.s0_256
      , U = E.s1_256
      , H = E.g0_256
      , Z = E.g1_256
      , J = S.BlockHash
      , ie = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function oe() {
        if (!(this instanceof oe))
            return new oe;
        J.call(this),
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
        this.k = ie,
        this.W = new Array(64)
    }
    return C.inherits(oe, J),
    _256 = oe,
    oe.blockSize = 512,
    oe.outSize = 256,
    oe.hmacStrength = 192,
    oe.padLength = 64,
    oe.prototype._update = function(se, le) {
        for (var de = this.W, fe = 0; fe < 16; fe++)
            de[fe] = se[le + fe];
        for (; fe < de.length; fe++)
            de[fe] = $(Z(de[fe - 2]), de[fe - 7], H(de[fe - 15]), de[fe - 16]);
        var pe = this.h[0]
          , ge = this.h[1]
          , we = this.h[2]
          , Ae = this.h[3]
          , Se = this.h[4]
          , ue = this.h[5]
          , V = this.h[6]
          , W = this.h[7];
        for (M(this.k.length === de.length),
        fe = 0; fe < de.length; fe++) {
            var D = B(W, U(Se), O(Se, ue, V), this.k[fe], de[fe])
              , I = T(N(pe), F(pe, ge, we));
            W = V,
            V = ue,
            ue = Se,
            Se = T(Ae, D),
            Ae = we,
            we = ge,
            ge = pe,
            pe = T(D, I)
        }
        this.h[0] = T(this.h[0], pe),
        this.h[1] = T(this.h[1], ge),
        this.h[2] = T(this.h[2], we),
        this.h[3] = T(this.h[3], Ae),
        this.h[4] = T(this.h[4], Se),
        this.h[5] = T(this.h[5], ue),
        this.h[6] = T(this.h[6], V),
        this.h[7] = T(this.h[7], W)
    }
    ,
    oe.prototype._digest = function(se) {
        return se === "hex" ? C.toHex32(this.h, "big") : C.split32(this.h, "big")
    }
    ,
    _256
}
var _224, hasRequired_224;
function require_224() {
    if (hasRequired_224)
        return _224;
    hasRequired_224 = 1;
    var C = requireUtils()
      , S = require_256();
    function E() {
        if (!(this instanceof E))
            return new E;
        S.call(this),
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    return C.inherits(E, S),
    _224 = E,
    E.blockSize = 512,
    E.outSize = 224,
    E.hmacStrength = 192,
    E.padLength = 64,
    E.prototype._digest = function(T) {
        return T === "hex" ? C.toHex32(this.h.slice(0, 7), "big") : C.split32(this.h.slice(0, 7), "big")
    }
    ,
    _224
}
var _512, hasRequired_512;
function require_512() {
    if (hasRequired_512)
        return _512;
    hasRequired_512 = 1;
    var C = requireUtils()
      , S = requireCommon$1()
      , E = requireMinimalisticAssert()
      , M = C.rotr64_hi
      , T = C.rotr64_lo
      , $ = C.shr64_hi
      , B = C.shr64_lo
      , O = C.sum64
      , F = C.sum64_hi
      , N = C.sum64_lo
      , U = C.sum64_4_hi
      , H = C.sum64_4_lo
      , Z = C.sum64_5_hi
      , J = C.sum64_5_lo
      , ie = S.BlockHash
      , oe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function ae() {
        if (!(this instanceof ae))
            return new ae;
        ie.call(this),
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209],
        this.k = oe,
        this.W = new Array(160)
    }
    C.inherits(ae, ie),
    _512 = ae,
    ae.blockSize = 1024,
    ae.outSize = 512,
    ae.hmacStrength = 192,
    ae.padLength = 128,
    ae.prototype._prepareBlock = function(I, L) {
        for (var K = this.W, X = 0; X < 32; X++)
            K[X] = I[L + X];
        for (; X < K.length; X += 2) {
            var Y = V(K[X - 4], K[X - 3])
              , j = W(K[X - 4], K[X - 3])
              , G = K[X - 14]
              , ne = K[X - 13]
              , te = Se(K[X - 30], K[X - 29])
              , ce = ue(K[X - 30], K[X - 29])
              , Ee = K[X - 32]
              , Re = K[X - 31];
            K[X] = U(Y, j, G, ne, te, ce, Ee, Re),
            K[X + 1] = H(Y, j, G, ne, te, ce, Ee, Re)
        }
    }
    ,
    ae.prototype._update = function(I, L) {
        this._prepareBlock(I, L);
        var K = this.W
          , X = this.h[0]
          , Y = this.h[1]
          , j = this.h[2]
          , G = this.h[3]
          , ne = this.h[4]
          , te = this.h[5]
          , ce = this.h[6]
          , Ee = this.h[7]
          , Re = this.h[8]
          , Te = this.h[9]
          , xe = this.h[10]
          , ve = this.h[11]
          , Me = this.h[12]
          , Fe = this.h[13]
          , be = this.h[14]
          , Ce = this.h[15];
        E(this.k.length === K.length);
        for (var ze = 0; ze < K.length; ze += 2) {
            var Ge = be
              , nt = Ce
              , bt = we(Re, Te)
              , ct = Ae(Re, Te)
              , De = se(Re, Te, xe, ve, Me)
              , Ue = le(Re, Te, xe, ve, Me, Fe)
              , We = this.k[ze]
              , Xe = this.k[ze + 1]
              , ht = K[ze]
              , Je = K[ze + 1]
              , ot = Z(Ge, nt, bt, ct, De, Ue, We, Xe, ht, Je)
              , je = J(Ge, nt, bt, ct, De, Ue, We, Xe, ht, Je);
            Ge = pe(X, Y),
            nt = ge(X, Y),
            bt = de(X, Y, j, G, ne),
            ct = fe(X, Y, j, G, ne, te);
            var $e = F(Ge, nt, bt, ct)
              , Ie = N(Ge, nt, bt, ct);
            be = Me,
            Ce = Fe,
            Me = xe,
            Fe = ve,
            xe = Re,
            ve = Te,
            Re = F(ce, Ee, ot, je),
            Te = N(Ee, Ee, ot, je),
            ce = ne,
            Ee = te,
            ne = j,
            te = G,
            j = X,
            G = Y,
            X = F(ot, je, $e, Ie),
            Y = N(ot, je, $e, Ie)
        }
        O(this.h, 0, X, Y),
        O(this.h, 2, j, G),
        O(this.h, 4, ne, te),
        O(this.h, 6, ce, Ee),
        O(this.h, 8, Re, Te),
        O(this.h, 10, xe, ve),
        O(this.h, 12, Me, Fe),
        O(this.h, 14, be, Ce)
    }
    ,
    ae.prototype._digest = function(I) {
        return I === "hex" ? C.toHex32(this.h, "big") : C.split32(this.h, "big")
    }
    ;
    function se(D, I, L, K, X) {
        var Y = D & L ^ ~D & X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function le(D, I, L, K, X, Y) {
        var j = I & K ^ ~I & Y;
        return j < 0 && (j += 4294967296),
        j
    }
    function de(D, I, L, K, X) {
        var Y = D & L ^ D & X ^ L & X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function fe(D, I, L, K, X, Y) {
        var j = I & K ^ I & Y ^ K & Y;
        return j < 0 && (j += 4294967296),
        j
    }
    function pe(D, I) {
        var L = M(D, I, 28)
          , K = M(I, D, 2)
          , X = M(I, D, 7)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function ge(D, I) {
        var L = T(D, I, 28)
          , K = T(I, D, 2)
          , X = T(I, D, 7)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function we(D, I) {
        var L = M(D, I, 14)
          , K = M(D, I, 18)
          , X = M(I, D, 9)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function Ae(D, I) {
        var L = T(D, I, 14)
          , K = T(D, I, 18)
          , X = T(I, D, 9)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function Se(D, I) {
        var L = M(D, I, 1)
          , K = M(D, I, 8)
          , X = $(D, I, 7)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function ue(D, I) {
        var L = T(D, I, 1)
          , K = T(D, I, 8)
          , X = B(D, I, 7)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function V(D, I) {
        var L = M(D, I, 19)
          , K = M(I, D, 29)
          , X = $(D, I, 6)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    function W(D, I) {
        var L = T(D, I, 19)
          , K = T(I, D, 29)
          , X = B(D, I, 6)
          , Y = L ^ K ^ X;
        return Y < 0 && (Y += 4294967296),
        Y
    }
    return _512
}
var _384, hasRequired_384;
function require_384() {
    if (hasRequired_384)
        return _384;
    hasRequired_384 = 1;
    var C = requireUtils()
      , S = require_512();
    function E() {
        if (!(this instanceof E))
            return new E;
        S.call(this),
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    return C.inherits(E, S),
    _384 = E,
    E.blockSize = 1024,
    E.outSize = 384,
    E.hmacStrength = 192,
    E.padLength = 128,
    E.prototype._digest = function(T) {
        return T === "hex" ? C.toHex32(this.h.slice(0, 12), "big") : C.split32(this.h.slice(0, 12), "big")
    }
    ,
    _384
}
var hasRequiredSha;
function requireSha() {
    return hasRequiredSha || (hasRequiredSha = 1,
    sha.sha1 = require_1(),
    sha.sha224 = require_224(),
    sha.sha256 = require_256(),
    sha.sha384 = require_384(),
    sha.sha512 = require_512()),
    sha
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
    if (hasRequiredRipemd)
        return ripemd;
    hasRequiredRipemd = 1;
    var C = requireUtils()
      , S = requireCommon$1()
      , E = C.rotl32
      , M = C.sum32
      , T = C.sum32_3
      , $ = C.sum32_4
      , B = S.BlockHash;
    function O() {
        if (!(this instanceof O))
            return new O;
        B.call(this),
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        this.endian = "little"
    }
    C.inherits(O, B),
    ripemd.ripemd160 = O,
    O.blockSize = 512,
    O.outSize = 160,
    O.hmacStrength = 192,
    O.padLength = 64,
    O.prototype._update = function(ae, se) {
        for (var le = this.h[0], de = this.h[1], fe = this.h[2], pe = this.h[3], ge = this.h[4], we = le, Ae = de, Se = fe, ue = pe, V = ge, W = 0; W < 80; W++) {
            var D = M(E($(le, F(W, de, fe, pe), ae[H[W] + se], N(W)), J[W]), ge);
            le = ge,
            ge = pe,
            pe = E(fe, 10),
            fe = de,
            de = D,
            D = M(E($(we, F(79 - W, Ae, Se, ue), ae[Z[W] + se], U(W)), ie[W]), V),
            we = V,
            V = ue,
            ue = E(Se, 10),
            Se = Ae,
            Ae = D
        }
        D = T(this.h[1], fe, ue),
        this.h[1] = T(this.h[2], pe, V),
        this.h[2] = T(this.h[3], ge, we),
        this.h[3] = T(this.h[4], le, Ae),
        this.h[4] = T(this.h[0], de, Se),
        this.h[0] = D
    }
    ,
    O.prototype._digest = function(ae) {
        return ae === "hex" ? C.toHex32(this.h, "little") : C.split32(this.h, "little")
    }
    ;
    function F(oe, ae, se, le) {
        return oe <= 15 ? ae ^ se ^ le : oe <= 31 ? ae & se | ~ae & le : oe <= 47 ? (ae | ~se) ^ le : oe <= 63 ? ae & le | se & ~le : ae ^ (se | ~le)
    }
    function N(oe) {
        return oe <= 15 ? 0 : oe <= 31 ? 1518500249 : oe <= 47 ? 1859775393 : oe <= 63 ? 2400959708 : 2840853838
    }
    function U(oe) {
        return oe <= 15 ? 1352829926 : oe <= 31 ? 1548603684 : oe <= 47 ? 1836072691 : oe <= 63 ? 2053994217 : 0
    }
    var H = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
      , Z = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
      , J = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
      , ie = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    return ripemd
}
var hmac, hasRequiredHmac;
function requireHmac() {
    if (hasRequiredHmac)
        return hmac;
    hasRequiredHmac = 1;
    var C = requireUtils()
      , S = requireMinimalisticAssert();
    function E(M, T, $) {
        if (!(this instanceof E))
            return new E(M,T,$);
        this.Hash = M,
        this.blockSize = M.blockSize / 8,
        this.outSize = M.outSize / 8,
        this.inner = null,
        this.outer = null,
        this._init(C.toArray(T, $))
    }
    return hmac = E,
    E.prototype._init = function(T) {
        T.length > this.blockSize && (T = new this.Hash().update(T).digest()),
        S(T.length <= this.blockSize);
        for (var $ = T.length; $ < this.blockSize; $++)
            T.push(0);
        for ($ = 0; $ < T.length; $++)
            T[$] ^= 54;
        for (this.inner = new this.Hash().update(T),
        $ = 0; $ < T.length; $++)
            T[$] ^= 106;
        this.outer = new this.Hash().update(T)
    }
    ,
    E.prototype.update = function(T, $) {
        return this.inner.update(T, $),
        this
    }
    ,
    E.prototype.digest = function(T) {
        return this.outer.update(this.inner.digest()),
        this.outer.digest(T)
    }
    ,
    hmac
}
var hasRequiredHash;
function requireHash() {
    return hasRequiredHash || (hasRequiredHash = 1,
    function(C) {
        var S = C;
        S.utils = requireUtils(),
        S.common = requireCommon$1(),
        S.sha = requireSha(),
        S.ripemd = requireRipemd(),
        S.hmac = requireHmac(),
        S.sha1 = S.sha.sha1,
        S.sha256 = S.sha.sha256,
        S.sha224 = S.sha.sha224,
        S.sha384 = S.sha.sha384,
        S.sha512 = S.sha.sha512,
        S.ripemd160 = S.ripemd.ripemd160
    }(hash$1)),
    hash$1
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
    return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1,
    secp256k1 = {
        doubles: {
            step: 4,
            points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
        },
        naf: {
            wnd: 7,
            points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
        }
    }),
    secp256k1
}
var hasRequiredCurves;
function requireCurves() {
    return hasRequiredCurves || (hasRequiredCurves = 1,
    function(C) {
        var S = C
          , E = requireHash()
          , M = requireCurve()
          , T = requireUtils$1()
          , $ = T.assert;
        function B(N) {
            N.type === "short" ? this.curve = new M.short(N) : N.type === "edwards" ? this.curve = new M.edwards(N) : this.curve = new M.mont(N),
            this.g = this.curve.g,
            this.n = this.curve.n,
            this.hash = N.hash,
            $(this.g.validate(), "Invalid curve"),
            $(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        S.PresetCurve = B;
        function O(N, U) {
            Object.defineProperty(S, N, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var H = new B(U);
                    return Object.defineProperty(S, N, {
                        configurable: !0,
                        enumerable: !0,
                        value: H
                    }),
                    H
                }
            })
        }
        O("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: E.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }),
        O("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: E.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }),
        O("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: E.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }),
        O("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: E.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }),
        O("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: E.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }),
        O("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: E.sha256,
            gRed: !1,
            g: ["9"]
        }),
        O("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: E.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var F;
        try {
            F = requireSecp256k1()
        } catch {
            F = void 0
        }
        O("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: E.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", F]
        })
    }(curves)),
    curves
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
    if (hasRequiredHmacDrbg)
        return hmacDrbg;
    hasRequiredHmacDrbg = 1;
    var C = requireHash()
      , S = requireUtils$2()
      , E = requireMinimalisticAssert();
    function M(T) {
        if (!(this instanceof M))
            return new M(T);
        this.hash = T.hash,
        this.predResist = !!T.predResist,
        this.outLen = this.hash.outSize,
        this.minEntropy = T.minEntropy || this.hash.hmacStrength,
        this._reseed = null,
        this.reseedInterval = null,
        this.K = null,
        this.V = null;
        var $ = S.toArray(T.entropy, T.entropyEnc || "hex")
          , B = S.toArray(T.nonce, T.nonceEnc || "hex")
          , O = S.toArray(T.pers, T.persEnc || "hex");
        E($.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._init($, B, O)
    }
    return hmacDrbg = M,
    M.prototype._init = function($, B, O) {
        var F = $.concat(B).concat(O);
        this.K = new Array(this.outLen / 8),
        this.V = new Array(this.outLen / 8);
        for (var N = 0; N < this.V.length; N++)
            this.K[N] = 0,
            this.V[N] = 1;
        this._update(F),
        this._reseed = 1,
        this.reseedInterval = 281474976710656
    }
    ,
    M.prototype._hmac = function() {
        return new C.hmac(this.hash,this.K)
    }
    ,
    M.prototype._update = function($) {
        var B = this._hmac().update(this.V).update([0]);
        $ && (B = B.update($)),
        this.K = B.digest(),
        this.V = this._hmac().update(this.V).digest(),
        $ && (this.K = this._hmac().update(this.V).update([1]).update($).digest(),
        this.V = this._hmac().update(this.V).digest())
    }
    ,
    M.prototype.reseed = function($, B, O, F) {
        typeof B != "string" && (F = O,
        O = B,
        B = null),
        $ = S.toArray($, B),
        O = S.toArray(O, F),
        E($.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update($.concat(O || [])),
        this._reseed = 1
    }
    ,
    M.prototype.generate = function($, B, O, F) {
        if (this._reseed > this.reseedInterval)
            throw new Error("Reseed is required");
        typeof B != "string" && (F = O,
        O = B,
        B = null),
        O && (O = S.toArray(O, F || "hex"),
        this._update(O));
        for (var N = []; N.length < $; )
            this.V = this._hmac().update(this.V).digest(),
            N = N.concat(this.V);
        var U = N.slice(0, $);
        return this._update(O),
        this._reseed++,
        S.encode(U, B)
    }
    ,
    hmacDrbg
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
    if (hasRequiredKey$1)
        return key$1;
    hasRequiredKey$1 = 1;
    var C = requireBn$2()
      , S = requireUtils$1()
      , E = S.assert;
    function M(T, $) {
        this.ec = T,
        this.priv = null,
        this.pub = null,
        $.priv && this._importPrivate($.priv, $.privEnc),
        $.pub && this._importPublic($.pub, $.pubEnc)
    }
    return key$1 = M,
    M.fromPublic = function($, B, O) {
        return B instanceof M ? B : new M($,{
            pub: B,
            pubEnc: O
        })
    }
    ,
    M.fromPrivate = function($, B, O) {
        return B instanceof M ? B : new M($,{
            priv: B,
            privEnc: O
        })
    }
    ,
    M.prototype.validate = function() {
        var $ = this.getPublic();
        return $.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : $.validate() ? $.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        }
    }
    ,
    M.prototype.getPublic = function($, B) {
        return typeof $ == "string" && (B = $,
        $ = null),
        this.pub || (this.pub = this.ec.g.mul(this.priv)),
        B ? this.pub.encode(B, $) : this.pub
    }
    ,
    M.prototype.getPrivate = function($) {
        return $ === "hex" ? this.priv.toString(16, 2) : this.priv
    }
    ,
    M.prototype._importPrivate = function($, B) {
        this.priv = new C($,B || 16),
        this.priv = this.priv.umod(this.ec.curve.n)
    }
    ,
    M.prototype._importPublic = function($, B) {
        if ($.x || $.y) {
            this.ec.curve.type === "mont" ? E($.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && E($.x && $.y, "Need both x and y coordinate"),
            this.pub = this.ec.curve.point($.x, $.y);
            return
        }
        this.pub = this.ec.curve.decodePoint($, B)
    }
    ,
    M.prototype.derive = function($) {
        return $.validate() || E($.validate(), "public point not validated"),
        $.mul(this.priv).getX()
    }
    ,
    M.prototype.sign = function($, B, O) {
        return this.ec.sign($, this, B, O)
    }
    ,
    M.prototype.verify = function($, B) {
        return this.ec.verify($, B, this)
    }
    ,
    M.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
    }
    ,
    key$1
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
    if (hasRequiredSignature$1)
        return signature$1;
    hasRequiredSignature$1 = 1;
    var C = requireBn$2()
      , S = requireUtils$1()
      , E = S.assert;
    function M(F, N) {
        if (F instanceof M)
            return F;
        this._importDER(F, N) || (E(F.r && F.s, "Signature without r or s"),
        this.r = new C(F.r,16),
        this.s = new C(F.s,16),
        F.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = F.recoveryParam)
    }
    signature$1 = M;
    function T() {
        this.place = 0
    }
    function $(F, N) {
        var U = F[N.place++];
        if (!(U & 128))
            return U;
        var H = U & 15;
        if (H === 0 || H > 4)
            return !1;
        for (var Z = 0, J = 0, ie = N.place; J < H; J++,
        ie++)
            Z <<= 8,
            Z |= F[ie],
            Z >>>= 0;
        return Z <= 127 ? !1 : (N.place = ie,
        Z)
    }
    function B(F) {
        for (var N = 0, U = F.length - 1; !F[N] && !(F[N + 1] & 128) && N < U; )
            N++;
        return N === 0 ? F : F.slice(N)
    }
    M.prototype._importDER = function(N, U) {
        N = S.toArray(N, U);
        var H = new T;
        if (N[H.place++] !== 48)
            return !1;
        var Z = $(N, H);
        if (Z === !1 || Z + H.place !== N.length || N[H.place++] !== 2)
            return !1;
        var J = $(N, H);
        if (J === !1)
            return !1;
        var ie = N.slice(H.place, J + H.place);
        if (H.place += J,
        N[H.place++] !== 2)
            return !1;
        var oe = $(N, H);
        if (oe === !1 || N.length !== oe + H.place)
            return !1;
        var ae = N.slice(H.place, oe + H.place);
        if (ie[0] === 0)
            if (ie[1] & 128)
                ie = ie.slice(1);
            else
                return !1;
        if (ae[0] === 0)
            if (ae[1] & 128)
                ae = ae.slice(1);
            else
                return !1;
        return this.r = new C(ie),
        this.s = new C(ae),
        this.recoveryParam = null,
        !0
    }
    ;
    function O(F, N) {
        if (N < 128) {
            F.push(N);
            return
        }
        var U = 1 + (Math.log(N) / Math.LN2 >>> 3);
        for (F.push(U | 128); --U; )
            F.push(N >>> (U << 3) & 255);
        F.push(N)
    }
    return M.prototype.toDER = function(N) {
        var U = this.r.toArray()
          , H = this.s.toArray();
        for (U[0] & 128 && (U = [0].concat(U)),
        H[0] & 128 && (H = [0].concat(H)),
        U = B(U),
        H = B(H); !H[0] && !(H[1] & 128); )
            H = H.slice(1);
        var Z = [2];
        O(Z, U.length),
        Z = Z.concat(U),
        Z.push(2),
        O(Z, H.length);
        var J = Z.concat(H)
          , ie = [48];
        return O(ie, J.length),
        ie = ie.concat(J),
        S.encode(ie, N)
    }
    ,
    signature$1
}
var ec, hasRequiredEc;
function requireEc() {
    if (hasRequiredEc)
        return ec;
    hasRequiredEc = 1;
    var C = requireBn$2()
      , S = requireHmacDrbg()
      , E = requireUtils$1()
      , M = requireCurves()
      , T = requireBrorand()
      , $ = E.assert
      , B = requireKey$1()
      , O = requireSignature$1();
    function F(N) {
        if (!(this instanceof F))
            return new F(N);
        typeof N == "string" && ($(Object.prototype.hasOwnProperty.call(M, N), "Unknown curve " + N),
        N = M[N]),
        N instanceof M.PresetCurve && (N = {
            curve: N
        }),
        this.curve = N.curve.curve,
        this.n = this.curve.n,
        this.nh = this.n.ushrn(1),
        this.g = this.curve.g,
        this.g = N.curve.g,
        this.g.precompute(N.curve.n.bitLength() + 1),
        this.hash = N.hash || N.curve.hash
    }
    return ec = F,
    F.prototype.keyPair = function(U) {
        return new B(this,U)
    }
    ,
    F.prototype.keyFromPrivate = function(U, H) {
        return B.fromPrivate(this, U, H)
    }
    ,
    F.prototype.keyFromPublic = function(U, H) {
        return B.fromPublic(this, U, H)
    }
    ,
    F.prototype.genKeyPair = function(U) {
        U || (U = {});
        for (var H = new S({
            hash: this.hash,
            pers: U.pers,
            persEnc: U.persEnc || "utf8",
            entropy: U.entropy || T(this.hash.hmacStrength),
            entropyEnc: U.entropy && U.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), Z = this.n.byteLength(), J = this.n.sub(new C(2)); ; ) {
            var ie = new C(H.generate(Z));
            if (!(ie.cmp(J) > 0))
                return ie.iaddn(1),
                this.keyFromPrivate(ie)
        }
    }
    ,
    F.prototype._truncateToN = function(U, H) {
        var Z = U.byteLength() * 8 - this.n.bitLength();
        return Z > 0 && (U = U.ushrn(Z)),
        !H && U.cmp(this.n) >= 0 ? U.sub(this.n) : U
    }
    ,
    F.prototype.sign = function(U, H, Z, J) {
        typeof Z == "object" && (J = Z,
        Z = null),
        J || (J = {}),
        H = this.keyFromPrivate(H, Z),
        U = this._truncateToN(new C(U,16));
        for (var ie = this.n.byteLength(), oe = H.getPrivate().toArray("be", ie), ae = U.toArray("be", ie), se = new S({
            hash: this.hash,
            entropy: oe,
            nonce: ae,
            pers: J.pers,
            persEnc: J.persEnc || "utf8"
        }), le = this.n.sub(new C(1)), de = 0; ; de++) {
            var fe = J.k ? J.k(de) : new C(se.generate(this.n.byteLength()));
            if (fe = this._truncateToN(fe, !0),
            !(fe.cmpn(1) <= 0 || fe.cmp(le) >= 0)) {
                var pe = this.g.mul(fe);
                if (!pe.isInfinity()) {
                    var ge = pe.getX()
                      , we = ge.umod(this.n);
                    if (we.cmpn(0) !== 0) {
                        var Ae = fe.invm(this.n).mul(we.mul(H.getPrivate()).iadd(U));
                        if (Ae = Ae.umod(this.n),
                        Ae.cmpn(0) !== 0) {
                            var Se = (pe.getY().isOdd() ? 1 : 0) | (ge.cmp(we) !== 0 ? 2 : 0);
                            return J.canonical && Ae.cmp(this.nh) > 0 && (Ae = this.n.sub(Ae),
                            Se ^= 1),
                            new O({
                                r: we,
                                s: Ae,
                                recoveryParam: Se
                            })
                        }
                    }
                }
            }
        }
    }
    ,
    F.prototype.verify = function(U, H, Z, J) {
        U = this._truncateToN(new C(U,16)),
        Z = this.keyFromPublic(Z, J),
        H = new O(H,"hex");
        var ie = H.r
          , oe = H.s;
        if (ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0 || oe.cmpn(1) < 0 || oe.cmp(this.n) >= 0)
            return !1;
        var ae = oe.invm(this.n), se = ae.mul(U).umod(this.n), le = ae.mul(ie).umod(this.n), de;
        return this.curve._maxwellTrick ? (de = this.g.jmulAdd(se, Z.getPublic(), le),
        de.isInfinity() ? !1 : de.eqXToP(ie)) : (de = this.g.mulAdd(se, Z.getPublic(), le),
        de.isInfinity() ? !1 : de.getX().umod(this.n).cmp(ie) === 0)
    }
    ,
    F.prototype.recoverPubKey = function(N, U, H, Z) {
        $((3 & H) === H, "The recovery param is more than two bits"),
        U = new O(U,Z);
        var J = this.n
          , ie = new C(N)
          , oe = U.r
          , ae = U.s
          , se = H & 1
          , le = H >> 1;
        if (oe.cmp(this.curve.p.umod(this.curve.n)) >= 0 && le)
            throw new Error("Unable to find sencond key candinate");
        le ? oe = this.curve.pointFromX(oe.add(this.curve.n), se) : oe = this.curve.pointFromX(oe, se);
        var de = U.r.invm(J)
          , fe = J.sub(ie).mul(de).umod(J)
          , pe = ae.mul(de).umod(J);
        return this.g.mulAdd(fe, oe, pe)
    }
    ,
    F.prototype.getKeyRecoveryParam = function(N, U, H, Z) {
        if (U = new O(U,Z),
        U.recoveryParam !== null)
            return U.recoveryParam;
        for (var J = 0; J < 4; J++) {
            var ie;
            try {
                ie = this.recoverPubKey(N, U, J)
            } catch {
                continue
            }
            if (ie.eq(H))
                return J
        }
        throw new Error("Unable to find valid recovery factor")
    }
    ,
    ec
}
var key, hasRequiredKey;
function requireKey() {
    if (hasRequiredKey)
        return key;
    hasRequiredKey = 1;
    var C = requireUtils$1()
      , S = C.assert
      , E = C.parseBytes
      , M = C.cachedProperty;
    function T($, B) {
        this.eddsa = $,
        this._secret = E(B.secret),
        $.isPoint(B.pub) ? this._pub = B.pub : this._pubBytes = E(B.pub)
    }
    return T.fromPublic = function(B, O) {
        return O instanceof T ? O : new T(B,{
            pub: O
        })
    }
    ,
    T.fromSecret = function(B, O) {
        return O instanceof T ? O : new T(B,{
            secret: O
        })
    }
    ,
    T.prototype.secret = function() {
        return this._secret
    }
    ,
    M(T, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub())
    }),
    M(T, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
    }),
    M(T, "privBytes", function() {
        var B = this.eddsa
          , O = this.hash()
          , F = B.encodingLength - 1
          , N = O.slice(0, B.encodingLength);
        return N[0] &= 248,
        N[F] &= 127,
        N[F] |= 64,
        N
    }),
    M(T, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes())
    }),
    M(T, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest()
    }),
    M(T, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength)
    }),
    T.prototype.sign = function(B) {
        return S(this._secret, "KeyPair can only verify"),
        this.eddsa.sign(B, this)
    }
    ,
    T.prototype.verify = function(B, O) {
        return this.eddsa.verify(B, O, this)
    }
    ,
    T.prototype.getSecret = function(B) {
        return S(this._secret, "KeyPair is public only"),
        C.encode(this.secret(), B)
    }
    ,
    T.prototype.getPublic = function(B) {
        return C.encode(this.pubBytes(), B)
    }
    ,
    key = T,
    key
}
var signature, hasRequiredSignature;
function requireSignature() {
    if (hasRequiredSignature)
        return signature;
    hasRequiredSignature = 1;
    var C = requireBn$2()
      , S = requireUtils$1()
      , E = S.assert
      , M = S.cachedProperty
      , T = S.parseBytes;
    function $(B, O) {
        this.eddsa = B,
        typeof O != "object" && (O = T(O)),
        Array.isArray(O) && (O = {
            R: O.slice(0, B.encodingLength),
            S: O.slice(B.encodingLength)
        }),
        E(O.R && O.S, "Signature without R or S"),
        B.isPoint(O.R) && (this._R = O.R),
        O.S instanceof C && (this._S = O.S),
        this._Rencoded = Array.isArray(O.R) ? O.R : O.Rencoded,
        this._Sencoded = Array.isArray(O.S) ? O.S : O.Sencoded
    }
    return M($, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded())
    }),
    M($, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded())
    }),
    M($, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R())
    }),
    M($, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S())
    }),
    $.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded())
    }
    ,
    $.prototype.toHex = function() {
        return S.encode(this.toBytes(), "hex").toUpperCase()
    }
    ,
    signature = $,
    signature
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
    if (hasRequiredEddsa)
        return eddsa;
    hasRequiredEddsa = 1;
    var C = requireHash()
      , S = requireCurves()
      , E = requireUtils$1()
      , M = E.assert
      , T = E.parseBytes
      , $ = requireKey()
      , B = requireSignature();
    function O(F) {
        if (M(F === "ed25519", "only tested with ed25519 so far"),
        !(this instanceof O))
            return new O(F);
        F = S[F].curve,
        this.curve = F,
        this.g = F.g,
        this.g.precompute(F.n.bitLength() + 1),
        this.pointClass = F.point().constructor,
        this.encodingLength = Math.ceil(F.n.bitLength() / 8),
        this.hash = C.sha512
    }
    return eddsa = O,
    O.prototype.sign = function(N, U) {
        N = T(N);
        var H = this.keyFromSecret(U)
          , Z = this.hashInt(H.messagePrefix(), N)
          , J = this.g.mul(Z)
          , ie = this.encodePoint(J)
          , oe = this.hashInt(ie, H.pubBytes(), N).mul(H.priv())
          , ae = Z.add(oe).umod(this.curve.n);
        return this.makeSignature({
            R: J,
            S: ae,
            Rencoded: ie
        })
    }
    ,
    O.prototype.verify = function(N, U, H) {
        N = T(N),
        U = this.makeSignature(U);
        var Z = this.keyFromPublic(H)
          , J = this.hashInt(U.Rencoded(), Z.pubBytes(), N)
          , ie = this.g.mul(U.S())
          , oe = U.R().add(Z.pub().mul(J));
        return oe.eq(ie)
    }
    ,
    O.prototype.hashInt = function() {
        for (var N = this.hash(), U = 0; U < arguments.length; U++)
            N.update(arguments[U]);
        return E.intFromLE(N.digest()).umod(this.curve.n)
    }
    ,
    O.prototype.keyFromPublic = function(N) {
        return $.fromPublic(this, N)
    }
    ,
    O.prototype.keyFromSecret = function(N) {
        return $.fromSecret(this, N)
    }
    ,
    O.prototype.makeSignature = function(N) {
        return N instanceof B ? N : new B(this,N)
    }
    ,
    O.prototype.encodePoint = function(N) {
        var U = N.getY().toArray("le", this.encodingLength);
        return U[this.encodingLength - 1] |= N.getX().isOdd() ? 128 : 0,
        U
    }
    ,
    O.prototype.decodePoint = function(N) {
        N = E.parseBytes(N);
        var U = N.length - 1
          , H = N.slice(0, U).concat(N[U] & -129)
          , Z = (N[U] & 128) !== 0
          , J = E.intFromLE(H);
        return this.curve.pointFromY(J, Z)
    }
    ,
    O.prototype.encodeInt = function(N) {
        return N.toArray("le", this.encodingLength)
    }
    ,
    O.prototype.decodeInt = function(N) {
        return E.intFromLE(N)
    }
    ,
    O.prototype.isPoint = function(N) {
        return N instanceof this.pointClass
    }
    ,
    eddsa
}
var hasRequiredElliptic;
function requireElliptic() {
    return hasRequiredElliptic || (hasRequiredElliptic = 1,
    function(C) {
        var S = C;
        S.version = require$$0$1.version,
        S.utils = requireUtils$1(),
        S.rand = requireBrorand(),
        S.curve = requireCurve(),
        S.curves = requireCurves(),
        S.ec = requireEc(),
        S.eddsa = requireEddsa()
    }(elliptic)),
    elliptic
}
var bn$3 = {
    exports: {}
};
bn$3.exports;
var hasRequiredBn;
function requireBn() {
    return hasRequiredBn || (hasRequiredBn = 1,
    function(C) {
        (function(S, E) {
            function M(D, I) {
                if (!D)
                    throw new Error(I || "Assertion failed")
            }
            function T(D, I) {
                D.super_ = I;
                var L = function() {};
                L.prototype = I.prototype,
                D.prototype = new L,
                D.prototype.constructor = D
            }
            function $(D, I, L) {
                if ($.isBN(D))
                    return D;
                this.negative = 0,
                this.words = null,
                this.length = 0,
                this.red = null,
                D !== null && ((I === "le" || I === "be") && (L = I,
                I = 10),
                this._init(D || 0, I || 10, L || "be"))
            }
            typeof S == "object" ? S.exports = $ : E.BN = $,
            $.BN = $,
            $.wordSize = 26;
            var B;
            try {
                typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = require$$0$2.Buffer
            } catch {}
            $.isBN = function(I) {
                return I instanceof $ ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === $.wordSize && Array.isArray(I.words)
            }
            ,
            $.max = function(I, L) {
                return I.cmp(L) > 0 ? I : L
            }
            ,
            $.min = function(I, L) {
                return I.cmp(L) < 0 ? I : L
            }
            ,
            $.prototype._init = function(I, L, K) {
                if (typeof I == "number")
                    return this._initNumber(I, L, K);
                if (typeof I == "object")
                    return this._initArray(I, L, K);
                L === "hex" && (L = 16),
                M(L === (L | 0) && L >= 2 && L <= 36),
                I = I.toString().replace(/\s+/g, "");
                var X = 0;
                I[0] === "-" && (X++,
                this.negative = 1),
                X < I.length && (L === 16 ? this._parseHex(I, X, K) : (this._parseBase(I, L, X),
                K === "le" && this._initArray(this.toArray(), L, K)))
            }
            ,
            $.prototype._initNumber = function(I, L, K) {
                I < 0 && (this.negative = 1,
                I = -I),
                I < 67108864 ? (this.words = [I & 67108863],
                this.length = 1) : I < 4503599627370496 ? (this.words = [I & 67108863, I / 67108864 & 67108863],
                this.length = 2) : (M(I < 9007199254740992),
                this.words = [I & 67108863, I / 67108864 & 67108863, 1],
                this.length = 3),
                K === "le" && this._initArray(this.toArray(), L, K)
            }
            ,
            $.prototype._initArray = function(I, L, K) {
                if (M(typeof I.length == "number"),
                I.length <= 0)
                    return this.words = [0],
                    this.length = 1,
                    this;
                this.length = Math.ceil(I.length / 3),
                this.words = new Array(this.length);
                for (var X = 0; X < this.length; X++)
                    this.words[X] = 0;
                var Y, j, G = 0;
                if (K === "be")
                    for (X = I.length - 1,
                    Y = 0; X >= 0; X -= 3)
                        j = I[X] | I[X - 1] << 8 | I[X - 2] << 16,
                        this.words[Y] |= j << G & 67108863,
                        this.words[Y + 1] = j >>> 26 - G & 67108863,
                        G += 24,
                        G >= 26 && (G -= 26,
                        Y++);
                else if (K === "le")
                    for (X = 0,
                    Y = 0; X < I.length; X += 3)
                        j = I[X] | I[X + 1] << 8 | I[X + 2] << 16,
                        this.words[Y] |= j << G & 67108863,
                        this.words[Y + 1] = j >>> 26 - G & 67108863,
                        G += 24,
                        G >= 26 && (G -= 26,
                        Y++);
                return this._strip()
            }
            ;
            function O(D, I) {
                var L = D.charCodeAt(I);
                if (L >= 48 && L <= 57)
                    return L - 48;
                if (L >= 65 && L <= 70)
                    return L - 55;
                if (L >= 97 && L <= 102)
                    return L - 87;
                M(!1, "Invalid character in " + D)
            }
            function F(D, I, L) {
                var K = O(D, L);
                return L - 1 >= I && (K |= O(D, L - 1) << 4),
                K
            }
            $.prototype._parseHex = function(I, L, K) {
                this.length = Math.ceil((I.length - L) / 6),
                this.words = new Array(this.length);
                for (var X = 0; X < this.length; X++)
                    this.words[X] = 0;
                var Y = 0, j = 0, G;
                if (K === "be")
                    for (X = I.length - 1; X >= L; X -= 2)
                        G = F(I, L, X) << Y,
                        this.words[j] |= G & 67108863,
                        Y >= 18 ? (Y -= 18,
                        j += 1,
                        this.words[j] |= G >>> 26) : Y += 8;
                else {
                    var ne = I.length - L;
                    for (X = ne % 2 === 0 ? L + 1 : L; X < I.length; X += 2)
                        G = F(I, L, X) << Y,
                        this.words[j] |= G & 67108863,
                        Y >= 18 ? (Y -= 18,
                        j += 1,
                        this.words[j] |= G >>> 26) : Y += 8
                }
                this._strip()
            }
            ;
            function N(D, I, L, K) {
                for (var X = 0, Y = 0, j = Math.min(D.length, L), G = I; G < j; G++) {
                    var ne = D.charCodeAt(G) - 48;
                    X *= K,
                    ne >= 49 ? Y = ne - 49 + 10 : ne >= 17 ? Y = ne - 17 + 10 : Y = ne,
                    M(ne >= 0 && Y < K, "Invalid character"),
                    X += Y
                }
                return X
            }
            $.prototype._parseBase = function(I, L, K) {
                this.words = [0],
                this.length = 1;
                for (var X = 0, Y = 1; Y <= 67108863; Y *= L)
                    X++;
                X--,
                Y = Y / L | 0;
                for (var j = I.length - K, G = j % X, ne = Math.min(j, j - G) + K, te = 0, ce = K; ce < ne; ce += X)
                    te = N(I, ce, ce + X, L),
                    this.imuln(Y),
                    this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
                if (G !== 0) {
                    var Ee = 1;
                    for (te = N(I, ce, I.length, L),
                    ce = 0; ce < G; ce++)
                        Ee *= L;
                    this.imuln(Ee),
                    this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te)
                }
                this._strip()
            }
            ,
            $.prototype.copy = function(I) {
                I.words = new Array(this.length);
                for (var L = 0; L < this.length; L++)
                    I.words[L] = this.words[L];
                I.length = this.length,
                I.negative = this.negative,
                I.red = this.red
            }
            ;
            function U(D, I) {
                D.words = I.words,
                D.length = I.length,
                D.negative = I.negative,
                D.red = I.red
            }
            if ($.prototype._move = function(I) {
                U(I, this)
            }
            ,
            $.prototype.clone = function() {
                var I = new $(null);
                return this.copy(I),
                I
            }
            ,
            $.prototype._expand = function(I) {
                for (; this.length < I; )
                    this.words[this.length++] = 0;
                return this
            }
            ,
            $.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0; )
                    this.length--;
                return this._normSign()
            }
            ,
            $.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
                this
            }
            ,
            typeof Symbol < "u" && typeof Symbol.for == "function")
                try {
                    $.prototype[Symbol.for("nodejs.util.inspect.custom")] = H
                } catch {
                    $.prototype.inspect = H
                }
            else
                $.prototype.inspect = H;
            function H() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
            }
            var Z = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
              , J = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
              , ie = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
            $.prototype.toString = function(I, L) {
                I = I || 10,
                L = L | 0 || 1;
                var K;
                if (I === 16 || I === "hex") {
                    K = "";
                    for (var X = 0, Y = 0, j = 0; j < this.length; j++) {
                        var G = this.words[j]
                          , ne = ((G << X | Y) & 16777215).toString(16);
                        Y = G >>> 24 - X & 16777215,
                        X += 2,
                        X >= 26 && (X -= 26,
                        j--),
                        Y !== 0 || j !== this.length - 1 ? K = Z[6 - ne.length] + ne + K : K = ne + K
                    }
                    for (Y !== 0 && (K = Y.toString(16) + K); K.length % L !== 0; )
                        K = "0" + K;
                    return this.negative !== 0 && (K = "-" + K),
                    K
                }
                if (I === (I | 0) && I >= 2 && I <= 36) {
                    var te = J[I]
                      , ce = ie[I];
                    K = "";
                    var Ee = this.clone();
                    for (Ee.negative = 0; !Ee.isZero(); ) {
                        var Re = Ee.modrn(ce).toString(I);
                        Ee = Ee.idivn(ce),
                        Ee.isZero() ? K = Re + K : K = Z[te - Re.length] + Re + K
                    }
                    for (this.isZero() && (K = "0" + K); K.length % L !== 0; )
                        K = "0" + K;
                    return this.negative !== 0 && (K = "-" + K),
                    K
                }
                M(!1, "Base should be between 2 and 36")
            }
            ,
            $.prototype.toNumber = function() {
                var I = this.words[0];
                return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
                this.negative !== 0 ? -I : I
            }
            ,
            $.prototype.toJSON = function() {
                return this.toString(16, 2)
            }
            ,
            B && ($.prototype.toBuffer = function(I, L) {
                return this.toArrayLike(B, I, L)
            }
            ),
            $.prototype.toArray = function(I, L) {
                return this.toArrayLike(Array, I, L)
            }
            ;
            var oe = function(I, L) {
                return I.allocUnsafe ? I.allocUnsafe(L) : new I(L)
            };
            $.prototype.toArrayLike = function(I, L, K) {
                this._strip();
                var X = this.byteLength()
                  , Y = K || Math.max(1, X);
                M(X <= Y, "byte array longer than desired length"),
                M(Y > 0, "Requested array length <= 0");
                var j = oe(I, Y)
                  , G = L === "le" ? "LE" : "BE";
                return this["_toArrayLike" + G](j, X),
                j
            }
            ,
            $.prototype._toArrayLikeLE = function(I, L) {
                for (var K = 0, X = 0, Y = 0, j = 0; Y < this.length; Y++) {
                    var G = this.words[Y] << j | X;
                    I[K++] = G & 255,
                    K < I.length && (I[K++] = G >> 8 & 255),
                    K < I.length && (I[K++] = G >> 16 & 255),
                    j === 6 ? (K < I.length && (I[K++] = G >> 24 & 255),
                    X = 0,
                    j = 0) : (X = G >>> 24,
                    j += 2)
                }
                if (K < I.length)
                    for (I[K++] = X; K < I.length; )
                        I[K++] = 0
            }
            ,
            $.prototype._toArrayLikeBE = function(I, L) {
                for (var K = I.length - 1, X = 0, Y = 0, j = 0; Y < this.length; Y++) {
                    var G = this.words[Y] << j | X;
                    I[K--] = G & 255,
                    K >= 0 && (I[K--] = G >> 8 & 255),
                    K >= 0 && (I[K--] = G >> 16 & 255),
                    j === 6 ? (K >= 0 && (I[K--] = G >> 24 & 255),
                    X = 0,
                    j = 0) : (X = G >>> 24,
                    j += 2)
                }
                if (K >= 0)
                    for (I[K--] = X; K >= 0; )
                        I[K--] = 0
            }
            ,
            Math.clz32 ? $.prototype._countBits = function(I) {
                return 32 - Math.clz32(I)
            }
            : $.prototype._countBits = function(I) {
                var L = I
                  , K = 0;
                return L >= 4096 && (K += 13,
                L >>>= 13),
                L >= 64 && (K += 7,
                L >>>= 7),
                L >= 8 && (K += 4,
                L >>>= 4),
                L >= 2 && (K += 2,
                L >>>= 2),
                K + L
            }
            ,
            $.prototype._zeroBits = function(I) {
                if (I === 0)
                    return 26;
                var L = I
                  , K = 0;
                return L & 8191 || (K += 13,
                L >>>= 13),
                L & 127 || (K += 7,
                L >>>= 7),
                L & 15 || (K += 4,
                L >>>= 4),
                L & 3 || (K += 2,
                L >>>= 2),
                L & 1 || K++,
                K
            }
            ,
            $.prototype.bitLength = function() {
                var I = this.words[this.length - 1]
                  , L = this._countBits(I);
                return (this.length - 1) * 26 + L
            }
            ;
            function ae(D) {
                for (var I = new Array(D.bitLength()), L = 0; L < I.length; L++) {
                    var K = L / 26 | 0
                      , X = L % 26;
                    I[L] = D.words[K] >>> X & 1
                }
                return I
            }
            $.prototype.zeroBits = function() {
                if (this.isZero())
                    return 0;
                for (var I = 0, L = 0; L < this.length; L++) {
                    var K = this._zeroBits(this.words[L]);
                    if (I += K,
                    K !== 26)
                        break
                }
                return I
            }
            ,
            $.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8)
            }
            ,
            $.prototype.toTwos = function(I) {
                return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone()
            }
            ,
            $.prototype.fromTwos = function(I) {
                return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone()
            }
            ,
            $.prototype.isNeg = function() {
                return this.negative !== 0
            }
            ,
            $.prototype.neg = function() {
                return this.clone().ineg()
            }
            ,
            $.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1),
                this
            }
            ,
            $.prototype.iuor = function(I) {
                for (; this.length < I.length; )
                    this.words[this.length++] = 0;
                for (var L = 0; L < I.length; L++)
                    this.words[L] = this.words[L] | I.words[L];
                return this._strip()
            }
            ,
            $.prototype.ior = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuor(I)
            }
            ,
            $.prototype.or = function(I) {
                return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this)
            }
            ,
            $.prototype.uor = function(I) {
                return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this)
            }
            ,
            $.prototype.iuand = function(I) {
                var L;
                this.length > I.length ? L = I : L = this;
                for (var K = 0; K < L.length; K++)
                    this.words[K] = this.words[K] & I.words[K];
                return this.length = L.length,
                this._strip()
            }
            ,
            $.prototype.iand = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuand(I)
            }
            ,
            $.prototype.and = function(I) {
                return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this)
            }
            ,
            $.prototype.uand = function(I) {
                return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this)
            }
            ,
            $.prototype.iuxor = function(I) {
                var L, K;
                this.length > I.length ? (L = this,
                K = I) : (L = I,
                K = this);
                for (var X = 0; X < K.length; X++)
                    this.words[X] = L.words[X] ^ K.words[X];
                if (this !== L)
                    for (; X < L.length; X++)
                        this.words[X] = L.words[X];
                return this.length = L.length,
                this._strip()
            }
            ,
            $.prototype.ixor = function(I) {
                return M((this.negative | I.negative) === 0),
                this.iuxor(I)
            }
            ,
            $.prototype.xor = function(I) {
                return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this)
            }
            ,
            $.prototype.uxor = function(I) {
                return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this)
            }
            ,
            $.prototype.inotn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = Math.ceil(I / 26) | 0
                  , K = I % 26;
                this._expand(L),
                K > 0 && L--;
                for (var X = 0; X < L; X++)
                    this.words[X] = ~this.words[X] & 67108863;
                return K > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - K),
                this._strip()
            }
            ,
            $.prototype.notn = function(I) {
                return this.clone().inotn(I)
            }
            ,
            $.prototype.setn = function(I, L) {
                M(typeof I == "number" && I >= 0);
                var K = I / 26 | 0
                  , X = I % 26;
                return this._expand(K + 1),
                L ? this.words[K] = this.words[K] | 1 << X : this.words[K] = this.words[K] & ~(1 << X),
                this._strip()
            }
            ,
            $.prototype.iadd = function(I) {
                var L;
                if (this.negative !== 0 && I.negative === 0)
                    return this.negative = 0,
                    L = this.isub(I),
                    this.negative ^= 1,
                    this._normSign();
                if (this.negative === 0 && I.negative !== 0)
                    return I.negative = 0,
                    L = this.isub(I),
                    I.negative = 1,
                    L._normSign();
                var K, X;
                this.length > I.length ? (K = this,
                X = I) : (K = I,
                X = this);
                for (var Y = 0, j = 0; j < X.length; j++)
                    L = (K.words[j] | 0) + (X.words[j] | 0) + Y,
                    this.words[j] = L & 67108863,
                    Y = L >>> 26;
                for (; Y !== 0 && j < K.length; j++)
                    L = (K.words[j] | 0) + Y,
                    this.words[j] = L & 67108863,
                    Y = L >>> 26;
                if (this.length = K.length,
                Y !== 0)
                    this.words[this.length] = Y,
                    this.length++;
                else if (K !== this)
                    for (; j < K.length; j++)
                        this.words[j] = K.words[j];
                return this
            }
            ,
            $.prototype.add = function(I) {
                var L;
                return I.negative !== 0 && this.negative === 0 ? (I.negative = 0,
                L = this.sub(I),
                I.negative ^= 1,
                L) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0,
                L = I.sub(this),
                this.negative = 1,
                L) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this)
            }
            ,
            $.prototype.isub = function(I) {
                if (I.negative !== 0) {
                    I.negative = 0;
                    var L = this.iadd(I);
                    return I.negative = 1,
                    L._normSign()
                } else if (this.negative !== 0)
                    return this.negative = 0,
                    this.iadd(I),
                    this.negative = 1,
                    this._normSign();
                var K = this.cmp(I);
                if (K === 0)
                    return this.negative = 0,
                    this.length = 1,
                    this.words[0] = 0,
                    this;
                var X, Y;
                K > 0 ? (X = this,
                Y = I) : (X = I,
                Y = this);
                for (var j = 0, G = 0; G < Y.length; G++)
                    L = (X.words[G] | 0) - (Y.words[G] | 0) + j,
                    j = L >> 26,
                    this.words[G] = L & 67108863;
                for (; j !== 0 && G < X.length; G++)
                    L = (X.words[G] | 0) + j,
                    j = L >> 26,
                    this.words[G] = L & 67108863;
                if (j === 0 && G < X.length && X !== this)
                    for (; G < X.length; G++)
                        this.words[G] = X.words[G];
                return this.length = Math.max(this.length, G),
                X !== this && (this.negative = 1),
                this._strip()
            }
            ,
            $.prototype.sub = function(I) {
                return this.clone().isub(I)
            }
            ;
            function se(D, I, L) {
                L.negative = I.negative ^ D.negative;
                var K = D.length + I.length | 0;
                L.length = K,
                K = K - 1 | 0;
                var X = D.words[0] | 0
                  , Y = I.words[0] | 0
                  , j = X * Y
                  , G = j & 67108863
                  , ne = j / 67108864 | 0;
                L.words[0] = G;
                for (var te = 1; te < K; te++) {
                    for (var ce = ne >>> 26, Ee = ne & 67108863, Re = Math.min(te, I.length - 1), Te = Math.max(0, te - D.length + 1); Te <= Re; Te++) {
                        var xe = te - Te | 0;
                        X = D.words[xe] | 0,
                        Y = I.words[Te] | 0,
                        j = X * Y + Ee,
                        ce += j / 67108864 | 0,
                        Ee = j & 67108863
                    }
                    L.words[te] = Ee | 0,
                    ne = ce | 0
                }
                return ne !== 0 ? L.words[te] = ne | 0 : L.length--,
                L._strip()
            }
            var le = function(I, L, K) {
                var X = I.words, Y = L.words, j = K.words, G = 0, ne, te, ce, Ee = X[0] | 0, Re = Ee & 8191, Te = Ee >>> 13, xe = X[1] | 0, ve = xe & 8191, Me = xe >>> 13, Fe = X[2] | 0, be = Fe & 8191, Ce = Fe >>> 13, ze = X[3] | 0, Ge = ze & 8191, nt = ze >>> 13, bt = X[4] | 0, ct = bt & 8191, De = bt >>> 13, Ue = X[5] | 0, We = Ue & 8191, Xe = Ue >>> 13, ht = X[6] | 0, Je = ht & 8191, ot = ht >>> 13, je = X[7] | 0, $e = je & 8191, Ie = je >>> 13, He = X[8] | 0, qe = He & 8191, Ne = He >>> 13, at = X[9] | 0, Ye = at & 8191, it = at >>> 13, At = Y[0] | 0, pt = At & 8191, ut = At >>> 13, Rt = Y[1] | 0, yt = Rt & 8191, st = Rt >>> 13, Wt = Y[2] | 0, Ct = Wt & 8191, Mt = Wt >>> 13, Kt = Y[3] | 0, Pt = Kt & 8191, St = Kt >>> 13, Zt = Y[4] | 0, Nt = Zt & 8191, $t = Zt >>> 13, Gt = Y[5] | 0, Ot = Gt & 8191, Bt = Gt >>> 13, Yt = Y[6] | 0, ye = Yt & 8191, Be = Yt >>> 13, Oe = Y[7] | 0, he = Oe & 8191, Pe = Oe >>> 13, rt = Y[8] | 0, Ze = rt & 8191, tt = rt >>> 13, Et = Y[9] | 0, Tt = Et & 8191, kt = Et >>> 13;
                K.negative = I.negative ^ L.negative,
                K.length = 19,
                ne = Math.imul(Re, pt),
                te = Math.imul(Re, ut),
                te = te + Math.imul(Te, pt) | 0,
                ce = Math.imul(Te, ut);
                var Qt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Qt >>> 26) | 0,
                Qt &= 67108863,
                ne = Math.imul(ve, pt),
                te = Math.imul(ve, ut),
                te = te + Math.imul(Me, pt) | 0,
                ce = Math.imul(Me, ut),
                ne = ne + Math.imul(Re, yt) | 0,
                te = te + Math.imul(Re, st) | 0,
                te = te + Math.imul(Te, yt) | 0,
                ce = ce + Math.imul(Te, st) | 0;
                var Vt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Vt >>> 26) | 0,
                Vt &= 67108863,
                ne = Math.imul(be, pt),
                te = Math.imul(be, ut),
                te = te + Math.imul(Ce, pt) | 0,
                ce = Math.imul(Ce, ut),
                ne = ne + Math.imul(ve, yt) | 0,
                te = te + Math.imul(ve, st) | 0,
                te = te + Math.imul(Me, yt) | 0,
                ce = ce + Math.imul(Me, st) | 0,
                ne = ne + Math.imul(Re, Ct) | 0,
                te = te + Math.imul(Re, Mt) | 0,
                te = te + Math.imul(Te, Ct) | 0,
                ce = ce + Math.imul(Te, Mt) | 0;
                var Ve = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ve >>> 26) | 0,
                Ve &= 67108863,
                ne = Math.imul(Ge, pt),
                te = Math.imul(Ge, ut),
                te = te + Math.imul(nt, pt) | 0,
                ce = Math.imul(nt, ut),
                ne = ne + Math.imul(be, yt) | 0,
                te = te + Math.imul(be, st) | 0,
                te = te + Math.imul(Ce, yt) | 0,
                ce = ce + Math.imul(Ce, st) | 0,
                ne = ne + Math.imul(ve, Ct) | 0,
                te = te + Math.imul(ve, Mt) | 0,
                te = te + Math.imul(Me, Ct) | 0,
                ce = ce + Math.imul(Me, Mt) | 0,
                ne = ne + Math.imul(Re, Pt) | 0,
                te = te + Math.imul(Re, St) | 0,
                te = te + Math.imul(Te, Pt) | 0,
                ce = ce + Math.imul(Te, St) | 0;
                var me = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (me >>> 26) | 0,
                me &= 67108863,
                ne = Math.imul(ct, pt),
                te = Math.imul(ct, ut),
                te = te + Math.imul(De, pt) | 0,
                ce = Math.imul(De, ut),
                ne = ne + Math.imul(Ge, yt) | 0,
                te = te + Math.imul(Ge, st) | 0,
                te = te + Math.imul(nt, yt) | 0,
                ce = ce + Math.imul(nt, st) | 0,
                ne = ne + Math.imul(be, Ct) | 0,
                te = te + Math.imul(be, Mt) | 0,
                te = te + Math.imul(Ce, Ct) | 0,
                ce = ce + Math.imul(Ce, Mt) | 0,
                ne = ne + Math.imul(ve, Pt) | 0,
                te = te + Math.imul(ve, St) | 0,
                te = te + Math.imul(Me, Pt) | 0,
                ce = ce + Math.imul(Me, St) | 0,
                ne = ne + Math.imul(Re, Nt) | 0,
                te = te + Math.imul(Re, $t) | 0,
                te = te + Math.imul(Te, Nt) | 0,
                ce = ce + Math.imul(Te, $t) | 0;
                var ke = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (ke >>> 26) | 0,
                ke &= 67108863,
                ne = Math.imul(We, pt),
                te = Math.imul(We, ut),
                te = te + Math.imul(Xe, pt) | 0,
                ce = Math.imul(Xe, ut),
                ne = ne + Math.imul(ct, yt) | 0,
                te = te + Math.imul(ct, st) | 0,
                te = te + Math.imul(De, yt) | 0,
                ce = ce + Math.imul(De, st) | 0,
                ne = ne + Math.imul(Ge, Ct) | 0,
                te = te + Math.imul(Ge, Mt) | 0,
                te = te + Math.imul(nt, Ct) | 0,
                ce = ce + Math.imul(nt, Mt) | 0,
                ne = ne + Math.imul(be, Pt) | 0,
                te = te + Math.imul(be, St) | 0,
                te = te + Math.imul(Ce, Pt) | 0,
                ce = ce + Math.imul(Ce, St) | 0,
                ne = ne + Math.imul(ve, Nt) | 0,
                te = te + Math.imul(ve, $t) | 0,
                te = te + Math.imul(Me, Nt) | 0,
                ce = ce + Math.imul(Me, $t) | 0,
                ne = ne + Math.imul(Re, Ot) | 0,
                te = te + Math.imul(Re, Bt) | 0,
                te = te + Math.imul(Te, Ot) | 0,
                ce = ce + Math.imul(Te, Bt) | 0;
                var Le = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Le >>> 26) | 0,
                Le &= 67108863,
                ne = Math.imul(Je, pt),
                te = Math.imul(Je, ut),
                te = te + Math.imul(ot, pt) | 0,
                ce = Math.imul(ot, ut),
                ne = ne + Math.imul(We, yt) | 0,
                te = te + Math.imul(We, st) | 0,
                te = te + Math.imul(Xe, yt) | 0,
                ce = ce + Math.imul(Xe, st) | 0,
                ne = ne + Math.imul(ct, Ct) | 0,
                te = te + Math.imul(ct, Mt) | 0,
                te = te + Math.imul(De, Ct) | 0,
                ce = ce + Math.imul(De, Mt) | 0,
                ne = ne + Math.imul(Ge, Pt) | 0,
                te = te + Math.imul(Ge, St) | 0,
                te = te + Math.imul(nt, Pt) | 0,
                ce = ce + Math.imul(nt, St) | 0,
                ne = ne + Math.imul(be, Nt) | 0,
                te = te + Math.imul(be, $t) | 0,
                te = te + Math.imul(Ce, Nt) | 0,
                ce = ce + Math.imul(Ce, $t) | 0,
                ne = ne + Math.imul(ve, Ot) | 0,
                te = te + Math.imul(ve, Bt) | 0,
                te = te + Math.imul(Me, Ot) | 0,
                ce = ce + Math.imul(Me, Bt) | 0,
                ne = ne + Math.imul(Re, ye) | 0,
                te = te + Math.imul(Re, Be) | 0,
                te = te + Math.imul(Te, ye) | 0,
                ce = ce + Math.imul(Te, Be) | 0;
                var Qe = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Qe >>> 26) | 0,
                Qe &= 67108863,
                ne = Math.imul($e, pt),
                te = Math.imul($e, ut),
                te = te + Math.imul(Ie, pt) | 0,
                ce = Math.imul(Ie, ut),
                ne = ne + Math.imul(Je, yt) | 0,
                te = te + Math.imul(Je, st) | 0,
                te = te + Math.imul(ot, yt) | 0,
                ce = ce + Math.imul(ot, st) | 0,
                ne = ne + Math.imul(We, Ct) | 0,
                te = te + Math.imul(We, Mt) | 0,
                te = te + Math.imul(Xe, Ct) | 0,
                ce = ce + Math.imul(Xe, Mt) | 0,
                ne = ne + Math.imul(ct, Pt) | 0,
                te = te + Math.imul(ct, St) | 0,
                te = te + Math.imul(De, Pt) | 0,
                ce = ce + Math.imul(De, St) | 0,
                ne = ne + Math.imul(Ge, Nt) | 0,
                te = te + Math.imul(Ge, $t) | 0,
                te = te + Math.imul(nt, Nt) | 0,
                ce = ce + Math.imul(nt, $t) | 0,
                ne = ne + Math.imul(be, Ot) | 0,
                te = te + Math.imul(be, Bt) | 0,
                te = te + Math.imul(Ce, Ot) | 0,
                ce = ce + Math.imul(Ce, Bt) | 0,
                ne = ne + Math.imul(ve, ye) | 0,
                te = te + Math.imul(ve, Be) | 0,
                te = te + Math.imul(Me, ye) | 0,
                ce = ce + Math.imul(Me, Be) | 0,
                ne = ne + Math.imul(Re, he) | 0,
                te = te + Math.imul(Re, Pe) | 0,
                te = te + Math.imul(Te, he) | 0,
                ce = ce + Math.imul(Te, Pe) | 0;
                var Ke = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ke >>> 26) | 0,
                Ke &= 67108863,
                ne = Math.imul(qe, pt),
                te = Math.imul(qe, ut),
                te = te + Math.imul(Ne, pt) | 0,
                ce = Math.imul(Ne, ut),
                ne = ne + Math.imul($e, yt) | 0,
                te = te + Math.imul($e, st) | 0,
                te = te + Math.imul(Ie, yt) | 0,
                ce = ce + Math.imul(Ie, st) | 0,
                ne = ne + Math.imul(Je, Ct) | 0,
                te = te + Math.imul(Je, Mt) | 0,
                te = te + Math.imul(ot, Ct) | 0,
                ce = ce + Math.imul(ot, Mt) | 0,
                ne = ne + Math.imul(We, Pt) | 0,
                te = te + Math.imul(We, St) | 0,
                te = te + Math.imul(Xe, Pt) | 0,
                ce = ce + Math.imul(Xe, St) | 0,
                ne = ne + Math.imul(ct, Nt) | 0,
                te = te + Math.imul(ct, $t) | 0,
                te = te + Math.imul(De, Nt) | 0,
                ce = ce + Math.imul(De, $t) | 0,
                ne = ne + Math.imul(Ge, Ot) | 0,
                te = te + Math.imul(Ge, Bt) | 0,
                te = te + Math.imul(nt, Ot) | 0,
                ce = ce + Math.imul(nt, Bt) | 0,
                ne = ne + Math.imul(be, ye) | 0,
                te = te + Math.imul(be, Be) | 0,
                te = te + Math.imul(Ce, ye) | 0,
                ce = ce + Math.imul(Ce, Be) | 0,
                ne = ne + Math.imul(ve, he) | 0,
                te = te + Math.imul(ve, Pe) | 0,
                te = te + Math.imul(Me, he) | 0,
                ce = ce + Math.imul(Me, Pe) | 0,
                ne = ne + Math.imul(Re, Ze) | 0,
                te = te + Math.imul(Re, tt) | 0,
                te = te + Math.imul(Te, Ze) | 0,
                ce = ce + Math.imul(Te, tt) | 0;
                var vt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (vt >>> 26) | 0,
                vt &= 67108863,
                ne = Math.imul(Ye, pt),
                te = Math.imul(Ye, ut),
                te = te + Math.imul(it, pt) | 0,
                ce = Math.imul(it, ut),
                ne = ne + Math.imul(qe, yt) | 0,
                te = te + Math.imul(qe, st) | 0,
                te = te + Math.imul(Ne, yt) | 0,
                ce = ce + Math.imul(Ne, st) | 0,
                ne = ne + Math.imul($e, Ct) | 0,
                te = te + Math.imul($e, Mt) | 0,
                te = te + Math.imul(Ie, Ct) | 0,
                ce = ce + Math.imul(Ie, Mt) | 0,
                ne = ne + Math.imul(Je, Pt) | 0,
                te = te + Math.imul(Je, St) | 0,
                te = te + Math.imul(ot, Pt) | 0,
                ce = ce + Math.imul(ot, St) | 0,
                ne = ne + Math.imul(We, Nt) | 0,
                te = te + Math.imul(We, $t) | 0,
                te = te + Math.imul(Xe, Nt) | 0,
                ce = ce + Math.imul(Xe, $t) | 0,
                ne = ne + Math.imul(ct, Ot) | 0,
                te = te + Math.imul(ct, Bt) | 0,
                te = te + Math.imul(De, Ot) | 0,
                ce = ce + Math.imul(De, Bt) | 0,
                ne = ne + Math.imul(Ge, ye) | 0,
                te = te + Math.imul(Ge, Be) | 0,
                te = te + Math.imul(nt, ye) | 0,
                ce = ce + Math.imul(nt, Be) | 0,
                ne = ne + Math.imul(be, he) | 0,
                te = te + Math.imul(be, Pe) | 0,
                te = te + Math.imul(Ce, he) | 0,
                ce = ce + Math.imul(Ce, Pe) | 0,
                ne = ne + Math.imul(ve, Ze) | 0,
                te = te + Math.imul(ve, tt) | 0,
                te = te + Math.imul(Me, Ze) | 0,
                ce = ce + Math.imul(Me, tt) | 0,
                ne = ne + Math.imul(Re, Tt) | 0,
                te = te + Math.imul(Re, kt) | 0,
                te = te + Math.imul(Te, Tt) | 0,
                ce = ce + Math.imul(Te, kt) | 0;
                var dt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (dt >>> 26) | 0,
                dt &= 67108863,
                ne = Math.imul(Ye, yt),
                te = Math.imul(Ye, st),
                te = te + Math.imul(it, yt) | 0,
                ce = Math.imul(it, st),
                ne = ne + Math.imul(qe, Ct) | 0,
                te = te + Math.imul(qe, Mt) | 0,
                te = te + Math.imul(Ne, Ct) | 0,
                ce = ce + Math.imul(Ne, Mt) | 0,
                ne = ne + Math.imul($e, Pt) | 0,
                te = te + Math.imul($e, St) | 0,
                te = te + Math.imul(Ie, Pt) | 0,
                ce = ce + Math.imul(Ie, St) | 0,
                ne = ne + Math.imul(Je, Nt) | 0,
                te = te + Math.imul(Je, $t) | 0,
                te = te + Math.imul(ot, Nt) | 0,
                ce = ce + Math.imul(ot, $t) | 0,
                ne = ne + Math.imul(We, Ot) | 0,
                te = te + Math.imul(We, Bt) | 0,
                te = te + Math.imul(Xe, Ot) | 0,
                ce = ce + Math.imul(Xe, Bt) | 0,
                ne = ne + Math.imul(ct, ye) | 0,
                te = te + Math.imul(ct, Be) | 0,
                te = te + Math.imul(De, ye) | 0,
                ce = ce + Math.imul(De, Be) | 0,
                ne = ne + Math.imul(Ge, he) | 0,
                te = te + Math.imul(Ge, Pe) | 0,
                te = te + Math.imul(nt, he) | 0,
                ce = ce + Math.imul(nt, Pe) | 0,
                ne = ne + Math.imul(be, Ze) | 0,
                te = te + Math.imul(be, tt) | 0,
                te = te + Math.imul(Ce, Ze) | 0,
                ce = ce + Math.imul(Ce, tt) | 0,
                ne = ne + Math.imul(ve, Tt) | 0,
                te = te + Math.imul(ve, kt) | 0,
                te = te + Math.imul(Me, Tt) | 0,
                ce = ce + Math.imul(Me, kt) | 0;
                var It = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (It >>> 26) | 0,
                It &= 67108863,
                ne = Math.imul(Ye, Ct),
                te = Math.imul(Ye, Mt),
                te = te + Math.imul(it, Ct) | 0,
                ce = Math.imul(it, Mt),
                ne = ne + Math.imul(qe, Pt) | 0,
                te = te + Math.imul(qe, St) | 0,
                te = te + Math.imul(Ne, Pt) | 0,
                ce = ce + Math.imul(Ne, St) | 0,
                ne = ne + Math.imul($e, Nt) | 0,
                te = te + Math.imul($e, $t) | 0,
                te = te + Math.imul(Ie, Nt) | 0,
                ce = ce + Math.imul(Ie, $t) | 0,
                ne = ne + Math.imul(Je, Ot) | 0,
                te = te + Math.imul(Je, Bt) | 0,
                te = te + Math.imul(ot, Ot) | 0,
                ce = ce + Math.imul(ot, Bt) | 0,
                ne = ne + Math.imul(We, ye) | 0,
                te = te + Math.imul(We, Be) | 0,
                te = te + Math.imul(Xe, ye) | 0,
                ce = ce + Math.imul(Xe, Be) | 0,
                ne = ne + Math.imul(ct, he) | 0,
                te = te + Math.imul(ct, Pe) | 0,
                te = te + Math.imul(De, he) | 0,
                ce = ce + Math.imul(De, Pe) | 0,
                ne = ne + Math.imul(Ge, Ze) | 0,
                te = te + Math.imul(Ge, tt) | 0,
                te = te + Math.imul(nt, Ze) | 0,
                ce = ce + Math.imul(nt, tt) | 0,
                ne = ne + Math.imul(be, Tt) | 0,
                te = te + Math.imul(be, kt) | 0,
                te = te + Math.imul(Ce, Tt) | 0,
                ce = ce + Math.imul(Ce, kt) | 0;
                var xt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (xt >>> 26) | 0,
                xt &= 67108863,
                ne = Math.imul(Ye, Pt),
                te = Math.imul(Ye, St),
                te = te + Math.imul(it, Pt) | 0,
                ce = Math.imul(it, St),
                ne = ne + Math.imul(qe, Nt) | 0,
                te = te + Math.imul(qe, $t) | 0,
                te = te + Math.imul(Ne, Nt) | 0,
                ce = ce + Math.imul(Ne, $t) | 0,
                ne = ne + Math.imul($e, Ot) | 0,
                te = te + Math.imul($e, Bt) | 0,
                te = te + Math.imul(Ie, Ot) | 0,
                ce = ce + Math.imul(Ie, Bt) | 0,
                ne = ne + Math.imul(Je, ye) | 0,
                te = te + Math.imul(Je, Be) | 0,
                te = te + Math.imul(ot, ye) | 0,
                ce = ce + Math.imul(ot, Be) | 0,
                ne = ne + Math.imul(We, he) | 0,
                te = te + Math.imul(We, Pe) | 0,
                te = te + Math.imul(Xe, he) | 0,
                ce = ce + Math.imul(Xe, Pe) | 0,
                ne = ne + Math.imul(ct, Ze) | 0,
                te = te + Math.imul(ct, tt) | 0,
                te = te + Math.imul(De, Ze) | 0,
                ce = ce + Math.imul(De, tt) | 0,
                ne = ne + Math.imul(Ge, Tt) | 0,
                te = te + Math.imul(Ge, kt) | 0,
                te = te + Math.imul(nt, Tt) | 0,
                ce = ce + Math.imul(nt, kt) | 0;
                var Dt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Dt >>> 26) | 0,
                Dt &= 67108863,
                ne = Math.imul(Ye, Nt),
                te = Math.imul(Ye, $t),
                te = te + Math.imul(it, Nt) | 0,
                ce = Math.imul(it, $t),
                ne = ne + Math.imul(qe, Ot) | 0,
                te = te + Math.imul(qe, Bt) | 0,
                te = te + Math.imul(Ne, Ot) | 0,
                ce = ce + Math.imul(Ne, Bt) | 0,
                ne = ne + Math.imul($e, ye) | 0,
                te = te + Math.imul($e, Be) | 0,
                te = te + Math.imul(Ie, ye) | 0,
                ce = ce + Math.imul(Ie, Be) | 0,
                ne = ne + Math.imul(Je, he) | 0,
                te = te + Math.imul(Je, Pe) | 0,
                te = te + Math.imul(ot, he) | 0,
                ce = ce + Math.imul(ot, Pe) | 0,
                ne = ne + Math.imul(We, Ze) | 0,
                te = te + Math.imul(We, tt) | 0,
                te = te + Math.imul(Xe, Ze) | 0,
                ce = ce + Math.imul(Xe, tt) | 0,
                ne = ne + Math.imul(ct, Tt) | 0,
                te = te + Math.imul(ct, kt) | 0,
                te = te + Math.imul(De, Tt) | 0,
                ce = ce + Math.imul(De, kt) | 0;
                var qt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (qt >>> 26) | 0,
                qt &= 67108863,
                ne = Math.imul(Ye, Ot),
                te = Math.imul(Ye, Bt),
                te = te + Math.imul(it, Ot) | 0,
                ce = Math.imul(it, Bt),
                ne = ne + Math.imul(qe, ye) | 0,
                te = te + Math.imul(qe, Be) | 0,
                te = te + Math.imul(Ne, ye) | 0,
                ce = ce + Math.imul(Ne, Be) | 0,
                ne = ne + Math.imul($e, he) | 0,
                te = te + Math.imul($e, Pe) | 0,
                te = te + Math.imul(Ie, he) | 0,
                ce = ce + Math.imul(Ie, Pe) | 0,
                ne = ne + Math.imul(Je, Ze) | 0,
                te = te + Math.imul(Je, tt) | 0,
                te = te + Math.imul(ot, Ze) | 0,
                ce = ce + Math.imul(ot, tt) | 0,
                ne = ne + Math.imul(We, Tt) | 0,
                te = te + Math.imul(We, kt) | 0,
                te = te + Math.imul(Xe, Tt) | 0,
                ce = ce + Math.imul(Xe, kt) | 0;
                var zt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (zt >>> 26) | 0,
                zt &= 67108863,
                ne = Math.imul(Ye, ye),
                te = Math.imul(Ye, Be),
                te = te + Math.imul(it, ye) | 0,
                ce = Math.imul(it, Be),
                ne = ne + Math.imul(qe, he) | 0,
                te = te + Math.imul(qe, Pe) | 0,
                te = te + Math.imul(Ne, he) | 0,
                ce = ce + Math.imul(Ne, Pe) | 0,
                ne = ne + Math.imul($e, Ze) | 0,
                te = te + Math.imul($e, tt) | 0,
                te = te + Math.imul(Ie, Ze) | 0,
                ce = ce + Math.imul(Ie, tt) | 0,
                ne = ne + Math.imul(Je, Tt) | 0,
                te = te + Math.imul(Je, kt) | 0,
                te = te + Math.imul(ot, Tt) | 0,
                ce = ce + Math.imul(ot, kt) | 0;
                var mt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (mt >>> 26) | 0,
                mt &= 67108863,
                ne = Math.imul(Ye, he),
                te = Math.imul(Ye, Pe),
                te = te + Math.imul(it, he) | 0,
                ce = Math.imul(it, Pe),
                ne = ne + Math.imul(qe, Ze) | 0,
                te = te + Math.imul(qe, tt) | 0,
                te = te + Math.imul(Ne, Ze) | 0,
                ce = ce + Math.imul(Ne, tt) | 0,
                ne = ne + Math.imul($e, Tt) | 0,
                te = te + Math.imul($e, kt) | 0,
                te = te + Math.imul(Ie, Tt) | 0,
                ce = ce + Math.imul(Ie, kt) | 0;
                var wt = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (wt >>> 26) | 0,
                wt &= 67108863,
                ne = Math.imul(Ye, Ze),
                te = Math.imul(Ye, tt),
                te = te + Math.imul(it, Ze) | 0,
                ce = Math.imul(it, tt),
                ne = ne + Math.imul(qe, Tt) | 0,
                te = te + Math.imul(qe, kt) | 0,
                te = te + Math.imul(Ne, Tt) | 0,
                ce = ce + Math.imul(Ne, kt) | 0;
                var Ut = (G + ne | 0) + ((te & 8191) << 13) | 0;
                G = (ce + (te >>> 13) | 0) + (Ut >>> 26) | 0,
                Ut &= 67108863,
                ne = Math.imul(Ye, Tt),
                te = Math.imul(Ye, kt),
                te = te + Math.imul(it, Tt) | 0,
                ce = Math.imul(it, kt);
                var Ft = (G + ne | 0) + ((te & 8191) << 13) | 0;
                return G = (ce + (te >>> 13) | 0) + (Ft >>> 26) | 0,
                Ft &= 67108863,
                j[0] = Qt,
                j[1] = Vt,
                j[2] = Ve,
                j[3] = me,
                j[4] = ke,
                j[5] = Le,
                j[6] = Qe,
                j[7] = Ke,
                j[8] = vt,
                j[9] = dt,
                j[10] = It,
                j[11] = xt,
                j[12] = Dt,
                j[13] = qt,
                j[14] = zt,
                j[15] = mt,
                j[16] = wt,
                j[17] = Ut,
                j[18] = Ft,
                G !== 0 && (j[19] = G,
                K.length++),
                K
            };
            Math.imul || (le = se);
            function de(D, I, L) {
                L.negative = I.negative ^ D.negative,
                L.length = D.length + I.length;
                for (var K = 0, X = 0, Y = 0; Y < L.length - 1; Y++) {
                    var j = X;
                    X = 0;
                    for (var G = K & 67108863, ne = Math.min(Y, I.length - 1), te = Math.max(0, Y - D.length + 1); te <= ne; te++) {
                        var ce = Y - te
                          , Ee = D.words[ce] | 0
                          , Re = I.words[te] | 0
                          , Te = Ee * Re
                          , xe = Te & 67108863;
                        j = j + (Te / 67108864 | 0) | 0,
                        xe = xe + G | 0,
                        G = xe & 67108863,
                        j = j + (xe >>> 26) | 0,
                        X += j >>> 26,
                        j &= 67108863
                    }
                    L.words[Y] = G,
                    K = j,
                    j = X
                }
                return K !== 0 ? L.words[Y] = K : L.length--,
                L._strip()
            }
            function fe(D, I, L) {
                return de(D, I, L)
            }
            $.prototype.mulTo = function(I, L) {
                var K, X = this.length + I.length;
                return this.length === 10 && I.length === 10 ? K = le(this, I, L) : X < 63 ? K = se(this, I, L) : X < 1024 ? K = de(this, I, L) : K = fe(this, I, L),
                K
            }
            ,
            $.prototype.mul = function(I) {
                var L = new $(null);
                return L.words = new Array(this.length + I.length),
                this.mulTo(I, L)
            }
            ,
            $.prototype.mulf = function(I) {
                var L = new $(null);
                return L.words = new Array(this.length + I.length),
                fe(this, I, L)
            }
            ,
            $.prototype.imul = function(I) {
                return this.clone().mulTo(I, this)
            }
            ,
            $.prototype.imuln = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(typeof I == "number"),
                M(I < 67108864);
                for (var K = 0, X = 0; X < this.length; X++) {
                    var Y = (this.words[X] | 0) * I
                      , j = (Y & 67108863) + (K & 67108863);
                    K >>= 26,
                    K += Y / 67108864 | 0,
                    K += j >>> 26,
                    this.words[X] = j & 67108863
                }
                return K !== 0 && (this.words[X] = K,
                this.length++),
                L ? this.ineg() : this
            }
            ,
            $.prototype.muln = function(I) {
                return this.clone().imuln(I)
            }
            ,
            $.prototype.sqr = function() {
                return this.mul(this)
            }
            ,
            $.prototype.isqr = function() {
                return this.imul(this.clone())
            }
            ,
            $.prototype.pow = function(I) {
                var L = ae(I);
                if (L.length === 0)
                    return new $(1);
                for (var K = this, X = 0; X < L.length && L[X] === 0; X++,
                K = K.sqr())
                    ;
                if (++X < L.length)
                    for (var Y = K.sqr(); X < L.length; X++,
                    Y = Y.sqr())
                        L[X] !== 0 && (K = K.mul(Y));
                return K
            }
            ,
            $.prototype.iushln = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26, K = (I - L) / 26, X = 67108863 >>> 26 - L << 26 - L, Y;
                if (L !== 0) {
                    var j = 0;
                    for (Y = 0; Y < this.length; Y++) {
                        var G = this.words[Y] & X
                          , ne = (this.words[Y] | 0) - G << L;
                        this.words[Y] = ne | j,
                        j = G >>> 26 - L
                    }
                    j && (this.words[Y] = j,
                    this.length++)
                }
                if (K !== 0) {
                    for (Y = this.length - 1; Y >= 0; Y--)
                        this.words[Y + K] = this.words[Y];
                    for (Y = 0; Y < K; Y++)
                        this.words[Y] = 0;
                    this.length += K
                }
                return this._strip()
            }
            ,
            $.prototype.ishln = function(I) {
                return M(this.negative === 0),
                this.iushln(I)
            }
            ,
            $.prototype.iushrn = function(I, L, K) {
                M(typeof I == "number" && I >= 0);
                var X;
                L ? X = (L - L % 26) / 26 : X = 0;
                var Y = I % 26
                  , j = Math.min((I - Y) / 26, this.length)
                  , G = 67108863 ^ 67108863 >>> Y << Y
                  , ne = K;
                if (X -= j,
                X = Math.max(0, X),
                ne) {
                    for (var te = 0; te < j; te++)
                        ne.words[te] = this.words[te];
                    ne.length = j
                }
                if (j !== 0)
                    if (this.length > j)
                        for (this.length -= j,
                        te = 0; te < this.length; te++)
                            this.words[te] = this.words[te + j];
                    else
                        this.words[0] = 0,
                        this.length = 1;
                var ce = 0;
                for (te = this.length - 1; te >= 0 && (ce !== 0 || te >= X); te--) {
                    var Ee = this.words[te] | 0;
                    this.words[te] = ce << 26 - Y | Ee >>> Y,
                    ce = Ee & G
                }
                return ne && ce !== 0 && (ne.words[ne.length++] = ce),
                this.length === 0 && (this.words[0] = 0,
                this.length = 1),
                this._strip()
            }
            ,
            $.prototype.ishrn = function(I, L, K) {
                return M(this.negative === 0),
                this.iushrn(I, L, K)
            }
            ,
            $.prototype.shln = function(I) {
                return this.clone().ishln(I)
            }
            ,
            $.prototype.ushln = function(I) {
                return this.clone().iushln(I)
            }
            ,
            $.prototype.shrn = function(I) {
                return this.clone().ishrn(I)
            }
            ,
            $.prototype.ushrn = function(I) {
                return this.clone().iushrn(I)
            }
            ,
            $.prototype.testn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26
                  , K = (I - L) / 26
                  , X = 1 << L;
                if (this.length <= K)
                    return !1;
                var Y = this.words[K];
                return !!(Y & X)
            }
            ,
            $.prototype.imaskn = function(I) {
                M(typeof I == "number" && I >= 0);
                var L = I % 26
                  , K = (I - L) / 26;
                if (M(this.negative === 0, "imaskn works only with positive numbers"),
                this.length <= K)
                    return this;
                if (L !== 0 && K++,
                this.length = Math.min(K, this.length),
                L !== 0) {
                    var X = 67108863 ^ 67108863 >>> L << L;
                    this.words[this.length - 1] &= X
                }
                return this._strip()
            }
            ,
            $.prototype.maskn = function(I) {
                return this.clone().imaskn(I)
            }
            ,
            $.prototype.iaddn = function(I) {
                return M(typeof I == "number"),
                M(I < 67108864),
                I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= I ? (this.words[0] = I - (this.words[0] | 0),
                this.negative = 0,
                this) : (this.negative = 0,
                this.isubn(I),
                this.negative = 1,
                this) : this._iaddn(I)
            }
            ,
            $.prototype._iaddn = function(I) {
                this.words[0] += I;
                for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                    this.words[L] -= 67108864,
                    L === this.length - 1 ? this.words[L + 1] = 1 : this.words[L + 1]++;
                return this.length = Math.max(this.length, L + 1),
                this
            }
            ,
            $.prototype.isubn = function(I) {
                if (M(typeof I == "number"),
                M(I < 67108864),
                I < 0)
                    return this.iaddn(-I);
                if (this.negative !== 0)
                    return this.negative = 0,
                    this.iaddn(I),
                    this.negative = 1,
                    this;
                if (this.words[0] -= I,
                this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0],
                    this.negative = 1;
                else
                    for (var L = 0; L < this.length && this.words[L] < 0; L++)
                        this.words[L] += 67108864,
                        this.words[L + 1] -= 1;
                return this._strip()
            }
            ,
            $.prototype.addn = function(I) {
                return this.clone().iaddn(I)
            }
            ,
            $.prototype.subn = function(I) {
                return this.clone().isubn(I)
            }
            ,
            $.prototype.iabs = function() {
                return this.negative = 0,
                this
            }
            ,
            $.prototype.abs = function() {
                return this.clone().iabs()
            }
            ,
            $.prototype._ishlnsubmul = function(I, L, K) {
                var X = I.length + K, Y;
                this._expand(X);
                var j, G = 0;
                for (Y = 0; Y < I.length; Y++) {
                    j = (this.words[Y + K] | 0) + G;
                    var ne = (I.words[Y] | 0) * L;
                    j -= ne & 67108863,
                    G = (j >> 26) - (ne / 67108864 | 0),
                    this.words[Y + K] = j & 67108863
                }
                for (; Y < this.length - K; Y++)
                    j = (this.words[Y + K] | 0) + G,
                    G = j >> 26,
                    this.words[Y + K] = j & 67108863;
                if (G === 0)
                    return this._strip();
                for (M(G === -1),
                G = 0,
                Y = 0; Y < this.length; Y++)
                    j = -(this.words[Y] | 0) + G,
                    G = j >> 26,
                    this.words[Y] = j & 67108863;
                return this.negative = 1,
                this._strip()
            }
            ,
            $.prototype._wordDiv = function(I, L) {
                var K = this.length - I.length
                  , X = this.clone()
                  , Y = I
                  , j = Y.words[Y.length - 1] | 0
                  , G = this._countBits(j);
                K = 26 - G,
                K !== 0 && (Y = Y.ushln(K),
                X.iushln(K),
                j = Y.words[Y.length - 1] | 0);
                var ne = X.length - Y.length, te;
                if (L !== "mod") {
                    te = new $(null),
                    te.length = ne + 1,
                    te.words = new Array(te.length);
                    for (var ce = 0; ce < te.length; ce++)
                        te.words[ce] = 0
                }
                var Ee = X.clone()._ishlnsubmul(Y, 1, ne);
                Ee.negative === 0 && (X = Ee,
                te && (te.words[ne] = 1));
                for (var Re = ne - 1; Re >= 0; Re--) {
                    var Te = (X.words[Y.length + Re] | 0) * 67108864 + (X.words[Y.length + Re - 1] | 0);
                    for (Te = Math.min(Te / j | 0, 67108863),
                    X._ishlnsubmul(Y, Te, Re); X.negative !== 0; )
                        Te--,
                        X.negative = 0,
                        X._ishlnsubmul(Y, 1, Re),
                        X.isZero() || (X.negative ^= 1);
                    te && (te.words[Re] = Te)
                }
                return te && te._strip(),
                X._strip(),
                L !== "div" && K !== 0 && X.iushrn(K),
                {
                    div: te || null,
                    mod: X
                }
            }
            ,
            $.prototype.divmod = function(I, L, K) {
                if (M(!I.isZero()),
                this.isZero())
                    return {
                        div: new $(0),
                        mod: new $(0)
                    };
                var X, Y, j;
                return this.negative !== 0 && I.negative === 0 ? (j = this.neg().divmod(I, L),
                L !== "mod" && (X = j.div.neg()),
                L !== "div" && (Y = j.mod.neg(),
                K && Y.negative !== 0 && Y.iadd(I)),
                {
                    div: X,
                    mod: Y
                }) : this.negative === 0 && I.negative !== 0 ? (j = this.divmod(I.neg(), L),
                L !== "mod" && (X = j.div.neg()),
                {
                    div: X,
                    mod: j.mod
                }) : this.negative & I.negative ? (j = this.neg().divmod(I.neg(), L),
                L !== "div" && (Y = j.mod.neg(),
                K && Y.negative !== 0 && Y.isub(I)),
                {
                    div: j.div,
                    mod: Y
                }) : I.length > this.length || this.cmp(I) < 0 ? {
                    div: new $(0),
                    mod: this
                } : I.length === 1 ? L === "div" ? {
                    div: this.divn(I.words[0]),
                    mod: null
                } : L === "mod" ? {
                    div: null,
                    mod: new $(this.modrn(I.words[0]))
                } : {
                    div: this.divn(I.words[0]),
                    mod: new $(this.modrn(I.words[0]))
                } : this._wordDiv(I, L)
            }
            ,
            $.prototype.div = function(I) {
                return this.divmod(I, "div", !1).div
            }
            ,
            $.prototype.mod = function(I) {
                return this.divmod(I, "mod", !1).mod
            }
            ,
            $.prototype.umod = function(I) {
                return this.divmod(I, "mod", !0).mod
            }
            ,
            $.prototype.divRound = function(I) {
                var L = this.divmod(I);
                if (L.mod.isZero())
                    return L.div;
                var K = L.div.negative !== 0 ? L.mod.isub(I) : L.mod
                  , X = I.ushrn(1)
                  , Y = I.andln(1)
                  , j = K.cmp(X);
                return j < 0 || Y === 1 && j === 0 ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }
            ,
            $.prototype.modrn = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(I <= 67108863);
                for (var K = (1 << 26) % I, X = 0, Y = this.length - 1; Y >= 0; Y--)
                    X = (K * X + (this.words[Y] | 0)) % I;
                return L ? -X : X
            }
            ,
            $.prototype.modn = function(I) {
                return this.modrn(I)
            }
            ,
            $.prototype.idivn = function(I) {
                var L = I < 0;
                L && (I = -I),
                M(I <= 67108863);
                for (var K = 0, X = this.length - 1; X >= 0; X--) {
                    var Y = (this.words[X] | 0) + K * 67108864;
                    this.words[X] = Y / I | 0,
                    K = Y % I
                }
                return this._strip(),
                L ? this.ineg() : this
            }
            ,
            $.prototype.divn = function(I) {
                return this.clone().idivn(I)
            }
            ,
            $.prototype.egcd = function(I) {
                M(I.negative === 0),
                M(!I.isZero());
                var L = this
                  , K = I.clone();
                L.negative !== 0 ? L = L.umod(I) : L = L.clone();
                for (var X = new $(1), Y = new $(0), j = new $(0), G = new $(1), ne = 0; L.isEven() && K.isEven(); )
                    L.iushrn(1),
                    K.iushrn(1),
                    ++ne;
                for (var te = K.clone(), ce = L.clone(); !L.isZero(); ) {
                    for (var Ee = 0, Re = 1; !(L.words[0] & Re) && Ee < 26; ++Ee,
                    Re <<= 1)
                        ;
                    if (Ee > 0)
                        for (L.iushrn(Ee); Ee-- > 0; )
                            (X.isOdd() || Y.isOdd()) && (X.iadd(te),
                            Y.isub(ce)),
                            X.iushrn(1),
                            Y.iushrn(1);
                    for (var Te = 0, xe = 1; !(K.words[0] & xe) && Te < 26; ++Te,
                    xe <<= 1)
                        ;
                    if (Te > 0)
                        for (K.iushrn(Te); Te-- > 0; )
                            (j.isOdd() || G.isOdd()) && (j.iadd(te),
                            G.isub(ce)),
                            j.iushrn(1),
                            G.iushrn(1);
                    L.cmp(K) >= 0 ? (L.isub(K),
                    X.isub(j),
                    Y.isub(G)) : (K.isub(L),
                    j.isub(X),
                    G.isub(Y))
                }
                return {
                    a: j,
                    b: G,
                    gcd: K.iushln(ne)
                }
            }
            ,
            $.prototype._invmp = function(I) {
                M(I.negative === 0),
                M(!I.isZero());
                var L = this
                  , K = I.clone();
                L.negative !== 0 ? L = L.umod(I) : L = L.clone();
                for (var X = new $(1), Y = new $(0), j = K.clone(); L.cmpn(1) > 0 && K.cmpn(1) > 0; ) {
                    for (var G = 0, ne = 1; !(L.words[0] & ne) && G < 26; ++G,
                    ne <<= 1)
                        ;
                    if (G > 0)
                        for (L.iushrn(G); G-- > 0; )
                            X.isOdd() && X.iadd(j),
                            X.iushrn(1);
                    for (var te = 0, ce = 1; !(K.words[0] & ce) && te < 26; ++te,
                    ce <<= 1)
                        ;
                    if (te > 0)
                        for (K.iushrn(te); te-- > 0; )
                            Y.isOdd() && Y.iadd(j),
                            Y.iushrn(1);
                    L.cmp(K) >= 0 ? (L.isub(K),
                    X.isub(Y)) : (K.isub(L),
                    Y.isub(X))
                }
                var Ee;
                return L.cmpn(1) === 0 ? Ee = X : Ee = Y,
                Ee.cmpn(0) < 0 && Ee.iadd(I),
                Ee
            }
            ,
            $.prototype.gcd = function(I) {
                if (this.isZero())
                    return I.abs();
                if (I.isZero())
                    return this.abs();
                var L = this.clone()
                  , K = I.clone();
                L.negative = 0,
                K.negative = 0;
                for (var X = 0; L.isEven() && K.isEven(); X++)
                    L.iushrn(1),
                    K.iushrn(1);
                do {
                    for (; L.isEven(); )
                        L.iushrn(1);
                    for (; K.isEven(); )
                        K.iushrn(1);
                    var Y = L.cmp(K);
                    if (Y < 0) {
                        var j = L;
                        L = K,
                        K = j
                    } else if (Y === 0 || K.cmpn(1) === 0)
                        break;
                    L.isub(K)
                } while (!0);
                return K.iushln(X)
            }
            ,
            $.prototype.invm = function(I) {
                return this.egcd(I).a.umod(I)
            }
            ,
            $.prototype.isEven = function() {
                return (this.words[0] & 1) === 0
            }
            ,
            $.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1
            }
            ,
            $.prototype.andln = function(I) {
                return this.words[0] & I
            }
            ,
            $.prototype.bincn = function(I) {
                M(typeof I == "number");
                var L = I % 26
                  , K = (I - L) / 26
                  , X = 1 << L;
                if (this.length <= K)
                    return this._expand(K + 1),
                    this.words[K] |= X,
                    this;
                for (var Y = X, j = K; Y !== 0 && j < this.length; j++) {
                    var G = this.words[j] | 0;
                    G += Y,
                    Y = G >>> 26,
                    G &= 67108863,
                    this.words[j] = G
                }
                return Y !== 0 && (this.words[j] = Y,
                this.length++),
                this
            }
            ,
            $.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0
            }
            ,
            $.prototype.cmpn = function(I) {
                var L = I < 0;
                if (this.negative !== 0 && !L)
                    return -1;
                if (this.negative === 0 && L)
                    return 1;
                this._strip();
                var K;
                if (this.length > 1)
                    K = 1;
                else {
                    L && (I = -I),
                    M(I <= 67108863, "Number is too big");
                    var X = this.words[0] | 0;
                    K = X === I ? 0 : X < I ? -1 : 1
                }
                return this.negative !== 0 ? -K | 0 : K
            }
            ,
            $.prototype.cmp = function(I) {
                if (this.negative !== 0 && I.negative === 0)
                    return -1;
                if (this.negative === 0 && I.negative !== 0)
                    return 1;
                var L = this.ucmp(I);
                return this.negative !== 0 ? -L | 0 : L
            }
            ,
            $.prototype.ucmp = function(I) {
                if (this.length > I.length)
                    return 1;
                if (this.length < I.length)
                    return -1;
                for (var L = 0, K = this.length - 1; K >= 0; K--) {
                    var X = this.words[K] | 0
                      , Y = I.words[K] | 0;
                    if (X !== Y) {
                        X < Y ? L = -1 : X > Y && (L = 1);
                        break
                    }
                }
                return L
            }
            ,
            $.prototype.gtn = function(I) {
                return this.cmpn(I) === 1
            }
            ,
            $.prototype.gt = function(I) {
                return this.cmp(I) === 1
            }
            ,
            $.prototype.gten = function(I) {
                return this.cmpn(I) >= 0
            }
            ,
            $.prototype.gte = function(I) {
                return this.cmp(I) >= 0
            }
            ,
            $.prototype.ltn = function(I) {
                return this.cmpn(I) === -1
            }
            ,
            $.prototype.lt = function(I) {
                return this.cmp(I) === -1
            }
            ,
            $.prototype.lten = function(I) {
                return this.cmpn(I) <= 0
            }
            ,
            $.prototype.lte = function(I) {
                return this.cmp(I) <= 0
            }
            ,
            $.prototype.eqn = function(I) {
                return this.cmpn(I) === 0
            }
            ,
            $.prototype.eq = function(I) {
                return this.cmp(I) === 0
            }
            ,
            $.red = function(I) {
                return new V(I)
            }
            ,
            $.prototype.toRed = function(I) {
                return M(!this.red, "Already a number in reduction context"),
                M(this.negative === 0, "red works only with positives"),
                I.convertTo(this)._forceRed(I)
            }
            ,
            $.prototype.fromRed = function() {
                return M(this.red, "fromRed works only with numbers in reduction context"),
                this.red.convertFrom(this)
            }
            ,
            $.prototype._forceRed = function(I) {
                return this.red = I,
                this
            }
            ,
            $.prototype.forceRed = function(I) {
                return M(!this.red, "Already a number in reduction context"),
                this._forceRed(I)
            }
            ,
            $.prototype.redAdd = function(I) {
                return M(this.red, "redAdd works only with red numbers"),
                this.red.add(this, I)
            }
            ,
            $.prototype.redIAdd = function(I) {
                return M(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, I)
            }
            ,
            $.prototype.redSub = function(I) {
                return M(this.red, "redSub works only with red numbers"),
                this.red.sub(this, I)
            }
            ,
            $.prototype.redISub = function(I) {
                return M(this.red, "redISub works only with red numbers"),
                this.red.isub(this, I)
            }
            ,
            $.prototype.redShl = function(I) {
                return M(this.red, "redShl works only with red numbers"),
                this.red.shl(this, I)
            }
            ,
            $.prototype.redMul = function(I) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, I),
                this.red.mul(this, I)
            }
            ,
            $.prototype.redIMul = function(I) {
                return M(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, I),
                this.red.imul(this, I)
            }
            ,
            $.prototype.redSqr = function() {
                return M(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
            }
            ,
            $.prototype.redISqr = function() {
                return M(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
            }
            ,
            $.prototype.redSqrt = function() {
                return M(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
            }
            ,
            $.prototype.redInvm = function() {
                return M(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
            }
            ,
            $.prototype.redNeg = function() {
                return M(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
            }
            ,
            $.prototype.redPow = function(I) {
                return M(this.red && !I.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, I)
            }
            ;
            var pe = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function ge(D, I) {
                this.name = D,
                this.p = new $(I,16),
                this.n = this.p.bitLength(),
                this.k = new $(1).iushln(this.n).isub(this.p),
                this.tmp = this._tmp()
            }
            ge.prototype._tmp = function() {
                var I = new $(null);
                return I.words = new Array(Math.ceil(this.n / 13)),
                I
            }
            ,
            ge.prototype.ireduce = function(I) {
                var L = I, K;
                do
                    this.split(L, this.tmp),
                    L = this.imulK(L),
                    L = L.iadd(this.tmp),
                    K = L.bitLength();
                while (K > this.n);
                var X = K < this.n ? -1 : L.ucmp(this.p);
                return X === 0 ? (L.words[0] = 0,
                L.length = 1) : X > 0 ? L.isub(this.p) : L.strip !== void 0 ? L.strip() : L._strip(),
                L
            }
            ,
            ge.prototype.split = function(I, L) {
                I.iushrn(this.n, 0, L)
            }
            ,
            ge.prototype.imulK = function(I) {
                return I.imul(this.k)
            }
            ;
            function we() {
                ge.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
            }
            T(we, ge),
            we.prototype.split = function(I, L) {
                for (var K = 4194303, X = Math.min(I.length, 9), Y = 0; Y < X; Y++)
                    L.words[Y] = I.words[Y];
                if (L.length = X,
                I.length <= 9) {
                    I.words[0] = 0,
                    I.length = 1;
                    return
                }
                var j = I.words[9];
                for (L.words[L.length++] = j & K,
                Y = 10; Y < I.length; Y++) {
                    var G = I.words[Y] | 0;
                    I.words[Y - 10] = (G & K) << 4 | j >>> 22,
                    j = G
                }
                j >>>= 22,
                I.words[Y - 10] = j,
                j === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9
            }
            ,
            we.prototype.imulK = function(I) {
                I.words[I.length] = 0,
                I.words[I.length + 1] = 0,
                I.length += 2;
                for (var L = 0, K = 0; K < I.length; K++) {
                    var X = I.words[K] | 0;
                    L += X * 977,
                    I.words[K] = L & 67108863,
                    L = X * 64 + (L / 67108864 | 0)
                }
                return I.words[I.length - 1] === 0 && (I.length--,
                I.words[I.length - 1] === 0 && I.length--),
                I
            }
            ;
            function Ae() {
                ge.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
            }
            T(Ae, ge);
            function Se() {
                ge.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
            }
            T(Se, ge);
            function ue() {
                ge.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
            }
            T(ue, ge),
            ue.prototype.imulK = function(I) {
                for (var L = 0, K = 0; K < I.length; K++) {
                    var X = (I.words[K] | 0) * 19 + L
                      , Y = X & 67108863;
                    X >>>= 26,
                    I.words[K] = Y,
                    L = X
                }
                return L !== 0 && (I.words[I.length++] = L),
                I
            }
            ,
            $._prime = function(I) {
                if (pe[I])
                    return pe[I];
                var L;
                if (I === "k256")
                    L = new we;
                else if (I === "p224")
                    L = new Ae;
                else if (I === "p192")
                    L = new Se;
                else if (I === "p25519")
                    L = new ue;
                else
                    throw new Error("Unknown prime " + I);
                return pe[I] = L,
                L
            }
            ;
            function V(D) {
                if (typeof D == "string") {
                    var I = $._prime(D);
                    this.m = I.p,
                    this.prime = I
                } else
                    M(D.gtn(1), "modulus must be greater than 1"),
                    this.m = D,
                    this.prime = null
            }
            V.prototype._verify1 = function(I) {
                M(I.negative === 0, "red works only with positives"),
                M(I.red, "red works only with red numbers")
            }
            ,
            V.prototype._verify2 = function(I, L) {
                M((I.negative | L.negative) === 0, "red works only with positives"),
                M(I.red && I.red === L.red, "red works only with red numbers")
            }
            ,
            V.prototype.imod = function(I) {
                return this.prime ? this.prime.ireduce(I)._forceRed(this) : (U(I, I.umod(this.m)._forceRed(this)),
                I)
            }
            ,
            V.prototype.neg = function(I) {
                return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this)
            }
            ,
            V.prototype.add = function(I, L) {
                this._verify2(I, L);
                var K = I.add(L);
                return K.cmp(this.m) >= 0 && K.isub(this.m),
                K._forceRed(this)
            }
            ,
            V.prototype.iadd = function(I, L) {
                this._verify2(I, L);
                var K = I.iadd(L);
                return K.cmp(this.m) >= 0 && K.isub(this.m),
                K
            }
            ,
            V.prototype.sub = function(I, L) {
                this._verify2(I, L);
                var K = I.sub(L);
                return K.cmpn(0) < 0 && K.iadd(this.m),
                K._forceRed(this)
            }
            ,
            V.prototype.isub = function(I, L) {
                this._verify2(I, L);
                var K = I.isub(L);
                return K.cmpn(0) < 0 && K.iadd(this.m),
                K
            }
            ,
            V.prototype.shl = function(I, L) {
                return this._verify1(I),
                this.imod(I.ushln(L))
            }
            ,
            V.prototype.imul = function(I, L) {
                return this._verify2(I, L),
                this.imod(I.imul(L))
            }
            ,
            V.prototype.mul = function(I, L) {
                return this._verify2(I, L),
                this.imod(I.mul(L))
            }
            ,
            V.prototype.isqr = function(I) {
                return this.imul(I, I.clone())
            }
            ,
            V.prototype.sqr = function(I) {
                return this.mul(I, I)
            }
            ,
            V.prototype.sqrt = function(I) {
                if (I.isZero())
                    return I.clone();
                var L = this.m.andln(3);
                if (M(L % 2 === 1),
                L === 3) {
                    var K = this.m.add(new $(1)).iushrn(2);
                    return this.pow(I, K)
                }
                for (var X = this.m.subn(1), Y = 0; !X.isZero() && X.andln(1) === 0; )
                    Y++,
                    X.iushrn(1);
                M(!X.isZero());
                var j = new $(1).toRed(this)
                  , G = j.redNeg()
                  , ne = this.m.subn(1).iushrn(1)
                  , te = this.m.bitLength();
                for (te = new $(2 * te * te).toRed(this); this.pow(te, ne).cmp(G) !== 0; )
                    te.redIAdd(G);
                for (var ce = this.pow(te, X), Ee = this.pow(I, X.addn(1).iushrn(1)), Re = this.pow(I, X), Te = Y; Re.cmp(j) !== 0; ) {
                    for (var xe = Re, ve = 0; xe.cmp(j) !== 0; ve++)
                        xe = xe.redSqr();
                    M(ve < Te);
                    var Me = this.pow(ce, new $(1).iushln(Te - ve - 1));
                    Ee = Ee.redMul(Me),
                    ce = Me.redSqr(),
                    Re = Re.redMul(ce),
                    Te = ve
                }
                return Ee
            }
            ,
            V.prototype.invm = function(I) {
                var L = I._invmp(this.m);
                return L.negative !== 0 ? (L.negative = 0,
                this.imod(L).redNeg()) : this.imod(L)
            }
            ,
            V.prototype.pow = function(I, L) {
                if (L.isZero())
                    return new $(1).toRed(this);
                if (L.cmpn(1) === 0)
                    return I.clone();
                var K = 4
                  , X = new Array(1 << K);
                X[0] = new $(1).toRed(this),
                X[1] = I;
                for (var Y = 2; Y < X.length; Y++)
                    X[Y] = this.mul(X[Y - 1], I);
                var j = X[0]
                  , G = 0
                  , ne = 0
                  , te = L.bitLength() % 26;
                for (te === 0 && (te = 26),
                Y = L.length - 1; Y >= 0; Y--) {
                    for (var ce = L.words[Y], Ee = te - 1; Ee >= 0; Ee--) {
                        var Re = ce >> Ee & 1;
                        if (j !== X[0] && (j = this.sqr(j)),
                        Re === 0 && G === 0) {
                            ne = 0;
                            continue
                        }
                        G <<= 1,
                        G |= Re,
                        ne++,
                        !(ne !== K && (Y !== 0 || Ee !== 0)) && (j = this.mul(j, X[G]),
                        ne = 0,
                        G = 0)
                    }
                    te = 26
                }
                return j
            }
            ,
            V.prototype.convertTo = function(I) {
                var L = I.umod(this.m);
                return L === I ? L.clone() : L
            }
            ,
            V.prototype.convertFrom = function(I) {
                var L = I.clone();
                return L.red = null,
                L
            }
            ,
            $.mont = function(I) {
                return new W(I)
            }
            ;
            function W(D) {
                V.call(this, D),
                this.shift = this.m.bitLength(),
                this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
                this.r = new $(1).iushln(this.shift),
                this.r2 = this.imod(this.r.sqr()),
                this.rinv = this.r._invmp(this.m),
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
                this.minv = this.minv.umod(this.r),
                this.minv = this.r.sub(this.minv)
            }
            T(W, V),
            W.prototype.convertTo = function(I) {
                return this.imod(I.ushln(this.shift))
            }
            ,
            W.prototype.convertFrom = function(I) {
                var L = this.imod(I.mul(this.rinv));
                return L.red = null,
                L
            }
            ,
            W.prototype.imul = function(I, L) {
                if (I.isZero() || L.isZero())
                    return I.words[0] = 0,
                    I.length = 1,
                    I;
                var K = I.imul(L)
                  , X = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Y = K.isub(X).iushrn(this.shift)
                  , j = Y;
                return Y.cmp(this.m) >= 0 ? j = Y.isub(this.m) : Y.cmpn(0) < 0 && (j = Y.iadd(this.m)),
                j._forceRed(this)
            }
            ,
            W.prototype.mul = function(I, L) {
                if (I.isZero() || L.isZero())
                    return new $(0)._forceRed(this);
                var K = I.mul(L)
                  , X = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
                  , Y = K.isub(X).iushrn(this.shift)
                  , j = Y;
                return Y.cmp(this.m) >= 0 ? j = Y.isub(this.m) : Y.cmpn(0) < 0 && (j = Y.iadd(this.m)),
                j._forceRed(this)
            }
            ,
            W.prototype.invm = function(I) {
                var L = this.imod(I._invmp(this.m).mul(this.r2));
                return L._forceRed(this)
            }
        }
        )(C, commonjsGlobal)
    }(bn$3)),
    bn$3.exports
}
var asn1$1 = {}, asn1 = {}, api$1 = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
    return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1,
    function(exports) {
        var indexOf = function(C, S) {
            if (C.indexOf)
                return C.indexOf(S);
            for (var E = 0; E < C.length; E++)
                if (C[E] === S)
                    return E;
            return -1
        }
          , Object_keys = function(C) {
            if (Object.keys)
                return Object.keys(C);
            var S = [];
            for (var E in C)
                S.push(E);
            return S
        }
          , forEach = function(C, S) {
            if (C.forEach)
                return C.forEach(S);
            for (var E = 0; E < C.length; E++)
                S(C[E], E, C)
        }
          , defineProp = function() {
            try {
                return Object.defineProperty({}, "_", {}),
                function(C, S, E) {
                    Object.defineProperty(C, S, {
                        writable: !0,
                        enumerable: !1,
                        configurable: !0,
                        value: E
                    })
                }
            } catch {
                return function(S, E, M) {
                    S[E] = M
                }
            }
        }()
          , globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
        function Context() {}
        Context.prototype = {};
        var Script = exports.Script = function(S) {
            if (!(this instanceof Script))
                return new Script(S);
            this.code = S
        }
        ;
        Script.prototype.runInContext = function(C) {
            if (!(C instanceof Context))
                throw new TypeError("needs a 'context' argument.");
            var S = document.createElement("iframe");
            S.style || (S.style = {}),
            S.style.display = "none",
            document.body.appendChild(S);
            var E = S.contentWindow
              , M = E.eval
              , T = E.execScript;
            !M && T && (T.call(E, "null"),
            M = E.eval),
            forEach(Object_keys(C), function(O) {
                E[O] = C[O]
            }),
            forEach(globals, function(O) {
                C[O] && (E[O] = C[O])
            });
            var $ = Object_keys(E)
              , B = M.call(E, this.code);
            return forEach(Object_keys(E), function(O) {
                (O in C || indexOf($, O) === -1) && (C[O] = E[O])
            }),
            forEach(globals, function(O) {
                O in C || defineProp(C, O, E[O])
            }),
            document.body.removeChild(S),
            B
        }
        ,
        Script.prototype.runInThisContext = function() {
            return eval(this.code)
        }
        ,
        Script.prototype.runInNewContext = function(C) {
            var S = Script.createContext(C)
              , E = this.runInContext(S);
            return C && forEach(Object_keys(S), function(M) {
                C[M] = S[M]
            }),
            E
        }
        ,
        forEach(Object_keys(Script.prototype), function(C) {
            exports[C] = Script[C] = function(S) {
                var E = Script(S);
                return E[C].apply(E, [].slice.call(arguments, 1))
            }
        }),
        exports.isContext = function(C) {
            return C instanceof Context
        }
        ,
        exports.createScript = function(C) {
            return exports.Script(C)
        }
        ,
        exports.createContext = Script.createContext = function(C) {
            var S = new Context;
            return typeof C == "object" && forEach(Object_keys(C), function(E) {
                S[E] = C[E]
            }),
            S
        }
    }(vmBrowserify)),
    vmBrowserify
}
var hasRequiredApi;
function requireApi() {
    return hasRequiredApi || (hasRequiredApi = 1,
    function(C) {
        var S = requireAsn1$1()
          , E = requireInherits_browser()
          , M = C;
        M.define = function(B, O) {
            return new T(B,O)
        }
        ;
        function T($, B) {
            this.name = $,
            this.body = B,
            this.decoders = {},
            this.encoders = {}
        }
        T.prototype._createNamed = function(B) {
            var O;
            try {
                O = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`)
            } catch {
                O = function(N) {
                    this._initNamed(N)
                }
            }
            return E(O, B),
            O.prototype._initNamed = function(N) {
                B.call(this, N)
            }
            ,
            new O(this)
        }
        ,
        T.prototype._getDecoder = function(B) {
            return B = B || "der",
            this.decoders.hasOwnProperty(B) || (this.decoders[B] = this._createNamed(S.decoders[B])),
            this.decoders[B]
        }
        ,
        T.prototype.decode = function(B, O, F) {
            return this._getDecoder(O).decode(B, F)
        }
        ,
        T.prototype._getEncoder = function(B) {
            return B = B || "der",
            this.encoders.hasOwnProperty(B) || (this.encoders[B] = this._createNamed(S.encoders[B])),
            this.encoders[B]
        }
        ,
        T.prototype.encode = function(B, O, F) {
            return this._getEncoder(O).encode(B, F)
        }
    }(api$1)),
    api$1
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
    if (hasRequiredReporter)
        return reporter;
    hasRequiredReporter = 1;
    var C = requireInherits_browser();
    function S(M) {
        this._reporterState = {
            obj: null,
            path: [],
            options: M || {},
            errors: []
        }
    }
    reporter.Reporter = S,
    S.prototype.isError = function(T) {
        return T instanceof E
    }
    ,
    S.prototype.save = function() {
        var T = this._reporterState;
        return {
            obj: T.obj,
            pathLen: T.path.length
        }
    }
    ,
    S.prototype.restore = function(T) {
        var $ = this._reporterState;
        $.obj = T.obj,
        $.path = $.path.slice(0, T.pathLen)
    }
    ,
    S.prototype.enterKey = function(T) {
        return this._reporterState.path.push(T)
    }
    ,
    S.prototype.exitKey = function(T) {
        var $ = this._reporterState;
        $.path = $.path.slice(0, T - 1)
    }
    ,
    S.prototype.leaveKey = function(T, $, B) {
        var O = this._reporterState;
        this.exitKey(T),
        O.obj !== null && (O.obj[$] = B)
    }
    ,
    S.prototype.path = function() {
        return this._reporterState.path.join("/")
    }
    ,
    S.prototype.enterObject = function() {
        var T = this._reporterState
          , $ = T.obj;
        return T.obj = {},
        $
    }
    ,
    S.prototype.leaveObject = function(T) {
        var $ = this._reporterState
          , B = $.obj;
        return $.obj = T,
        B
    }
    ,
    S.prototype.error = function(T) {
        var $, B = this._reporterState, O = T instanceof E;
        if (O ? $ = T : $ = new E(B.path.map(function(F) {
            return "[" + JSON.stringify(F) + "]"
        }).join(""),T.message || T,T.stack),
        !B.options.partial)
            throw $;
        return O || B.errors.push($),
        $
    }
    ,
    S.prototype.wrapResult = function(T) {
        var $ = this._reporterState;
        return $.options.partial ? {
            result: this.isError(T) ? null : T,
            errors: $.errors
        } : T
    }
    ;
    function E(M, T) {
        this.path = M,
        this.rethrow(T)
    }
    return C(E, Error),
    E.prototype.rethrow = function(T) {
        if (this.message = T + " at: " + (this.path || "(shallow)"),
        Error.captureStackTrace && Error.captureStackTrace(this, E),
        !this.stack)
            try {
                throw new Error(this.message)
            } catch ($) {
                this.stack = $.stack
            }
        return this
    }
    ,
    reporter
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
    if (hasRequiredBuffer)
        return buffer;
    hasRequiredBuffer = 1;
    var C = requireInherits_browser()
      , S = requireBase().Reporter
      , E = require$$0$2.Buffer;
    function M($, B) {
        if (S.call(this, B),
        !E.isBuffer($)) {
            this.error("Input not Buffer");
            return
        }
        this.base = $,
        this.offset = 0,
        this.length = $.length
    }
    C(M, S),
    buffer.DecoderBuffer = M,
    M.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: S.prototype.save.call(this)
        }
    }
    ,
    M.prototype.restore = function(B) {
        var O = new M(this.base);
        return O.offset = B.offset,
        O.length = this.offset,
        this.offset = B.offset,
        S.prototype.restore.call(this, B.reporter),
        O
    }
    ,
    M.prototype.isEmpty = function() {
        return this.offset === this.length
    }
    ,
    M.prototype.readUInt8 = function(B) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(B || "DecoderBuffer overrun")
    }
    ,
    M.prototype.skip = function(B, O) {
        if (!(this.offset + B <= this.length))
            return this.error(O || "DecoderBuffer overrun");
        var F = new M(this.base);
        return F._reporterState = this._reporterState,
        F.offset = this.offset,
        F.length = this.offset + B,
        this.offset += B,
        F
    }
    ,
    M.prototype.raw = function(B) {
        return this.base.slice(B ? B.offset : this.offset, this.length)
    }
    ;
    function T($, B) {
        if (Array.isArray($))
            this.length = 0,
            this.value = $.map(function(O) {
                return O instanceof T || (O = new T(O,B)),
                this.length += O.length,
                O
            }, this);
        else if (typeof $ == "number") {
            if (!(0 <= $ && $ <= 255))
                return B.error("non-byte EncoderBuffer value");
            this.value = $,
            this.length = 1
        } else if (typeof $ == "string")
            this.value = $,
            this.length = E.byteLength($);
        else if (E.isBuffer($))
            this.value = $,
            this.length = $.length;
        else
            return B.error("Unsupported type: " + typeof $)
    }
    return buffer.EncoderBuffer = T,
    T.prototype.join = function(B, O) {
        return B || (B = new E(this.length)),
        O || (O = 0),
        this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(F) {
            F.join(B, O),
            O += F.length
        }) : (typeof this.value == "number" ? B[O] = this.value : typeof this.value == "string" ? B.write(this.value, O) : E.isBuffer(this.value) && this.value.copy(B, O),
        O += this.length)),
        B
    }
    ,
    buffer
}
var node$2, hasRequiredNode;
function requireNode() {
    if (hasRequiredNode)
        return node$2;
    hasRequiredNode = 1;
    var C = requireBase().Reporter
      , S = requireBase().EncoderBuffer
      , E = requireBase().DecoderBuffer
      , M = requireMinimalisticAssert()
      , T = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"]
      , $ = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(T)
      , B = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function O(N, U) {
        var H = {};
        this._baseState = H,
        H.enc = N,
        H.parent = U || null,
        H.children = null,
        H.tag = null,
        H.args = null,
        H.reverseArgs = null,
        H.choice = null,
        H.optional = !1,
        H.any = !1,
        H.obj = !1,
        H.use = null,
        H.useDecoder = null,
        H.key = null,
        H.default = null,
        H.explicit = null,
        H.implicit = null,
        H.contains = null,
        H.parent || (H.children = [],
        this._wrap())
    }
    node$2 = O;
    var F = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    return O.prototype.clone = function() {
        var U = this._baseState
          , H = {};
        F.forEach(function(J) {
            H[J] = U[J]
        });
        var Z = new this.constructor(H.parent);
        return Z._baseState = H,
        Z
    }
    ,
    O.prototype._wrap = function() {
        var U = this._baseState;
        $.forEach(function(H) {
            this[H] = function() {
                var J = new this.constructor(this);
                return U.children.push(J),
                J[H].apply(J, arguments)
            }
        }, this)
    }
    ,
    O.prototype._init = function(U) {
        var H = this._baseState;
        M(H.parent === null),
        U.call(this),
        H.children = H.children.filter(function(Z) {
            return Z._baseState.parent === this
        }, this),
        M.equal(H.children.length, 1, "Root node can have only one child")
    }
    ,
    O.prototype._useArgs = function(U) {
        var H = this._baseState
          , Z = U.filter(function(J) {
            return J instanceof this.constructor
        }, this);
        U = U.filter(function(J) {
            return !(J instanceof this.constructor)
        }, this),
        Z.length !== 0 && (M(H.children === null),
        H.children = Z,
        Z.forEach(function(J) {
            J._baseState.parent = this
        }, this)),
        U.length !== 0 && (M(H.args === null),
        H.args = U,
        H.reverseArgs = U.map(function(J) {
            if (typeof J != "object" || J.constructor !== Object)
                return J;
            var ie = {};
            return Object.keys(J).forEach(function(oe) {
                oe == (oe | 0) && (oe |= 0);
                var ae = J[oe];
                ie[ae] = oe
            }),
            ie
        }))
    }
    ,
    B.forEach(function(N) {
        O.prototype[N] = function() {
            var H = this._baseState;
            throw new Error(N + " not implemented for encoding: " + H.enc)
        }
    }),
    T.forEach(function(N) {
        O.prototype[N] = function() {
            var H = this._baseState
              , Z = Array.prototype.slice.call(arguments);
            return M(H.tag === null),
            H.tag = N,
            this._useArgs(Z),
            this
        }
    }),
    O.prototype.use = function(U) {
        M(U);
        var H = this._baseState;
        return M(H.use === null),
        H.use = U,
        this
    }
    ,
    O.prototype.optional = function() {
        var U = this._baseState;
        return U.optional = !0,
        this
    }
    ,
    O.prototype.def = function(U) {
        var H = this._baseState;
        return M(H.default === null),
        H.default = U,
        H.optional = !0,
        this
    }
    ,
    O.prototype.explicit = function(U) {
        var H = this._baseState;
        return M(H.explicit === null && H.implicit === null),
        H.explicit = U,
        this
    }
    ,
    O.prototype.implicit = function(U) {
        var H = this._baseState;
        return M(H.explicit === null && H.implicit === null),
        H.implicit = U,
        this
    }
    ,
    O.prototype.obj = function() {
        var U = this._baseState
          , H = Array.prototype.slice.call(arguments);
        return U.obj = !0,
        H.length !== 0 && this._useArgs(H),
        this
    }
    ,
    O.prototype.key = function(U) {
        var H = this._baseState;
        return M(H.key === null),
        H.key = U,
        this
    }
    ,
    O.prototype.any = function() {
        var U = this._baseState;
        return U.any = !0,
        this
    }
    ,
    O.prototype.choice = function(U) {
        var H = this._baseState;
        return M(H.choice === null),
        H.choice = U,
        this._useArgs(Object.keys(U).map(function(Z) {
            return U[Z]
        })),
        this
    }
    ,
    O.prototype.contains = function(U) {
        var H = this._baseState;
        return M(H.use === null),
        H.contains = U,
        this
    }
    ,
    O.prototype._decode = function(U, H) {
        var Z = this._baseState;
        if (Z.parent === null)
            return U.wrapResult(Z.children[0]._decode(U, H));
        var J = Z.default
          , ie = !0
          , oe = null;
        if (Z.key !== null && (oe = U.enterKey(Z.key)),
        Z.optional) {
            var ae = null;
            if (Z.explicit !== null ? ae = Z.explicit : Z.implicit !== null ? ae = Z.implicit : Z.tag !== null && (ae = Z.tag),
            ae === null && !Z.any) {
                var se = U.save();
                try {
                    Z.choice === null ? this._decodeGeneric(Z.tag, U, H) : this._decodeChoice(U, H),
                    ie = !0
                } catch {
                    ie = !1
                }
                U.restore(se)
            } else if (ie = this._peekTag(U, ae, Z.any),
            U.isError(ie))
                return ie
        }
        var le;
        if (Z.obj && ie && (le = U.enterObject()),
        ie) {
            if (Z.explicit !== null) {
                var de = this._decodeTag(U, Z.explicit);
                if (U.isError(de))
                    return de;
                U = de
            }
            var fe = U.offset;
            if (Z.use === null && Z.choice === null) {
                if (Z.any)
                    var se = U.save();
                var pe = this._decodeTag(U, Z.implicit !== null ? Z.implicit : Z.tag, Z.any);
                if (U.isError(pe))
                    return pe;
                Z.any ? J = U.raw(se) : U = pe
            }
            if (H && H.track && Z.tag !== null && H.track(U.path(), fe, U.length, "tagged"),
            H && H.track && Z.tag !== null && H.track(U.path(), U.offset, U.length, "content"),
            Z.any ? J = J : Z.choice === null ? J = this._decodeGeneric(Z.tag, U, H) : J = this._decodeChoice(U, H),
            U.isError(J))
                return J;
            if (!Z.any && Z.choice === null && Z.children !== null && Z.children.forEach(function(Ae) {
                Ae._decode(U, H)
            }),
            Z.contains && (Z.tag === "octstr" || Z.tag === "bitstr")) {
                var ge = new E(J);
                J = this._getUse(Z.contains, U._reporterState.obj)._decode(ge, H)
            }
        }
        return Z.obj && ie && (J = U.leaveObject(le)),
        Z.key !== null && (J !== null || ie === !0) ? U.leaveKey(oe, Z.key, J) : oe !== null && U.exitKey(oe),
        J
    }
    ,
    O.prototype._decodeGeneric = function(U, H, Z) {
        var J = this._baseState;
        return U === "seq" || U === "set" ? null : U === "seqof" || U === "setof" ? this._decodeList(H, U, J.args[0], Z) : /str$/.test(U) ? this._decodeStr(H, U, Z) : U === "objid" && J.args ? this._decodeObjid(H, J.args[0], J.args[1], Z) : U === "objid" ? this._decodeObjid(H, null, null, Z) : U === "gentime" || U === "utctime" ? this._decodeTime(H, U, Z) : U === "null_" ? this._decodeNull(H, Z) : U === "bool" ? this._decodeBool(H, Z) : U === "objDesc" ? this._decodeStr(H, U, Z) : U === "int" || U === "enum" ? this._decodeInt(H, J.args && J.args[0], Z) : J.use !== null ? this._getUse(J.use, H._reporterState.obj)._decode(H, Z) : H.error("unknown tag: " + U)
    }
    ,
    O.prototype._getUse = function(U, H) {
        var Z = this._baseState;
        return Z.useDecoder = this._use(U, H),
        M(Z.useDecoder._baseState.parent === null),
        Z.useDecoder = Z.useDecoder._baseState.children[0],
        Z.implicit !== Z.useDecoder._baseState.implicit && (Z.useDecoder = Z.useDecoder.clone(),
        Z.useDecoder._baseState.implicit = Z.implicit),
        Z.useDecoder
    }
    ,
    O.prototype._decodeChoice = function(U, H) {
        var Z = this._baseState
          , J = null
          , ie = !1;
        return Object.keys(Z.choice).some(function(oe) {
            var ae = U.save()
              , se = Z.choice[oe];
            try {
                var le = se._decode(U, H);
                if (U.isError(le))
                    return !1;
                J = {
                    type: oe,
                    value: le
                },
                ie = !0
            } catch {
                return U.restore(ae),
                !1
            }
            return !0
        }, this),
        ie ? J : U.error("Choice not matched")
    }
    ,
    O.prototype._createEncoderBuffer = function(U) {
        return new S(U,this.reporter)
    }
    ,
    O.prototype._encode = function(U, H, Z) {
        var J = this._baseState;
        if (!(J.default !== null && J.default === U)) {
            var ie = this._encodeValue(U, H, Z);
            if (ie !== void 0 && !this._skipDefault(ie, H, Z))
                return ie
        }
    }
    ,
    O.prototype._encodeValue = function(U, H, Z) {
        var J = this._baseState;
        if (J.parent === null)
            return J.children[0]._encode(U, H || new C);
        var se = null;
        if (this.reporter = H,
        J.optional && U === void 0)
            if (J.default !== null)
                U = J.default;
            else
                return;
        var ie = null
          , oe = !1;
        if (J.any)
            se = this._createEncoderBuffer(U);
        else if (J.choice)
            se = this._encodeChoice(U, H);
        else if (J.contains)
            ie = this._getUse(J.contains, Z)._encode(U, H),
            oe = !0;
        else if (J.children)
            ie = J.children.map(function(fe) {
                if (fe._baseState.tag === "null_")
                    return fe._encode(null, H, U);
                if (fe._baseState.key === null)
                    return H.error("Child should have a key");
                var pe = H.enterKey(fe._baseState.key);
                if (typeof U != "object")
                    return H.error("Child expected, but input is not object");
                var ge = fe._encode(U[fe._baseState.key], H, U);
                return H.leaveKey(pe),
                ge
            }, this).filter(function(fe) {
                return fe
            }),
            ie = this._createEncoderBuffer(ie);
        else if (J.tag === "seqof" || J.tag === "setof") {
            if (!(J.args && J.args.length === 1))
                return H.error("Too many args for : " + J.tag);
            if (!Array.isArray(U))
                return H.error("seqof/setof, but data is not Array");
            var ae = this.clone();
            ae._baseState.implicit = null,
            ie = this._createEncoderBuffer(U.map(function(fe) {
                var pe = this._baseState;
                return this._getUse(pe.args[0], U)._encode(fe, H)
            }, ae))
        } else
            J.use !== null ? se = this._getUse(J.use, Z)._encode(U, H) : (ie = this._encodePrimitive(J.tag, U),
            oe = !0);
        var se;
        if (!J.any && J.choice === null) {
            var le = J.implicit !== null ? J.implicit : J.tag
              , de = J.implicit === null ? "universal" : "context";
            le === null ? J.use === null && H.error("Tag could be omitted only for .use()") : J.use === null && (se = this._encodeComposite(le, oe, de, ie))
        }
        return J.explicit !== null && (se = this._encodeComposite(J.explicit, !1, "context", se)),
        se
    }
    ,
    O.prototype._encodeChoice = function(U, H) {
        var Z = this._baseState
          , J = Z.choice[U.type];
        return J || M(!1, U.type + " not found in " + JSON.stringify(Object.keys(Z.choice))),
        J._encode(U.value, H)
    }
    ,
    O.prototype._encodePrimitive = function(U, H) {
        var Z = this._baseState;
        if (/str$/.test(U))
            return this._encodeStr(H, U);
        if (U === "objid" && Z.args)
            return this._encodeObjid(H, Z.reverseArgs[0], Z.args[1]);
        if (U === "objid")
            return this._encodeObjid(H, null, null);
        if (U === "gentime" || U === "utctime")
            return this._encodeTime(H, U);
        if (U === "null_")
            return this._encodeNull();
        if (U === "int" || U === "enum")
            return this._encodeInt(H, Z.args && Z.reverseArgs[0]);
        if (U === "bool")
            return this._encodeBool(H);
        if (U === "objDesc")
            return this._encodeStr(H, U);
        throw new Error("Unsupported tag: " + U)
    }
    ,
    O.prototype._isNumstr = function(U) {
        return /^[0-9 ]*$/.test(U)
    }
    ,
    O.prototype._isPrintstr = function(U) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(U)
    }
    ,
    node$2
}
var hasRequiredBase;
function requireBase() {
    return hasRequiredBase || (hasRequiredBase = 1,
    function(C) {
        var S = C;
        S.Reporter = requireReporter().Reporter,
        S.DecoderBuffer = requireBuffer().DecoderBuffer,
        S.EncoderBuffer = requireBuffer().EncoderBuffer,
        S.Node = requireNode()
    }(base)),
    base
}
var constants$2 = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
    return hasRequiredDer$2 || (hasRequiredDer$2 = 1,
    function(C) {
        var S = requireConstants();
        C.tagClass = {
            0: "universal",
            1: "application",
            2: "context",
            3: "private"
        },
        C.tagClassByName = S._reverse(C.tagClass),
        C.tag = {
            0: "end",
            1: "bool",
            2: "int",
            3: "bitstr",
            4: "octstr",
            5: "null_",
            6: "objid",
            7: "objDesc",
            8: "external",
            9: "real",
            10: "enum",
            11: "embed",
            12: "utf8str",
            13: "relativeOid",
            16: "seq",
            17: "set",
            18: "numstr",
            19: "printstr",
            20: "t61str",
            21: "videostr",
            22: "ia5str",
            23: "utctime",
            24: "gentime",
            25: "graphstr",
            26: "iso646str",
            27: "genstr",
            28: "unistr",
            29: "charstr",
            30: "bmpstr"
        },
        C.tagByName = S._reverse(C.tag)
    }(der)),
    der
}
var hasRequiredConstants;
function requireConstants() {
    return hasRequiredConstants || (hasRequiredConstants = 1,
    function(C) {
        var S = C;
        S._reverse = function(M) {
            var T = {};
            return Object.keys(M).forEach(function($) {
                ($ | 0) == $ && ($ = $ | 0);
                var B = M[$];
                T[B] = $
            }),
            T
        }
        ,
        S.der = requireDer$2()
    }(constants$2)),
    constants$2
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
    if (hasRequiredDer$1)
        return der_1$1;
    hasRequiredDer$1 = 1;
    var C = requireInherits_browser()
      , S = requireAsn1$1()
      , E = S.base
      , M = S.bignum
      , T = S.constants.der;
    function $(N) {
        this.enc = "der",
        this.name = N.name,
        this.entity = N,
        this.tree = new B,
        this.tree._init(N.body)
    }
    der_1$1 = $,
    $.prototype.decode = function(U, H) {
        return U instanceof E.DecoderBuffer || (U = new E.DecoderBuffer(U,H)),
        this.tree._decode(U, H)
    }
    ;
    function B(N) {
        E.Node.call(this, "der", N)
    }
    C(B, E.Node),
    B.prototype._peekTag = function(U, H, Z) {
        if (U.isEmpty())
            return !1;
        var J = U.save()
          , ie = O(U, 'Failed to peek tag: "' + H + '"');
        return U.isError(ie) ? ie : (U.restore(J),
        ie.tag === H || ie.tagStr === H || ie.tagStr + "of" === H || Z)
    }
    ,
    B.prototype._decodeTag = function(U, H, Z) {
        var J = O(U, 'Failed to decode tag of "' + H + '"');
        if (U.isError(J))
            return J;
        var ie = F(U, J.primitive, 'Failed to get length of "' + H + '"');
        if (U.isError(ie))
            return ie;
        if (!Z && J.tag !== H && J.tagStr !== H && J.tagStr + "of" !== H)
            return U.error('Failed to match tag: "' + H + '"');
        if (J.primitive || ie !== null)
            return U.skip(ie, 'Failed to match body of: "' + H + '"');
        var oe = U.save()
          , ae = this._skipUntilEnd(U, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return U.isError(ae) ? ae : (ie = U.offset - oe.offset,
        U.restore(oe),
        U.skip(ie, 'Failed to match body of: "' + H + '"'))
    }
    ,
    B.prototype._skipUntilEnd = function(U, H) {
        for (; ; ) {
            var Z = O(U, H);
            if (U.isError(Z))
                return Z;
            var J = F(U, Z.primitive, H);
            if (U.isError(J))
                return J;
            var ie;
            if (Z.primitive || J !== null ? ie = U.skip(J) : ie = this._skipUntilEnd(U, H),
            U.isError(ie))
                return ie;
            if (Z.tagStr === "end")
                break
        }
    }
    ,
    B.prototype._decodeList = function(U, H, Z, J) {
        for (var ie = []; !U.isEmpty(); ) {
            var oe = this._peekTag(U, "end");
            if (U.isError(oe))
                return oe;
            var ae = Z.decode(U, "der", J);
            if (U.isError(ae) && oe)
                break;
            ie.push(ae)
        }
        return ie
    }
    ,
    B.prototype._decodeStr = function(U, H) {
        if (H === "bitstr") {
            var Z = U.readUInt8();
            return U.isError(Z) ? Z : {
                unused: Z,
                data: U.raw()
            }
        } else if (H === "bmpstr") {
            var J = U.raw();
            if (J.length % 2 === 1)
                return U.error("Decoding of string type: bmpstr length mismatch");
            for (var ie = "", oe = 0; oe < J.length / 2; oe++)
                ie += String.fromCharCode(J.readUInt16BE(oe * 2));
            return ie
        } else if (H === "numstr") {
            var ae = U.raw().toString("ascii");
            return this._isNumstr(ae) ? ae : U.error("Decoding of string type: numstr unsupported characters")
        } else {
            if (H === "octstr")
                return U.raw();
            if (H === "objDesc")
                return U.raw();
            if (H === "printstr") {
                var se = U.raw().toString("ascii");
                return this._isPrintstr(se) ? se : U.error("Decoding of string type: printstr unsupported characters")
            } else
                return /str$/.test(H) ? U.raw().toString() : U.error("Decoding of string type: " + H + " unsupported")
        }
    }
    ,
    B.prototype._decodeObjid = function(U, H, Z) {
        for (var J, ie = [], oe = 0; !U.isEmpty(); ) {
            var ae = U.readUInt8();
            oe <<= 7,
            oe |= ae & 127,
            ae & 128 || (ie.push(oe),
            oe = 0)
        }
        ae & 128 && ie.push(oe);
        var se = ie[0] / 40 | 0
          , le = ie[0] % 40;
        if (Z ? J = ie : J = [se, le].concat(ie.slice(1)),
        H) {
            var de = H[J.join(" ")];
            de === void 0 && (de = H[J.join(".")]),
            de !== void 0 && (J = de)
        }
        return J
    }
    ,
    B.prototype._decodeTime = function(U, H) {
        var Z = U.raw().toString();
        if (H === "gentime")
            var J = Z.slice(0, 4) | 0
              , ie = Z.slice(4, 6) | 0
              , oe = Z.slice(6, 8) | 0
              , ae = Z.slice(8, 10) | 0
              , se = Z.slice(10, 12) | 0
              , le = Z.slice(12, 14) | 0;
        else if (H === "utctime") {
            var J = Z.slice(0, 2) | 0
              , ie = Z.slice(2, 4) | 0
              , oe = Z.slice(4, 6) | 0
              , ae = Z.slice(6, 8) | 0
              , se = Z.slice(8, 10) | 0
              , le = Z.slice(10, 12) | 0;
            J < 70 ? J = 2e3 + J : J = 1900 + J
        } else
            return U.error("Decoding " + H + " time is not supported yet");
        return Date.UTC(J, ie - 1, oe, ae, se, le, 0)
    }
    ,
    B.prototype._decodeNull = function(U) {
        return null
    }
    ,
    B.prototype._decodeBool = function(U) {
        var H = U.readUInt8();
        return U.isError(H) ? H : H !== 0
    }
    ,
    B.prototype._decodeInt = function(U, H) {
        var Z = U.raw()
          , J = new M(Z);
        return H && (J = H[J.toString(10)] || J),
        J
    }
    ,
    B.prototype._use = function(U, H) {
        return typeof U == "function" && (U = U(H)),
        U._getDecoder("der").tree
    }
    ;
    function O(N, U) {
        var H = N.readUInt8(U);
        if (N.isError(H))
            return H;
        var Z = T.tagClass[H >> 6]
          , J = (H & 32) === 0;
        if ((H & 31) === 31) {
            var ie = H;
            for (H = 0; (ie & 128) === 128; ) {
                if (ie = N.readUInt8(U),
                N.isError(ie))
                    return ie;
                H <<= 7,
                H |= ie & 127
            }
        } else
            H &= 31;
        var oe = T.tag[H];
        return {
            cls: Z,
            primitive: J,
            tag: H,
            tagStr: oe
        }
    }
    function F(N, U, H) {
        var Z = N.readUInt8(H);
        if (N.isError(Z))
            return Z;
        if (!U && Z === 128)
            return null;
        if (!(Z & 128))
            return Z;
        var J = Z & 127;
        if (J > 4)
            return N.error("length octect is too long");
        Z = 0;
        for (var ie = 0; ie < J; ie++) {
            Z <<= 8;
            var oe = N.readUInt8(H);
            if (N.isError(oe))
                return oe;
            Z |= oe
        }
        return Z
    }
    return der_1$1
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
    if (hasRequiredPem$1)
        return pem$1;
    hasRequiredPem$1 = 1;
    var C = requireInherits_browser()
      , S = require$$0$2.Buffer
      , E = requireDer$1();
    function M(T) {
        E.call(this, T),
        this.enc = "pem"
    }
    return C(M, E),
    pem$1 = M,
    M.prototype.decode = function($, B) {
        for (var O = $.toString().split(/[\r\n]+/g), F = B.label.toUpperCase(), N = /^-----(BEGIN|END) ([^-]+)-----$/, U = -1, H = -1, Z = 0; Z < O.length; Z++) {
            var J = O[Z].match(N);
            if (J !== null && J[2] === F)
                if (U === -1) {
                    if (J[1] !== "BEGIN")
                        break;
                    U = Z
                } else {
                    if (J[1] !== "END")
                        break;
                    H = Z;
                    break
                }
        }
        if (U === -1 || H === -1)
            throw new Error("PEM section not found for: " + F);
        var ie = O.slice(U + 1, H).join("");
        ie.replace(/[^a-z0-9\+\/=]+/gi, "");
        var oe = new S(ie,"base64");
        return E.prototype.decode.call(this, oe, B)
    }
    ,
    pem$1
}
var hasRequiredDecoders;
function requireDecoders() {
    return hasRequiredDecoders || (hasRequiredDecoders = 1,
    function(C) {
        var S = C;
        S.der = requireDer$1(),
        S.pem = requirePem$1()
    }(decoders)),
    decoders
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
    if (hasRequiredDer)
        return der_1;
    hasRequiredDer = 1;
    var C = requireInherits_browser()
      , S = require$$0$2.Buffer
      , E = requireAsn1$1()
      , M = E.base
      , T = E.constants.der;
    function $(N) {
        this.enc = "der",
        this.name = N.name,
        this.entity = N,
        this.tree = new B,
        this.tree._init(N.body)
    }
    der_1 = $,
    $.prototype.encode = function(U, H) {
        return this.tree._encode(U, H).join()
    }
    ;
    function B(N) {
        M.Node.call(this, "der", N)
    }
    C(B, M.Node),
    B.prototype._encodeComposite = function(U, H, Z, J) {
        var ie = F(U, H, Z, this.reporter);
        if (J.length < 128) {
            var se = new S(2);
            return se[0] = ie,
            se[1] = J.length,
            this._createEncoderBuffer([se, J])
        }
        for (var oe = 1, ae = J.length; ae >= 256; ae >>= 8)
            oe++;
        var se = new S(2 + oe);
        se[0] = ie,
        se[1] = 128 | oe;
        for (var ae = 1 + oe, le = J.length; le > 0; ae--,
        le >>= 8)
            se[ae] = le & 255;
        return this._createEncoderBuffer([se, J])
    }
    ,
    B.prototype._encodeStr = function(U, H) {
        if (H === "bitstr")
            return this._createEncoderBuffer([U.unused | 0, U.data]);
        if (H === "bmpstr") {
            for (var Z = new S(U.length * 2), J = 0; J < U.length; J++)
                Z.writeUInt16BE(U.charCodeAt(J), J * 2);
            return this._createEncoderBuffer(Z)
        } else
            return H === "numstr" ? this._isNumstr(U) ? this._createEncoderBuffer(U) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : H === "printstr" ? this._isPrintstr(U) ? this._createEncoderBuffer(U) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(H) ? this._createEncoderBuffer(U) : H === "objDesc" ? this._createEncoderBuffer(U) : this.reporter.error("Encoding of string type: " + H + " unsupported")
    }
    ,
    B.prototype._encodeObjid = function(U, H, Z) {
        if (typeof U == "string") {
            if (!H)
                return this.reporter.error("string objid given, but no values map found");
            if (!H.hasOwnProperty(U))
                return this.reporter.error("objid not found in values map");
            U = H[U].split(/[\s\.]+/g);
            for (var J = 0; J < U.length; J++)
                U[J] |= 0
        } else if (Array.isArray(U)) {
            U = U.slice();
            for (var J = 0; J < U.length; J++)
                U[J] |= 0
        }
        if (!Array.isArray(U))
            return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(U));
        if (!Z) {
            if (U[1] >= 40)
                return this.reporter.error("Second objid identifier OOB");
            U.splice(0, 2, U[0] * 40 + U[1])
        }
        for (var ie = 0, J = 0; J < U.length; J++) {
            var oe = U[J];
            for (ie++; oe >= 128; oe >>= 7)
                ie++
        }
        for (var ae = new S(ie), se = ae.length - 1, J = U.length - 1; J >= 0; J--) {
            var oe = U[J];
            for (ae[se--] = oe & 127; (oe >>= 7) > 0; )
                ae[se--] = 128 | oe & 127
        }
        return this._createEncoderBuffer(ae)
    }
    ;
    function O(N) {
        return N < 10 ? "0" + N : N
    }
    B.prototype._encodeTime = function(U, H) {
        var Z, J = new Date(U);
        return H === "gentime" ? Z = [O(J.getFullYear()), O(J.getUTCMonth() + 1), O(J.getUTCDate()), O(J.getUTCHours()), O(J.getUTCMinutes()), O(J.getUTCSeconds()), "Z"].join("") : H === "utctime" ? Z = [O(J.getFullYear() % 100), O(J.getUTCMonth() + 1), O(J.getUTCDate()), O(J.getUTCHours()), O(J.getUTCMinutes()), O(J.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + H + " time is not supported yet"),
        this._encodeStr(Z, "octstr")
    }
    ,
    B.prototype._encodeNull = function() {
        return this._createEncoderBuffer("")
    }
    ,
    B.prototype._encodeInt = function(U, H) {
        if (typeof U == "string") {
            if (!H)
                return this.reporter.error("String int or enum given, but no values map");
            if (!H.hasOwnProperty(U))
                return this.reporter.error("Values map doesn't contain: " + JSON.stringify(U));
            U = H[U]
        }
        if (typeof U != "number" && !S.isBuffer(U)) {
            var Z = U.toArray();
            !U.sign && Z[0] & 128 && Z.unshift(0),
            U = new S(Z)
        }
        if (S.isBuffer(U)) {
            var J = U.length;
            U.length === 0 && J++;
            var oe = new S(J);
            return U.copy(oe),
            U.length === 0 && (oe[0] = 0),
            this._createEncoderBuffer(oe)
        }
        if (U < 128)
            return this._createEncoderBuffer(U);
        if (U < 256)
            return this._createEncoderBuffer([0, U]);
        for (var J = 1, ie = U; ie >= 256; ie >>= 8)
            J++;
        for (var oe = new Array(J), ie = oe.length - 1; ie >= 0; ie--)
            oe[ie] = U & 255,
            U >>= 8;
        return oe[0] & 128 && oe.unshift(0),
        this._createEncoderBuffer(new S(oe))
    }
    ,
    B.prototype._encodeBool = function(U) {
        return this._createEncoderBuffer(U ? 255 : 0)
    }
    ,
    B.prototype._use = function(U, H) {
        return typeof U == "function" && (U = U(H)),
        U._getEncoder("der").tree
    }
    ,
    B.prototype._skipDefault = function(U, H, Z) {
        var J = this._baseState, ie;
        if (J.default === null)
            return !1;
        var oe = U.join();
        if (J.defaultBuffer === void 0 && (J.defaultBuffer = this._encodeValue(J.default, H, Z).join()),
        oe.length !== J.defaultBuffer.length)
            return !1;
        for (ie = 0; ie < oe.length; ie++)
            if (oe[ie] !== J.defaultBuffer[ie])
                return !1;
        return !0
    }
    ;
    function F(N, U, H, Z) {
        var J;
        if (N === "seqof" ? N = "seq" : N === "setof" && (N = "set"),
        T.tagByName.hasOwnProperty(N))
            J = T.tagByName[N];
        else if (typeof N == "number" && (N | 0) === N)
            J = N;
        else
            return Z.error("Unknown tag: " + N);
        return J >= 31 ? Z.error("Multi-octet tag encoding unsupported") : (U || (J |= 32),
        J |= T.tagClassByName[H || "universal"] << 6,
        J)
    }
    return der_1
}
var pem, hasRequiredPem;
function requirePem() {
    if (hasRequiredPem)
        return pem;
    hasRequiredPem = 1;
    var C = requireInherits_browser()
      , S = requireDer();
    function E(M) {
        S.call(this, M),
        this.enc = "pem"
    }
    return C(E, S),
    pem = E,
    E.prototype.encode = function(T, $) {
        for (var B = S.prototype.encode.call(this, T), O = B.toString("base64"), F = ["-----BEGIN " + $.label + "-----"], N = 0; N < O.length; N += 64)
            F.push(O.slice(N, N + 64));
        return F.push("-----END " + $.label + "-----"),
        F.join(`
`)
    }
    ,
    pem
}
var hasRequiredEncoders;
function requireEncoders() {
    return hasRequiredEncoders || (hasRequiredEncoders = 1,
    function(C) {
        var S = C;
        S.der = requireDer(),
        S.pem = requirePem()
    }(encoders)),
    encoders
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
    return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1,
    function(C) {
        var S = C;
        S.bignum = requireBn$2(),
        S.define = requireApi().define,
        S.base = requireBase(),
        S.constants = requireConstants(),
        S.decoders = requireDecoders(),
        S.encoders = requireEncoders()
    }(asn1)),
    asn1
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
    if (hasRequiredCertificate)
        return certificate;
    hasRequiredCertificate = 1;
    var C = requireAsn1$1()
      , S = C.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        })
    })
      , E = C.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any())
    })
      , M = C.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
    })
      , T = C.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(M), this.key("subjectPublicKey").bitstr())
    })
      , $ = C.define("RelativeDistinguishedName", function() {
        this.setof(E)
    })
      , B = C.define("RDNSequence", function() {
        this.seqof($)
    })
      , O = C.define("Name", function() {
        this.choice({
            rdnSequence: this.use(B)
        })
    })
      , F = C.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(S), this.key("notAfter").use(S))
    })
      , N = C.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
    })
      , U = C.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(M), this.key("issuer").use(O), this.key("validity").use(F), this.key("subject").use(O), this.key("subjectPublicKeyInfo").use(T), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(N).optional())
    })
      , H = C.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(U), this.key("signatureAlgorithm").use(M), this.key("signatureValue").bitstr())
    });
    return certificate = H,
    certificate
}
var hasRequiredAsn1;
function requireAsn1() {
    if (hasRequiredAsn1)
        return asn1$1;
    hasRequiredAsn1 = 1;
    var C = requireAsn1$1();
    asn1$1.certificate = requireCertificate();
    var S = C.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
    });
    asn1$1.RSAPrivateKey = S;
    var E = C.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
    });
    asn1$1.RSAPublicKey = E;
    var M = C.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
    })
      , T = C.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(M), this.key("subjectPublicKey").bitstr())
    });
    asn1$1.PublicKey = T;
    var $ = C.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(M), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.PrivateKey = $;
    var B = C.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
    });
    asn1$1.EncryptedPrivateKey = B;
    var O = C.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
    });
    asn1$1.DSAPrivateKey = O,
    asn1$1.DSAparam = C.define("DSAparam", function() {
        this.int()
    });
    var F = C.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        })
    })
      , N = C.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(F), this.key("publicKey").optional().explicit(1).bitstr())
    });
    return asn1$1.ECPrivateKey = N,
    asn1$1.signature = C.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int())
    }),
    asn1$1
}
const require$$1$5 = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
    if (hasRequiredFixProc)
        return fixProc;
    hasRequiredFixProc = 1;
    var C = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
      , S = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
      , E = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
      , M = requireEvp_bytestokey()
      , T = requireBrowser$6()
      , $ = requireSafeBuffer$1().Buffer;
    return fixProc = function(B, O) {
        var F = B.toString(), N = F.match(C), U;
        if (N) {
            var Z = "aes" + N[1]
              , J = $.from(N[2], "hex")
              , ie = $.from(N[3].replace(/[\r\n]/g, ""), "base64")
              , oe = M(O, J.slice(0, 8), parseInt(N[1], 10)).key
              , ae = []
              , se = T.createDecipheriv(Z, oe, J);
            ae.push(se.update(ie)),
            ae.push(se.final()),
            U = $.concat(ae)
        } else {
            var H = F.match(E);
            U = $.from(H[2].replace(/[\r\n]/g, ""), "base64")
        }
        var le = F.match(S)[1];
        return {
            tag: le,
            data: U
        }
    }
    ,
    fixProc
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
    if (hasRequiredParseAsn1)
        return parseAsn1;
    hasRequiredParseAsn1 = 1;
    var C = requireAsn1()
      , S = require$$1$5
      , E = requireFixProc()
      , M = requireBrowser$6()
      , T = requireBrowser$7()
      , $ = requireSafeBuffer$1().Buffer;
    function B(F, N) {
        var U = F.algorithm.decrypt.kde.kdeparams.salt
          , H = parseInt(F.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
          , Z = S[F.algorithm.decrypt.cipher.algo.join(".")]
          , J = F.algorithm.decrypt.cipher.iv
          , ie = F.subjectPrivateKey
          , oe = parseInt(Z.split("-")[1], 10) / 8
          , ae = T.pbkdf2Sync(N, U, H, oe, "sha1")
          , se = M.createDecipheriv(Z, ae, J)
          , le = [];
        return le.push(se.update(ie)),
        le.push(se.final()),
        $.concat(le)
    }
    function O(F) {
        var N;
        typeof F == "object" && !$.isBuffer(F) && (N = F.passphrase,
        F = F.key),
        typeof F == "string" && (F = $.from(F));
        var U = E(F, N), H = U.tag, Z = U.data, J, ie;
        switch (H) {
        case "CERTIFICATE":
            ie = C.certificate.decode(Z, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            switch (ie || (ie = C.PublicKey.decode(Z, "der")),
            J = ie.algorithm.algorithm.join("."),
            J) {
            case "1.2.840.113549.1.1.1":
                return C.RSAPublicKey.decode(ie.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
                return ie.subjectPrivateKey = ie.subjectPublicKey,
                {
                    type: "ec",
                    data: ie
                };
            case "1.2.840.10040.4.1":
                return ie.algorithm.params.pub_key = C.DSAparam.decode(ie.subjectPublicKey.data, "der"),
                {
                    type: "dsa",
                    data: ie.algorithm.params
                };
            default:
                throw new Error("unknown key id " + J)
            }
        case "ENCRYPTED PRIVATE KEY":
            Z = C.EncryptedPrivateKey.decode(Z, "der"),
            Z = B(Z, N);
        case "PRIVATE KEY":
            switch (ie = C.PrivateKey.decode(Z, "der"),
            J = ie.algorithm.algorithm.join("."),
            J) {
            case "1.2.840.113549.1.1.1":
                return C.RSAPrivateKey.decode(ie.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
                return {
                    curve: ie.algorithm.curve,
                    privateKey: C.ECPrivateKey.decode(ie.subjectPrivateKey, "der").privateKey
                };
            case "1.2.840.10040.4.1":
                return ie.algorithm.params.priv_key = C.DSAparam.decode(ie.subjectPrivateKey, "der"),
                {
                    type: "dsa",
                    params: ie.algorithm.params
                };
            default:
                throw new Error("unknown key id " + J)
            }
        case "RSA PUBLIC KEY":
            return C.RSAPublicKey.decode(Z, "der");
        case "RSA PRIVATE KEY":
            return C.RSAPrivateKey.decode(Z, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: C.DSAPrivateKey.decode(Z, "der")
            };
        case "EC PRIVATE KEY":
            return Z = C.ECPrivateKey.decode(Z, "der"),
            {
                curve: Z.parameters.value,
                privateKey: Z.privateKey
            };
        default:
            throw new Error("unknown key type " + H)
        }
    }
    return O.signature = C.signature,
    parseAsn1 = O,
    parseAsn1
}
const require$$4$2 = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
    if (hasRequiredSign)
        return sign$1.exports;
    hasRequiredSign = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireBrowser$8()
      , E = requireBrowserifyRsa()
      , M = requireElliptic().ec
      , T = requireBn()
      , $ = requireParseAsn1()
      , B = require$$4$2
      , O = 1;
    function F(se, le, de, fe, pe) {
        var ge = $(le);
        if (ge.curve) {
            if (fe !== "ecdsa" && fe !== "ecdsa/rsa")
                throw new Error("wrong private key type");
            return N(se, ge)
        } else if (ge.type === "dsa") {
            if (fe !== "dsa")
                throw new Error("wrong private key type");
            return U(se, ge, de)
        }
        if (fe !== "rsa" && fe !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        if (le.padding !== void 0 && le.padding !== O)
            throw new Error("illegal or unsupported padding mode");
        se = C.concat([pe, se]);
        for (var we = ge.modulus.byteLength(), Ae = [0, 1]; se.length + Ae.length + 1 < we; )
            Ae.push(255);
        Ae.push(0);
        for (var Se = -1; ++Se < se.length; )
            Ae.push(se[Se]);
        var ue = E(Ae, ge);
        return ue
    }
    function N(se, le) {
        var de = B[le.curve.join(".")];
        if (!de)
            throw new Error("unknown curve " + le.curve.join("."));
        var fe = new M(de)
          , pe = fe.keyFromPrivate(le.privateKey)
          , ge = pe.sign(se);
        return C.from(ge.toDER())
    }
    function U(se, le, de) {
        for (var fe = le.params.priv_key, pe = le.params.p, ge = le.params.q, we = le.params.g, Ae = new T(0), Se, ue = J(se, ge).mod(ge), V = !1, W = Z(fe, ge, se, de); V === !1; )
            Se = oe(ge, W, de),
            Ae = ae(we, Se, pe, ge),
            V = Se.invm(ge).imul(ue.add(fe.mul(Ae))).mod(ge),
            V.cmpn(0) === 0 && (V = !1,
            Ae = new T(0));
        return H(Ae, V)
    }
    function H(se, le) {
        se = se.toArray(),
        le = le.toArray(),
        se[0] & 128 && (se = [0].concat(se)),
        le[0] & 128 && (le = [0].concat(le));
        var de = se.length + le.length + 4
          , fe = [48, de, 2, se.length];
        return fe = fe.concat(se, [2, le.length], le),
        C.from(fe)
    }
    function Z(se, le, de, fe) {
        if (se = C.from(se.toArray()),
        se.length < le.byteLength()) {
            var pe = C.alloc(le.byteLength() - se.length);
            se = C.concat([pe, se])
        }
        var ge = de.length
          , we = ie(de, le)
          , Ae = C.alloc(ge);
        Ae.fill(1);
        var Se = C.alloc(ge);
        return Se = S(fe, Se).update(Ae).update(C.from([0])).update(se).update(we).digest(),
        Ae = S(fe, Se).update(Ae).digest(),
        Se = S(fe, Se).update(Ae).update(C.from([1])).update(se).update(we).digest(),
        Ae = S(fe, Se).update(Ae).digest(),
        {
            k: Se,
            v: Ae
        }
    }
    function J(se, le) {
        var de = new T(se)
          , fe = (se.length << 3) - le.bitLength();
        return fe > 0 && de.ishrn(fe),
        de
    }
    function ie(se, le) {
        se = J(se, le),
        se = se.mod(le);
        var de = C.from(se.toArray());
        if (de.length < le.byteLength()) {
            var fe = C.alloc(le.byteLength() - de.length);
            de = C.concat([fe, de])
        }
        return de
    }
    function oe(se, le, de) {
        var fe, pe;
        do {
            for (fe = C.alloc(0); fe.length * 8 < se.bitLength(); )
                le.v = S(de, le.k).update(le.v).digest(),
                fe = C.concat([fe, le.v]);
            pe = J(fe, se),
            le.k = S(de, le.k).update(le.v).update(C.from([0])).digest(),
            le.v = S(de, le.k).update(le.v).digest()
        } while (pe.cmp(se) !== -1);
        return pe
    }
    function ae(se, le, de, fe) {
        return se.toRed(T.mont(de)).redPow(le).fromRed().mod(fe)
    }
    return sign$1.exports = F,
    sign$1.exports.getKey = Z,
    sign$1.exports.makeKey = oe,
    sign$1.exports
}
var verify_1, hasRequiredVerify;
function requireVerify() {
    if (hasRequiredVerify)
        return verify_1;
    hasRequiredVerify = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireBn()
      , E = requireElliptic().ec
      , M = requireParseAsn1()
      , T = require$$4$2;
    function $(N, U, H, Z, J) {
        var ie = M(H);
        if (ie.type === "ec") {
            if (Z !== "ecdsa" && Z !== "ecdsa/rsa")
                throw new Error("wrong public key type");
            return B(N, U, ie)
        } else if (ie.type === "dsa") {
            if (Z !== "dsa")
                throw new Error("wrong public key type");
            return O(N, U, ie)
        }
        if (Z !== "rsa" && Z !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        U = C.concat([J, U]);
        for (var oe = ie.modulus.byteLength(), ae = [1], se = 0; U.length + ae.length + 2 < oe; )
            ae.push(255),
            se += 1;
        ae.push(0);
        for (var le = -1; ++le < U.length; )
            ae.push(U[le]);
        ae = C.from(ae);
        var de = S.mont(ie.modulus);
        N = new S(N).toRed(de),
        N = N.redPow(new S(ie.publicExponent)),
        N = C.from(N.fromRed().toArray());
        var fe = se < 8 ? 1 : 0;
        for (oe = Math.min(N.length, ae.length),
        N.length !== ae.length && (fe = 1),
        le = -1; ++le < oe; )
            fe |= N[le] ^ ae[le];
        return fe === 0
    }
    function B(N, U, H) {
        var Z = T[H.data.algorithm.curve.join(".")];
        if (!Z)
            throw new Error("unknown curve " + H.data.algorithm.curve.join("."));
        var J = new E(Z)
          , ie = H.data.subjectPrivateKey.data;
        return J.verify(U, N, ie)
    }
    function O(N, U, H) {
        var Z = H.data.p
          , J = H.data.q
          , ie = H.data.g
          , oe = H.data.pub_key
          , ae = M.signature.decode(N, "der")
          , se = ae.s
          , le = ae.r;
        F(se, J),
        F(le, J);
        var de = S.mont(Z)
          , fe = se.invm(J)
          , pe = ie.toRed(de).redPow(new S(U).mul(fe).mod(J)).fromRed().mul(oe.toRed(de).redPow(le.mul(fe).mod(J)).fromRed()).mod(Z).mod(J);
        return pe.cmp(le) === 0
    }
    function F(N, U) {
        if (N.cmpn(0) <= 0)
            throw new Error("invalid sig");
        if (N.cmp(U) >= 0)
            throw new Error("invalid sig")
    }
    return verify_1 = $,
    verify_1
}
var browser$5, hasRequiredBrowser$3;
function requireBrowser$3() {
    if (hasRequiredBrowser$3)
        return browser$5;
    hasRequiredBrowser$3 = 1;
    var C = requireSafeBuffer$1().Buffer
      , S = requireBrowser$9()
      , E = requireReadableBrowser()
      , M = requireInherits_browser()
      , T = requireSign()
      , $ = requireVerify()
      , B = require$$6$1;
    Object.keys(B).forEach(function(H) {
        B[H].id = C.from(B[H].id, "hex"),
        B[H.toLowerCase()] = B[H]
    });
    function O(H) {
        E.Writable.call(this);
        var Z = B[H];
        if (!Z)
            throw new Error("Unknown message digest");
        this._hashType = Z.hash,
        this._hash = S(Z.hash),
        this._tag = Z.id,
        this._signType = Z.sign
    }
    M(O, E.Writable),
    O.prototype._write = function(Z, J, ie) {
        this._hash.update(Z),
        ie()
    }
    ,
    O.prototype.update = function(Z, J) {
        return this._hash.update(typeof Z == "string" ? C.from(Z, J) : Z),
        this
    }
    ,
    O.prototype.sign = function(Z, J) {
        this.end();
        var ie = this._hash.digest()
          , oe = T(ie, Z, this._hashType, this._signType, this._tag);
        return J ? oe.toString(J) : oe
    }
    ;
    function F(H) {
        E.Writable.call(this);
        var Z = B[H];
        if (!Z)
            throw new Error("Unknown message digest");
        this._hash = S(Z.hash),
        this._tag = Z.id,
        this._signType = Z.sign
    }
    M(F, E.Writable),
    F.prototype._write = function(Z, J, ie) {
        this._hash.update(Z),
        ie()
    }
    ,
    F.prototype.update = function(Z, J) {
        return this._hash.update(typeof Z == "string" ? C.from(Z, J) : Z),
        this
    }
    ,
    F.prototype.verify = function(Z, J, ie) {
        var oe = typeof J == "string" ? C.from(J, ie) : J;
        this.end();
        var ae = this._hash.digest();
        return $(oe, ae, Z, this._signType, this._tag)
    }
    ;
    function N(H) {
        return new O(H)
    }
    function U(H) {
        return new F(H)
    }
    return browser$5 = {
        Sign: N,
        Verify: U,
        createSign: N,
        createVerify: U
    },
    browser$5
}
var browser$4, hasRequiredBrowser$2;
function requireBrowser$2() {
    if (hasRequiredBrowser$2)
        return browser$4;
    hasRequiredBrowser$2 = 1;
    var C = requireElliptic()
      , S = requireBn$2();
    browser$4 = function(B) {
        return new M(B)
    }
    ;
    var E = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    E.p224 = E.secp224r1,
    E.p256 = E.secp256r1 = E.prime256v1,
    E.p192 = E.secp192r1 = E.prime192v1,
    E.p384 = E.secp384r1,
    E.p521 = E.secp521r1;
    function M($) {
        this.curveType = E[$],
        this.curveType || (this.curveType = {
            name: $
        }),
        this.curve = new C.ec(this.curveType.name),
        this.keys = void 0
    }
    M.prototype.generateKeys = function($, B) {
        return this.keys = this.curve.genKeyPair(),
        this.getPublicKey($, B)
    }
    ,
    M.prototype.computeSecret = function($, B, O) {
        B = B || "utf8",
        Buffer.isBuffer($) || ($ = new Buffer($,B));
        var F = this.curve.keyFromPublic($).getPublic()
          , N = F.mul(this.keys.getPrivate()).getX();
        return T(N, O, this.curveType.byteLength)
    }
    ,
    M.prototype.getPublicKey = function($, B) {
        var O = this.keys.getPublic(B === "compressed", !0);
        return B === "hybrid" && (O[O.length - 1] % 2 ? O[0] = 7 : O[0] = 6),
        T(O, $)
    }
    ,
    M.prototype.getPrivateKey = function($) {
        return T(this.keys.getPrivate(), $)
    }
    ,
    M.prototype.setPublicKey = function($, B) {
        return B = B || "utf8",
        Buffer.isBuffer($) || ($ = new Buffer($,B)),
        this.keys._importPublic($),
        this
    }
    ,
    M.prototype.setPrivateKey = function($, B) {
        B = B || "utf8",
        Buffer.isBuffer($) || ($ = new Buffer($,B));
        var O = new S($);
        return O = O.toString(16),
        this.keys = this.curve.genKeyPair(),
        this.keys._importPrivate(O),
        this
    }
    ;
    function T($, B, O) {
        Array.isArray($) || ($ = $.toArray());
        var F = new Buffer($);
        if (O && F.length < O) {
            var N = new Buffer(O - F.length);
            N.fill(0),
            F = Buffer.concat([N, F])
        }
        return B ? F.toString(B) : F
    }
    return browser$4
}
var browser$3 = {}, mgf, hasRequiredMgf;
function requireMgf() {
    if (hasRequiredMgf)
        return mgf;
    hasRequiredMgf = 1;
    var C = requireBrowser$9()
      , S = requireSafeBuffer$1().Buffer;
    mgf = function(M, T) {
        for (var $ = S.alloc(0), B = 0, O; $.length < T; )
            O = E(B++),
            $ = S.concat([$, C("sha1").update(M).update(O).digest()]);
        return $.slice(0, T)
    }
    ;
    function E(M) {
        var T = S.allocUnsafe(4);
        return T.writeUInt32BE(M, 0),
        T
    }
    return mgf
}
var xor, hasRequiredXor;
function requireXor() {
    return hasRequiredXor || (hasRequiredXor = 1,
    xor = function(S, E) {
        for (var M = S.length, T = -1; ++T < M; )
            S[T] ^= E[T];
        return S
    }
    ),
    xor
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
    if (hasRequiredWithPublic)
        return withPublic_1;
    hasRequiredWithPublic = 1;
    var C = requireBn$2()
      , S = requireSafeBuffer$1().Buffer;
    function E(M, T) {
        return S.from(M.toRed(C.mont(T.modulus)).redPow(new C(T.publicExponent)).fromRed().toArray())
    }
    return withPublic_1 = E,
    withPublic_1
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
    if (hasRequiredPublicEncrypt)
        return publicEncrypt;
    hasRequiredPublicEncrypt = 1;
    var C = requireParseAsn1()
      , S = requireBrowser$b()
      , E = requireBrowser$9()
      , M = requireMgf()
      , T = requireXor()
      , $ = requireBn$2()
      , B = requireWithPublic()
      , O = requireBrowserifyRsa()
      , F = requireSafeBuffer$1().Buffer;
    publicEncrypt = function(J, ie, oe) {
        var ae;
        J.padding ? ae = J.padding : oe ? ae = 1 : ae = 4;
        var se = C(J), le;
        if (ae === 4)
            le = N(se, ie);
        else if (ae === 1)
            le = U(se, ie, oe);
        else if (ae === 3) {
            if (le = new $(ie),
            le.cmp(se.modulus) >= 0)
                throw new Error("data too long for modulus")
        } else
            throw new Error("unknown padding");
        return oe ? O(le, se) : B(le, se)
    }
    ;
    function N(Z, J) {
        var ie = Z.modulus.byteLength()
          , oe = J.length
          , ae = E("sha1").update(F.alloc(0)).digest()
          , se = ae.length
          , le = 2 * se;
        if (oe > ie - le - 2)
            throw new Error("message too long");
        var de = F.alloc(ie - oe - le - 2)
          , fe = ie - se - 1
          , pe = S(se)
          , ge = T(F.concat([ae, de, F.alloc(1, 1), J], fe), M(pe, fe))
          , we = T(pe, M(ge, se));
        return new $(F.concat([F.alloc(1), we, ge], ie))
    }
    function U(Z, J, ie) {
        var oe = J.length
          , ae = Z.modulus.byteLength();
        if (oe > ae - 11)
            throw new Error("message too long");
        var se;
        return ie ? se = F.alloc(ae - oe - 3, 255) : se = H(ae - oe - 3),
        new $(F.concat([F.from([0, ie ? 1 : 2]), se, F.alloc(1), J], ae))
    }
    function H(Z) {
        for (var J = F.allocUnsafe(Z), ie = 0, oe = S(Z * 2), ae = 0, se; ie < Z; )
            ae === oe.length && (oe = S(Z * 2),
            ae = 0),
            se = oe[ae++],
            se && (J[ie++] = se);
        return J
    }
    return publicEncrypt
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
    if (hasRequiredPrivateDecrypt)
        return privateDecrypt;
    hasRequiredPrivateDecrypt = 1;
    var C = requireParseAsn1()
      , S = requireMgf()
      , E = requireXor()
      , M = requireBn$2()
      , T = requireBrowserifyRsa()
      , $ = requireBrowser$9()
      , B = requireWithPublic()
      , O = requireSafeBuffer$1().Buffer;
    privateDecrypt = function(Z, J, ie) {
        var oe;
        Z.padding ? oe = Z.padding : ie ? oe = 1 : oe = 4;
        var ae = C(Z)
          , se = ae.modulus.byteLength();
        if (J.length > se || new M(J).cmp(ae.modulus) >= 0)
            throw new Error("decryption error");
        var le;
        ie ? le = B(new M(J), ae) : le = T(J, ae);
        var de = O.alloc(se - le.length);
        if (le = O.concat([de, le], se),
        oe === 4)
            return F(ae, le);
        if (oe === 1)
            return N(ae, le, ie);
        if (oe === 3)
            return le;
        throw new Error("unknown padding")
    }
    ;
    function F(H, Z) {
        var J = H.modulus.byteLength()
          , ie = $("sha1").update(O.alloc(0)).digest()
          , oe = ie.length;
        if (Z[0] !== 0)
            throw new Error("decryption error");
        var ae = Z.slice(1, oe + 1)
          , se = Z.slice(oe + 1)
          , le = E(ae, S(se, oe))
          , de = E(se, S(le, J - oe - 1));
        if (U(ie, de.slice(0, oe)))
            throw new Error("decryption error");
        for (var fe = oe; de[fe] === 0; )
            fe++;
        if (de[fe++] !== 1)
            throw new Error("decryption error");
        return de.slice(fe)
    }
    function N(H, Z, J) {
        for (var ie = Z.slice(0, 2), oe = 2, ae = 0; Z[oe++] !== 0; )
            if (oe >= Z.length) {
                ae++;
                break
            }
        var se = Z.slice(2, oe - 1);
        if ((ie.toString("hex") !== "0002" && !J || ie.toString("hex") !== "0001" && J) && ae++,
        se.length < 8 && ae++,
        ae)
            throw new Error("decryption error");
        return Z.slice(oe)
    }
    function U(H, Z) {
        H = O.from(H),
        Z = O.from(Z);
        var J = 0
          , ie = H.length;
        H.length !== Z.length && (J++,
        ie = Math.min(H.length, Z.length));
        for (var oe = -1; ++oe < ie; )
            J += H[oe] ^ Z[oe];
        return J
    }
    return privateDecrypt
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
    return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1,
    function(C) {
        C.publicEncrypt = requirePublicEncrypt(),
        C.privateDecrypt = requirePrivateDecrypt(),
        C.privateEncrypt = function(E, M) {
            return C.publicEncrypt(E, M, !0)
        }
        ,
        C.publicDecrypt = function(E, M) {
            return C.privateDecrypt(E, M, !0)
        }
    }(browser$3)),
    browser$3
}
var browser$2 = {}, hasRequiredBrowser;
function requireBrowser() {
    if (hasRequiredBrowser)
        return browser$2;
    hasRequiredBrowser = 1;
    function C() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
    }
    var S = requireSafeBuffer$1()
      , E = requireBrowser$b()
      , M = S.Buffer
      , T = S.kMaxLength
      , $ = commonjsGlobal.crypto || commonjsGlobal.msCrypto
      , B = Math.pow(2, 32) - 1;
    function O(Z, J) {
        if (typeof Z != "number" || Z !== Z)
            throw new TypeError("offset must be a number");
        if (Z > B || Z < 0)
            throw new TypeError("offset must be a uint32");
        if (Z > T || Z > J)
            throw new RangeError("offset out of range")
    }
    function F(Z, J, ie) {
        if (typeof Z != "number" || Z !== Z)
            throw new TypeError("size must be a number");
        if (Z > B || Z < 0)
            throw new TypeError("size must be a uint32");
        if (Z + J > ie || Z > T)
            throw new RangeError("buffer too small")
    }
    $ && $.getRandomValues || !process$1.browser ? (browser$2.randomFill = N,
    browser$2.randomFillSync = H) : (browser$2.randomFill = C,
    browser$2.randomFillSync = C);
    function N(Z, J, ie, oe) {
        if (!M.isBuffer(Z) && !(Z instanceof commonjsGlobal.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof J == "function")
            oe = J,
            J = 0,
            ie = Z.length;
        else if (typeof ie == "function")
            oe = ie,
            ie = Z.length - J;
        else if (typeof oe != "function")
            throw new TypeError('"cb" argument must be a function');
        return O(J, Z.length),
        F(ie, J, Z.length),
        U(Z, J, ie, oe)
    }
    function U(Z, J, ie, oe) {
        if (process$1.browser) {
            var ae = Z.buffer
              , se = new Uint8Array(ae,J,ie);
            if ($.getRandomValues(se),
            oe) {
                process$1.nextTick(function() {
                    oe(null, Z)
                });
                return
            }
            return Z
        }
        if (oe) {
            E(ie, function(de, fe) {
                if (de)
                    return oe(de);
                fe.copy(Z, J),
                oe(null, Z)
            });
            return
        }
        var le = E(ie);
        return le.copy(Z, J),
        Z
    }
    function H(Z, J, ie) {
        if (typeof J > "u" && (J = 0),
        !M.isBuffer(Z) && !(Z instanceof commonjsGlobal.Uint8Array))
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return O(J, Z.length),
        ie === void 0 && (ie = Z.length - J),
        F(ie, J, Z.length),
        U(Z, J, ie)
    }
    return browser$2
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
    if (hasRequiredCryptoBrowserify)
        return cryptoBrowserify;
    hasRequiredCryptoBrowserify = 1,
    cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(),
    cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(),
    cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
    var C = requireAlgos()
      , S = Object.keys(C)
      , E = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(S);
    cryptoBrowserify.getHashes = function() {
        return E
    }
    ;
    var M = requireBrowser$7();
    cryptoBrowserify.pbkdf2 = M.pbkdf2,
    cryptoBrowserify.pbkdf2Sync = M.pbkdf2Sync;
    var T = requireBrowser$5();
    cryptoBrowserify.Cipher = T.Cipher,
    cryptoBrowserify.createCipher = T.createCipher,
    cryptoBrowserify.Cipheriv = T.Cipheriv,
    cryptoBrowserify.createCipheriv = T.createCipheriv,
    cryptoBrowserify.Decipher = T.Decipher,
    cryptoBrowserify.createDecipher = T.createDecipher,
    cryptoBrowserify.Decipheriv = T.Decipheriv,
    cryptoBrowserify.createDecipheriv = T.createDecipheriv,
    cryptoBrowserify.getCiphers = T.getCiphers,
    cryptoBrowserify.listCiphers = T.listCiphers;
    var $ = requireBrowser$4();
    cryptoBrowserify.DiffieHellmanGroup = $.DiffieHellmanGroup,
    cryptoBrowserify.createDiffieHellmanGroup = $.createDiffieHellmanGroup,
    cryptoBrowserify.getDiffieHellman = $.getDiffieHellman,
    cryptoBrowserify.createDiffieHellman = $.createDiffieHellman,
    cryptoBrowserify.DiffieHellman = $.DiffieHellman;
    var B = requireBrowser$3();
    cryptoBrowserify.createSign = B.createSign,
    cryptoBrowserify.Sign = B.Sign,
    cryptoBrowserify.createVerify = B.createVerify,
    cryptoBrowserify.Verify = B.Verify,
    cryptoBrowserify.createECDH = requireBrowser$2();
    var O = requireBrowser$1();
    cryptoBrowserify.publicEncrypt = O.publicEncrypt,
    cryptoBrowserify.privateEncrypt = O.privateEncrypt,
    cryptoBrowserify.publicDecrypt = O.publicDecrypt,
    cryptoBrowserify.privateDecrypt = O.privateDecrypt;
    var F = requireBrowser();
    return cryptoBrowserify.randomFill = F.randomFill,
    cryptoBrowserify.randomFillSync = F.randomFillSync,
    cryptoBrowserify.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
    }
    ,
    cryptoBrowserify.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    },
    cryptoBrowserify
}
(function(C) {
    (function(S) {
        var E = function(ye) {
            var Be, Oe = new Float64Array(16);
            if (ye)
                for (Be = 0; Be < ye.length; Be++)
                    Oe[Be] = ye[Be];
            return Oe
        }
          , M = function() {
            throw new Error("no PRNG")
        }
          , T = new Uint8Array(16)
          , $ = new Uint8Array(32);
        $[0] = 9;
        var B = E()
          , O = E([1])
          , F = E([56129, 1])
          , N = E([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995])
          , U = E([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])
          , H = E([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
          , Z = E([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214])
          , J = E([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ie(ye, Be, Oe, he) {
            ye[Be] = Oe >> 24 & 255,
            ye[Be + 1] = Oe >> 16 & 255,
            ye[Be + 2] = Oe >> 8 & 255,
            ye[Be + 3] = Oe & 255,
            ye[Be + 4] = he >> 24 & 255,
            ye[Be + 5] = he >> 16 & 255,
            ye[Be + 6] = he >> 8 & 255,
            ye[Be + 7] = he & 255
        }
        function oe(ye, Be, Oe, he, Pe) {
            var rt, Ze = 0;
            for (rt = 0; rt < Pe; rt++)
                Ze |= ye[Be + rt] ^ Oe[he + rt];
            return (1 & Ze - 1 >>> 8) - 1
        }
        function ae(ye, Be, Oe, he) {
            return oe(ye, Be, Oe, he, 16)
        }
        function se(ye, Be, Oe, he) {
            return oe(ye, Be, Oe, he, 32)
        }
        function le(ye, Be, Oe, he) {
            for (var Pe = he[0] & 255 | (he[1] & 255) << 8 | (he[2] & 255) << 16 | (he[3] & 255) << 24, rt = Oe[0] & 255 | (Oe[1] & 255) << 8 | (Oe[2] & 255) << 16 | (Oe[3] & 255) << 24, Ze = Oe[4] & 255 | (Oe[5] & 255) << 8 | (Oe[6] & 255) << 16 | (Oe[7] & 255) << 24, tt = Oe[8] & 255 | (Oe[9] & 255) << 8 | (Oe[10] & 255) << 16 | (Oe[11] & 255) << 24, Et = Oe[12] & 255 | (Oe[13] & 255) << 8 | (Oe[14] & 255) << 16 | (Oe[15] & 255) << 24, Tt = he[4] & 255 | (he[5] & 255) << 8 | (he[6] & 255) << 16 | (he[7] & 255) << 24, kt = Be[0] & 255 | (Be[1] & 255) << 8 | (Be[2] & 255) << 16 | (Be[3] & 255) << 24, Qt = Be[4] & 255 | (Be[5] & 255) << 8 | (Be[6] & 255) << 16 | (Be[7] & 255) << 24, Vt = Be[8] & 255 | (Be[9] & 255) << 8 | (Be[10] & 255) << 16 | (Be[11] & 255) << 24, Ve = Be[12] & 255 | (Be[13] & 255) << 8 | (Be[14] & 255) << 16 | (Be[15] & 255) << 24, me = he[8] & 255 | (he[9] & 255) << 8 | (he[10] & 255) << 16 | (he[11] & 255) << 24, ke = Oe[16] & 255 | (Oe[17] & 255) << 8 | (Oe[18] & 255) << 16 | (Oe[19] & 255) << 24, Le = Oe[20] & 255 | (Oe[21] & 255) << 8 | (Oe[22] & 255) << 16 | (Oe[23] & 255) << 24, Qe = Oe[24] & 255 | (Oe[25] & 255) << 8 | (Oe[26] & 255) << 16 | (Oe[27] & 255) << 24, Ke = Oe[28] & 255 | (Oe[29] & 255) << 8 | (Oe[30] & 255) << 16 | (Oe[31] & 255) << 24, vt = he[12] & 255 | (he[13] & 255) << 8 | (he[14] & 255) << 16 | (he[15] & 255) << 24, dt = Pe, It = rt, xt = Ze, Dt = tt, qt = Et, zt = Tt, mt = kt, wt = Qt, Ut = Vt, Ft = Ve, Lt = me, Ht = ke, Xt = Le, Jt = Qe, tr = Ke, er = vt, et, nr = 0; nr < 20; nr += 2)
                et = dt + Xt | 0,
                qt ^= et << 7 | et >>> 25,
                et = qt + dt | 0,
                Ut ^= et << 9 | et >>> 23,
                et = Ut + qt | 0,
                Xt ^= et << 13 | et >>> 19,
                et = Xt + Ut | 0,
                dt ^= et << 18 | et >>> 14,
                et = zt + It | 0,
                Ft ^= et << 7 | et >>> 25,
                et = Ft + zt | 0,
                Jt ^= et << 9 | et >>> 23,
                et = Jt + Ft | 0,
                It ^= et << 13 | et >>> 19,
                et = It + Jt | 0,
                zt ^= et << 18 | et >>> 14,
                et = Lt + mt | 0,
                tr ^= et << 7 | et >>> 25,
                et = tr + Lt | 0,
                xt ^= et << 9 | et >>> 23,
                et = xt + tr | 0,
                mt ^= et << 13 | et >>> 19,
                et = mt + xt | 0,
                Lt ^= et << 18 | et >>> 14,
                et = er + Ht | 0,
                Dt ^= et << 7 | et >>> 25,
                et = Dt + er | 0,
                wt ^= et << 9 | et >>> 23,
                et = wt + Dt | 0,
                Ht ^= et << 13 | et >>> 19,
                et = Ht + wt | 0,
                er ^= et << 18 | et >>> 14,
                et = dt + Dt | 0,
                It ^= et << 7 | et >>> 25,
                et = It + dt | 0,
                xt ^= et << 9 | et >>> 23,
                et = xt + It | 0,
                Dt ^= et << 13 | et >>> 19,
                et = Dt + xt | 0,
                dt ^= et << 18 | et >>> 14,
                et = zt + qt | 0,
                mt ^= et << 7 | et >>> 25,
                et = mt + zt | 0,
                wt ^= et << 9 | et >>> 23,
                et = wt + mt | 0,
                qt ^= et << 13 | et >>> 19,
                et = qt + wt | 0,
                zt ^= et << 18 | et >>> 14,
                et = Lt + Ft | 0,
                Ht ^= et << 7 | et >>> 25,
                et = Ht + Lt | 0,
                Ut ^= et << 9 | et >>> 23,
                et = Ut + Ht | 0,
                Ft ^= et << 13 | et >>> 19,
                et = Ft + Ut | 0,
                Lt ^= et << 18 | et >>> 14,
                et = er + tr | 0,
                Xt ^= et << 7 | et >>> 25,
                et = Xt + er | 0,
                Jt ^= et << 9 | et >>> 23,
                et = Jt + Xt | 0,
                tr ^= et << 13 | et >>> 19,
                et = tr + Jt | 0,
                er ^= et << 18 | et >>> 14;
            dt = dt + Pe | 0,
            It = It + rt | 0,
            xt = xt + Ze | 0,
            Dt = Dt + tt | 0,
            qt = qt + Et | 0,
            zt = zt + Tt | 0,
            mt = mt + kt | 0,
            wt = wt + Qt | 0,
            Ut = Ut + Vt | 0,
            Ft = Ft + Ve | 0,
            Lt = Lt + me | 0,
            Ht = Ht + ke | 0,
            Xt = Xt + Le | 0,
            Jt = Jt + Qe | 0,
            tr = tr + Ke | 0,
            er = er + vt | 0,
            ye[0] = dt >>> 0 & 255,
            ye[1] = dt >>> 8 & 255,
            ye[2] = dt >>> 16 & 255,
            ye[3] = dt >>> 24 & 255,
            ye[4] = It >>> 0 & 255,
            ye[5] = It >>> 8 & 255,
            ye[6] = It >>> 16 & 255,
            ye[7] = It >>> 24 & 255,
            ye[8] = xt >>> 0 & 255,
            ye[9] = xt >>> 8 & 255,
            ye[10] = xt >>> 16 & 255,
            ye[11] = xt >>> 24 & 255,
            ye[12] = Dt >>> 0 & 255,
            ye[13] = Dt >>> 8 & 255,
            ye[14] = Dt >>> 16 & 255,
            ye[15] = Dt >>> 24 & 255,
            ye[16] = qt >>> 0 & 255,
            ye[17] = qt >>> 8 & 255,
            ye[18] = qt >>> 16 & 255,
            ye[19] = qt >>> 24 & 255,
            ye[20] = zt >>> 0 & 255,
            ye[21] = zt >>> 8 & 255,
            ye[22] = zt >>> 16 & 255,
            ye[23] = zt >>> 24 & 255,
            ye[24] = mt >>> 0 & 255,
            ye[25] = mt >>> 8 & 255,
            ye[26] = mt >>> 16 & 255,
            ye[27] = mt >>> 24 & 255,
            ye[28] = wt >>> 0 & 255,
            ye[29] = wt >>> 8 & 255,
            ye[30] = wt >>> 16 & 255,
            ye[31] = wt >>> 24 & 255,
            ye[32] = Ut >>> 0 & 255,
            ye[33] = Ut >>> 8 & 255,
            ye[34] = Ut >>> 16 & 255,
            ye[35] = Ut >>> 24 & 255,
            ye[36] = Ft >>> 0 & 255,
            ye[37] = Ft >>> 8 & 255,
            ye[38] = Ft >>> 16 & 255,
            ye[39] = Ft >>> 24 & 255,
            ye[40] = Lt >>> 0 & 255,
            ye[41] = Lt >>> 8 & 255,
            ye[42] = Lt >>> 16 & 255,
            ye[43] = Lt >>> 24 & 255,
            ye[44] = Ht >>> 0 & 255,
            ye[45] = Ht >>> 8 & 255,
            ye[46] = Ht >>> 16 & 255,
            ye[47] = Ht >>> 24 & 255,
            ye[48] = Xt >>> 0 & 255,
            ye[49] = Xt >>> 8 & 255,
            ye[50] = Xt >>> 16 & 255,
            ye[51] = Xt >>> 24 & 255,
            ye[52] = Jt >>> 0 & 255,
            ye[53] = Jt >>> 8 & 255,
            ye[54] = Jt >>> 16 & 255,
            ye[55] = Jt >>> 24 & 255,
            ye[56] = tr >>> 0 & 255,
            ye[57] = tr >>> 8 & 255,
            ye[58] = tr >>> 16 & 255,
            ye[59] = tr >>> 24 & 255,
            ye[60] = er >>> 0 & 255,
            ye[61] = er >>> 8 & 255,
            ye[62] = er >>> 16 & 255,
            ye[63] = er >>> 24 & 255
        }
        function de(ye, Be, Oe, he) {
            for (var Pe = he[0] & 255 | (he[1] & 255) << 8 | (he[2] & 255) << 16 | (he[3] & 255) << 24, rt = Oe[0] & 255 | (Oe[1] & 255) << 8 | (Oe[2] & 255) << 16 | (Oe[3] & 255) << 24, Ze = Oe[4] & 255 | (Oe[5] & 255) << 8 | (Oe[6] & 255) << 16 | (Oe[7] & 255) << 24, tt = Oe[8] & 255 | (Oe[9] & 255) << 8 | (Oe[10] & 255) << 16 | (Oe[11] & 255) << 24, Et = Oe[12] & 255 | (Oe[13] & 255) << 8 | (Oe[14] & 255) << 16 | (Oe[15] & 255) << 24, Tt = he[4] & 255 | (he[5] & 255) << 8 | (he[6] & 255) << 16 | (he[7] & 255) << 24, kt = Be[0] & 255 | (Be[1] & 255) << 8 | (Be[2] & 255) << 16 | (Be[3] & 255) << 24, Qt = Be[4] & 255 | (Be[5] & 255) << 8 | (Be[6] & 255) << 16 | (Be[7] & 255) << 24, Vt = Be[8] & 255 | (Be[9] & 255) << 8 | (Be[10] & 255) << 16 | (Be[11] & 255) << 24, Ve = Be[12] & 255 | (Be[13] & 255) << 8 | (Be[14] & 255) << 16 | (Be[15] & 255) << 24, me = he[8] & 255 | (he[9] & 255) << 8 | (he[10] & 255) << 16 | (he[11] & 255) << 24, ke = Oe[16] & 255 | (Oe[17] & 255) << 8 | (Oe[18] & 255) << 16 | (Oe[19] & 255) << 24, Le = Oe[20] & 255 | (Oe[21] & 255) << 8 | (Oe[22] & 255) << 16 | (Oe[23] & 255) << 24, Qe = Oe[24] & 255 | (Oe[25] & 255) << 8 | (Oe[26] & 255) << 16 | (Oe[27] & 255) << 24, Ke = Oe[28] & 255 | (Oe[29] & 255) << 8 | (Oe[30] & 255) << 16 | (Oe[31] & 255) << 24, vt = he[12] & 255 | (he[13] & 255) << 8 | (he[14] & 255) << 16 | (he[15] & 255) << 24, dt = Pe, It = rt, xt = Ze, Dt = tt, qt = Et, zt = Tt, mt = kt, wt = Qt, Ut = Vt, Ft = Ve, Lt = me, Ht = ke, Xt = Le, Jt = Qe, tr = Ke, er = vt, et, nr = 0; nr < 20; nr += 2)
                et = dt + Xt | 0,
                qt ^= et << 7 | et >>> 25,
                et = qt + dt | 0,
                Ut ^= et << 9 | et >>> 23,
                et = Ut + qt | 0,
                Xt ^= et << 13 | et >>> 19,
                et = Xt + Ut | 0,
                dt ^= et << 18 | et >>> 14,
                et = zt + It | 0,
                Ft ^= et << 7 | et >>> 25,
                et = Ft + zt | 0,
                Jt ^= et << 9 | et >>> 23,
                et = Jt + Ft | 0,
                It ^= et << 13 | et >>> 19,
                et = It + Jt | 0,
                zt ^= et << 18 | et >>> 14,
                et = Lt + mt | 0,
                tr ^= et << 7 | et >>> 25,
                et = tr + Lt | 0,
                xt ^= et << 9 | et >>> 23,
                et = xt + tr | 0,
                mt ^= et << 13 | et >>> 19,
                et = mt + xt | 0,
                Lt ^= et << 18 | et >>> 14,
                et = er + Ht | 0,
                Dt ^= et << 7 | et >>> 25,
                et = Dt + er | 0,
                wt ^= et << 9 | et >>> 23,
                et = wt + Dt | 0,
                Ht ^= et << 13 | et >>> 19,
                et = Ht + wt | 0,
                er ^= et << 18 | et >>> 14,
                et = dt + Dt | 0,
                It ^= et << 7 | et >>> 25,
                et = It + dt | 0,
                xt ^= et << 9 | et >>> 23,
                et = xt + It | 0,
                Dt ^= et << 13 | et >>> 19,
                et = Dt + xt | 0,
                dt ^= et << 18 | et >>> 14,
                et = zt + qt | 0,
                mt ^= et << 7 | et >>> 25,
                et = mt + zt | 0,
                wt ^= et << 9 | et >>> 23,
                et = wt + mt | 0,
                qt ^= et << 13 | et >>> 19,
                et = qt + wt | 0,
                zt ^= et << 18 | et >>> 14,
                et = Lt + Ft | 0,
                Ht ^= et << 7 | et >>> 25,
                et = Ht + Lt | 0,
                Ut ^= et << 9 | et >>> 23,
                et = Ut + Ht | 0,
                Ft ^= et << 13 | et >>> 19,
                et = Ft + Ut | 0,
                Lt ^= et << 18 | et >>> 14,
                et = er + tr | 0,
                Xt ^= et << 7 | et >>> 25,
                et = Xt + er | 0,
                Jt ^= et << 9 | et >>> 23,
                et = Jt + Xt | 0,
                tr ^= et << 13 | et >>> 19,
                et = tr + Jt | 0,
                er ^= et << 18 | et >>> 14;
            ye[0] = dt >>> 0 & 255,
            ye[1] = dt >>> 8 & 255,
            ye[2] = dt >>> 16 & 255,
            ye[3] = dt >>> 24 & 255,
            ye[4] = zt >>> 0 & 255,
            ye[5] = zt >>> 8 & 255,
            ye[6] = zt >>> 16 & 255,
            ye[7] = zt >>> 24 & 255,
            ye[8] = Lt >>> 0 & 255,
            ye[9] = Lt >>> 8 & 255,
            ye[10] = Lt >>> 16 & 255,
            ye[11] = Lt >>> 24 & 255,
            ye[12] = er >>> 0 & 255,
            ye[13] = er >>> 8 & 255,
            ye[14] = er >>> 16 & 255,
            ye[15] = er >>> 24 & 255,
            ye[16] = mt >>> 0 & 255,
            ye[17] = mt >>> 8 & 255,
            ye[18] = mt >>> 16 & 255,
            ye[19] = mt >>> 24 & 255,
            ye[20] = wt >>> 0 & 255,
            ye[21] = wt >>> 8 & 255,
            ye[22] = wt >>> 16 & 255,
            ye[23] = wt >>> 24 & 255,
            ye[24] = Ut >>> 0 & 255,
            ye[25] = Ut >>> 8 & 255,
            ye[26] = Ut >>> 16 & 255,
            ye[27] = Ut >>> 24 & 255,
            ye[28] = Ft >>> 0 & 255,
            ye[29] = Ft >>> 8 & 255,
            ye[30] = Ft >>> 16 & 255,
            ye[31] = Ft >>> 24 & 255
        }
        function fe(ye, Be, Oe, he) {
            le(ye, Be, Oe, he)
        }
        function pe(ye, Be, Oe, he) {
            de(ye, Be, Oe, he)
        }
        var ge = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function we(ye, Be, Oe, he, Pe, rt, Ze) {
            var tt = new Uint8Array(16), Et = new Uint8Array(64), Tt, kt;
            for (kt = 0; kt < 16; kt++)
                tt[kt] = 0;
            for (kt = 0; kt < 8; kt++)
                tt[kt] = rt[kt];
            for (; Pe >= 64; ) {
                for (fe(Et, tt, Ze, ge),
                kt = 0; kt < 64; kt++)
                    ye[Be + kt] = Oe[he + kt] ^ Et[kt];
                for (Tt = 1,
                kt = 8; kt < 16; kt++)
                    Tt = Tt + (tt[kt] & 255) | 0,
                    tt[kt] = Tt & 255,
                    Tt >>>= 8;
                Pe -= 64,
                Be += 64,
                he += 64
            }
            if (Pe > 0)
                for (fe(Et, tt, Ze, ge),
                kt = 0; kt < Pe; kt++)
                    ye[Be + kt] = Oe[he + kt] ^ Et[kt];
            return 0
        }
        function Ae(ye, Be, Oe, he, Pe) {
            var rt = new Uint8Array(16), Ze = new Uint8Array(64), tt, Et;
            for (Et = 0; Et < 16; Et++)
                rt[Et] = 0;
            for (Et = 0; Et < 8; Et++)
                rt[Et] = he[Et];
            for (; Oe >= 64; ) {
                for (fe(Ze, rt, Pe, ge),
                Et = 0; Et < 64; Et++)
                    ye[Be + Et] = Ze[Et];
                for (tt = 1,
                Et = 8; Et < 16; Et++)
                    tt = tt + (rt[Et] & 255) | 0,
                    rt[Et] = tt & 255,
                    tt >>>= 8;
                Oe -= 64,
                Be += 64
            }
            if (Oe > 0)
                for (fe(Ze, rt, Pe, ge),
                Et = 0; Et < Oe; Et++)
                    ye[Be + Et] = Ze[Et];
            return 0
        }
        function Se(ye, Be, Oe, he, Pe) {
            var rt = new Uint8Array(32);
            pe(rt, he, Pe, ge);
            for (var Ze = new Uint8Array(8), tt = 0; tt < 8; tt++)
                Ze[tt] = he[tt + 16];
            return Ae(ye, Be, Oe, Ze, rt)
        }
        function ue(ye, Be, Oe, he, Pe, rt, Ze) {
            var tt = new Uint8Array(32);
            pe(tt, rt, Ze, ge);
            for (var Et = new Uint8Array(8), Tt = 0; Tt < 8; Tt++)
                Et[Tt] = rt[Tt + 16];
            return we(ye, Be, Oe, he, Pe, Et, tt)
        }
        var V = function(ye) {
            this.buffer = new Uint8Array(16),
            this.r = new Uint16Array(10),
            this.h = new Uint16Array(10),
            this.pad = new Uint16Array(8),
            this.leftover = 0,
            this.fin = 0;
            var Be, Oe, he, Pe, rt, Ze, tt, Et;
            Be = ye[0] & 255 | (ye[1] & 255) << 8,
            this.r[0] = Be & 8191,
            Oe = ye[2] & 255 | (ye[3] & 255) << 8,
            this.r[1] = (Be >>> 13 | Oe << 3) & 8191,
            he = ye[4] & 255 | (ye[5] & 255) << 8,
            this.r[2] = (Oe >>> 10 | he << 6) & 7939,
            Pe = ye[6] & 255 | (ye[7] & 255) << 8,
            this.r[3] = (he >>> 7 | Pe << 9) & 8191,
            rt = ye[8] & 255 | (ye[9] & 255) << 8,
            this.r[4] = (Pe >>> 4 | rt << 12) & 255,
            this.r[5] = rt >>> 1 & 8190,
            Ze = ye[10] & 255 | (ye[11] & 255) << 8,
            this.r[6] = (rt >>> 14 | Ze << 2) & 8191,
            tt = ye[12] & 255 | (ye[13] & 255) << 8,
            this.r[7] = (Ze >>> 11 | tt << 5) & 8065,
            Et = ye[14] & 255 | (ye[15] & 255) << 8,
            this.r[8] = (tt >>> 8 | Et << 8) & 8191,
            this.r[9] = Et >>> 5 & 127,
            this.pad[0] = ye[16] & 255 | (ye[17] & 255) << 8,
            this.pad[1] = ye[18] & 255 | (ye[19] & 255) << 8,
            this.pad[2] = ye[20] & 255 | (ye[21] & 255) << 8,
            this.pad[3] = ye[22] & 255 | (ye[23] & 255) << 8,
            this.pad[4] = ye[24] & 255 | (ye[25] & 255) << 8,
            this.pad[5] = ye[26] & 255 | (ye[27] & 255) << 8,
            this.pad[6] = ye[28] & 255 | (ye[29] & 255) << 8,
            this.pad[7] = ye[30] & 255 | (ye[31] & 255) << 8
        };
        V.prototype.blocks = function(ye, Be, Oe) {
            for (var he = this.fin ? 0 : 2048, Pe, rt, Ze, tt, Et, Tt, kt, Qt, Vt, Ve, me, ke, Le, Qe, Ke, vt, dt, It, xt, Dt = this.h[0], qt = this.h[1], zt = this.h[2], mt = this.h[3], wt = this.h[4], Ut = this.h[5], Ft = this.h[6], Lt = this.h[7], Ht = this.h[8], Xt = this.h[9], Jt = this.r[0], tr = this.r[1], er = this.r[2], et = this.r[3], nr = this.r[4], ar = this.r[5], sr = this.r[6], rr = this.r[7], ir = this.r[8], or = this.r[9]; Oe >= 16; )
                Pe = ye[Be + 0] & 255 | (ye[Be + 1] & 255) << 8,
                Dt += Pe & 8191,
                rt = ye[Be + 2] & 255 | (ye[Be + 3] & 255) << 8,
                qt += (Pe >>> 13 | rt << 3) & 8191,
                Ze = ye[Be + 4] & 255 | (ye[Be + 5] & 255) << 8,
                zt += (rt >>> 10 | Ze << 6) & 8191,
                tt = ye[Be + 6] & 255 | (ye[Be + 7] & 255) << 8,
                mt += (Ze >>> 7 | tt << 9) & 8191,
                Et = ye[Be + 8] & 255 | (ye[Be + 9] & 255) << 8,
                wt += (tt >>> 4 | Et << 12) & 8191,
                Ut += Et >>> 1 & 8191,
                Tt = ye[Be + 10] & 255 | (ye[Be + 11] & 255) << 8,
                Ft += (Et >>> 14 | Tt << 2) & 8191,
                kt = ye[Be + 12] & 255 | (ye[Be + 13] & 255) << 8,
                Lt += (Tt >>> 11 | kt << 5) & 8191,
                Qt = ye[Be + 14] & 255 | (ye[Be + 15] & 255) << 8,
                Ht += (kt >>> 8 | Qt << 8) & 8191,
                Xt += Qt >>> 5 | he,
                Vt = 0,
                Ve = Vt,
                Ve += Dt * Jt,
                Ve += qt * (5 * or),
                Ve += zt * (5 * ir),
                Ve += mt * (5 * rr),
                Ve += wt * (5 * sr),
                Vt = Ve >>> 13,
                Ve &= 8191,
                Ve += Ut * (5 * ar),
                Ve += Ft * (5 * nr),
                Ve += Lt * (5 * et),
                Ve += Ht * (5 * er),
                Ve += Xt * (5 * tr),
                Vt += Ve >>> 13,
                Ve &= 8191,
                me = Vt,
                me += Dt * tr,
                me += qt * Jt,
                me += zt * (5 * or),
                me += mt * (5 * ir),
                me += wt * (5 * rr),
                Vt = me >>> 13,
                me &= 8191,
                me += Ut * (5 * sr),
                me += Ft * (5 * ar),
                me += Lt * (5 * nr),
                me += Ht * (5 * et),
                me += Xt * (5 * er),
                Vt += me >>> 13,
                me &= 8191,
                ke = Vt,
                ke += Dt * er,
                ke += qt * tr,
                ke += zt * Jt,
                ke += mt * (5 * or),
                ke += wt * (5 * ir),
                Vt = ke >>> 13,
                ke &= 8191,
                ke += Ut * (5 * rr),
                ke += Ft * (5 * sr),
                ke += Lt * (5 * ar),
                ke += Ht * (5 * nr),
                ke += Xt * (5 * et),
                Vt += ke >>> 13,
                ke &= 8191,
                Le = Vt,
                Le += Dt * et,
                Le += qt * er,
                Le += zt * tr,
                Le += mt * Jt,
                Le += wt * (5 * or),
                Vt = Le >>> 13,
                Le &= 8191,
                Le += Ut * (5 * ir),
                Le += Ft * (5 * rr),
                Le += Lt * (5 * sr),
                Le += Ht * (5 * ar),
                Le += Xt * (5 * nr),
                Vt += Le >>> 13,
                Le &= 8191,
                Qe = Vt,
                Qe += Dt * nr,
                Qe += qt * et,
                Qe += zt * er,
                Qe += mt * tr,
                Qe += wt * Jt,
                Vt = Qe >>> 13,
                Qe &= 8191,
                Qe += Ut * (5 * or),
                Qe += Ft * (5 * ir),
                Qe += Lt * (5 * rr),
                Qe += Ht * (5 * sr),
                Qe += Xt * (5 * ar),
                Vt += Qe >>> 13,
                Qe &= 8191,
                Ke = Vt,
                Ke += Dt * ar,
                Ke += qt * nr,
                Ke += zt * et,
                Ke += mt * er,
                Ke += wt * tr,
                Vt = Ke >>> 13,
                Ke &= 8191,
                Ke += Ut * Jt,
                Ke += Ft * (5 * or),
                Ke += Lt * (5 * ir),
                Ke += Ht * (5 * rr),
                Ke += Xt * (5 * sr),
                Vt += Ke >>> 13,
                Ke &= 8191,
                vt = Vt,
                vt += Dt * sr,
                vt += qt * ar,
                vt += zt * nr,
                vt += mt * et,
                vt += wt * er,
                Vt = vt >>> 13,
                vt &= 8191,
                vt += Ut * tr,
                vt += Ft * Jt,
                vt += Lt * (5 * or),
                vt += Ht * (5 * ir),
                vt += Xt * (5 * rr),
                Vt += vt >>> 13,
                vt &= 8191,
                dt = Vt,
                dt += Dt * rr,
                dt += qt * sr,
                dt += zt * ar,
                dt += mt * nr,
                dt += wt * et,
                Vt = dt >>> 13,
                dt &= 8191,
                dt += Ut * er,
                dt += Ft * tr,
                dt += Lt * Jt,
                dt += Ht * (5 * or),
                dt += Xt * (5 * ir),
                Vt += dt >>> 13,
                dt &= 8191,
                It = Vt,
                It += Dt * ir,
                It += qt * rr,
                It += zt * sr,
                It += mt * ar,
                It += wt * nr,
                Vt = It >>> 13,
                It &= 8191,
                It += Ut * et,
                It += Ft * er,
                It += Lt * tr,
                It += Ht * Jt,
                It += Xt * (5 * or),
                Vt += It >>> 13,
                It &= 8191,
                xt = Vt,
                xt += Dt * or,
                xt += qt * ir,
                xt += zt * rr,
                xt += mt * sr,
                xt += wt * ar,
                Vt = xt >>> 13,
                xt &= 8191,
                xt += Ut * nr,
                xt += Ft * et,
                xt += Lt * er,
                xt += Ht * tr,
                xt += Xt * Jt,
                Vt += xt >>> 13,
                xt &= 8191,
                Vt = (Vt << 2) + Vt | 0,
                Vt = Vt + Ve | 0,
                Ve = Vt & 8191,
                Vt = Vt >>> 13,
                me += Vt,
                Dt = Ve,
                qt = me,
                zt = ke,
                mt = Le,
                wt = Qe,
                Ut = Ke,
                Ft = vt,
                Lt = dt,
                Ht = It,
                Xt = xt,
                Be += 16,
                Oe -= 16;
            this.h[0] = Dt,
            this.h[1] = qt,
            this.h[2] = zt,
            this.h[3] = mt,
            this.h[4] = wt,
            this.h[5] = Ut,
            this.h[6] = Ft,
            this.h[7] = Lt,
            this.h[8] = Ht,
            this.h[9] = Xt
        }
        ,
        V.prototype.finish = function(ye, Be) {
            var Oe = new Uint16Array(10), he, Pe, rt, Ze;
            if (this.leftover) {
                for (Ze = this.leftover,
                this.buffer[Ze++] = 1; Ze < 16; Ze++)
                    this.buffer[Ze] = 0;
                this.fin = 1,
                this.blocks(this.buffer, 0, 16)
            }
            for (he = this.h[1] >>> 13,
            this.h[1] &= 8191,
            Ze = 2; Ze < 10; Ze++)
                this.h[Ze] += he,
                he = this.h[Ze] >>> 13,
                this.h[Ze] &= 8191;
            for (this.h[0] += he * 5,
            he = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += he,
            he = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += he,
            Oe[0] = this.h[0] + 5,
            he = Oe[0] >>> 13,
            Oe[0] &= 8191,
            Ze = 1; Ze < 10; Ze++)
                Oe[Ze] = this.h[Ze] + he,
                he = Oe[Ze] >>> 13,
                Oe[Ze] &= 8191;
            for (Oe[9] -= 8192,
            Pe = (he ^ 1) - 1,
            Ze = 0; Ze < 10; Ze++)
                Oe[Ze] &= Pe;
            for (Pe = ~Pe,
            Ze = 0; Ze < 10; Ze++)
                this.h[Ze] = this.h[Ze] & Pe | Oe[Ze];
            for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535,
            this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535,
            this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535,
            this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535,
            this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535,
            this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535,
            this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535,
            this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535,
            rt = this.h[0] + this.pad[0],
            this.h[0] = rt & 65535,
            Ze = 1; Ze < 8; Ze++)
                rt = (this.h[Ze] + this.pad[Ze] | 0) + (rt >>> 16) | 0,
                this.h[Ze] = rt & 65535;
            ye[Be + 0] = this.h[0] >>> 0 & 255,
            ye[Be + 1] = this.h[0] >>> 8 & 255,
            ye[Be + 2] = this.h[1] >>> 0 & 255,
            ye[Be + 3] = this.h[1] >>> 8 & 255,
            ye[Be + 4] = this.h[2] >>> 0 & 255,
            ye[Be + 5] = this.h[2] >>> 8 & 255,
            ye[Be + 6] = this.h[3] >>> 0 & 255,
            ye[Be + 7] = this.h[3] >>> 8 & 255,
            ye[Be + 8] = this.h[4] >>> 0 & 255,
            ye[Be + 9] = this.h[4] >>> 8 & 255,
            ye[Be + 10] = this.h[5] >>> 0 & 255,
            ye[Be + 11] = this.h[5] >>> 8 & 255,
            ye[Be + 12] = this.h[6] >>> 0 & 255,
            ye[Be + 13] = this.h[6] >>> 8 & 255,
            ye[Be + 14] = this.h[7] >>> 0 & 255,
            ye[Be + 15] = this.h[7] >>> 8 & 255
        }
        ,
        V.prototype.update = function(ye, Be, Oe) {
            var he, Pe;
            if (this.leftover) {
                for (Pe = 16 - this.leftover,
                Pe > Oe && (Pe = Oe),
                he = 0; he < Pe; he++)
                    this.buffer[this.leftover + he] = ye[Be + he];
                if (Oe -= Pe,
                Be += Pe,
                this.leftover += Pe,
                this.leftover < 16)
                    return;
                this.blocks(this.buffer, 0, 16),
                this.leftover = 0
            }
            if (Oe >= 16 && (Pe = Oe - Oe % 16,
            this.blocks(ye, Be, Pe),
            Be += Pe,
            Oe -= Pe),
            Oe) {
                for (he = 0; he < Oe; he++)
                    this.buffer[this.leftover + he] = ye[Be + he];
                this.leftover += Oe
            }
        }
        ;
        function W(ye, Be, Oe, he, Pe, rt) {
            var Ze = new V(rt);
            return Ze.update(Oe, he, Pe),
            Ze.finish(ye, Be),
            0
        }
        function D(ye, Be, Oe, he, Pe, rt) {
            var Ze = new Uint8Array(16);
            return W(Ze, 0, Oe, he, Pe, rt),
            ae(ye, Be, Ze, 0)
        }
        function I(ye, Be, Oe, he, Pe) {
            var rt;
            if (Oe < 32)
                return -1;
            for (ue(ye, 0, Be, 0, Oe, he, Pe),
            W(ye, 16, ye, 32, Oe - 32, ye),
            rt = 0; rt < 16; rt++)
                ye[rt] = 0;
            return 0
        }
        function L(ye, Be, Oe, he, Pe) {
            var rt, Ze = new Uint8Array(32);
            if (Oe < 32 || (Se(Ze, 0, 32, he, Pe),
            D(Be, 16, Be, 32, Oe - 32, Ze) !== 0))
                return -1;
            for (ue(ye, 0, Be, 0, Oe, he, Pe),
            rt = 0; rt < 32; rt++)
                ye[rt] = 0;
            return 0
        }
        function K(ye, Be) {
            var Oe;
            for (Oe = 0; Oe < 16; Oe++)
                ye[Oe] = Be[Oe] | 0
        }
        function X(ye) {
            var Be, Oe, he = 1;
            for (Be = 0; Be < 16; Be++)
                Oe = ye[Be] + he + 65535,
                he = Math.floor(Oe / 65536),
                ye[Be] = Oe - he * 65536;
            ye[0] += he - 1 + 37 * (he - 1)
        }
        function Y(ye, Be, Oe) {
            for (var he, Pe = ~(Oe - 1), rt = 0; rt < 16; rt++)
                he = Pe & (ye[rt] ^ Be[rt]),
                ye[rt] ^= he,
                Be[rt] ^= he
        }
        function j(ye, Be) {
            var Oe, he, Pe, rt = E(), Ze = E();
            for (Oe = 0; Oe < 16; Oe++)
                Ze[Oe] = Be[Oe];
            for (X(Ze),
            X(Ze),
            X(Ze),
            he = 0; he < 2; he++) {
                for (rt[0] = Ze[0] - 65517,
                Oe = 1; Oe < 15; Oe++)
                    rt[Oe] = Ze[Oe] - 65535 - (rt[Oe - 1] >> 16 & 1),
                    rt[Oe - 1] &= 65535;
                rt[15] = Ze[15] - 32767 - (rt[14] >> 16 & 1),
                Pe = rt[15] >> 16 & 1,
                rt[14] &= 65535,
                Y(Ze, rt, 1 - Pe)
            }
            for (Oe = 0; Oe < 16; Oe++)
                ye[2 * Oe] = Ze[Oe] & 255,
                ye[2 * Oe + 1] = Ze[Oe] >> 8
        }
        function G(ye, Be) {
            var Oe = new Uint8Array(32)
              , he = new Uint8Array(32);
            return j(Oe, ye),
            j(he, Be),
            se(Oe, 0, he, 0)
        }
        function ne(ye) {
            var Be = new Uint8Array(32);
            return j(Be, ye),
            Be[0] & 1
        }
        function te(ye, Be) {
            var Oe;
            for (Oe = 0; Oe < 16; Oe++)
                ye[Oe] = Be[2 * Oe] + (Be[2 * Oe + 1] << 8);
            ye[15] &= 32767
        }
        function ce(ye, Be, Oe) {
            for (var he = 0; he < 16; he++)
                ye[he] = Be[he] + Oe[he]
        }
        function Ee(ye, Be, Oe) {
            for (var he = 0; he < 16; he++)
                ye[he] = Be[he] - Oe[he]
        }
        function Re(ye, Be, Oe) {
            var he, Pe, rt = 0, Ze = 0, tt = 0, Et = 0, Tt = 0, kt = 0, Qt = 0, Vt = 0, Ve = 0, me = 0, ke = 0, Le = 0, Qe = 0, Ke = 0, vt = 0, dt = 0, It = 0, xt = 0, Dt = 0, qt = 0, zt = 0, mt = 0, wt = 0, Ut = 0, Ft = 0, Lt = 0, Ht = 0, Xt = 0, Jt = 0, tr = 0, er = 0, et = Oe[0], nr = Oe[1], ar = Oe[2], sr = Oe[3], rr = Oe[4], ir = Oe[5], or = Oe[6], dr = Oe[7], lr = Oe[8], cr = Oe[9], ur = Oe[10], fr = Oe[11], hr = Oe[12], pr = Oe[13], gr = Oe[14], vr = Oe[15];
            he = Be[0],
            rt += he * et,
            Ze += he * nr,
            tt += he * ar,
            Et += he * sr,
            Tt += he * rr,
            kt += he * ir,
            Qt += he * or,
            Vt += he * dr,
            Ve += he * lr,
            me += he * cr,
            ke += he * ur,
            Le += he * fr,
            Qe += he * hr,
            Ke += he * pr,
            vt += he * gr,
            dt += he * vr,
            he = Be[1],
            Ze += he * et,
            tt += he * nr,
            Et += he * ar,
            Tt += he * sr,
            kt += he * rr,
            Qt += he * ir,
            Vt += he * or,
            Ve += he * dr,
            me += he * lr,
            ke += he * cr,
            Le += he * ur,
            Qe += he * fr,
            Ke += he * hr,
            vt += he * pr,
            dt += he * gr,
            It += he * vr,
            he = Be[2],
            tt += he * et,
            Et += he * nr,
            Tt += he * ar,
            kt += he * sr,
            Qt += he * rr,
            Vt += he * ir,
            Ve += he * or,
            me += he * dr,
            ke += he * lr,
            Le += he * cr,
            Qe += he * ur,
            Ke += he * fr,
            vt += he * hr,
            dt += he * pr,
            It += he * gr,
            xt += he * vr,
            he = Be[3],
            Et += he * et,
            Tt += he * nr,
            kt += he * ar,
            Qt += he * sr,
            Vt += he * rr,
            Ve += he * ir,
            me += he * or,
            ke += he * dr,
            Le += he * lr,
            Qe += he * cr,
            Ke += he * ur,
            vt += he * fr,
            dt += he * hr,
            It += he * pr,
            xt += he * gr,
            Dt += he * vr,
            he = Be[4],
            Tt += he * et,
            kt += he * nr,
            Qt += he * ar,
            Vt += he * sr,
            Ve += he * rr,
            me += he * ir,
            ke += he * or,
            Le += he * dr,
            Qe += he * lr,
            Ke += he * cr,
            vt += he * ur,
            dt += he * fr,
            It += he * hr,
            xt += he * pr,
            Dt += he * gr,
            qt += he * vr,
            he = Be[5],
            kt += he * et,
            Qt += he * nr,
            Vt += he * ar,
            Ve += he * sr,
            me += he * rr,
            ke += he * ir,
            Le += he * or,
            Qe += he * dr,
            Ke += he * lr,
            vt += he * cr,
            dt += he * ur,
            It += he * fr,
            xt += he * hr,
            Dt += he * pr,
            qt += he * gr,
            zt += he * vr,
            he = Be[6],
            Qt += he * et,
            Vt += he * nr,
            Ve += he * ar,
            me += he * sr,
            ke += he * rr,
            Le += he * ir,
            Qe += he * or,
            Ke += he * dr,
            vt += he * lr,
            dt += he * cr,
            It += he * ur,
            xt += he * fr,
            Dt += he * hr,
            qt += he * pr,
            zt += he * gr,
            mt += he * vr,
            he = Be[7],
            Vt += he * et,
            Ve += he * nr,
            me += he * ar,
            ke += he * sr,
            Le += he * rr,
            Qe += he * ir,
            Ke += he * or,
            vt += he * dr,
            dt += he * lr,
            It += he * cr,
            xt += he * ur,
            Dt += he * fr,
            qt += he * hr,
            zt += he * pr,
            mt += he * gr,
            wt += he * vr,
            he = Be[8],
            Ve += he * et,
            me += he * nr,
            ke += he * ar,
            Le += he * sr,
            Qe += he * rr,
            Ke += he * ir,
            vt += he * or,
            dt += he * dr,
            It += he * lr,
            xt += he * cr,
            Dt += he * ur,
            qt += he * fr,
            zt += he * hr,
            mt += he * pr,
            wt += he * gr,
            Ut += he * vr,
            he = Be[9],
            me += he * et,
            ke += he * nr,
            Le += he * ar,
            Qe += he * sr,
            Ke += he * rr,
            vt += he * ir,
            dt += he * or,
            It += he * dr,
            xt += he * lr,
            Dt += he * cr,
            qt += he * ur,
            zt += he * fr,
            mt += he * hr,
            wt += he * pr,
            Ut += he * gr,
            Ft += he * vr,
            he = Be[10],
            ke += he * et,
            Le += he * nr,
            Qe += he * ar,
            Ke += he * sr,
            vt += he * rr,
            dt += he * ir,
            It += he * or,
            xt += he * dr,
            Dt += he * lr,
            qt += he * cr,
            zt += he * ur,
            mt += he * fr,
            wt += he * hr,
            Ut += he * pr,
            Ft += he * gr,
            Lt += he * vr,
            he = Be[11],
            Le += he * et,
            Qe += he * nr,
            Ke += he * ar,
            vt += he * sr,
            dt += he * rr,
            It += he * ir,
            xt += he * or,
            Dt += he * dr,
            qt += he * lr,
            zt += he * cr,
            mt += he * ur,
            wt += he * fr,
            Ut += he * hr,
            Ft += he * pr,
            Lt += he * gr,
            Ht += he * vr,
            he = Be[12],
            Qe += he * et,
            Ke += he * nr,
            vt += he * ar,
            dt += he * sr,
            It += he * rr,
            xt += he * ir,
            Dt += he * or,
            qt += he * dr,
            zt += he * lr,
            mt += he * cr,
            wt += he * ur,
            Ut += he * fr,
            Ft += he * hr,
            Lt += he * pr,
            Ht += he * gr,
            Xt += he * vr,
            he = Be[13],
            Ke += he * et,
            vt += he * nr,
            dt += he * ar,
            It += he * sr,
            xt += he * rr,
            Dt += he * ir,
            qt += he * or,
            zt += he * dr,
            mt += he * lr,
            wt += he * cr,
            Ut += he * ur,
            Ft += he * fr,
            Lt += he * hr,
            Ht += he * pr,
            Xt += he * gr,
            Jt += he * vr,
            he = Be[14],
            vt += he * et,
            dt += he * nr,
            It += he * ar,
            xt += he * sr,
            Dt += he * rr,
            qt += he * ir,
            zt += he * or,
            mt += he * dr,
            wt += he * lr,
            Ut += he * cr,
            Ft += he * ur,
            Lt += he * fr,
            Ht += he * hr,
            Xt += he * pr,
            Jt += he * gr,
            tr += he * vr,
            he = Be[15],
            dt += he * et,
            It += he * nr,
            xt += he * ar,
            Dt += he * sr,
            qt += he * rr,
            zt += he * ir,
            mt += he * or,
            wt += he * dr,
            Ut += he * lr,
            Ft += he * cr,
            Lt += he * ur,
            Ht += he * fr,
            Xt += he * hr,
            Jt += he * pr,
            tr += he * gr,
            er += he * vr,
            rt += 38 * It,
            Ze += 38 * xt,
            tt += 38 * Dt,
            Et += 38 * qt,
            Tt += 38 * zt,
            kt += 38 * mt,
            Qt += 38 * wt,
            Vt += 38 * Ut,
            Ve += 38 * Ft,
            me += 38 * Lt,
            ke += 38 * Ht,
            Le += 38 * Xt,
            Qe += 38 * Jt,
            Ke += 38 * tr,
            vt += 38 * er,
            Pe = 1,
            he = rt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            rt = he - Pe * 65536,
            he = Ze + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ze = he - Pe * 65536,
            he = tt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            tt = he - Pe * 65536,
            he = Et + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Et = he - Pe * 65536,
            he = Tt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Tt = he - Pe * 65536,
            he = kt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            kt = he - Pe * 65536,
            he = Qt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Qt = he - Pe * 65536,
            he = Vt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Vt = he - Pe * 65536,
            he = Ve + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ve = he - Pe * 65536,
            he = me + Pe + 65535,
            Pe = Math.floor(he / 65536),
            me = he - Pe * 65536,
            he = ke + Pe + 65535,
            Pe = Math.floor(he / 65536),
            ke = he - Pe * 65536,
            he = Le + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Le = he - Pe * 65536,
            he = Qe + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Qe = he - Pe * 65536,
            he = Ke + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ke = he - Pe * 65536,
            he = vt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            vt = he - Pe * 65536,
            he = dt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            dt = he - Pe * 65536,
            rt += Pe - 1 + 37 * (Pe - 1),
            Pe = 1,
            he = rt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            rt = he - Pe * 65536,
            he = Ze + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ze = he - Pe * 65536,
            he = tt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            tt = he - Pe * 65536,
            he = Et + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Et = he - Pe * 65536,
            he = Tt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Tt = he - Pe * 65536,
            he = kt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            kt = he - Pe * 65536,
            he = Qt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Qt = he - Pe * 65536,
            he = Vt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Vt = he - Pe * 65536,
            he = Ve + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ve = he - Pe * 65536,
            he = me + Pe + 65535,
            Pe = Math.floor(he / 65536),
            me = he - Pe * 65536,
            he = ke + Pe + 65535,
            Pe = Math.floor(he / 65536),
            ke = he - Pe * 65536,
            he = Le + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Le = he - Pe * 65536,
            he = Qe + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Qe = he - Pe * 65536,
            he = Ke + Pe + 65535,
            Pe = Math.floor(he / 65536),
            Ke = he - Pe * 65536,
            he = vt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            vt = he - Pe * 65536,
            he = dt + Pe + 65535,
            Pe = Math.floor(he / 65536),
            dt = he - Pe * 65536,
            rt += Pe - 1 + 37 * (Pe - 1),
            ye[0] = rt,
            ye[1] = Ze,
            ye[2] = tt,
            ye[3] = Et,
            ye[4] = Tt,
            ye[5] = kt,
            ye[6] = Qt,
            ye[7] = Vt,
            ye[8] = Ve,
            ye[9] = me,
            ye[10] = ke,
            ye[11] = Le,
            ye[12] = Qe,
            ye[13] = Ke,
            ye[14] = vt,
            ye[15] = dt
        }
        function Te(ye, Be) {
            Re(ye, Be, Be)
        }
        function xe(ye, Be) {
            var Oe = E(), he;
            for (he = 0; he < 16; he++)
                Oe[he] = Be[he];
            for (he = 253; he >= 0; he--)
                Te(Oe, Oe),
                he !== 2 && he !== 4 && Re(Oe, Oe, Be);
            for (he = 0; he < 16; he++)
                ye[he] = Oe[he]
        }
        function ve(ye, Be) {
            var Oe = E(), he;
            for (he = 0; he < 16; he++)
                Oe[he] = Be[he];
            for (he = 250; he >= 0; he--)
                Te(Oe, Oe),
                he !== 1 && Re(Oe, Oe, Be);
            for (he = 0; he < 16; he++)
                ye[he] = Oe[he]
        }
        function Me(ye, Be, Oe) {
            var he = new Uint8Array(32), Pe = new Float64Array(80), rt, Ze, tt = E(), Et = E(), Tt = E(), kt = E(), Qt = E(), Vt = E();
            for (Ze = 0; Ze < 31; Ze++)
                he[Ze] = Be[Ze];
            for (he[31] = Be[31] & 127 | 64,
            he[0] &= 248,
            te(Pe, Oe),
            Ze = 0; Ze < 16; Ze++)
                Et[Ze] = Pe[Ze],
                kt[Ze] = tt[Ze] = Tt[Ze] = 0;
            for (tt[0] = kt[0] = 1,
            Ze = 254; Ze >= 0; --Ze)
                rt = he[Ze >>> 3] >>> (Ze & 7) & 1,
                Y(tt, Et, rt),
                Y(Tt, kt, rt),
                ce(Qt, tt, Tt),
                Ee(tt, tt, Tt),
                ce(Tt, Et, kt),
                Ee(Et, Et, kt),
                Te(kt, Qt),
                Te(Vt, tt),
                Re(tt, Tt, tt),
                Re(Tt, Et, Qt),
                ce(Qt, tt, Tt),
                Ee(tt, tt, Tt),
                Te(Et, tt),
                Ee(Tt, kt, Vt),
                Re(tt, Tt, F),
                ce(tt, tt, kt),
                Re(Tt, Tt, tt),
                Re(tt, kt, Vt),
                Re(kt, Et, Pe),
                Te(Et, Qt),
                Y(tt, Et, rt),
                Y(Tt, kt, rt);
            for (Ze = 0; Ze < 16; Ze++)
                Pe[Ze + 16] = tt[Ze],
                Pe[Ze + 32] = Tt[Ze],
                Pe[Ze + 48] = Et[Ze],
                Pe[Ze + 64] = kt[Ze];
            var Ve = Pe.subarray(32)
              , me = Pe.subarray(16);
            return xe(Ve, Ve),
            Re(me, me, Ve),
            j(ye, me),
            0
        }
        function Fe(ye, Be) {
            return Me(ye, Be, $)
        }
        function be(ye, Be) {
            return M(Be, 32),
            Fe(ye, Be)
        }
        function Ce(ye, Be, Oe) {
            var he = new Uint8Array(32);
            return Me(he, Oe, Be),
            pe(ye, T, he, ge)
        }
        var ze = I
          , Ge = L;
        function nt(ye, Be, Oe, he, Pe, rt) {
            var Ze = new Uint8Array(32);
            return Ce(Ze, Pe, rt),
            ze(ye, Be, Oe, he, Ze)
        }
        function bt(ye, Be, Oe, he, Pe, rt) {
            var Ze = new Uint8Array(32);
            return Ce(Ze, Pe, rt),
            Ge(ye, Be, Oe, he, Ze)
        }
        var ct = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function De(ye, Be, Oe, he) {
            for (var Pe = new Int32Array(16), rt = new Int32Array(16), Ze, tt, Et, Tt, kt, Qt, Vt, Ve, me, ke, Le, Qe, Ke, vt, dt, It, xt, Dt, qt, zt, mt, wt, Ut, Ft, Lt, Ht, Xt = ye[0], Jt = ye[1], tr = ye[2], er = ye[3], et = ye[4], nr = ye[5], ar = ye[6], sr = ye[7], rr = Be[0], ir = Be[1], or = Be[2], dr = Be[3], lr = Be[4], cr = Be[5], ur = Be[6], fr = Be[7], hr = 0; he >= 128; ) {
                for (qt = 0; qt < 16; qt++)
                    zt = 8 * qt + hr,
                    Pe[qt] = Oe[zt + 0] << 24 | Oe[zt + 1] << 16 | Oe[zt + 2] << 8 | Oe[zt + 3],
                    rt[qt] = Oe[zt + 4] << 24 | Oe[zt + 5] << 16 | Oe[zt + 6] << 8 | Oe[zt + 7];
                for (qt = 0; qt < 80; qt++)
                    if (Ze = Xt,
                    tt = Jt,
                    Et = tr,
                    Tt = er,
                    kt = et,
                    Qt = nr,
                    Vt = ar,
                    Ve = sr,
                    me = rr,
                    ke = ir,
                    Le = or,
                    Qe = dr,
                    Ke = lr,
                    vt = cr,
                    dt = ur,
                    It = fr,
                    mt = sr,
                    wt = fr,
                    Ut = wt & 65535,
                    Ft = wt >>> 16,
                    Lt = mt & 65535,
                    Ht = mt >>> 16,
                    mt = (et >>> 14 | lr << 18) ^ (et >>> 18 | lr << 14) ^ (lr >>> 9 | et << 23),
                    wt = (lr >>> 14 | et << 18) ^ (lr >>> 18 | et << 14) ^ (et >>> 9 | lr << 23),
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    mt = et & nr ^ ~et & ar,
                    wt = lr & cr ^ ~lr & ur,
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    mt = ct[qt * 2],
                    wt = ct[qt * 2 + 1],
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    mt = Pe[qt % 16],
                    wt = rt[qt % 16],
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    Ft += Ut >>> 16,
                    Lt += Ft >>> 16,
                    Ht += Lt >>> 16,
                    xt = Lt & 65535 | Ht << 16,
                    Dt = Ut & 65535 | Ft << 16,
                    mt = xt,
                    wt = Dt,
                    Ut = wt & 65535,
                    Ft = wt >>> 16,
                    Lt = mt & 65535,
                    Ht = mt >>> 16,
                    mt = (Xt >>> 28 | rr << 4) ^ (rr >>> 2 | Xt << 30) ^ (rr >>> 7 | Xt << 25),
                    wt = (rr >>> 28 | Xt << 4) ^ (Xt >>> 2 | rr << 30) ^ (Xt >>> 7 | rr << 25),
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    mt = Xt & Jt ^ Xt & tr ^ Jt & tr,
                    wt = rr & ir ^ rr & or ^ ir & or,
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    Ft += Ut >>> 16,
                    Lt += Ft >>> 16,
                    Ht += Lt >>> 16,
                    Ve = Lt & 65535 | Ht << 16,
                    It = Ut & 65535 | Ft << 16,
                    mt = Tt,
                    wt = Qe,
                    Ut = wt & 65535,
                    Ft = wt >>> 16,
                    Lt = mt & 65535,
                    Ht = mt >>> 16,
                    mt = xt,
                    wt = Dt,
                    Ut += wt & 65535,
                    Ft += wt >>> 16,
                    Lt += mt & 65535,
                    Ht += mt >>> 16,
                    Ft += Ut >>> 16,
                    Lt += Ft >>> 16,
                    Ht += Lt >>> 16,
                    Tt = Lt & 65535 | Ht << 16,
                    Qe = Ut & 65535 | Ft << 16,
                    Jt = Ze,
                    tr = tt,
                    er = Et,
                    et = Tt,
                    nr = kt,
                    ar = Qt,
                    sr = Vt,
                    Xt = Ve,
                    ir = me,
                    or = ke,
                    dr = Le,
                    lr = Qe,
                    cr = Ke,
                    ur = vt,
                    fr = dt,
                    rr = It,
                    qt % 16 === 15)
                        for (zt = 0; zt < 16; zt++)
                            mt = Pe[zt],
                            wt = rt[zt],
                            Ut = wt & 65535,
                            Ft = wt >>> 16,
                            Lt = mt & 65535,
                            Ht = mt >>> 16,
                            mt = Pe[(zt + 9) % 16],
                            wt = rt[(zt + 9) % 16],
                            Ut += wt & 65535,
                            Ft += wt >>> 16,
                            Lt += mt & 65535,
                            Ht += mt >>> 16,
                            xt = Pe[(zt + 1) % 16],
                            Dt = rt[(zt + 1) % 16],
                            mt = (xt >>> 1 | Dt << 31) ^ (xt >>> 8 | Dt << 24) ^ xt >>> 7,
                            wt = (Dt >>> 1 | xt << 31) ^ (Dt >>> 8 | xt << 24) ^ (Dt >>> 7 | xt << 25),
                            Ut += wt & 65535,
                            Ft += wt >>> 16,
                            Lt += mt & 65535,
                            Ht += mt >>> 16,
                            xt = Pe[(zt + 14) % 16],
                            Dt = rt[(zt + 14) % 16],
                            mt = (xt >>> 19 | Dt << 13) ^ (Dt >>> 29 | xt << 3) ^ xt >>> 6,
                            wt = (Dt >>> 19 | xt << 13) ^ (xt >>> 29 | Dt << 3) ^ (Dt >>> 6 | xt << 26),
                            Ut += wt & 65535,
                            Ft += wt >>> 16,
                            Lt += mt & 65535,
                            Ht += mt >>> 16,
                            Ft += Ut >>> 16,
                            Lt += Ft >>> 16,
                            Ht += Lt >>> 16,
                            Pe[zt] = Lt & 65535 | Ht << 16,
                            rt[zt] = Ut & 65535 | Ft << 16;
                mt = Xt,
                wt = rr,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[0],
                wt = Be[0],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[0] = Xt = Lt & 65535 | Ht << 16,
                Be[0] = rr = Ut & 65535 | Ft << 16,
                mt = Jt,
                wt = ir,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[1],
                wt = Be[1],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[1] = Jt = Lt & 65535 | Ht << 16,
                Be[1] = ir = Ut & 65535 | Ft << 16,
                mt = tr,
                wt = or,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[2],
                wt = Be[2],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[2] = tr = Lt & 65535 | Ht << 16,
                Be[2] = or = Ut & 65535 | Ft << 16,
                mt = er,
                wt = dr,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[3],
                wt = Be[3],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[3] = er = Lt & 65535 | Ht << 16,
                Be[3] = dr = Ut & 65535 | Ft << 16,
                mt = et,
                wt = lr,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[4],
                wt = Be[4],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[4] = et = Lt & 65535 | Ht << 16,
                Be[4] = lr = Ut & 65535 | Ft << 16,
                mt = nr,
                wt = cr,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[5],
                wt = Be[5],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[5] = nr = Lt & 65535 | Ht << 16,
                Be[5] = cr = Ut & 65535 | Ft << 16,
                mt = ar,
                wt = ur,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[6],
                wt = Be[6],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[6] = ar = Lt & 65535 | Ht << 16,
                Be[6] = ur = Ut & 65535 | Ft << 16,
                mt = sr,
                wt = fr,
                Ut = wt & 65535,
                Ft = wt >>> 16,
                Lt = mt & 65535,
                Ht = mt >>> 16,
                mt = ye[7],
                wt = Be[7],
                Ut += wt & 65535,
                Ft += wt >>> 16,
                Lt += mt & 65535,
                Ht += mt >>> 16,
                Ft += Ut >>> 16,
                Lt += Ft >>> 16,
                Ht += Lt >>> 16,
                ye[7] = sr = Lt & 65535 | Ht << 16,
                Be[7] = fr = Ut & 65535 | Ft << 16,
                hr += 128,
                he -= 128
            }
            return he
        }
        function Ue(ye, Be, Oe) {
            var he = new Int32Array(8), Pe = new Int32Array(8), rt = new Uint8Array(256), Ze, tt = Oe;
            for (he[0] = 1779033703,
            he[1] = 3144134277,
            he[2] = 1013904242,
            he[3] = 2773480762,
            he[4] = 1359893119,
            he[5] = 2600822924,
            he[6] = 528734635,
            he[7] = 1541459225,
            Pe[0] = 4089235720,
            Pe[1] = 2227873595,
            Pe[2] = 4271175723,
            Pe[3] = 1595750129,
            Pe[4] = 2917565137,
            Pe[5] = 725511199,
            Pe[6] = 4215389547,
            Pe[7] = 327033209,
            De(he, Pe, Be, Oe),
            Oe %= 128,
            Ze = 0; Ze < Oe; Ze++)
                rt[Ze] = Be[tt - Oe + Ze];
            for (rt[Oe] = 128,
            Oe = 256 - 128 * (Oe < 112 ? 1 : 0),
            rt[Oe - 9] = 0,
            ie(rt, Oe - 8, tt / 536870912 | 0, tt << 3),
            De(he, Pe, rt, Oe),
            Ze = 0; Ze < 8; Ze++)
                ie(ye, 8 * Ze, he[Ze], Pe[Ze]);
            return 0
        }
        function We(ye, Be) {
            var Oe = E()
              , he = E()
              , Pe = E()
              , rt = E()
              , Ze = E()
              , tt = E()
              , Et = E()
              , Tt = E()
              , kt = E();
            Ee(Oe, ye[1], ye[0]),
            Ee(kt, Be[1], Be[0]),
            Re(Oe, Oe, kt),
            ce(he, ye[0], ye[1]),
            ce(kt, Be[0], Be[1]),
            Re(he, he, kt),
            Re(Pe, ye[3], Be[3]),
            Re(Pe, Pe, U),
            Re(rt, ye[2], Be[2]),
            ce(rt, rt, rt),
            Ee(Ze, he, Oe),
            Ee(tt, rt, Pe),
            ce(Et, rt, Pe),
            ce(Tt, he, Oe),
            Re(ye[0], Ze, tt),
            Re(ye[1], Tt, Et),
            Re(ye[2], Et, tt),
            Re(ye[3], Ze, Tt)
        }
        function Xe(ye, Be, Oe) {
            var he;
            for (he = 0; he < 4; he++)
                Y(ye[he], Be[he], Oe)
        }
        function ht(ye, Be) {
            var Oe = E()
              , he = E()
              , Pe = E();
            xe(Pe, Be[2]),
            Re(Oe, Be[0], Pe),
            Re(he, Be[1], Pe),
            j(ye, he),
            ye[31] ^= ne(Oe) << 7
        }
        function Je(ye, Be, Oe) {
            var he, Pe;
            for (K(ye[0], B),
            K(ye[1], O),
            K(ye[2], O),
            K(ye[3], B),
            Pe = 255; Pe >= 0; --Pe)
                he = Oe[Pe / 8 | 0] >> (Pe & 7) & 1,
                Xe(ye, Be, he),
                We(Be, ye),
                We(ye, ye),
                Xe(ye, Be, he)
        }
        function ot(ye, Be) {
            var Oe = [E(), E(), E(), E()];
            K(Oe[0], H),
            K(Oe[1], Z),
            K(Oe[2], O),
            Re(Oe[3], H, Z),
            Je(ye, Oe, Be)
        }
        function je(ye, Be, Oe) {
            var he = new Uint8Array(64), Pe = [E(), E(), E(), E()], rt;
            for (Oe || M(Be, 32),
            Ue(he, Be, 32),
            he[0] &= 248,
            he[31] &= 127,
            he[31] |= 64,
            ot(Pe, he),
            ht(ye, Pe),
            rt = 0; rt < 32; rt++)
                Be[rt + 32] = ye[rt];
            return 0
        }
        var $e = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function Ie(ye, Be) {
            var Oe, he, Pe, rt;
            for (he = 63; he >= 32; --he) {
                for (Oe = 0,
                Pe = he - 32,
                rt = he - 12; Pe < rt; ++Pe)
                    Be[Pe] += Oe - 16 * Be[he] * $e[Pe - (he - 32)],
                    Oe = Math.floor((Be[Pe] + 128) / 256),
                    Be[Pe] -= Oe * 256;
                Be[Pe] += Oe,
                Be[he] = 0
            }
            for (Oe = 0,
            Pe = 0; Pe < 32; Pe++)
                Be[Pe] += Oe - (Be[31] >> 4) * $e[Pe],
                Oe = Be[Pe] >> 8,
                Be[Pe] &= 255;
            for (Pe = 0; Pe < 32; Pe++)
                Be[Pe] -= Oe * $e[Pe];
            for (he = 0; he < 32; he++)
                Be[he + 1] += Be[he] >> 8,
                ye[he] = Be[he] & 255
        }
        function He(ye) {
            var Be = new Float64Array(64), Oe;
            for (Oe = 0; Oe < 64; Oe++)
                Be[Oe] = ye[Oe];
            for (Oe = 0; Oe < 64; Oe++)
                ye[Oe] = 0;
            Ie(ye, Be)
        }
        function qe(ye, Be, Oe, he) {
            var Pe = new Uint8Array(64), rt = new Uint8Array(64), Ze = new Uint8Array(64), tt, Et, Tt = new Float64Array(64), kt = [E(), E(), E(), E()];
            Ue(Pe, he, 32),
            Pe[0] &= 248,
            Pe[31] &= 127,
            Pe[31] |= 64;
            var Qt = Oe + 64;
            for (tt = 0; tt < Oe; tt++)
                ye[64 + tt] = Be[tt];
            for (tt = 0; tt < 32; tt++)
                ye[32 + tt] = Pe[32 + tt];
            for (Ue(Ze, ye.subarray(32), Oe + 32),
            He(Ze),
            ot(kt, Ze),
            ht(ye, kt),
            tt = 32; tt < 64; tt++)
                ye[tt] = he[tt];
            for (Ue(rt, ye, Oe + 64),
            He(rt),
            tt = 0; tt < 64; tt++)
                Tt[tt] = 0;
            for (tt = 0; tt < 32; tt++)
                Tt[tt] = Ze[tt];
            for (tt = 0; tt < 32; tt++)
                for (Et = 0; Et < 32; Et++)
                    Tt[tt + Et] += rt[tt] * Pe[Et];
            return Ie(ye.subarray(32), Tt),
            Qt
        }
        function Ne(ye, Be) {
            var Oe = E()
              , he = E()
              , Pe = E()
              , rt = E()
              , Ze = E()
              , tt = E()
              , Et = E();
            return K(ye[2], O),
            te(ye[1], Be),
            Te(Pe, ye[1]),
            Re(rt, Pe, N),
            Ee(Pe, Pe, ye[2]),
            ce(rt, ye[2], rt),
            Te(Ze, rt),
            Te(tt, Ze),
            Re(Et, tt, Ze),
            Re(Oe, Et, Pe),
            Re(Oe, Oe, rt),
            ve(Oe, Oe),
            Re(Oe, Oe, Pe),
            Re(Oe, Oe, rt),
            Re(Oe, Oe, rt),
            Re(ye[0], Oe, rt),
            Te(he, ye[0]),
            Re(he, he, rt),
            G(he, Pe) && Re(ye[0], ye[0], J),
            Te(he, ye[0]),
            Re(he, he, rt),
            G(he, Pe) ? -1 : (ne(ye[0]) === Be[31] >> 7 && Ee(ye[0], B, ye[0]),
            Re(ye[3], ye[0], ye[1]),
            0)
        }
        function at(ye, Be, Oe, he) {
            var Pe, rt = new Uint8Array(32), Ze = new Uint8Array(64), tt = [E(), E(), E(), E()], Et = [E(), E(), E(), E()];
            if (Oe < 64 || Ne(Et, he))
                return -1;
            for (Pe = 0; Pe < Oe; Pe++)
                ye[Pe] = Be[Pe];
            for (Pe = 0; Pe < 32; Pe++)
                ye[Pe + 32] = he[Pe];
            if (Ue(Ze, ye, Oe),
            He(Ze),
            Je(tt, Et, Ze),
            ot(Et, Be.subarray(32)),
            We(tt, Et),
            ht(rt, tt),
            Oe -= 64,
            se(Be, 0, rt, 0)) {
                for (Pe = 0; Pe < Oe; Pe++)
                    ye[Pe] = 0;
                return -1
            }
            for (Pe = 0; Pe < Oe; Pe++)
                ye[Pe] = Be[Pe + 64];
            return Oe
        }
        var Ye = 32
          , it = 24
          , At = 32
          , pt = 16
          , ut = 32
          , Rt = 32
          , yt = 32
          , st = 32
          , Wt = 32
          , Ct = it
          , Mt = At
          , Kt = pt
          , Pt = 64
          , St = 32
          , Zt = 64
          , Nt = 32
          , $t = 64;
        S.lowlevel = {
            crypto_core_hsalsa20: pe,
            crypto_stream_xor: ue,
            crypto_stream: Se,
            crypto_stream_salsa20_xor: we,
            crypto_stream_salsa20: Ae,
            crypto_onetimeauth: W,
            crypto_onetimeauth_verify: D,
            crypto_verify_16: ae,
            crypto_verify_32: se,
            crypto_secretbox: I,
            crypto_secretbox_open: L,
            crypto_scalarmult: Me,
            crypto_scalarmult_base: Fe,
            crypto_box_beforenm: Ce,
            crypto_box_afternm: ze,
            crypto_box: nt,
            crypto_box_open: bt,
            crypto_box_keypair: be,
            crypto_hash: Ue,
            crypto_sign: qe,
            crypto_sign_keypair: je,
            crypto_sign_open: at,
            crypto_secretbox_KEYBYTES: Ye,
            crypto_secretbox_NONCEBYTES: it,
            crypto_secretbox_ZEROBYTES: At,
            crypto_secretbox_BOXZEROBYTES: pt,
            crypto_scalarmult_BYTES: ut,
            crypto_scalarmult_SCALARBYTES: Rt,
            crypto_box_PUBLICKEYBYTES: yt,
            crypto_box_SECRETKEYBYTES: st,
            crypto_box_BEFORENMBYTES: Wt,
            crypto_box_NONCEBYTES: Ct,
            crypto_box_ZEROBYTES: Mt,
            crypto_box_BOXZEROBYTES: Kt,
            crypto_sign_BYTES: Pt,
            crypto_sign_PUBLICKEYBYTES: St,
            crypto_sign_SECRETKEYBYTES: Zt,
            crypto_sign_SEEDBYTES: Nt,
            crypto_hash_BYTES: $t,
            gf: E,
            D: N,
            L: $e,
            pack25519: j,
            unpack25519: te,
            M: Re,
            A: ce,
            S: Te,
            Z: Ee,
            pow2523: ve,
            add: We,
            set25519: K,
            modL: Ie,
            scalarmult: Je,
            scalarbase: ot
        };
        function Gt(ye, Be) {
            if (ye.length !== Ye)
                throw new Error("bad key size");
            if (Be.length !== it)
                throw new Error("bad nonce size")
        }
        function Ot(ye, Be) {
            if (ye.length !== yt)
                throw new Error("bad public key size");
            if (Be.length !== st)
                throw new Error("bad secret key size")
        }
        function Bt() {
            for (var ye = 0; ye < arguments.length; ye++)
                if (!(arguments[ye]instanceof Uint8Array))
                    throw new TypeError("unexpected type, use Uint8Array")
        }
        function Yt(ye) {
            for (var Be = 0; Be < ye.length; Be++)
                ye[Be] = 0
        }
        S.randomBytes = function(ye) {
            var Be = new Uint8Array(ye);
            return M(Be, ye),
            Be
        }
        ,
        S.secretbox = function(ye, Be, Oe) {
            Bt(ye, Be, Oe),
            Gt(Oe, Be);
            for (var he = new Uint8Array(At + ye.length), Pe = new Uint8Array(he.length), rt = 0; rt < ye.length; rt++)
                he[rt + At] = ye[rt];
            return I(Pe, he, he.length, Be, Oe),
            Pe.subarray(pt)
        }
        ,
        S.secretbox.open = function(ye, Be, Oe) {
            Bt(ye, Be, Oe),
            Gt(Oe, Be);
            for (var he = new Uint8Array(pt + ye.length), Pe = new Uint8Array(he.length), rt = 0; rt < ye.length; rt++)
                he[rt + pt] = ye[rt];
            return he.length < 32 || L(Pe, he, he.length, Be, Oe) !== 0 ? null : Pe.subarray(At)
        }
        ,
        S.secretbox.keyLength = Ye,
        S.secretbox.nonceLength = it,
        S.secretbox.overheadLength = pt,
        S.scalarMult = function(ye, Be) {
            if (Bt(ye, Be),
            ye.length !== Rt)
                throw new Error("bad n size");
            if (Be.length !== ut)
                throw new Error("bad p size");
            var Oe = new Uint8Array(ut);
            return Me(Oe, ye, Be),
            Oe
        }
        ,
        S.scalarMult.base = function(ye) {
            if (Bt(ye),
            ye.length !== Rt)
                throw new Error("bad n size");
            var Be = new Uint8Array(ut);
            return Fe(Be, ye),
            Be
        }
        ,
        S.scalarMult.scalarLength = Rt,
        S.scalarMult.groupElementLength = ut,
        S.box = function(ye, Be, Oe, he) {
            var Pe = S.box.before(Oe, he);
            return S.secretbox(ye, Be, Pe)
        }
        ,
        S.box.before = function(ye, Be) {
            Bt(ye, Be),
            Ot(ye, Be);
            var Oe = new Uint8Array(Wt);
            return Ce(Oe, ye, Be),
            Oe
        }
        ,
        S.box.after = S.secretbox,
        S.box.open = function(ye, Be, Oe, he) {
            var Pe = S.box.before(Oe, he);
            return S.secretbox.open(ye, Be, Pe)
        }
        ,
        S.box.open.after = S.secretbox.open,
        S.box.keyPair = function() {
            var ye = new Uint8Array(yt)
              , Be = new Uint8Array(st);
            return be(ye, Be),
            {
                publicKey: ye,
                secretKey: Be
            }
        }
        ,
        S.box.keyPair.fromSecretKey = function(ye) {
            if (Bt(ye),
            ye.length !== st)
                throw new Error("bad secret key size");
            var Be = new Uint8Array(yt);
            return Fe(Be, ye),
            {
                publicKey: Be,
                secretKey: new Uint8Array(ye)
            }
        }
        ,
        S.box.publicKeyLength = yt,
        S.box.secretKeyLength = st,
        S.box.sharedKeyLength = Wt,
        S.box.nonceLength = Ct,
        S.box.overheadLength = S.secretbox.overheadLength,
        S.sign = function(ye, Be) {
            if (Bt(ye, Be),
            Be.length !== Zt)
                throw new Error("bad secret key size");
            var Oe = new Uint8Array(Pt + ye.length);
            return qe(Oe, ye, ye.length, Be),
            Oe
        }
        ,
        S.sign.open = function(ye, Be) {
            if (Bt(ye, Be),
            Be.length !== St)
                throw new Error("bad public key size");
            var Oe = new Uint8Array(ye.length)
              , he = at(Oe, ye, ye.length, Be);
            if (he < 0)
                return null;
            for (var Pe = new Uint8Array(he), rt = 0; rt < Pe.length; rt++)
                Pe[rt] = Oe[rt];
            return Pe
        }
        ,
        S.sign.detached = function(ye, Be) {
            for (var Oe = S.sign(ye, Be), he = new Uint8Array(Pt), Pe = 0; Pe < he.length; Pe++)
                he[Pe] = Oe[Pe];
            return he
        }
        ,
        S.sign.detached.verify = function(ye, Be, Oe) {
            if (Bt(ye, Be, Oe),
            Be.length !== Pt)
                throw new Error("bad signature size");
            if (Oe.length !== St)
                throw new Error("bad public key size");
            var he = new Uint8Array(Pt + ye.length), Pe = new Uint8Array(Pt + ye.length), rt;
            for (rt = 0; rt < Pt; rt++)
                he[rt] = Be[rt];
            for (rt = 0; rt < ye.length; rt++)
                he[rt + Pt] = ye[rt];
            return at(Pe, he, he.length, Oe) >= 0
        }
        ,
        S.sign.keyPair = function() {
            var ye = new Uint8Array(St)
              , Be = new Uint8Array(Zt);
            return je(ye, Be),
            {
                publicKey: ye,
                secretKey: Be
            }
        }
        ,
        S.sign.keyPair.fromSecretKey = function(ye) {
            if (Bt(ye),
            ye.length !== Zt)
                throw new Error("bad secret key size");
            for (var Be = new Uint8Array(St), Oe = 0; Oe < Be.length; Oe++)
                Be[Oe] = ye[32 + Oe];
            return {
                publicKey: Be,
                secretKey: new Uint8Array(ye)
            }
        }
        ,
        S.sign.keyPair.fromSeed = function(ye) {
            if (Bt(ye),
            ye.length !== Nt)
                throw new Error("bad seed size");
            for (var Be = new Uint8Array(St), Oe = new Uint8Array(Zt), he = 0; he < 32; he++)
                Oe[he] = ye[he];
            return je(Be, Oe, !0),
            {
                publicKey: Be,
                secretKey: Oe
            }
        }
        ,
        S.sign.publicKeyLength = St,
        S.sign.secretKeyLength = Zt,
        S.sign.seedLength = Nt,
        S.sign.signatureLength = Pt,
        S.hash = function(ye) {
            Bt(ye);
            var Be = new Uint8Array($t);
            return Ue(Be, ye, ye.length),
            Be
        }
        ,
        S.hash.hashLength = $t,
        S.verify = function(ye, Be) {
            return Bt(ye, Be),
            ye.length === 0 || Be.length === 0 || ye.length !== Be.length ? !1 : oe(ye, 0, Be, 0, ye.length) === 0
        }
        ,
        S.setPRNG = function(ye) {
            M = ye
        }
        ,
        function() {
            var ye = typeof self < "u" ? self.crypto || self.msCrypto : null;
            if (ye && ye.getRandomValues) {
                var Be = 65536;
                S.setPRNG(function(Oe, he) {
                    var Pe, rt = new Uint8Array(he);
                    for (Pe = 0; Pe < he; Pe += Be)
                        ye.getRandomValues(rt.subarray(Pe, Pe + Math.min(he - Pe, Be)));
                    for (Pe = 0; Pe < he; Pe++)
                        Oe[Pe] = rt[Pe];
                    Yt(rt)
                })
            } else
                typeof commonjsRequire < "u" && (ye = requireCryptoBrowserify(),
                ye && ye.randomBytes && S.setPRNG(function(Oe, he) {
                    var Pe, rt = ye.randomBytes(he);
                    for (Pe = 0; Pe < he; Pe++)
                        Oe[Pe] = rt[Pe];
                    Yt(rt)
                }))
        }()
    }
    )(C.exports ? C.exports : self.nacl = self.nacl || {})
}
)(naclFast);
var naclFastExports = naclFast.exports;
const nacl$1$1 = getDefaultExportFromCjs$1(naclFastExports);
var binary = {};
Object.defineProperty(binary, "__esModule", {
    value: !0
});
binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
function lpad(C, S, E) {
    for (; C.length < E; )
        C = S + C;
    return C
}
binary.lpad = lpad;
function bytesToBits(C) {
    let S = "";
    for (let E = 0; E < C.length; E++) {
        let M = C.at(E);
        S += lpad(M.toString(2), "0", 8)
    }
    return S
}
binary.bytesToBits = bytesToBits;
function bitsToBytes(C) {
    if (C.length % 8 !== 0)
        throw Error("Uneven bits");
    let S = [];
    for (; C.length > 0; )
        S.push(parseInt(C.slice(0, 8), 2)),
        C = C.slice(8);
    return Buffer.from(S)
}
binary.bitsToBytes = bitsToBytes;
var wordlist = {};
Object.defineProperty(wordlist, "__esModule", {
    value: !0
});
wordlist.wordlist = void 0;
const EN = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
wordlist.wordlist = EN;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(mnemonic, "__esModule", {
    value: !0
});
mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
const tweetnacl_1$1 = __importDefault$4(naclFastExports)
  , getSecureRandom_1 = getSecureRandom
  , hmac_sha512_1$3 = hmac_sha512$1
  , pbkdf2_sha512_1 = pbkdf2_sha512$1
  , binary_1 = binary
  , wordlist_1 = wordlist
  , PBKDF_ITERATIONS = 1e5;
async function isPasswordNeeded(C) {
    const S = await mnemonicToEntropy(C);
    return await isPasswordSeed(S) && !await isBasicSeed(S)
}
function normalizeMnemonic(C) {
    return C.map(S=>S.toLowerCase().trim())
}
async function isBasicSeed(C) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(C, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64))[0] == 0
}
async function isPasswordSeed(C) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(C, "TON fast seed version", 1, 64))[0] == 1
}
async function mnemonicToEntropy(C, S) {
    return await (0,
    hmac_sha512_1$3.hmac_sha512)(C.join(" "), S && S.length > 0 ? S : "")
}
mnemonic.mnemonicToEntropy = mnemonicToEntropy;
async function mnemonicToSeed(C, S, E) {
    const M = await mnemonicToEntropy(C, E);
    return await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(M, S, PBKDF_ITERATIONS, 64)
}
mnemonic.mnemonicToSeed = mnemonicToSeed;
async function mnemonicToPrivateKey(C, S) {
    C = normalizeMnemonic(C);
    const E = await mnemonicToSeed(C, "TON default seed", S);
    let M = tweetnacl_1$1.default.sign.keyPair.fromSeed(E.slice(0, 32));
    return {
        publicKey: Buffer.from(M.publicKey),
        secretKey: Buffer.from(M.secretKey)
    }
}
mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
async function mnemonicToWalletKey(C, S) {
    let M = (await mnemonicToPrivateKey(C, S)).secretKey.slice(0, 32);
    const T = tweetnacl_1$1.default.sign.keyPair.fromSeed(M);
    return {
        publicKey: Buffer.from(T.publicKey),
        secretKey: Buffer.from(T.secretKey)
    }
}
mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
async function mnemonicToHDSeed(C, S) {
    return C = normalizeMnemonic(C),
    await mnemonicToSeed(C, "TON HD Keys seed", S)
}
mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
async function mnemonicValidate(C, S) {
    C = normalizeMnemonic(C);
    for (let E of C)
        if (wordlist_1.wordlist.indexOf(E) < 0)
            return !1;
    return S && S.length > 0 && !await isPasswordNeeded(C) ? !1 : await isBasicSeed(await mnemonicToEntropy(C, S))
}
mnemonic.mnemonicValidate = mnemonicValidate;
async function mnemonicNew(C=24, S) {
    let E = [];
    for (; ; ) {
        E = [];
        for (let M = 0; M < C; M++) {
            let T = await (0,
            getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
            E.push(wordlist_1.wordlist[T])
        }
        if (!(S && S.length > 0 && !await isPasswordNeeded(E)) && await isBasicSeed(await mnemonicToEntropy(E, S)))
            break
    }
    return E
}
mnemonic.mnemonicNew = mnemonicNew;
function bytesToMnemonicIndexes(C, S) {
    let E = (0,
    binary_1.bytesToBits)(C)
      , M = [];
    for (let T = 0; T < S; T++) {
        let $ = E.slice(T * 11, T * 11 + 11);
        M.push(parseInt($, 2))
    }
    return M
}
mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
function bytesToMnemonics(C, S) {
    let E = bytesToMnemonicIndexes(C, S)
      , M = [];
    for (let T of E)
        M.push(wordlist_1.wordlist[T]);
    return M
}
mnemonic.bytesToMnemonics = bytesToMnemonics;
function mnemonicIndexesToBytes(C) {
    let S = "";
    for (let E of C) {
        if (!Number.isSafeInteger(E) || E < 0 || E >= 2028)
            throw Error("Invalid input");
        S += (0,
        binary_1.lpad)(E.toString(2), "0", 11)
    }
    for (; S.length % 8 !== 0; )
        S = S + "0";
    return (0,
    binary_1.bitsToBytes)(S)
}
mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
async function mnemonicFromRandomSeed(C, S=24, E) {
    const M = Math.ceil(S * 11 / 8);
    let T = C;
    for (; ; ) {
        let $ = await (0,
        pbkdf2_sha512_1.pbkdf2_sha512)(T, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), M)
          , B = bytesToMnemonics($, S);
        if (await mnemonicValidate(B, E))
            return B;
        T = $
    }
}
mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
var nacl$6 = {}
  , __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(nacl$6, "__esModule", {
    value: !0
});
nacl$6.openBox = nacl$6.sealBox = nacl$6.signVerify = nacl$6.sign = nacl$6.keyPairFromSeed = nacl$6.keyPairFromSecretKey = void 0;
const tweetnacl_1 = __importDefault$3(naclFastExports);
function keyPairFromSecretKey(C) {
    let S = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(C));
    return {
        publicKey: Buffer.from(S.publicKey),
        secretKey: Buffer.from(S.secretKey)
    }
}
nacl$6.keyPairFromSecretKey = keyPairFromSecretKey;
function keyPairFromSeed$2(C) {
    let S = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(C));
    return {
        publicKey: Buffer.from(S.publicKey),
        secretKey: Buffer.from(S.secretKey)
    }
}
nacl$6.keyPairFromSeed = keyPairFromSeed$2;
function sign(C, S) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(C), new Uint8Array(S)))
}
nacl$6.sign = sign;
function signVerify(C, S, E) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(C), new Uint8Array(S), new Uint8Array(E))
}
nacl$6.signVerify = signVerify;
function sealBox(C, S, E) {
    return Buffer.from(tweetnacl_1.default.secretbox(C, S, E))
}
nacl$6.sealBox = sealBox;
function openBox(C, S, E) {
    let M = tweetnacl_1.default.secretbox.open(C, S, E);
    return M ? Buffer.from(M) : null
}
nacl$6.openBox = openBox;
var ed25519 = {};
Object.defineProperty(ed25519, "__esModule", {
    value: !0
});
ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
const hmac_sha512_1$2 = hmac_sha512$1
  , ED25519_CURVE = "ed25519 seed"
  , HARDENED_OFFSET$1 = 2147483648;
async function getED25519MasterKeyFromSeed(C) {
    const S = await (0,
    hmac_sha512_1$2.hmac_sha512)(ED25519_CURVE, C)
      , E = S.slice(0, 32)
      , M = S.slice(32);
    return {
        key: E,
        chainCode: M
    }
}
ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
async function deriveED25519HardenedKey(C, S) {
    if (S >= HARDENED_OFFSET$1)
        throw Error("Key index must be less than offset");
    const E = Buffer.alloc(4);
    E.writeUInt32BE(S + HARDENED_OFFSET$1, 0);
    const M = Buffer.concat([Buffer.alloc(1, 0), C.key, E])
      , T = await (0,
    hmac_sha512_1$2.hmac_sha512)(C.chainCode, M)
      , $ = T.slice(0, 32)
      , B = T.slice(32);
    return {
        key: $,
        chainCode: B
    }
}
ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
async function deriveEd25519Path(C, S) {
    let E = await getED25519MasterKeyFromSeed(C)
      , M = [...S];
    for (; M.length > 0; ) {
        let T = M[0];
        M = M.slice(1),
        E = await deriveED25519HardenedKey(E, T)
    }
    return E.key
}
ed25519.deriveEd25519Path = deriveEd25519Path;
var symmetric = {};
Object.defineProperty(symmetric, "__esModule", {
    value: !0
});
symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
const hmac_sha512_1$1 = hmac_sha512$1
  , SYMMETRIC_SEED = "Symmetric key seed";
async function getSymmetricMasterKeyFromSeed(C) {
    const S = await (0,
    hmac_sha512_1$1.hmac_sha512)(SYMMETRIC_SEED, C)
      , E = S.slice(32)
      , M = S.slice(0, 32);
    return {
        key: E,
        chainCode: M
    }
}
symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
async function deriveSymmetricHardenedKey(C, S) {
    const E = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(S)])
      , M = await (0,
    hmac_sha512_1$1.hmac_sha512)(C.chainCode, E)
      , T = M.slice(32)
      , $ = M.slice(0, 32);
    return {
        key: T,
        chainCode: $
    }
}
symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
async function deriveSymmetricPath(C, S) {
    let E = await getSymmetricMasterKeyFromSeed(C)
      , M = [...S];
    for (; M.length > 0; ) {
        let T = M[0];
        M = M.slice(1),
        E = await deriveSymmetricHardenedKey(E, T)
    }
    return E.key
}
symmetric.deriveSymmetricPath = deriveSymmetricPath;
var mnemonics = {};
Object.defineProperty(mnemonics, "__esModule", {
    value: !0
});
mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
const mnemonic_1 = mnemonic
  , hmac_sha512_1 = hmac_sha512$1
  , HARDENED_OFFSET = 2147483648
  , MNEMONICS_SEED = "TON Mnemonics HD seed";
async function getMnemonicsMasterKeyFromSeed(C) {
    const S = await (0,
    hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, C)
      , E = S.slice(0, 32)
      , M = S.slice(32);
    return {
        key: E,
        chainCode: M
    }
}
mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
async function deriveMnemonicHardenedKey(C, S) {
    if (S >= HARDENED_OFFSET)
        throw Error("Key index must be less than offset");
    const E = Buffer.alloc(4);
    E.writeUInt32BE(S + HARDENED_OFFSET, 0);
    const M = Buffer.concat([Buffer.alloc(1, 0), C.key, E])
      , T = await (0,
    hmac_sha512_1.hmac_sha512)(C.chainCode, M)
      , $ = T.slice(0, 32)
      , B = T.slice(32);
    return {
        key: $,
        chainCode: B
    }
}
mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
async function deriveMnemonicsPath(C, S, E=24, M) {
    let T = await getMnemonicsMasterKeyFromSeed(C)
      , $ = [...S];
    for (; $.length > 0; ) {
        let B = $[0];
        $ = $.slice(1),
        T = await deriveMnemonicHardenedKey(T, B)
    }
    return await (0,
    mnemonic_1.mnemonicFromRandomSeed)(T.key, E, M)
}
mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
var hasRequiredDist;
function requireDist() {
    return hasRequiredDist || (hasRequiredDist = 1,
    function(C) {
        Object.defineProperty(C, "__esModule", {
            value: !0
        }),
        C.getMnemonicsMasterKeyFromSeed = C.deriveMnemonicHardenedKey = C.deriveMnemonicsPath = C.deriveSymmetricPath = C.deriveSymmetricHardenedKey = C.getSymmetricMasterKeyFromSeed = C.deriveEd25519Path = C.deriveED25519HardenedKey = C.getED25519MasterKeyFromSeed = C.signVerify = C.sign = C.keyPairFromSecretKey = C.keyPairFromSeed = C.openBox = C.sealBox = C.mnemonicWordList = C.mnemonicToHDSeed = C.mnemonicToSeed = C.mnemonicToWalletKey = C.mnemonicToPrivateKey = C.mnemonicValidate = C.mnemonicNew = C.newSecurePassphrase = C.newSecureWords = C.getSecureRandomNumber = C.getSecureRandomWords = C.getSecureRandomBytes = C.hmac_sha512 = C.pbkdf2_sha512 = C.sha512_sync = C.sha512 = C.sha256_sync = C.sha256 = void 0;
        var S = sha256$9;
        Object.defineProperty(C, "sha256", {
            enumerable: !0,
            get: function() {
                return S.sha256
            }
        }),
        Object.defineProperty(C, "sha256_sync", {
            enumerable: !0,
            get: function() {
                return S.sha256_sync
            }
        });
        var E = sha512$3;
        Object.defineProperty(C, "sha512", {
            enumerable: !0,
            get: function() {
                return E.sha512
            }
        }),
        Object.defineProperty(C, "sha512_sync", {
            enumerable: !0,
            get: function() {
                return E.sha512_sync
            }
        });
        var M = pbkdf2_sha512$1;
        Object.defineProperty(C, "pbkdf2_sha512", {
            enumerable: !0,
            get: function() {
                return M.pbkdf2_sha512
            }
        });
        var T = hmac_sha512$1;
        Object.defineProperty(C, "hmac_sha512", {
            enumerable: !0,
            get: function() {
                return T.hmac_sha512
            }
        });
        var $ = getSecureRandom;
        Object.defineProperty(C, "getSecureRandomBytes", {
            enumerable: !0,
            get: function() {
                return $.getSecureRandomBytes
            }
        }),
        Object.defineProperty(C, "getSecureRandomWords", {
            enumerable: !0,
            get: function() {
                return $.getSecureRandomWords
            }
        }),
        Object.defineProperty(C, "getSecureRandomNumber", {
            enumerable: !0,
            get: function() {
                return $.getSecureRandomNumber
            }
        });
        var B = newSecureWords$1;
        Object.defineProperty(C, "newSecureWords", {
            enumerable: !0,
            get: function() {
                return B.newSecureWords
            }
        });
        var O = requireNewSecurePassphrase();
        Object.defineProperty(C, "newSecurePassphrase", {
            enumerable: !0,
            get: function() {
                return O.newSecurePassphrase
            }
        });
        var F = mnemonic;
        Object.defineProperty(C, "mnemonicNew", {
            enumerable: !0,
            get: function() {
                return F.mnemonicNew
            }
        }),
        Object.defineProperty(C, "mnemonicValidate", {
            enumerable: !0,
            get: function() {
                return F.mnemonicValidate
            }
        }),
        Object.defineProperty(C, "mnemonicToPrivateKey", {
            enumerable: !0,
            get: function() {
                return F.mnemonicToPrivateKey
            }
        }),
        Object.defineProperty(C, "mnemonicToWalletKey", {
            enumerable: !0,
            get: function() {
                return F.mnemonicToWalletKey
            }
        }),
        Object.defineProperty(C, "mnemonicToSeed", {
            enumerable: !0,
            get: function() {
                return F.mnemonicToSeed
            }
        }),
        Object.defineProperty(C, "mnemonicToHDSeed", {
            enumerable: !0,
            get: function() {
                return F.mnemonicToHDSeed
            }
        });
        var N = wordlist;
        Object.defineProperty(C, "mnemonicWordList", {
            enumerable: !0,
            get: function() {
                return N.wordlist
            }
        });
        var U = nacl$6;
        Object.defineProperty(C, "sealBox", {
            enumerable: !0,
            get: function() {
                return U.sealBox
            }
        }),
        Object.defineProperty(C, "openBox", {
            enumerable: !0,
            get: function() {
                return U.openBox
            }
        });
        var H = nacl$6;
        Object.defineProperty(C, "keyPairFromSeed", {
            enumerable: !0,
            get: function() {
                return H.keyPairFromSeed
            }
        }),
        Object.defineProperty(C, "keyPairFromSecretKey", {
            enumerable: !0,
            get: function() {
                return H.keyPairFromSecretKey
            }
        }),
        Object.defineProperty(C, "sign", {
            enumerable: !0,
            get: function() {
                return H.sign
            }
        }),
        Object.defineProperty(C, "signVerify", {
            enumerable: !0,
            get: function() {
                return H.signVerify
            }
        });
        var Z = ed25519;
        Object.defineProperty(C, "getED25519MasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return Z.getED25519MasterKeyFromSeed
            }
        }),
        Object.defineProperty(C, "deriveED25519HardenedKey", {
            enumerable: !0,
            get: function() {
                return Z.deriveED25519HardenedKey
            }
        }),
        Object.defineProperty(C, "deriveEd25519Path", {
            enumerable: !0,
            get: function() {
                return Z.deriveEd25519Path
            }
        });
        var J = symmetric;
        Object.defineProperty(C, "getSymmetricMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return J.getSymmetricMasterKeyFromSeed
            }
        }),
        Object.defineProperty(C, "deriveSymmetricHardenedKey", {
            enumerable: !0,
            get: function() {
                return J.deriveSymmetricHardenedKey
            }
        }),
        Object.defineProperty(C, "deriveSymmetricPath", {
            enumerable: !0,
            get: function() {
                return J.deriveSymmetricPath
            }
        });
        var ie = mnemonics;
        Object.defineProperty(C, "deriveMnemonicsPath", {
            enumerable: !0,
            get: function() {
                return ie.deriveMnemonicsPath
            }
        }),
        Object.defineProperty(C, "deriveMnemonicHardenedKey", {
            enumerable: !0,
            get: function() {
                return ie.deriveMnemonicHardenedKey
            }
        }),
        Object.defineProperty(C, "getMnemonicsMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return ie.getMnemonicsMasterKeyFromSeed
            }
        })
    }(dist$3)),
    dist$3
}
Object.defineProperty(wonderCalculator$1, "__esModule", {
    value: !0
});
wonderCalculator$1.wonderCalculator = void 0;
const BitString_1$1 = requireBitString()
  , CellType_1 = CellType
  , LevelMask_1 = LevelMask$1
  , exoticPruned_1 = exoticPruned$1
  , exoticMerkleProof_1 = exoticMerkleProof$1
  , descriptor_1 = descriptor
  , crypto_1$4 = requireDist()
  , exoticMerkleUpdate_1 = exoticMerkleUpdate$1
  , exoticLibrary_1 = exoticLibrary$1;
function wonderCalculator(C, S, E) {
    let M, T = null;
    if (C === CellType_1.CellType.Ordinary) {
        let Z = 0;
        for (let J of E)
            Z = Z | J.mask.value;
        M = new LevelMask_1.LevelMask(Z)
    } else if (C === CellType_1.CellType.PrunedBranch)
        T = (0,
        exoticPruned_1.exoticPruned)(S, E),
        M = new LevelMask_1.LevelMask(T.mask);
    else if (C === CellType_1.CellType.MerkleProof)
        (0,
        exoticMerkleProof_1.exoticMerkleProof)(S, E),
        M = new LevelMask_1.LevelMask(E[0].mask.value >> 1);
    else if (C === CellType_1.CellType.MerkleUpdate)
        (0,
        exoticMerkleUpdate_1.exoticMerkleUpdate)(S, E),
        M = new LevelMask_1.LevelMask((E[0].mask.value | E[1].mask.value) >> 1);
    else if (C === CellType_1.CellType.Library)
        (0,
        exoticLibrary_1.exoticLibrary)(S, E),
        M = new LevelMask_1.LevelMask;
    else
        throw new Error("Unsupported exotic type");
    let $ = []
      , B = []
      , O = C === CellType_1.CellType.PrunedBranch ? 1 : M.hashCount
      , N = M.hashCount - O;
    for (let Z = 0, J = 0; Z <= M.level; Z++) {
        if (!M.isSignificant(Z))
            continue;
        if (J < N) {
            J++;
            continue
        }
        let ie;
        if (J === N) {
            if (!(Z === 0 || C === CellType_1.CellType.PrunedBranch))
                throw Error("Invalid");
            ie = S
        } else {
            if (!(Z !== 0 && C !== CellType_1.CellType.PrunedBranch))
                throw Error("Invalid: " + Z + ", " + C);
            ie = new BitString_1$1.BitString(B[J - N - 1],0,256)
        }
        let oe = 0;
        for (let de of E) {
            let fe;
            C == CellType_1.CellType.MerkleProof || C == CellType_1.CellType.MerkleUpdate ? fe = de.depth(Z + 1) : fe = de.depth(Z),
            oe = Math.max(oe, fe)
        }
        E.length > 0 && oe++;
        let ae = (0,
        descriptor_1.getRepr)(S, ie, E, Z, C)
          , se = (0,
        crypto_1$4.sha256_sync)(ae)
          , le = J - N;
        $[le] = oe,
        B[le] = se,
        J++
    }
    let U = []
      , H = [];
    if (T)
        for (let Z = 0; Z < 4; Z++) {
            const {hashIndex: J} = M.apply(Z)
              , {hashIndex: ie} = M;
            J !== ie ? (U.push(T.pruned[J].hash),
            H.push(T.pruned[J].depth)) : (U.push(B[0]),
            H.push($[0]))
        }
    else
        for (let Z = 0; Z < 4; Z++)
            U.push(B[M.apply(Z).hashIndex]),
            H.push($[M.apply(Z).hashIndex]);
    return {
        mask: M,
        hashes: U,
        depths: H
    }
}
wonderCalculator$1.wonderCalculator = wonderCalculator;
var serialization = {}
  , topologicalSort$1 = {};
Object.defineProperty(topologicalSort$1, "__esModule", {
    value: !0
});
topologicalSort$1.topologicalSort = void 0;
function topologicalSort(C) {
    let S = [C]
      , E = new Map
      , M = new Set
      , T = [];
    for (; S.length > 0; ) {
        const N = [...S];
        S = [];
        for (let U of N) {
            const H = U.hash().toString("hex");
            if (!E.has(H)) {
                M.add(H),
                E.set(H, {
                    cell: U,
                    refs: U.refs.map(Z=>Z.hash().toString("hex"))
                });
                for (let Z of U.refs)
                    S.push(Z)
            }
        }
    }
    let $ = new Set;
    function B(N) {
        if (M.has(N)) {
            if ($.has(N))
                throw Error("Not a DAG");
            $.add(N);
            for (let U of E.get(N).refs)
                B(U);
            T.unshift(N),
            $.delete(N),
            M.delete(N)
        }
    }
    for (; M.size > 0; ) {
        const N = Array.from(M)[0];
        B(N)
    }
    let O = new Map;
    for (let N = 0; N < T.length; N++)
        O.set(T[N], N);
    let F = [];
    for (let N of T) {
        const U = E.get(N);
        F.push({
            cell: U.cell,
            refs: U.refs.map(H=>O.get(H))
        })
    }
    return F
}
topologicalSort$1.topologicalSort = topologicalSort;
var bitsForNumber$1 = {};
Object.defineProperty(bitsForNumber$1, "__esModule", {
    value: !0
});
bitsForNumber$1.bitsForNumber = void 0;
function bitsForNumber(C, S) {
    let E = BigInt(C);
    if (S === "int")
        return E === 0n || E === -1n ? 1 : (E > 0 ? E : -E).toString(2).length + 1;
    if (S === "uint") {
        if (E < 0)
            throw Error(`value is negative. Got ${C}`);
        return E.toString(2).length
    } else
        throw Error(`invalid mode. Got ${S}`)
}
bitsForNumber$1.bitsForNumber = bitsForNumber;
var crc32c$4 = {};
Object.defineProperty(crc32c$4, "__esModule", {
    value: !0
});
crc32c$4.crc32c = void 0;
const POLY = 2197175160;
function crc32c$3(C) {
    let S = -1;
    for (let M = 0; M < C.length; M++)
        S ^= C[M],
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1,
        S = S & 1 ? S >>> 1 ^ POLY : S >>> 1;
    S = S ^ 4294967295;
    let E = Buffer.alloc(4);
    return E.writeInt32LE(S),
    E
}
crc32c$4.crc32c = crc32c$3;
var hasRequiredSerialization;
function requireSerialization() {
    if (hasRequiredSerialization)
        return serialization;
    hasRequiredSerialization = 1,
    Object.defineProperty(serialization, "__esModule", {
        value: !0
    }),
    serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
    const C = BitReader$1
      , S = requireBitString()
      , E = requireCell()
      , M = topologicalSort$1
      , T = bitsForNumber$1
      , $ = requireBitBuilder()
      , B = descriptor
      , O = requirePaddedBits()
      , F = crc32c$4;
    function N(se) {
        return U(se & 7)
    }
    function U(se) {
        let le = 0;
        for (let de = 0; de < 3; de++)
            le += se & 1,
            se = se >> 1;
        return le + 1
    }
    function H(se, le) {
        const de = se.loadUint(8)
          , fe = de % 8
          , pe = !!(de & 8)
          , ge = se.loadUint(8)
          , we = Math.ceil(ge / 2)
          , Ae = !!(ge % 2)
          , Se = de >> 5
          , ue = (de & 16) != 0
          , W = ue ? N(Se) * 32 : 0
          , D = ue ? N(Se) * 2 : 0;
        se.skip(W * 8),
        se.skip(D * 8);
        let I = S.BitString.EMPTY;
        we > 0 && (Ae ? I = se.loadPaddedBits(we * 8) : I = se.loadBits(we * 8));
        let L = [];
        for (let K = 0; K < fe; K++)
            L.push(se.loadUint(le * 8));
        return {
            bits: I,
            refs: L,
            exotic: pe
        }
    }
    function Z(se, le) {
        return 2 + Math.ceil(se.bits.length / 8) + se.refs.length * le
    }
    function J(se) {
        let le = new C.BitReader(new S.BitString(se,0,se.length * 8))
          , de = le.loadUint(32);
        if (de === 1761568243) {
            let fe = le.loadUint(8)
              , pe = le.loadUint(8)
              , ge = le.loadUint(fe * 8)
              , we = le.loadUint(fe * 8)
              , Ae = le.loadUint(fe * 8)
              , Se = le.loadUint(pe * 8)
              , ue = le.loadBuffer(ge * pe)
              , V = le.loadBuffer(Se);
            return {
                size: fe,
                offBytes: pe,
                cells: ge,
                roots: we,
                absent: Ae,
                totalCellSize: Se,
                index: ue,
                cellData: V,
                root: [0]
            }
        } else if (de === 2898503464) {
            let fe = le.loadUint(8)
              , pe = le.loadUint(8)
              , ge = le.loadUint(fe * 8)
              , we = le.loadUint(fe * 8)
              , Ae = le.loadUint(fe * 8)
              , Se = le.loadUint(pe * 8)
              , ue = le.loadBuffer(ge * pe)
              , V = le.loadBuffer(Se)
              , W = le.loadBuffer(4);
            if (!(0,
            F.crc32c)(se.subarray(0, se.length - 4)).equals(W))
                throw Error("Invalid CRC32C");
            return {
                size: fe,
                offBytes: pe,
                cells: ge,
                roots: we,
                absent: Ae,
                totalCellSize: Se,
                index: ue,
                cellData: V,
                root: [0]
            }
        } else if (de === 3052313714) {
            let fe = le.loadUint(1)
              , pe = le.loadUint(1);
            le.loadUint(1),
            le.loadUint(2);
            let ge = le.loadUint(3)
              , we = le.loadUint(8)
              , Ae = le.loadUint(ge * 8)
              , Se = le.loadUint(ge * 8)
              , ue = le.loadUint(ge * 8)
              , V = le.loadUint(we * 8)
              , W = [];
            for (let L = 0; L < Se; L++)
                W.push(le.loadUint(ge * 8));
            let D = null;
            fe && (D = le.loadBuffer(Ae * we));
            let I = le.loadBuffer(V);
            if (pe) {
                let L = le.loadBuffer(4);
                if (!(0,
                F.crc32c)(se.subarray(0, se.length - 4)).equals(L))
                    throw Error("Invalid CRC32C")
            }
            return {
                size: ge,
                offBytes: we,
                cells: Ae,
                roots: Se,
                absent: ue,
                totalCellSize: V,
                index: D,
                cellData: I,
                root: W
            }
        } else
            throw Error("Invalid magic")
    }
    serialization.parseBoc = J;
    function ie(se) {
        let le = J(se)
          , de = new C.BitReader(new S.BitString(le.cellData,0,le.cellData.length * 8))
          , fe = [];
        for (let ge = 0; ge < le.cells; ge++) {
            let we = H(de, le.size);
            fe.push({
                ...we,
                result: null
            })
        }
        for (let ge = fe.length - 1; ge >= 0; ge--) {
            if (fe[ge].result)
                throw Error("Impossible");
            let we = [];
            for (let Ae of fe[ge].refs) {
                if (!fe[Ae].result)
                    throw Error("Invalid BOC file");
                we.push(fe[Ae].result)
            }
            fe[ge].result = new E.Cell({
                bits: fe[ge].bits,
                refs: we,
                exotic: fe[ge].exotic
            })
        }
        let pe = [];
        for (let ge = 0; ge < le.root.length; ge++)
            pe.push(fe[le.root[ge]].result);
        return pe
    }
    serialization.deserializeBoc = ie;
    function oe(se, le, de, fe) {
        let pe = (0,
        B.getRefsDescriptor)(se.refs, se.level(), se.type)
          , ge = (0,
        B.getBitsDescriptor)(se.bits);
        fe.writeUint(pe, 8),
        fe.writeUint(ge, 8),
        fe.writeBuffer((0,
        O.bitsToPaddedBuffer)(se.bits));
        for (let we of le)
            fe.writeUint(we, de * 8)
    }
    function ae(se, le) {
        let de = (0,
        M.topologicalSort)(se)
          , fe = de.length
          , pe = le.idx
          , ge = le.crc32
          , we = !1
          , Ae = 0
          , Se = Math.max(Math.ceil((0,
        T.bitsForNumber)(fe, "uint") / 8), 1)
          , ue = 0
          , V = [];
        for (let K of de) {
            let X = Z(K.cell, Se);
            V.push(ue),
            ue += X
        }
        let W = Math.max(Math.ceil((0,
        T.bitsForNumber)(ue, "uint") / 8), 1)
          , D = (6 + 3 * Se + W + 1 * Se + (pe ? fe * W : 0) + ue + (ge ? 4 : 0)) * 8
          , I = new $.BitBuilder(D);
        if (I.writeUint(3052313714, 32),
        I.writeBit(pe),
        I.writeBit(ge),
        I.writeBit(we),
        I.writeUint(Ae, 2),
        I.writeUint(Se, 3),
        I.writeUint(W, 8),
        I.writeUint(fe, Se * 8),
        I.writeUint(1, Se * 8),
        I.writeUint(0, Se * 8),
        I.writeUint(ue, W * 8),
        I.writeUint(0, Se * 8),
        pe)
            for (let K = 0; K < fe; K++)
                I.writeUint(V[K], W * 8);
        for (let K = 0; K < fe; K++)
            oe(de[K].cell, de[K].refs, Se, I);
        if (ge) {
            let K = (0,
            F.crc32c)(I.buffer());
            I.writeBuffer(K)
        }
        let L = I.buffer();
        if (L.length !== D / 8)
            throw Error("Internal error");
        return L
    }
    return serialization.serializeBoc = ae,
    serialization
}
var hasRequiredCell;
function requireCell() {
    if (hasRequiredCell)
        return Cell$r;
    hasRequiredCell = 1;
    var C = commonjsGlobal && commonjsGlobal.__importDefault || function(Z) {
        return Z && Z.__esModule ? Z : {
            default: Z
        }
    }
    , S;
    Object.defineProperty(Cell$r, "__esModule", {
        value: !0
    }),
    Cell$r.Cell = void 0;
    const E = C(symbol_inspect)
      , M = requireBitString()
      , T = CellType
      , $ = requireSlice()
      , B = resolveExotic$1
      , O = wonderCalculator$1
      , F = requireSerialization()
      , N = BitReader$1
      , U = requireBuilder();
    class H {
        static fromBoc(J) {
            return (0,
            F.deserializeBoc)(J)
        }
        static fromBase64(J) {
            let ie = H.fromBoc(Buffer.from(J, "base64"));
            if (ie.length !== 1)
                throw new Error("Deserialized more than one cell");
            return ie[0]
        }
        constructor(J) {
            this._hashes = [],
            this._depths = [],
            this.beginParse = (fe=!1)=>{
                if (this.isExotic && !fe)
                    throw new Error("Exotic cells cannot be parsed");
                return new $.Slice(new N.BitReader(this.bits),this.refs)
            }
            ,
            this.hash = (fe=3)=>this._hashes[Math.min(this._hashes.length - 1, fe)],
            this.depth = (fe=3)=>this._depths[Math.min(this._depths.length - 1, fe)],
            this.level = ()=>this.mask.level,
            this.equals = fe=>this.hash().equals(fe.hash()),
            this[S] = ()=>this.toString();
            let ie = M.BitString.EMPTY;
            J && J.bits && (ie = J.bits);
            let oe = [];
            J && J.refs && (oe = [...J.refs]);
            let ae, se, le, de = T.CellType.Ordinary;
            if (J && J.exotic) {
                let fe = (0,
                B.resolveExotic)(ie, oe)
                  , pe = (0,
                O.wonderCalculator)(fe.type, ie, oe);
                le = pe.mask,
                se = pe.depths,
                ae = pe.hashes,
                de = fe.type
            } else {
                if (oe.length > 4)
                    throw new Error("Invalid number of references");
                if (ie.length > 1023)
                    throw new Error(`Bits overflow: ${ie.length} > 1023`);
                let fe = (0,
                O.wonderCalculator)(T.CellType.Ordinary, ie, oe);
                le = fe.mask,
                se = fe.depths,
                ae = fe.hashes,
                de = T.CellType.Ordinary
            }
            this.type = de,
            this.bits = ie,
            this.refs = oe,
            this.mask = le,
            this._depths = se,
            this._hashes = ae,
            Object.freeze(this),
            Object.freeze(this.refs),
            Object.freeze(this.bits),
            Object.freeze(this.mask),
            Object.freeze(this._depths),
            Object.freeze(this._hashes)
        }
        get isExotic() {
            return this.type !== T.CellType.Ordinary
        }
        toBoc(J) {
            let ie = J && J.idx !== null && J.idx !== void 0 ? J.idx : !1
              , oe = J && J.crc32 !== null && J.crc32 !== void 0 ? J.crc32 : !0;
            return (0,
            F.serializeBoc)(this, {
                idx: ie,
                crc32: oe
            })
        }
        toString(J) {
            let ie = J || ""
              , oe = "x";
            this.isExotic && (this.type === T.CellType.MerkleProof ? oe = "p" : this.type === T.CellType.MerkleUpdate ? oe = "u" : this.type === T.CellType.PrunedBranch && (oe = "p"));
            let ae = ie + (this.isExotic ? oe : "x") + "{" + this.bits.toString() + "}";
            for (let se in this.refs) {
                const le = this.refs[se];
                ae += `
` + le.toString(ie + " ")
            }
            return ae
        }
        asSlice() {
            return this.beginParse()
        }
        asBuilder() {
            return (0,
            U.beginCell)().storeSlice(this.asSlice())
        }
    }
    return Cell$r.Cell = H,
    S = E.default,
    H.EMPTY = new H,
    Cell$r
}
var hasRequiredBuilder;
function requireBuilder() {
    if (hasRequiredBuilder)
        return Builder;
    hasRequiredBuilder = 1,
    Object.defineProperty(Builder, "__esModule", {
        value: !0
    }),
    Builder.Builder = Builder.beginCell = void 0;
    const C = requireBitBuilder()
      , S = requireCell()
      , E = requireStrings();
    function M() {
        return new T
    }
    Builder.beginCell = M;
    let T = class Br {
        constructor() {
            this._bits = new C.BitBuilder,
            this._refs = []
        }
        get bits() {
            return this._bits.length
        }
        get refs() {
            return this._refs.length
        }
        get availableBits() {
            return 1023 - this.bits
        }
        get availableRefs() {
            return 4 - this.refs
        }
        storeBit(B) {
            return this._bits.writeBit(B),
            this
        }
        storeBits(B) {
            return this._bits.writeBits(B),
            this
        }
        storeBuffer(B, O) {
            if (O != null && B.length !== O)
                throw Error(`Buffer length ${B.length} is not equal to ${O}`);
            return this._bits.writeBuffer(B),
            this
        }
        storeMaybeBuffer(B, O) {
            return B !== null ? (this.storeBit(1),
            this.storeBuffer(B, O)) : this.storeBit(0),
            this
        }
        storeUint(B, O) {
            return this._bits.writeUint(B, O),
            this
        }
        storeMaybeUint(B, O) {
            return B != null ? (this.storeBit(1),
            this.storeUint(B, O)) : this.storeBit(0),
            this
        }
        storeInt(B, O) {
            return this._bits.writeInt(B, O),
            this
        }
        storeMaybeInt(B, O) {
            return B != null ? (this.storeBit(1),
            this.storeInt(B, O)) : this.storeBit(0),
            this
        }
        storeVarUint(B, O) {
            return this._bits.writeVarUint(B, O),
            this
        }
        storeMaybeVarUint(B, O) {
            return B != null ? (this.storeBit(1),
            this.storeVarUint(B, O)) : this.storeBit(0),
            this
        }
        storeVarInt(B, O) {
            return this._bits.writeVarInt(B, O),
            this
        }
        storeMaybeVarInt(B, O) {
            return B != null ? (this.storeBit(1),
            this.storeVarInt(B, O)) : this.storeBit(0),
            this
        }
        storeCoins(B) {
            return this._bits.writeCoins(B),
            this
        }
        storeMaybeCoins(B) {
            return B != null ? (this.storeBit(1),
            this.storeCoins(B)) : this.storeBit(0),
            this
        }
        storeAddress(B) {
            return this._bits.writeAddress(B),
            this
        }
        storeRef(B) {
            if (this._refs.length >= 4)
                throw new Error("Too many references");
            if (B instanceof S.Cell)
                this._refs.push(B);
            else if (B instanceof Br)
                this._refs.push(B.endCell());
            else
                throw new Error("Invalid argument");
            return this
        }
        storeMaybeRef(B) {
            return B ? (this.storeBit(1),
            this.storeRef(B)) : this.storeBit(0),
            this
        }
        storeSlice(B) {
            let O = B.clone();
            for (O.remainingBits > 0 && this.storeBits(O.loadBits(O.remainingBits)); O.remainingRefs > 0; )
                this.storeRef(O.loadRef());
            return this
        }
        storeMaybeSlice(B) {
            return B ? (this.storeBit(1),
            this.storeSlice(B)) : this.storeBit(0),
            this
        }
        storeBuilder(B) {
            return this.storeSlice(B.endCell().beginParse())
        }
        storeMaybeBuilder(B) {
            return B ? (this.storeBit(1),
            this.storeBuilder(B)) : this.storeBit(0),
            this
        }
        storeWritable(B) {
            return typeof B == "object" ? B.writeTo(this) : B(this),
            this
        }
        storeMaybeWritable(B) {
            return B ? (this.storeBit(1),
            this.storeWritable(B)) : this.storeBit(0),
            this
        }
        store(B) {
            return this.storeWritable(B),
            this
        }
        storeStringTail(B) {
            return (0,
            E.writeString)(B, this),
            this
        }
        storeMaybeStringTail(B) {
            return B != null ? (this.storeBit(1),
            (0,
            E.writeString)(B, this)) : this.storeBit(0),
            this
        }
        storeStringRefTail(B) {
            return this.storeRef(M().storeStringTail(B)),
            this
        }
        storeMaybeStringRefTail(B) {
            return B != null ? (this.storeBit(1),
            this.storeStringRefTail(B)) : this.storeBit(0),
            this
        }
        storeDict(B, O, F) {
            return B ? B.store(this, O, F) : this.storeBit(0),
            this
        }
        storeDictDirect(B, O, F) {
            return B.storeDirect(this, O, F),
            this
        }
        endCell() {
            return new S.Cell({
                bits: this._bits.build(),
                refs: this._refs
            })
        }
        asCell() {
            return this.endCell()
        }
        asSlice() {
            return this.endCell().beginParse()
        }
    }
    ;
    return Builder.Builder = T,
    Builder
}
var StateInit = {}
  , SimpleLibrary = {};
Object.defineProperty(SimpleLibrary, "__esModule", {
    value: !0
});
SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
function loadSimpleLibrary(C) {
    return {
        public: C.loadBit(),
        root: C.loadRef()
    }
}
SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
function storeSimpleLibrary(C) {
    return S=>{
        S.storeBit(C.public),
        S.storeRef(C.root)
    }
}
SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
SimpleLibrary.SimpleLibraryValue = {
    serialize(C, S) {
        storeSimpleLibrary(C)(S)
    },
    parse(C) {
        return loadSimpleLibrary(C)
    }
};
var TickTock = {};
Object.defineProperty(TickTock, "__esModule", {
    value: !0
});
TickTock.storeTickTock = TickTock.loadTickTock = void 0;
function loadTickTock(C) {
    return {
        tick: C.loadBit(),
        tock: C.loadBit()
    }
}
TickTock.loadTickTock = loadTickTock;
function storeTickTock(C) {
    return S=>{
        S.storeBit(C.tick),
        S.storeBit(C.tock)
    }
}
TickTock.storeTickTock = storeTickTock;
Object.defineProperty(StateInit, "__esModule", {
    value: !0
});
StateInit.storeStateInit = StateInit.loadStateInit = void 0;
const Dictionary_1$2 = requireDictionary()
  , SimpleLibrary_1 = SimpleLibrary
  , TickTock_1 = TickTock;
function loadStateInit(C) {
    let S;
    C.loadBit() && (S = C.loadUint(5));
    let E;
    C.loadBit() && (E = (0,
    TickTock_1.loadTickTock)(C));
    let M = C.loadMaybeRef()
      , T = C.loadMaybeRef()
      , $ = C.loadDict(Dictionary_1$2.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    return $.size === 0 && ($ = void 0),
    {
        splitDepth: S,
        special: E,
        code: M,
        data: T,
        libraries: $
    }
}
StateInit.loadStateInit = loadStateInit;
function storeStateInit(C) {
    return S=>{
        C.splitDepth !== null && C.splitDepth !== void 0 ? (S.storeBit(!0),
        S.storeUint(C.splitDepth, 5)) : S.storeBit(!1),
        C.special !== null && C.special !== void 0 ? (S.storeBit(!0),
        S.store((0,
        TickTock_1.storeTickTock)(C.special))) : S.storeBit(!1),
        S.storeMaybeRef(C.code),
        S.storeMaybeRef(C.data),
        S.storeDict(C.libraries)
    }
}
StateInit.storeStateInit = storeStateInit;
Object.defineProperty(contractAddress$1, "__esModule", {
    value: !0
});
contractAddress$1.contractAddress = void 0;
const Builder_1$8 = requireBuilder()
  , StateInit_1$3 = StateInit
  , Address_1$2 = Address$i;
function contractAddress(C, S) {
    let E = (0,
    Builder_1$8.beginCell)().store((0,
    StateInit_1$3.storeStateInit)(S)).endCell().hash();
    return new Address_1$2.Address(C,E)
}
contractAddress$1.contractAddress = contractAddress;
var tuple = {};
Object.defineProperty(tuple, "__esModule", {
    value: !0
});
tuple.parseTuple = tuple.serializeTuple = void 0;
const Builder_1$7 = requireBuilder()
  , INT64_MIN = BigInt("-9223372036854775808")
  , INT64_MAX = BigInt("9223372036854775807");
function serializeTupleItem(C, S) {
    if (C.type === "null")
        S.storeUint(0, 8);
    else if (C.type === "int")
        C.value <= INT64_MAX && C.value >= INT64_MIN ? (S.storeUint(1, 8),
        S.storeInt(C.value, 64)) : (S.storeUint(256, 15),
        S.storeInt(C.value, 257));
    else if (C.type === "nan")
        S.storeInt(767, 16);
    else if (C.type === "cell")
        S.storeUint(3, 8),
        S.storeRef(C.cell);
    else if (C.type === "slice")
        S.storeUint(4, 8),
        S.storeUint(0, 10),
        S.storeUint(C.cell.bits.length, 10),
        S.storeUint(0, 3),
        S.storeUint(C.cell.refs.length, 3),
        S.storeRef(C.cell);
    else if (C.type === "builder")
        S.storeUint(5, 8),
        S.storeRef(C.cell);
    else if (C.type === "tuple") {
        let E = null
          , M = null;
        for (let T = 0; T < C.items.length; T++) {
            let $ = E;
            E = M,
            M = $,
            T > 1 && (E = (0,
            Builder_1$7.beginCell)().storeRef(M).storeRef(E).endCell());
            let B = (0,
            Builder_1$7.beginCell)();
            serializeTupleItem(C.items[T], B),
            M = B.endCell()
        }
        S.storeUint(7, 8),
        S.storeUint(C.items.length, 16),
        E && S.storeRef(E),
        M && S.storeRef(M)
    } else
        throw Error("Invalid value")
}
function parseStackItem$1(C) {
    let S = C.loadUint(8);
    if (S === 0)
        return {
            type: "null"
        };
    if (S === 1)
        return {
            type: "int",
            value: C.loadIntBig(64)
        };
    if (S === 2)
        return C.loadUint(7) === 0 ? {
            type: "int",
            value: C.loadIntBig(257)
        } : (C.loadBit(),
        {
            type: "nan"
        });
    if (S === 3)
        return {
            type: "cell",
            cell: C.loadRef()
        };
    if (S === 4) {
        let E = C.loadUint(10)
          , M = C.loadUint(10)
          , T = C.loadUint(3)
          , $ = C.loadUint(3)
          , B = C.loadRef().beginParse();
        B.skip(E);
        let O = B.loadBits(M - E)
          , F = (0,
        Builder_1$7.beginCell)().storeBits(O);
        if (T < $) {
            for (let N = 0; N < T; N++)
                B.loadRef();
            for (let N = 0; N < $ - T; N++)
                F.storeRef(B.loadRef())
        }
        return {
            type: "slice",
            cell: F.endCell()
        }
    } else {
        if (S === 5)
            return {
                type: "builder",
                cell: C.loadRef()
            };
        if (S === 7) {
            let E = C.loadUint(16)
              , M = [];
            if (E > 1) {
                let T = C.loadRef().beginParse()
                  , $ = C.loadRef().beginParse();
                M.unshift(parseStackItem$1($));
                for (let B = 0; B < E - 2; B++) {
                    let O = T;
                    T = O.loadRef().beginParse(),
                    $ = O.loadRef().beginParse(),
                    M.unshift(parseStackItem$1($))
                }
                M.unshift(parseStackItem$1(T))
            } else
                E === 1 && M.push(parseStackItem$1(C.loadRef().beginParse()));
            return {
                type: "tuple",
                items: M
            }
        } else
            throw Error("Unsupported stack item")
    }
}
function serializeTupleTail(C, S) {
    if (C.length > 0) {
        let E = (0,
        Builder_1$7.beginCell)();
        serializeTupleTail(C.slice(0, C.length - 1), E),
        S.storeRef(E.endCell()),
        serializeTupleItem(C[C.length - 1], S)
    }
}
function serializeTuple(C) {
    let S = (0,
    Builder_1$7.beginCell)();
    S.storeUint(C.length, 24);
    let E = [...C];
    return serializeTupleTail(E, S),
    S.endCell()
}
tuple.serializeTuple = serializeTuple;
function parseTuple(C) {
    let S = []
      , E = C.beginParse()
      , M = E.loadUint(24);
    for (let T = 0; T < M; T++) {
        let $ = E.loadRef();
        S.unshift(parseStackItem$1(E)),
        E = $.beginParse()
    }
    return S
}
tuple.parseTuple = parseTuple;
var reader = {};
Object.defineProperty(reader, "__esModule", {
    value: !0
});
reader.TupleReader = void 0;
class TupleReader {
    constructor(S) {
        this.items = [...S]
    }
    get remaining() {
        return this.items.length
    }
    peek() {
        if (this.items.length === 0)
            throw Error("EOF");
        return this.items[0]
    }
    pop() {
        if (this.items.length === 0)
            throw Error("EOF");
        let S = this.items[0];
        return this.items.splice(0, 1),
        S
    }
    skip(S=1) {
        for (let E = 0; E < S; E++)
            this.pop();
        return this
    }
    readBigNumber() {
        let S = this.pop();
        if (S.type !== "int")
            throw Error("Not a number");
        return S.value
    }
    readBigNumberOpt() {
        let S = this.pop();
        if (S.type === "null")
            return null;
        if (S.type !== "int")
            throw Error("Not a number");
        return S.value
    }
    readNumber() {
        return Number(this.readBigNumber())
    }
    readNumberOpt() {
        let S = this.readBigNumberOpt();
        return S !== null ? Number(S) : null
    }
    readBoolean() {
        return this.readNumber() !== 0
    }
    readBooleanOpt() {
        let S = this.readNumberOpt();
        return S !== null ? S !== 0 : null
    }
    readAddress() {
        let S = this.readCell().beginParse().loadAddress();
        if (S !== null)
            return S;
        throw Error("Not an address")
    }
    readAddressOpt() {
        let S = this.readCellOpt();
        return S !== null ? S.beginParse().loadMaybeAddress() : null
    }
    readCell() {
        let S = this.pop();
        if (S.type !== "cell" && S.type !== "slice" && S.type !== "builder")
            throw Error("Not a cell: " + S.type);
        return S.cell
    }
    readCellOpt() {
        let S = this.pop();
        if (S.type === "null")
            return null;
        if (S.type !== "cell" && S.type !== "slice" && S.type !== "builder")
            throw Error("Not a cell");
        return S.cell
    }
    readTuple() {
        let S = this.pop();
        if (S.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(S.items)
    }
    readTupleOpt() {
        let S = this.pop();
        if (S.type === "null")
            return null;
        if (S.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(S.items)
    }
    static readLispList(S) {
        const E = [];
        let M = S;
        for (; M !== null; ) {
            var T = M.pop();
            if (M.items.length === 0 || M.items[0].type !== "tuple" && M.items[0].type !== "null")
                throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
            M = M.readTupleOpt(),
            E.push(T)
        }
        return E
    }
    readLispListDirect() {
        return this.items.length === 1 && this.items[0].type === "null" ? [] : TupleReader.readLispList(this)
    }
    readLispList() {
        return TupleReader.readLispList(this.readTupleOpt())
    }
    readBuffer() {
        let S = this.readCell().beginParse();
        if (S.remainingRefs !== 0 || S.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return S.loadBuffer(S.remainingBits / 8)
    }
    readBufferOpt() {
        if (this.peek().type === "null")
            return null;
        let E = this.readCell().beginParse();
        if (E.remainingRefs !== 0 || E.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return E.loadBuffer(E.remainingBits / 8)
    }
    readString() {
        return this.readCell().beginParse().loadStringTail()
    }
    readStringOpt() {
        return this.peek().type === "null" ? null : this.readCell().beginParse().loadStringTail()
    }
}
reader.TupleReader = TupleReader;
var builder = {};
Object.defineProperty(builder, "__esModule", {
    value: !0
});
builder.TupleBuilder = void 0;
const Builder_1$6 = requireBuilder()
  , Cell_1$3 = requireCell()
  , Slice_1$1 = requireSlice();
class TupleBuilder {
    constructor() {
        this._tuple = []
    }
    writeNumber(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: BigInt(S)
        })
    }
    writeBoolean(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: S ? -1n : 0n
        })
    }
    writeBuffer(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeBuffer(S).endCell()
        })
    }
    writeString(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeStringTail(S).endCell()
        })
    }
    writeCell(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : S instanceof Cell_1$3.Cell ? this._tuple.push({
            type: "cell",
            cell: S
        }) : S instanceof Slice_1$1.Slice && this._tuple.push({
            type: "cell",
            cell: S.asCell()
        })
    }
    writeSlice(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : S instanceof Cell_1$3.Cell ? this._tuple.push({
            type: "slice",
            cell: S
        }) : S instanceof Slice_1$1.Slice && this._tuple.push({
            type: "slice",
            cell: S.asCell()
        })
    }
    writeBuilder(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : S instanceof Cell_1$3.Cell ? this._tuple.push({
            type: "builder",
            cell: S
        }) : S instanceof Slice_1$1.Slice && this._tuple.push({
            type: "builder",
            cell: S.asCell()
        })
    }
    writeTuple(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "tuple",
            items: S
        })
    }
    writeAddress(S) {
        S == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeAddress(S).endCell()
        })
    }
    build() {
        return [...this._tuple]
    }
}
builder.TupleBuilder = TupleBuilder;
var _export = {}
  , _helpers = {}
  , convert = {};
Object.defineProperty(convert, "__esModule", {
    value: !0
});
convert.fromNano = convert.toNano = void 0;
function toNano$3(C) {
    if (typeof C == "bigint")
        return C * 1000000000n;
    {
        if (typeof C == "number") {
            if (!Number.isFinite(C))
                throw Error("Invalid number");
            if (Math.log10(C) <= 6)
                C = C.toLocaleString("en", {
                    minimumFractionDigits: 9,
                    useGrouping: !1
                });
            else if (C - Math.trunc(C) === 0)
                C = C.toLocaleString("en", {
                    maximumFractionDigits: 0,
                    useGrouping: !1
                });
            else
                throw Error("Not enough precision for a number value. Use string value instead")
        }
        let S = !1;
        for (; C.startsWith("-"); )
            S = !S,
            C = C.slice(1);
        if (C === ".")
            throw Error("Invalid number");
        let E = C.split(".");
        if (E.length > 2)
            throw Error("Invalid number");
        let M = E[0]
          , T = E[1];
        if (M || (M = "0"),
        T || (T = "0"),
        T.length > 9)
            throw Error("Invalid number");
        for (; T.length < 9; )
            T += "0";
        let $ = BigInt(M) * 1000000000n + BigInt(T);
        return S && ($ = -$),
        $
    }
}
convert.toNano = toNano$3;
function fromNano$2(C) {
    let S = BigInt(C)
      , E = !1;
    S < 0 && (E = !0,
    S = -S);
    let T = (S % 1000000000n).toString();
    for (; T.length < 9; )
        T = "0" + T;
    T = T.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let O = `${(S / 1000000000n).toString()}${T === "0" ? "" : `.${T}`}`;
    return E && (O = "-" + O),
    O
}
convert.fromNano = fromNano$2;
Object.defineProperty(_helpers, "__esModule", {
    value: !0
});
_helpers.comment = _helpers.external = _helpers.internal = void 0;
const Address_1$1 = Address$i
  , Cell_1$2 = requireCell()
  , Builder_1$5 = requireBuilder()
  , convert_1 = convert;
function internal(C) {
    let S = !0;
    C.bounce !== null && C.bounce !== void 0 && (S = C.bounce);
    let E;
    if (typeof C.to == "string")
        E = Address_1$1.Address.parse(C.to);
    else if (Address_1$1.Address.isAddress(C.to))
        E = C.to;
    else
        throw new Error(`Invalid address ${C.to}`);
    let M;
    typeof C.value == "string" ? M = (0,
    convert_1.toNano)(C.value) : M = C.value;
    let T = Cell_1$2.Cell.EMPTY;
    return typeof C.body == "string" ? T = (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(C.body).endCell() : C.body && (T = C.body),
    {
        info: {
            type: "internal",
            dest: E,
            value: {
                coins: M
            },
            bounce: S,
            ihrDisabled: !0,
            bounced: !1,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
        },
        init: C.init ? {
            code: C.init.code,
            data: C.init.data
        } : void 0,
        body: T
    }
}
_helpers.internal = internal;
function external$1(C) {
    let S;
    if (typeof C.to == "string")
        S = Address_1$1.Address.parse(C.to);
    else if (Address_1$1.Address.isAddress(C.to))
        S = C.to;
    else
        throw new Error(`Invalid address ${C.to}`);
    return {
        info: {
            type: "external-in",
            dest: S,
            importFee: 0n
        },
        init: C.init ? {
            code: C.init.code,
            data: C.init.data
        } : void 0,
        body: C.body || Cell_1$2.Cell.EMPTY
    }
}
_helpers.external = external$1;
function comment$2(C) {
    return (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(C).endCell()
}
_helpers.comment = comment$2;
var Account = {}
  , AccountStorage = {}
  , AccountState = {};
Object.defineProperty(AccountState, "__esModule", {
    value: !0
});
AccountState.storeAccountState = AccountState.loadAccountState = void 0;
const StateInit_1$2 = StateInit;
function loadAccountState(C) {
    return C.loadBit() ? {
        type: "active",
        state: (0,
        StateInit_1$2.loadStateInit)(C)
    } : C.loadBit() ? {
        type: "frozen",
        stateHash: C.loadUintBig(256)
    } : {
        type: "uninit"
    }
}
AccountState.loadAccountState = loadAccountState;
function storeAccountState(C) {
    return S=>{
        C.type === "active" ? (S.storeBit(!0),
        S.store((0,
        StateInit_1$2.storeStateInit)(C.state))) : C.type === "frozen" ? (S.storeBit(!1),
        S.storeBit(!0),
        S.storeUint(C.stateHash, 256)) : C.type === "uninit" && (S.storeBit(!1),
        S.storeBit(!1))
    }
}
AccountState.storeAccountState = storeAccountState;
var CurrencyCollection = {};
Object.defineProperty(CurrencyCollection, "__esModule", {
    value: !0
});
CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
const Dictionary_1$1 = requireDictionary();
function loadCurrencyCollection(C) {
    const S = C.loadCoins()
      , E = C.loadDict(Dictionary_1$1.Dictionary.Keys.Uint(32), Dictionary_1$1.Dictionary.Values.BigVarUint(5));
    return E.size === 0 ? {
        coins: S
    } : {
        other: E,
        coins: S
    }
}
CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
function storeCurrencyCollection(C) {
    return S=>{
        S.storeCoins(C.coins),
        C.other ? S.storeDict(C.other) : S.storeBit(0)
    }
}
CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
Object.defineProperty(AccountStorage, "__esModule", {
    value: !0
});
AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
const AccountState_1 = AccountState
  , CurrencyCollection_1$5 = CurrencyCollection;
function loadAccountStorage(C) {
    return {
        lastTransLt: C.loadUintBig(64),
        balance: (0,
        CurrencyCollection_1$5.loadCurrencyCollection)(C),
        state: (0,
        AccountState_1.loadAccountState)(C)
    }
}
AccountStorage.loadAccountStorage = loadAccountStorage;
function storeAccountStorage(C) {
    return S=>{
        S.storeUint(C.lastTransLt, 64),
        S.store((0,
        CurrencyCollection_1$5.storeCurrencyCollection)(C.balance)),
        S.store((0,
        AccountState_1.storeAccountState)(C.state))
    }
}
AccountStorage.storeAccountStorage = storeAccountStorage;
var StorageInto = {}
  , StorageUsed = {};
Object.defineProperty(StorageUsed, "__esModule", {
    value: !0
});
StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
function loadStorageUsed(C) {
    return {
        cells: C.loadVarUintBig(3),
        bits: C.loadVarUintBig(3),
        publicCells: C.loadVarUintBig(3)
    }
}
StorageUsed.loadStorageUsed = loadStorageUsed;
function storeStorageUsed(C) {
    return S=>{
        S.storeVarUint(C.cells, 3),
        S.storeVarUint(C.bits, 3),
        S.storeVarUint(C.publicCells, 3)
    }
}
StorageUsed.storeStorageUsed = storeStorageUsed;
Object.defineProperty(StorageInto, "__esModule", {
    value: !0
});
StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0;
const StorageUsed_1 = StorageUsed;
function loadStorageInfo(C) {
    return {
        used: (0,
        StorageUsed_1.loadStorageUsed)(C),
        lastPaid: C.loadUint(32),
        duePayment: C.loadMaybeCoins()
    }
}
StorageInto.loadStorageInfo = loadStorageInfo;
function storeStorageInfo(C) {
    return S=>{
        S.store((0,
        StorageUsed_1.storeStorageUsed)(C.used)),
        S.storeUint(C.lastPaid, 32),
        S.storeMaybeCoins(C.duePayment)
    }
}
StorageInto.storeStorageInfo = storeStorageInfo;
Object.defineProperty(Account, "__esModule", {
    value: !0
});
Account.storeAccount = Account.loadAccount = void 0;
const AccountStorage_1 = AccountStorage
  , StorageInto_1 = StorageInto;
function loadAccount(C) {
    return {
        addr: C.loadAddress(),
        storageStats: (0,
        StorageInto_1.loadStorageInfo)(C),
        storage: (0,
        AccountStorage_1.loadAccountStorage)(C)
    }
}
Account.loadAccount = loadAccount;
function storeAccount(C) {
    return S=>{
        S.storeAddress(C.addr),
        S.store((0,
        StorageInto_1.storeStorageInfo)(C.storageStats)),
        S.store((0,
        AccountStorage_1.storeAccountStorage)(C.storage))
    }
}
Account.storeAccount = storeAccount;
var AccountStatus$1 = {};
Object.defineProperty(AccountStatus$1, "__esModule", {
    value: !0
});
AccountStatus$1.storeAccountStatus = AccountStatus$1.loadAccountStatus = void 0;
function loadAccountStatus(C) {
    const S = C.loadUint(2);
    if (S === 0)
        return "uninitialized";
    if (S === 1)
        return "frozen";
    if (S === 2)
        return "active";
    if (S === 3)
        return "non-existing";
    throw Error("Invalid data")
}
AccountStatus$1.loadAccountStatus = loadAccountStatus;
function storeAccountStatus(C) {
    return S=>{
        if (C === "uninitialized")
            S.storeUint(0, 2);
        else if (C === "frozen")
            S.storeUint(1, 2);
        else if (C === "active")
            S.storeUint(2, 2);
        else if (C === "non-existing")
            S.storeUint(3, 2);
        else
            throw Error("Invalid data");
        return S
    }
}
AccountStatus$1.storeAccountStatus = storeAccountStatus;
var AccountStatusChange = {};
Object.defineProperty(AccountStatusChange, "__esModule", {
    value: !0
});
AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
function loadAccountStatusChange(C) {
    return C.loadBit() ? C.loadBit() ? "frozen" : "deleted" : "unchanged"
}
AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
function storeAccountStatusChange(C) {
    return S=>{
        if (C == "unchanged")
            S.storeBit(0);
        else if (C === "frozen")
            S.storeBit(1),
            S.storeBit(0);
        else if (C === "deleted")
            S.storeBit(1),
            S.storeBit(1);
        else
            throw Error("Invalid account status change")
    }
}
AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
var OutList = {}
  , MessageRelaxed = {}
  , CommonMessageInfoRelaxed = {};
Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", {
    value: !0
});
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1$4 = CurrencyCollection;
function loadCommonMessageInfoRelaxed(C) {
    if (!C.loadBit()) {
        const $ = C.loadBit()
          , B = C.loadBit()
          , O = C.loadBit()
          , F = C.loadMaybeAddress()
          , N = C.loadAddress()
          , U = (0,
        CurrencyCollection_1$4.loadCurrencyCollection)(C)
          , H = C.loadCoins()
          , Z = C.loadCoins()
          , J = C.loadUintBig(64)
          , ie = C.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: $,
            bounce: B,
            bounced: O,
            src: F,
            dest: N,
            value: U,
            ihrFee: H,
            forwardFee: Z,
            createdLt: J,
            createdAt: ie
        }
    }
    if (!C.loadBit())
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    const S = C.loadMaybeAddress()
      , E = C.loadMaybeExternalAddress()
      , M = C.loadUintBig(64)
      , T = C.loadUint(32);
    return {
        type: "external-out",
        src: S,
        dest: E,
        createdLt: M,
        createdAt: T
    }
}
CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
function storeCommonMessageInfoRelaxed(C) {
    return S=>{
        if (C.type === "internal")
            S.storeBit(0),
            S.storeBit(C.ihrDisabled),
            S.storeBit(C.bounce),
            S.storeBit(C.bounced),
            S.storeAddress(C.src),
            S.storeAddress(C.dest),
            S.store((0,
            CurrencyCollection_1$4.storeCurrencyCollection)(C.value)),
            S.storeCoins(C.ihrFee),
            S.storeCoins(C.forwardFee),
            S.storeUint(C.createdLt, 64),
            S.storeUint(C.createdAt, 32);
        else if (C.type === "external-out")
            S.storeBit(1),
            S.storeBit(1),
            S.storeAddress(C.src),
            S.storeAddress(C.dest),
            S.storeUint(C.createdLt, 64),
            S.storeUint(C.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
Object.defineProperty(MessageRelaxed, "__esModule", {
    value: !0
});
MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
const Builder_1$4 = requireBuilder()
  , CommonMessageInfoRelaxed_1 = CommonMessageInfoRelaxed
  , StateInit_1$1 = StateInit;
function loadMessageRelaxed(C) {
    const S = (0,
    CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(C);
    let E = null;
    C.loadBit() && (C.loadBit() ? E = (0,
    StateInit_1$1.loadStateInit)(C.loadRef().beginParse()) : E = (0,
    StateInit_1$1.loadStateInit)(C));
    const M = C.loadBit() ? C.loadRef() : C.asCell();
    return {
        info: S,
        init: E,
        body: M
    }
}
MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
function storeMessageRelaxed(C, S) {
    return E=>{
        if (E.store((0,
        CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(C.info)),
        C.init) {
            E.storeBit(!0);
            let T = (0,
            Builder_1$4.beginCell)().store((0,
            StateInit_1$1.storeStateInit)(C.init))
              , $ = !1;
            S && S.forceRef ? $ = !0 : E.availableBits - 2 >= T.bits ? $ = !1 : $ = !0,
            $ ? (E.storeBit(!0),
            E.storeRef(T)) : (E.storeBit(!1),
            E.storeBuilder(T))
        } else
            E.storeBit(!1);
        let M = !1;
        S && S.forceRef ? M = !0 : E.availableBits - 1 >= C.body.bits.length && E.refs + C.body.refs.length <= 4 ? M = !1 : M = !0,
        M ? (E.storeBit(!0),
        E.storeRef(C.body)) : (E.storeBit(!1),
        E.storeBuilder(C.body.asBuilder()))
    }
}
MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
Object.defineProperty(OutList, "__esModule", {
    value: !0
});
OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
const MessageRelaxed_1 = MessageRelaxed
  , Builder_1$3 = requireBuilder();
function storeOutAction(C) {
    switch (C.type) {
    case "sendMsg":
        return storeOutActionSendMsg(C);
    case "setCode":
        return storeOutActionSetCode(C);
    default:
        throw new Error(`Unknown action type ${C.type}`)
    }
}
OutList.storeOutAction = storeOutAction;
const outActionSendMsgTag = 247711853;
function storeOutActionSendMsg(C) {
    return S=>{
        S.storeUint(outActionSendMsgTag, 32).storeUint(C.mode, 8).storeRef((0,
        Builder_1$3.beginCell)().store((0,
        MessageRelaxed_1.storeMessageRelaxed)(C.outMsg)).endCell())
    }
}
const outActionSetCodeTag = 2907562126;
function storeOutActionSetCode(C) {
    return S=>{
        S.storeUint(outActionSetCodeTag, 32).storeRef(C.newCode)
    }
}
function loadOutAction(C) {
    const S = C.loadUint(32);
    if (S === outActionSendMsgTag) {
        const E = C.loadUint(8)
          , M = (0,
        MessageRelaxed_1.loadMessageRelaxed)(C.loadRef().beginParse());
        return {
            type: "sendMsg",
            mode: E,
            outMsg: M
        }
    }
    if (S === outActionSetCodeTag)
        return {
            type: "setCode",
            newCode: C.loadRef()
        };
    throw new Error(`Unknown out action tag 0x${S.toString(16)}`)
}
OutList.loadOutAction = loadOutAction;
function storeOutList(C) {
    const S = C.reduce((E,M)=>(0,
    Builder_1$3.beginCell)().storeRef(E).store(storeOutAction(M)).endCell(), (0,
    Builder_1$3.beginCell)().endCell());
    return E=>{
        E.storeSlice(S.beginParse())
    }
}
OutList.storeOutList = storeOutList;
function loadOutList(C) {
    const S = [];
    for (; C.remainingRefs; ) {
        const E = C.loadRef();
        S.push(loadOutAction(C)),
        C = E.beginParse()
    }
    return S.reverse()
}
OutList.loadOutList = loadOutList;
var CommonMessageInfo = {};
Object.defineProperty(CommonMessageInfo, "__esModule", {
    value: !0
});
CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
const CurrencyCollection_1$3 = CurrencyCollection;
function loadCommonMessageInfo(C) {
    if (!C.loadBit()) {
        const $ = C.loadBit()
          , B = C.loadBit()
          , O = C.loadBit()
          , F = C.loadAddress()
          , N = C.loadAddress()
          , U = (0,
        CurrencyCollection_1$3.loadCurrencyCollection)(C)
          , H = C.loadCoins()
          , Z = C.loadCoins()
          , J = C.loadUintBig(64)
          , ie = C.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: $,
            bounce: B,
            bounced: O,
            src: F,
            dest: N,
            value: U,
            ihrFee: H,
            forwardFee: Z,
            createdLt: J,
            createdAt: ie
        }
    }
    if (!C.loadBit()) {
        const $ = C.loadMaybeExternalAddress()
          , B = C.loadAddress()
          , O = C.loadCoins();
        return {
            type: "external-in",
            src: $,
            dest: B,
            importFee: O
        }
    }
    const S = C.loadAddress()
      , E = C.loadMaybeExternalAddress()
      , M = C.loadUintBig(64)
      , T = C.loadUint(32);
    return {
        type: "external-out",
        src: S,
        dest: E,
        createdLt: M,
        createdAt: T
    }
}
CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
function storeCommonMessageInfo(C) {
    return S=>{
        if (C.type === "internal")
            S.storeBit(0),
            S.storeBit(C.ihrDisabled),
            S.storeBit(C.bounce),
            S.storeBit(C.bounced),
            S.storeAddress(C.src),
            S.storeAddress(C.dest),
            S.store((0,
            CurrencyCollection_1$3.storeCurrencyCollection)(C.value)),
            S.storeCoins(C.ihrFee),
            S.storeCoins(C.forwardFee),
            S.storeUint(C.createdLt, 64),
            S.storeUint(C.createdAt, 32);
        else if (C.type === "external-in")
            S.storeBit(1),
            S.storeBit(0),
            S.storeAddress(C.src),
            S.storeAddress(C.dest),
            S.storeCoins(C.importFee);
        else if (C.type === "external-out")
            S.storeBit(1),
            S.storeBit(1),
            S.storeAddress(C.src),
            S.storeAddress(C.dest),
            S.storeUint(C.createdLt, 64),
            S.storeUint(C.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
var ComputeSkipReason$1 = {};
Object.defineProperty(ComputeSkipReason$1, "__esModule", {
    value: !0
});
ComputeSkipReason$1.storeComputeSkipReason = ComputeSkipReason$1.loadComputeSkipReason = void 0;
function loadComputeSkipReason(C) {
    let S = C.loadUint(2);
    if (S === 0)
        return "no-state";
    if (S === 1)
        return "bad-state";
    if (S === 2)
        return "no-gas";
    throw new Error(`Unknown ComputeSkipReason: ${S}`)
}
ComputeSkipReason$1.loadComputeSkipReason = loadComputeSkipReason;
function storeComputeSkipReason(C) {
    return S=>{
        if (C === "no-state")
            S.storeUint(0, 2);
        else if (C === "bad-state")
            S.storeUint(1, 2);
        else if (C === "no-gas")
            S.storeUint(2, 2);
        else
            throw new Error(`Unknown ComputeSkipReason: ${C}`)
    }
}
ComputeSkipReason$1.storeComputeSkipReason = storeComputeSkipReason;
var DepthBalanceInfo = {};
Object.defineProperty(DepthBalanceInfo, "__esModule", {
    value: !0
});
DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1$2 = CurrencyCollection;
function loadDepthBalanceInfo(C) {
    return {
        splitDepth: C.loadUint(5),
        balance: (0,
        CurrencyCollection_1$2.loadCurrencyCollection)(C)
    }
}
DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
function storeDepthBalanceInfo(C) {
    return S=>{
        S.storeUint(C.splitDepth, 5),
        S.store((0,
        CurrencyCollection_1$2.storeCurrencyCollection)(C.balance))
    }
}
DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
var HashUpdate = {};
Object.defineProperty(HashUpdate, "__esModule", {
    value: !0
});
HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
function loadHashUpdate(C) {
    if (C.loadUint(8) !== 114)
        throw Error("Invalid data");
    const S = C.loadBuffer(32)
      , E = C.loadBuffer(32);
    return {
        oldHash: S,
        newHash: E
    }
}
HashUpdate.loadHashUpdate = loadHashUpdate;
function storeHashUpdate(C) {
    return S=>{
        S.storeUint(114, 8),
        S.storeBuffer(C.oldHash),
        S.storeBuffer(C.newHash)
    }
}
HashUpdate.storeHashUpdate = storeHashUpdate;
var MasterchainStateExtra = {};
Object.defineProperty(MasterchainStateExtra, "__esModule", {
    value: !0
});
MasterchainStateExtra.loadMasterchainStateExtra = void 0;
const Dictionary_1 = requireDictionary()
  , CurrencyCollection_1$1 = CurrencyCollection;
function loadMasterchainStateExtra(C) {
    if (C.loadUint(16) !== 52262)
        throw Error("Invalid data");
    C.loadBit() && C.loadRef();
    let S = C.loadUintBig(256)
      , E = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), C);
    const M = (0,
    CurrencyCollection_1$1.loadCurrencyCollection)(C);
    return {
        config: E,
        configAddress: S,
        globalBalance: M
    }
}
MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
var Message = {};
Object.defineProperty(Message, "__esModule", {
    value: !0
});
Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
const Builder_1$2 = requireBuilder()
  , CommonMessageInfo_1 = CommonMessageInfo
  , StateInit_1 = StateInit;
function loadMessage(C) {
    const S = (0,
    CommonMessageInfo_1.loadCommonMessageInfo)(C);
    let E = null;
    C.loadBit() && (C.loadBit() ? E = (0,
    StateInit_1.loadStateInit)(C.loadRef().beginParse()) : E = (0,
    StateInit_1.loadStateInit)(C));
    const M = C.loadBit() ? C.loadRef() : C.asCell();
    return {
        info: S,
        init: E,
        body: M
    }
}
Message.loadMessage = loadMessage;
function storeMessage(C, S) {
    return E=>{
        if (E.store((0,
        CommonMessageInfo_1.storeCommonMessageInfo)(C.info)),
        C.init) {
            E.storeBit(!0);
            let T = (0,
            Builder_1$2.beginCell)().store((0,
            StateInit_1.storeStateInit)(C.init))
              , $ = !1;
            S && S.forceRef ? $ = !0 : E.availableBits - 2 >= T.bits ? $ = !1 : $ = !0,
            $ ? (E.storeBit(!0),
            E.storeRef(T)) : (E.storeBit(!1),
            E.storeBuilder(T))
        } else
            E.storeBit(!1);
        let M = !1;
        S && S.forceRef ? M = !0 : E.availableBits - 1 >= C.body.bits.length && E.refs + C.body.refs.length <= 4 ? M = !1 : M = !0,
        M ? (E.storeBit(!0),
        E.storeRef(C.body)) : (E.storeBit(!1),
        E.storeBuilder(C.body.asBuilder()))
    }
}
Message.storeMessage = storeMessage;
Message.MessageValue = {
    serialize(C, S) {
        S.storeRef((0,
        Builder_1$2.beginCell)().store(storeMessage(C)))
    },
    parse(C) {
        return loadMessage(C.loadRef().beginParse())
    }
};
var SendMode = {};
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.SendMode = void 0,
    function(S) {
        S[S.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE",
        S[S.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE",
        S[S.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO",
        S[S.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY",
        S[S.IGNORE_ERRORS = 2] = "IGNORE_ERRORS",
        S[S.NONE = 0] = "NONE"
    }(C.SendMode || (C.SendMode = {}))
}
)(SendMode);
var ShardAccount = {};
Object.defineProperty(ShardAccount, "__esModule", {
    value: !0
});
ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
const Builder_1$1 = requireBuilder()
  , Account_1 = Account;
function loadShardAccount(C) {
    let S = C.loadRef(), E;
    if (!S.isExotic) {
        let M = S.beginParse();
        M.loadBit() && (E = (0,
        Account_1.loadAccount)(M))
    }
    return {
        account: E,
        lastTransactionHash: C.loadUintBig(256),
        lastTransactionLt: C.loadUintBig(64)
    }
}
ShardAccount.loadShardAccount = loadShardAccount;
function storeShardAccount(C) {
    return S=>{
        C.account ? S.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!0).store((0,
        Account_1.storeAccount)(C.account))) : S.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!1)),
        S.storeUint(C.lastTransactionHash, 256),
        S.storeUint(C.lastTransactionLt, 64)
    }
}
ShardAccount.storeShardAccount = storeShardAccount;
var ShardAccounts = {};
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.storeShardAccounts = C.loadShardAccounts = C.ShardAccountRefValue = void 0;
    const S = requireDictionary()
      , E = DepthBalanceInfo
      , M = ShardAccount;
    C.ShardAccountRefValue = {
        parse: B=>{
            let O = (0,
            E.loadDepthBalanceInfo)(B)
              , F = (0,
            M.loadShardAccount)(B);
            return {
                depthBalanceInfo: O,
                shardAccount: F
            }
        }
        ,
        serialize(B, O) {
            O.store((0,
            E.storeDepthBalanceInfo)(B.depthBalanceInfo)),
            O.store((0,
            M.storeShardAccount)(B.shardAccount))
        }
    };
    function T(B) {
        return S.Dictionary.load(S.Dictionary.Keys.BigUint(256), C.ShardAccountRefValue, B)
    }
    C.loadShardAccounts = T;
    function $(B) {
        return O=>{
            O.storeDict(B)
        }
    }
    C.storeShardAccounts = $
}
)(ShardAccounts);
var ShardIdent = {};
Object.defineProperty(ShardIdent, "__esModule", {
    value: !0
});
ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
function loadShardIdent(C) {
    if (C.loadUint(2) !== 0)
        throw Error("Invalid data");
    return {
        shardPrefixBits: C.loadUint(6),
        workchainId: C.loadInt(32),
        shardPrefix: C.loadUintBig(64)
    }
}
ShardIdent.loadShardIdent = loadShardIdent;
function storeShardIdent(C) {
    return S=>{
        S.storeUint(0, 2),
        S.storeUint(C.shardPrefixBits, 6),
        S.storeInt(C.workchainId, 32),
        S.storeUint(C.shardPrefix, 64)
    }
}
ShardIdent.storeShardIdent = storeShardIdent;
var ShardStateUnsplit = {};
Object.defineProperty(ShardStateUnsplit, "__esModule", {
    value: !0
});
ShardStateUnsplit.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = MasterchainStateExtra
  , ShardAccounts_1 = ShardAccounts
  , ShardIdent_1 = ShardIdent;
function loadShardStateUnsplit(C) {
    if (C.loadUint(32) !== 2418257890)
        throw Error("Invalid data");
    let S = C.loadInt(32)
      , E = (0,
    ShardIdent_1.loadShardIdent)(C)
      , M = C.loadUint(32)
      , T = C.loadUint(32)
      , $ = C.loadUint(32)
      , B = C.loadUintBig(64)
      , O = C.loadUint(32);
    C.loadRef();
    let F = C.loadBit(), N = C.loadRef(), U;
    N.isExotic || (U = (0,
    ShardAccounts_1.loadShardAccounts)(N.beginParse())),
    C.loadRef();
    let H = C.loadBit()
      , Z = null;
    if (H) {
        let J = C.loadRef();
        J.isExotic || (Z = (0,
        MasterchainStateExtra_1.loadMasterchainStateExtra)(J.beginParse()))
    }
    return {
        globalId: S,
        shardId: E,
        seqno: M,
        vertSeqNo: T,
        genUtime: $,
        genLt: B,
        minRefMcSeqno: O,
        beforeSplit: F,
        accounts: U,
        extras: Z
    }
}
ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
var SplitMergeInfo = {};
Object.defineProperty(SplitMergeInfo, "__esModule", {
    value: !0
});
SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
function loadSplitMergeInfo(C) {
    let S = C.loadUint(6)
      , E = C.loadUint(6)
      , M = C.loadUintBig(256)
      , T = C.loadUintBig(256);
    return {
        currentShardPrefixLength: S,
        accountSplitDepth: E,
        thisAddress: M,
        siblingAddress: T
    }
}
SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
function storeSplitMergeInfo(C) {
    return S=>{
        S.storeUint(C.currentShardPrefixLength, 6),
        S.storeUint(C.accountSplitDepth, 6),
        S.storeUint(C.thisAddress, 256),
        S.storeUint(C.siblingAddress, 256)
    }
}
SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
var StorageUsedShort = {};
Object.defineProperty(StorageUsedShort, "__esModule", {
    value: !0
});
StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0;
function loadStorageUsedShort(C) {
    let S = C.loadVarUintBig(3)
      , E = C.loadVarUintBig(3);
    return {
        cells: S,
        bits: E
    }
}
StorageUsedShort.loadStorageUsedShort = loadStorageUsedShort;
function storeStorageUsedShort(C) {
    return S=>{
        S.storeVarUint(C.cells, 3),
        S.storeVarUint(C.bits, 3)
    }
}
StorageUsedShort.storeStorageUsedShort = storeStorageUsedShort;
var Transaction = {}
  , TransactionDescription = {}
  , TransactionActionPhase = {};
Object.defineProperty(TransactionActionPhase, "__esModule", {
    value: !0
});
TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
const AccountStatusChange_1$1 = AccountStatusChange
  , StorageUsedShort_1$1 = StorageUsedShort;
function loadTransactionActionPhase(C) {
    let S = C.loadBit()
      , E = C.loadBit()
      , M = C.loadBit()
      , T = (0,
    AccountStatusChange_1$1.loadAccountStatusChange)(C)
      , $ = C.loadBit() ? C.loadCoins() : void 0
      , B = C.loadBit() ? C.loadCoins() : void 0
      , O = C.loadInt(32)
      , F = C.loadBit() ? C.loadInt(32) : void 0
      , N = C.loadUint(16)
      , U = C.loadUint(16)
      , H = C.loadUint(16)
      , Z = C.loadUint(16)
      , J = C.loadUintBig(256)
      , ie = (0,
    StorageUsedShort_1$1.loadStorageUsedShort)(C);
    return {
        success: S,
        valid: E,
        noFunds: M,
        statusChange: T,
        totalFwdFees: $,
        totalActionFees: B,
        resultCode: O,
        resultArg: F,
        totalActions: N,
        specActions: U,
        skippedActions: H,
        messagesCreated: Z,
        actionListHash: J,
        totalMessageSize: ie
    }
}
TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
function storeTransactionActionPhase(C) {
    return S=>{
        S.storeBit(C.success),
        S.storeBit(C.valid),
        S.storeBit(C.noFunds),
        S.store((0,
        AccountStatusChange_1$1.storeAccountStatusChange)(C.statusChange)),
        S.storeMaybeCoins(C.totalFwdFees),
        S.storeMaybeCoins(C.totalActionFees),
        S.storeInt(C.resultCode, 32),
        S.storeMaybeInt(C.resultArg, 32),
        S.storeUint(C.totalActions, 16),
        S.storeUint(C.specActions, 16),
        S.storeUint(C.skippedActions, 16),
        S.storeUint(C.messagesCreated, 16),
        S.storeUint(C.actionListHash, 256),
        S.store((0,
        StorageUsedShort_1$1.storeStorageUsedShort)(C.totalMessageSize))
    }
}
TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
var TransactionBouncePhase = {};
Object.defineProperty(TransactionBouncePhase, "__esModule", {
    value: !0
});
TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
const StorageUsedShort_1 = StorageUsedShort;
function loadTransactionBouncePhase(C) {
    if (C.loadBit()) {
        let S = (0,
        StorageUsedShort_1.loadStorageUsedShort)(C)
          , E = C.loadCoins()
          , M = C.loadCoins();
        return {
            type: "ok",
            messageSize: S,
            messageFees: E,
            forwardFees: M
        }
    }
    if (C.loadBit()) {
        let S = (0,
        StorageUsedShort_1.loadStorageUsedShort)(C)
          , E = C.loadCoins();
        return {
            type: "no-funds",
            messageSize: S,
            requiredForwardFees: E
        }
    }
    return {
        type: "negative-funds"
    }
}
TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
function storeTransactionBouncePhase(C) {
    return S=>{
        if (C.type === "ok")
            S.storeBit(!0),
            S.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(C.messageSize)),
            S.storeCoins(C.messageFees),
            S.storeCoins(C.forwardFees);
        else if (C.type === "negative-funds")
            S.storeBit(!1),
            S.storeBit(!1);
        else if (C.type === "no-funds")
            S.storeBit(!1),
            S.storeBit(!0),
            S.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(C.messageSize)),
            S.storeCoins(C.requiredForwardFees);
        else
            throw new Error("Invalid TransactionBouncePhase type")
    }
}
TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
var TransactionComputePhase = {};
Object.defineProperty(TransactionComputePhase, "__esModule", {
    value: !0
});
TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
const Builder_1 = requireBuilder()
  , ComputeSkipReason_1 = ComputeSkipReason$1;
function loadTransactionComputePhase(C) {
    if (!C.loadBit())
        return {
            type: "skipped",
            reason: (0,
            ComputeSkipReason_1.loadComputeSkipReason)(C)
        };
    let S = C.loadBit()
      , E = C.loadBit()
      , M = C.loadBit()
      , T = C.loadCoins();
    const $ = C.loadRef().beginParse();
    let B = $.loadVarUintBig(3)
      , O = $.loadVarUintBig(3)
      , F = $.loadBit() ? $.loadVarUintBig(2) : void 0
      , N = $.loadUint(8)
      , U = $.loadInt(32)
      , H = $.loadBit() ? $.loadInt(32) : void 0
      , Z = $.loadUint(32)
      , J = $.loadUintBig(256)
      , ie = $.loadUintBig(256);
    return {
        type: "vm",
        success: S,
        messageStateUsed: E,
        accountActivated: M,
        gasFees: T,
        gasUsed: B,
        gasLimit: O,
        gasCredit: F,
        mode: N,
        exitCode: U,
        exitArg: H,
        vmSteps: Z,
        vmInitStateHash: J,
        vmFinalStateHash: ie
    }
}
TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
function storeTransactionComputePhase(C) {
    return S=>{
        if (C.type === "skipped") {
            S.storeBit(0),
            S.store((0,
            ComputeSkipReason_1.storeComputeSkipReason)(C.reason));
            return
        }
        S.storeBit(1),
        S.storeBit(C.success),
        S.storeBit(C.messageStateUsed),
        S.storeBit(C.accountActivated),
        S.storeCoins(C.gasFees),
        S.storeRef((0,
        Builder_1.beginCell)().storeVarUint(C.gasUsed, 3).storeVarUint(C.gasLimit, 3).store(E=>C.gasCredit !== void 0 && C.gasCredit !== null ? E.storeBit(1).storeVarUint(C.gasCredit, 2) : E.storeBit(0)).storeUint(C.mode, 8).storeInt(C.exitCode, 32).store(E=>C.exitArg !== void 0 && C.exitArg !== null ? E.storeBit(1).storeInt(C.exitArg, 32) : E.storeBit(0)).storeUint(C.vmSteps, 32).storeUint(C.vmInitStateHash, 256).storeUint(C.vmFinalStateHash, 256).endCell())
    }
}
TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
var TransactionCreditPhase = {};
Object.defineProperty(TransactionCreditPhase, "__esModule", {
    value: !0
});
TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = CurrencyCollection;
function loadTransactionCreditPhase(C) {
    const S = C.loadBit() ? C.loadCoins() : void 0
      , E = (0,
    CurrencyCollection_1.loadCurrencyCollection)(C);
    return {
        dueFeesColelcted: S,
        credit: E
    }
}
TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
function storeTransactionCreditPhase(C) {
    return S=>{
        C.dueFeesColelcted === null || C.dueFeesColelcted === void 0 ? S.storeBit(!1) : (S.storeBit(!0),
        S.storeCoins(C.dueFeesColelcted)),
        S.store((0,
        CurrencyCollection_1.storeCurrencyCollection)(C.credit))
    }
}
TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
var TransactionStoragePhase = {};
Object.defineProperty(TransactionStoragePhase, "__esModule", {
    value: !0
});
TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = AccountStatusChange;
function loadTransactionStoragePhase(C) {
    const S = C.loadCoins();
    let E;
    C.loadBit() && (E = C.loadCoins());
    const M = (0,
    AccountStatusChange_1.loadAccountStatusChange)(C);
    return {
        storageFeesCollected: S,
        storageFeesDue: E,
        statusChange: M
    }
}
TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
function storeTransactionsStoragePhase(C) {
    return S=>{
        S.storeCoins(C.storageFeesCollected),
        C.storageFeesDue === null || C.storageFeesDue === void 0 ? S.storeBit(!1) : (S.storeBit(!0),
        S.storeCoins(C.storageFeesDue)),
        S.store((0,
        AccountStatusChange_1.storeAccountStatusChange)(C.statusChange))
    }
}
TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
    if (hasRequiredTransactionDescription)
        return TransactionDescription;
    hasRequiredTransactionDescription = 1,
    Object.defineProperty(TransactionDescription, "__esModule", {
        value: !0
    }),
    TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
    const C = requireBuilder()
      , S = SplitMergeInfo
      , E = requireTransaction()
      , M = TransactionActionPhase
      , T = TransactionBouncePhase
      , $ = TransactionComputePhase
      , B = TransactionCreditPhase
      , O = TransactionStoragePhase;
    function F(U) {
        let H = U.loadUint(4);
        if (H === 0) {
            const Z = U.loadBit();
            let J;
            U.loadBit() && (J = (0,
            O.loadTransactionStoragePhase)(U));
            let ie;
            U.loadBit() && (ie = (0,
            B.loadTransactionCreditPhase)(U));
            let oe = (0,
            $.loadTransactionComputePhase)(U), ae;
            U.loadBit() && (ae = (0,
            M.loadTransactionActionPhase)(U.loadRef().beginParse()));
            let se = U.loadBit(), le;
            U.loadBit() && (le = (0,
            T.loadTransactionBouncePhase)(U));
            const de = U.loadBit();
            return {
                type: "generic",
                creditFirst: Z,
                storagePhase: J,
                creditPhase: ie,
                computePhase: oe,
                actionPhase: ae,
                bouncePhase: le,
                aborted: se,
                destroyed: de
            }
        }
        if (H === 1)
            return {
                type: "storage",
                storagePhase: (0,
                O.loadTransactionStoragePhase)(U)
            };
        if (H === 2 || H === 3) {
            const Z = H === 3;
            let J = (0,
            O.loadTransactionStoragePhase)(U), ie = (0,
            $.loadTransactionComputePhase)(U), oe;
            U.loadBit() && (oe = (0,
            M.loadTransactionActionPhase)(U.loadRef().beginParse()));
            const ae = U.loadBit()
              , se = U.loadBit();
            return {
                type: "tick-tock",
                isTock: Z,
                storagePhase: J,
                computePhase: ie,
                actionPhase: oe,
                aborted: ae,
                destroyed: se
            }
        }
        if (H === 4) {
            let Z = (0,
            S.loadSplitMergeInfo)(U), J;
            U.loadBit() && (J = (0,
            O.loadTransactionStoragePhase)(U));
            let ie = (0,
            $.loadTransactionComputePhase)(U), oe;
            U.loadBit() && (oe = (0,
            M.loadTransactionActionPhase)(U.loadRef().beginParse()));
            const ae = U.loadBit()
              , se = U.loadBit();
            return {
                type: "split-prepare",
                splitInfo: Z,
                storagePhase: J,
                computePhase: ie,
                actionPhase: oe,
                aborted: ae,
                destroyed: se
            }
        }
        if (H === 5) {
            let Z = (0,
            S.loadSplitMergeInfo)(U)
              , J = (0,
            E.loadTransaction)(U.loadRef().beginParse());
            const ie = U.loadBit();
            return {
                type: "split-install",
                splitInfo: Z,
                prepareTransaction: J,
                installed: ie
            }
        }
        throw Error(`Unsupported transaction description type ${H}`)
    }
    TransactionDescription.loadTransactionDescription = F;
    function N(U) {
        return H=>{
            if (U.type === "generic")
                H.storeUint(0, 4),
                H.storeBit(U.creditFirst),
                U.storagePhase ? (H.storeBit(!0),
                H.store((0,
                O.storeTransactionsStoragePhase)(U.storagePhase))) : H.storeBit(!1),
                U.creditPhase ? (H.storeBit(!0),
                H.store((0,
                B.storeTransactionCreditPhase)(U.creditPhase))) : H.storeBit(!1),
                H.store((0,
                $.storeTransactionComputePhase)(U.computePhase)),
                U.actionPhase ? (H.storeBit(!0),
                H.storeRef((0,
                C.beginCell)().store((0,
                M.storeTransactionActionPhase)(U.actionPhase)))) : H.storeBit(!1),
                H.storeBit(U.aborted),
                U.bouncePhase ? (H.storeBit(!0),
                H.store((0,
                T.storeTransactionBouncePhase)(U.bouncePhase))) : H.storeBit(!1),
                H.storeBit(U.destroyed);
            else if (U.type === "storage")
                H.storeUint(1, 4),
                H.store((0,
                O.storeTransactionsStoragePhase)(U.storagePhase));
            else if (U.type === "tick-tock")
                H.storeUint(U.isTock ? 3 : 2, 4),
                H.store((0,
                O.storeTransactionsStoragePhase)(U.storagePhase)),
                H.store((0,
                $.storeTransactionComputePhase)(U.computePhase)),
                U.actionPhase ? (H.storeBit(!0),
                H.storeRef((0,
                C.beginCell)().store((0,
                M.storeTransactionActionPhase)(U.actionPhase)))) : H.storeBit(!1),
                H.storeBit(U.aborted),
                H.storeBit(U.destroyed);
            else if (U.type === "split-prepare")
                H.storeUint(4, 4),
                H.store((0,
                S.storeSplitMergeInfo)(U.splitInfo)),
                U.storagePhase ? (H.storeBit(!0),
                H.store((0,
                O.storeTransactionsStoragePhase)(U.storagePhase))) : H.storeBit(!1),
                H.store((0,
                $.storeTransactionComputePhase)(U.computePhase)),
                U.actionPhase ? (H.storeBit(!0),
                H.store((0,
                M.storeTransactionActionPhase)(U.actionPhase))) : H.storeBit(!1),
                H.storeBit(U.aborted),
                H.storeBit(U.destroyed);
            else if (U.type === "split-install")
                H.storeUint(5, 4),
                H.store((0,
                S.storeSplitMergeInfo)(U.splitInfo)),
                H.storeRef((0,
                C.beginCell)().store((0,
                E.storeTransaction)(U.prepareTransaction))),
                H.storeBit(U.installed);
            else
                throw Error(`Unsupported transaction description type ${U.type}`)
        }
    }
    return TransactionDescription.storeTransactionDescription = N,
    TransactionDescription
}
var hasRequiredTransaction;
function requireTransaction() {
    if (hasRequiredTransaction)
        return Transaction;
    hasRequiredTransaction = 1,
    Object.defineProperty(Transaction, "__esModule", {
        value: !0
    }),
    Transaction.storeTransaction = Transaction.loadTransaction = void 0;
    const C = requireBuilder()
      , S = requireDictionary()
      , E = AccountStatus$1
      , M = CurrencyCollection
      , T = HashUpdate
      , $ = Message
      , B = requireTransactionDescription();
    function O(N) {
        let U = N.asCell();
        if (N.loadUint(4) !== 7)
            throw Error("Invalid data");
        let H = N.loadUintBig(256)
          , Z = N.loadUintBig(64)
          , J = N.loadUintBig(256)
          , ie = N.loadUintBig(64)
          , oe = N.loadUint(32)
          , ae = N.loadUint(15)
          , se = (0,
        E.loadAccountStatus)(N)
          , le = (0,
        E.loadAccountStatus)(N)
          , fe = N.loadRef().beginParse()
          , pe = fe.loadBit() ? (0,
        $.loadMessage)(fe.loadRef().beginParse()) : void 0
          , ge = fe.loadDict(S.Dictionary.Keys.Uint(15), $.MessageValue);
        fe.endParse();
        let we = (0,
        M.loadCurrencyCollection)(N)
          , Ae = (0,
        T.loadHashUpdate)(N.loadRef().beginParse())
          , Se = (0,
        B.loadTransactionDescription)(N.loadRef().beginParse());
        return {
            address: H,
            lt: Z,
            prevTransactionHash: J,
            prevTransactionLt: ie,
            now: oe,
            outMessagesCount: ae,
            oldStatus: se,
            endStatus: le,
            inMessage: pe,
            outMessages: ge,
            totalFees: we,
            stateUpdate: Ae,
            description: Se,
            raw: U,
            hash: ()=>U.hash()
        }
    }
    Transaction.loadTransaction = O;
    function F(N) {
        return U=>{
            U.storeUint(7, 4),
            U.storeUint(N.address, 256),
            U.storeUint(N.lt, 64),
            U.storeUint(N.prevTransactionHash, 256),
            U.storeUint(N.prevTransactionLt, 64),
            U.storeUint(N.now, 32),
            U.storeUint(N.outMessagesCount, 15),
            U.store((0,
            E.storeAccountStatus)(N.oldStatus)),
            U.store((0,
            E.storeAccountStatus)(N.endStatus));
            let H = (0,
            C.beginCell)();
            N.inMessage ? (H.storeBit(!0),
            H.storeRef((0,
            C.beginCell)().store((0,
            $.storeMessage)(N.inMessage)))) : H.storeBit(!1),
            H.storeDict(N.outMessages),
            U.storeRef(H),
            U.store((0,
            M.storeCurrencyCollection)(N.totalFees)),
            U.storeRef((0,
            C.beginCell)().store((0,
            T.storeHashUpdate)(N.stateUpdate))),
            U.storeRef((0,
            C.beginCell)().store((0,
            B.storeTransactionDescription)(N.description)))
        }
    }
    return Transaction.storeTransaction = F,
    Transaction
}
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.loadStorageInfo = C.storeStateInit = C.loadStateInit = C.storeSplitMergeInfo = C.loadSplitMergeInfo = C.storeSimpleLibrary = C.loadSimpleLibrary = C.loadShardStateUnsplit = C.storeShardIdent = C.loadShardIdent = C.storeShardAccounts = C.loadShardAccounts = C.ShardAccountRefValue = C.storeShardAccount = C.loadShardAccount = C.SendMode = C.storeMessageRelaxed = C.loadMessageRelaxed = C.storeMessage = C.loadMessage = C.loadMasterchainStateExtra = C.storeHashUpdate = C.loadHashUpdate = C.storeDepthBalanceInfo = C.loadDepthBalanceInfo = C.storeCurrencyCollection = C.loadCurrencyCollection = C.storeComputeSkipReason = C.loadComputeSkipReason = C.storeCommonMessageInfoRelaxed = C.loadCommonMessageInfoRelaxed = C.storeCommonMessageInfo = C.loadCommonMessageInfo = C.storeOutList = C.loadOutList = C.storeOutAction = C.loadOutAction = C.storeAccountStorage = C.loadAccountStorage = C.storeAccountStatusChange = C.loadAccountStatusChange = C.storeAccountStatus = C.loadAccountStatus = C.storeAccountState = C.loadAccountState = C.storeAccount = C.loadAccount = C.comment = C.external = C.internal = void 0,
    C.storeTransactionsStoragePhase = C.loadTransactionStoragePhase = C.storeTransactionDescription = C.loadTransactionDescription = C.storeTransactionCreditPhase = C.loadTransactionCreditPhase = C.storeTransactionComputePhase = C.loadTransactionComputePhase = C.storeTransactionBouncePhase = C.loadTransactionBouncePhase = C.storeTransactionActionPhase = C.loadTransactionActionPhase = C.storeTransaction = C.loadTransaction = C.storeTickTock = C.loadTickTock = C.storeStorageUsedShort = C.loadStorageUsedShort = C.storeStorageUsed = C.loadStorageUsed = C.storeStorageInfo = void 0;
    var S = _helpers;
    Object.defineProperty(C, "internal", {
        enumerable: !0,
        get: function() {
            return S.internal
        }
    }),
    Object.defineProperty(C, "external", {
        enumerable: !0,
        get: function() {
            return S.external
        }
    }),
    Object.defineProperty(C, "comment", {
        enumerable: !0,
        get: function() {
            return S.comment
        }
    });
    var E = Account;
    Object.defineProperty(C, "loadAccount", {
        enumerable: !0,
        get: function() {
            return E.loadAccount
        }
    }),
    Object.defineProperty(C, "storeAccount", {
        enumerable: !0,
        get: function() {
            return E.storeAccount
        }
    });
    var M = AccountState;
    Object.defineProperty(C, "loadAccountState", {
        enumerable: !0,
        get: function() {
            return M.loadAccountState
        }
    }),
    Object.defineProperty(C, "storeAccountState", {
        enumerable: !0,
        get: function() {
            return M.storeAccountState
        }
    });
    var T = AccountStatus$1;
    Object.defineProperty(C, "loadAccountStatus", {
        enumerable: !0,
        get: function() {
            return T.loadAccountStatus
        }
    }),
    Object.defineProperty(C, "storeAccountStatus", {
        enumerable: !0,
        get: function() {
            return T.storeAccountStatus
        }
    });
    var $ = AccountStatusChange;
    Object.defineProperty(C, "loadAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return $.loadAccountStatusChange
        }
    }),
    Object.defineProperty(C, "storeAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return $.storeAccountStatusChange
        }
    });
    var B = AccountStorage;
    Object.defineProperty(C, "loadAccountStorage", {
        enumerable: !0,
        get: function() {
            return B.loadAccountStorage
        }
    }),
    Object.defineProperty(C, "storeAccountStorage", {
        enumerable: !0,
        get: function() {
            return B.storeAccountStorage
        }
    });
    var O = OutList;
    Object.defineProperty(C, "loadOutAction", {
        enumerable: !0,
        get: function() {
            return O.loadOutAction
        }
    }),
    Object.defineProperty(C, "storeOutAction", {
        enumerable: !0,
        get: function() {
            return O.storeOutAction
        }
    }),
    Object.defineProperty(C, "loadOutList", {
        enumerable: !0,
        get: function() {
            return O.loadOutList
        }
    }),
    Object.defineProperty(C, "storeOutList", {
        enumerable: !0,
        get: function() {
            return O.storeOutList
        }
    });
    var F = CommonMessageInfo;
    Object.defineProperty(C, "loadCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return F.loadCommonMessageInfo
        }
    }),
    Object.defineProperty(C, "storeCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return F.storeCommonMessageInfo
        }
    });
    var N = CommonMessageInfoRelaxed;
    Object.defineProperty(C, "loadCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return N.loadCommonMessageInfoRelaxed
        }
    }),
    Object.defineProperty(C, "storeCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return N.storeCommonMessageInfoRelaxed
        }
    });
    var U = ComputeSkipReason$1;
    Object.defineProperty(C, "loadComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return U.loadComputeSkipReason
        }
    }),
    Object.defineProperty(C, "storeComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return U.storeComputeSkipReason
        }
    });
    var H = CurrencyCollection;
    Object.defineProperty(C, "loadCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return H.loadCurrencyCollection
        }
    }),
    Object.defineProperty(C, "storeCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return H.storeCurrencyCollection
        }
    });
    var Z = DepthBalanceInfo;
    Object.defineProperty(C, "loadDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return Z.loadDepthBalanceInfo
        }
    }),
    Object.defineProperty(C, "storeDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return Z.storeDepthBalanceInfo
        }
    });
    var J = HashUpdate;
    Object.defineProperty(C, "loadHashUpdate", {
        enumerable: !0,
        get: function() {
            return J.loadHashUpdate
        }
    }),
    Object.defineProperty(C, "storeHashUpdate", {
        enumerable: !0,
        get: function() {
            return J.storeHashUpdate
        }
    });
    var ie = MasterchainStateExtra;
    Object.defineProperty(C, "loadMasterchainStateExtra", {
        enumerable: !0,
        get: function() {
            return ie.loadMasterchainStateExtra
        }
    });
    var oe = Message;
    Object.defineProperty(C, "loadMessage", {
        enumerable: !0,
        get: function() {
            return oe.loadMessage
        }
    }),
    Object.defineProperty(C, "storeMessage", {
        enumerable: !0,
        get: function() {
            return oe.storeMessage
        }
    });
    var ae = MessageRelaxed;
    Object.defineProperty(C, "loadMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return ae.loadMessageRelaxed
        }
    }),
    Object.defineProperty(C, "storeMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return ae.storeMessageRelaxed
        }
    });
    var se = SendMode;
    Object.defineProperty(C, "SendMode", {
        enumerable: !0,
        get: function() {
            return se.SendMode
        }
    });
    var le = ShardAccount;
    Object.defineProperty(C, "loadShardAccount", {
        enumerable: !0,
        get: function() {
            return le.loadShardAccount
        }
    }),
    Object.defineProperty(C, "storeShardAccount", {
        enumerable: !0,
        get: function() {
            return le.storeShardAccount
        }
    });
    var de = ShardAccounts;
    Object.defineProperty(C, "ShardAccountRefValue", {
        enumerable: !0,
        get: function() {
            return de.ShardAccountRefValue
        }
    }),
    Object.defineProperty(C, "loadShardAccounts", {
        enumerable: !0,
        get: function() {
            return de.loadShardAccounts
        }
    }),
    Object.defineProperty(C, "storeShardAccounts", {
        enumerable: !0,
        get: function() {
            return de.storeShardAccounts
        }
    });
    var fe = ShardIdent;
    Object.defineProperty(C, "loadShardIdent", {
        enumerable: !0,
        get: function() {
            return fe.loadShardIdent
        }
    }),
    Object.defineProperty(C, "storeShardIdent", {
        enumerable: !0,
        get: function() {
            return fe.storeShardIdent
        }
    });
    var pe = ShardStateUnsplit;
    Object.defineProperty(C, "loadShardStateUnsplit", {
        enumerable: !0,
        get: function() {
            return pe.loadShardStateUnsplit
        }
    });
    var ge = SimpleLibrary;
    Object.defineProperty(C, "loadSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return ge.loadSimpleLibrary
        }
    }),
    Object.defineProperty(C, "storeSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return ge.storeSimpleLibrary
        }
    });
    var we = SplitMergeInfo;
    Object.defineProperty(C, "loadSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return we.loadSplitMergeInfo
        }
    }),
    Object.defineProperty(C, "storeSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return we.storeSplitMergeInfo
        }
    });
    var Ae = StateInit;
    Object.defineProperty(C, "loadStateInit", {
        enumerable: !0,
        get: function() {
            return Ae.loadStateInit
        }
    }),
    Object.defineProperty(C, "storeStateInit", {
        enumerable: !0,
        get: function() {
            return Ae.storeStateInit
        }
    });
    var Se = StorageInto;
    Object.defineProperty(C, "loadStorageInfo", {
        enumerable: !0,
        get: function() {
            return Se.loadStorageInfo
        }
    }),
    Object.defineProperty(C, "storeStorageInfo", {
        enumerable: !0,
        get: function() {
            return Se.storeStorageInfo
        }
    });
    var ue = StorageUsed;
    Object.defineProperty(C, "loadStorageUsed", {
        enumerable: !0,
        get: function() {
            return ue.loadStorageUsed
        }
    }),
    Object.defineProperty(C, "storeStorageUsed", {
        enumerable: !0,
        get: function() {
            return ue.storeStorageUsed
        }
    });
    var V = StorageUsedShort;
    Object.defineProperty(C, "loadStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return V.loadStorageUsedShort
        }
    }),
    Object.defineProperty(C, "storeStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return V.storeStorageUsedShort
        }
    });
    var W = TickTock;
    Object.defineProperty(C, "loadTickTock", {
        enumerable: !0,
        get: function() {
            return W.loadTickTock
        }
    }),
    Object.defineProperty(C, "storeTickTock", {
        enumerable: !0,
        get: function() {
            return W.storeTickTock
        }
    });
    var D = requireTransaction();
    Object.defineProperty(C, "loadTransaction", {
        enumerable: !0,
        get: function() {
            return D.loadTransaction
        }
    }),
    Object.defineProperty(C, "storeTransaction", {
        enumerable: !0,
        get: function() {
            return D.storeTransaction
        }
    });
    var I = TransactionActionPhase;
    Object.defineProperty(C, "loadTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return I.loadTransactionActionPhase
        }
    }),
    Object.defineProperty(C, "storeTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return I.storeTransactionActionPhase
        }
    });
    var L = TransactionBouncePhase;
    Object.defineProperty(C, "loadTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return L.loadTransactionBouncePhase
        }
    }),
    Object.defineProperty(C, "storeTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return L.storeTransactionBouncePhase
        }
    });
    var K = TransactionComputePhase;
    Object.defineProperty(C, "loadTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return K.loadTransactionComputePhase
        }
    }),
    Object.defineProperty(C, "storeTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return K.storeTransactionComputePhase
        }
    });
    var X = TransactionCreditPhase;
    Object.defineProperty(C, "loadTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return X.loadTransactionCreditPhase
        }
    }),
    Object.defineProperty(C, "storeTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return X.storeTransactionCreditPhase
        }
    });
    var Y = requireTransactionDescription();
    Object.defineProperty(C, "loadTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Y.loadTransactionDescription
        }
    }),
    Object.defineProperty(C, "storeTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Y.storeTransactionDescription
        }
    });
    var j = TransactionStoragePhase;
    Object.defineProperty(C, "loadTransactionStoragePhase", {
        enumerable: !0,
        get: function() {
            return j.loadTransactionStoragePhase
        }
    }),
    Object.defineProperty(C, "storeTransactionsStoragePhase", {
        enumerable: !0,
        get: function() {
            return j.storeTransactionsStoragePhase
        }
    })
}
)(_export);
var openContract$1 = {};
Object.defineProperty(openContract$1, "__esModule", {
    value: !0
});
openContract$1.openContract = void 0;
const Address_1 = Address$i
  , Cell_1$1 = requireCell();
function openContract(C, S) {
    let E, M = null;
    if (!Address_1.Address.isAddress(C.address))
        throw Error("Invalid address");
    if (E = C.address,
    C.init) {
        if (!(C.init.code instanceof Cell_1$1.Cell))
            throw Error("Invalid init.code");
        if (!(C.init.data instanceof Cell_1$1.Cell))
            throw Error("Invalid init.data");
        M = C.init
    }
    let T = S({
        address: E,
        init: M
    });
    return new Proxy(C,{
        get($, B) {
            const O = $[B];
            return typeof B == "string" && (B.startsWith("get") || B.startsWith("send")) && typeof O == "function" ? (...F)=>O.apply($, [T, ...F]) : O
        }
    })
}
openContract$1.openContract = openContract;
var ComputeError$1 = {};
Object.defineProperty(ComputeError$1, "__esModule", {
    value: !0
});
ComputeError$1.ComputeError = void 0;
class ComputeError extends Error {
    constructor(S, E, M) {
        super(S),
        this.exitCode = E,
        this.debugLogs = M && M.debugLogs ? M.debugLogs : null,
        this.logs = M && M.logs ? M.logs : null,
        Object.setPrototypeOf(this, ComputeError.prototype)
    }
}
ComputeError$1.ComputeError = ComputeError;
var getMethodId$1 = {};
Object.defineProperty(getMethodId$1, "__esModule", {
    value: !0
});
getMethodId$1.getMethodId = void 0;
const TABLE = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);
function crc16$4(C) {
    C instanceof Buffer || (C = Buffer.from(C));
    let S = 0;
    for (let E = 0; E < C.length; E++) {
        const M = C[E];
        S = (TABLE[(S >> 8 ^ M) & 255] ^ S << 8) & 65535
    }
    return S
}
function getMethodId(C) {
    return crc16$4(C) & 65535 | 65536
}
getMethodId$1.getMethodId = getMethodId;
var safeSign$1 = {};
Object.defineProperty(safeSign$1, "__esModule", {
    value: !0
});
safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
const crypto_1$3 = requireDist()
  , MIN_SEED_LENGTH = 8
  , MAX_SEED_LENGTH = 64;
function createSafeSignHash(C, S) {
    let E = Buffer.from(S);
    if (E.length > MAX_SEED_LENGTH)
        throw Error("Seed can	 be longer than 64 bytes");
    if (E.length < MIN_SEED_LENGTH)
        throw Error("Seed must be at least 8 bytes");
    return (0,
    crypto_1$3.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), E, C.hash()]))
}
function safeSign(C, S, E="ton-safe-sign-magic") {
    return (0,
    crypto_1$3.sign)(createSafeSignHash(C, E), S)
}
safeSign$1.safeSign = safeSign;
function safeSignVerify(C, S, E, M="ton-safe-sign-magic") {
    return (0,
    crypto_1$3.signVerify)(createSafeSignHash(C, M), S, E)
}
safeSign$1.safeSignVerify = safeSignVerify;
(function(C) {
    var S = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(L, K, X, Y) {
        Y === void 0 && (Y = X);
        var j = Object.getOwnPropertyDescriptor(K, X);
        (!j || ("get"in j ? !K.__esModule : j.writable || j.configurable)) && (j = {
            enumerable: !0,
            get: function() {
                return K[X]
            }
        }),
        Object.defineProperty(L, Y, j)
    }
    : function(L, K, X, Y) {
        Y === void 0 && (Y = X),
        L[Y] = K[X]
    }
    )
      , E = commonjsGlobal && commonjsGlobal.__exportStar || function(L, K) {
        for (var X in L)
            X !== "default" && !Object.prototype.hasOwnProperty.call(K, X) && S(K, L, X)
    }
    ;
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.safeSignVerify = C.safeSign = C.getMethodId = C.base32Encode = C.base32Decode = C.crc32c = C.crc16 = C.fromNano = C.toNano = C.ComputeError = C.openContract = C.TupleBuilder = C.TupleReader = C.serializeTuple = C.parseTuple = C.generateMerkleUpdate = C.generateMerkleProof = C.exoticPruned = C.exoticMerkleUpdate = C.exoticMerkleProof = C.Dictionary = C.Cell = C.CellType = C.Slice = C.beginCell = C.Builder = C.BitBuilder = C.BitReader = C.BitString = C.contractAddress = C.ADNLAddress = C.ExternalAddress = C.address = C.Address = void 0;
    var M = Address$i;
    Object.defineProperty(C, "Address", {
        enumerable: !0,
        get: function() {
            return M.Address
        }
    }),
    Object.defineProperty(C, "address", {
        enumerable: !0,
        get: function() {
            return M.address
        }
    });
    var T = ExternalAddress$1;
    Object.defineProperty(C, "ExternalAddress", {
        enumerable: !0,
        get: function() {
            return T.ExternalAddress
        }
    });
    var $ = ADNLAddress$1;
    Object.defineProperty(C, "ADNLAddress", {
        enumerable: !0,
        get: function() {
            return $.ADNLAddress
        }
    });
    var B = contractAddress$1;
    Object.defineProperty(C, "contractAddress", {
        enumerable: !0,
        get: function() {
            return B.contractAddress
        }
    });
    var O = requireBitString();
    Object.defineProperty(C, "BitString", {
        enumerable: !0,
        get: function() {
            return O.BitString
        }
    });
    var F = BitReader$1;
    Object.defineProperty(C, "BitReader", {
        enumerable: !0,
        get: function() {
            return F.BitReader
        }
    });
    var N = requireBitBuilder();
    Object.defineProperty(C, "BitBuilder", {
        enumerable: !0,
        get: function() {
            return N.BitBuilder
        }
    });
    var U = requireBuilder();
    Object.defineProperty(C, "Builder", {
        enumerable: !0,
        get: function() {
            return U.Builder
        }
    }),
    Object.defineProperty(C, "beginCell", {
        enumerable: !0,
        get: function() {
            return U.beginCell
        }
    });
    var H = requireSlice();
    Object.defineProperty(C, "Slice", {
        enumerable: !0,
        get: function() {
            return H.Slice
        }
    });
    var Z = CellType;
    Object.defineProperty(C, "CellType", {
        enumerable: !0,
        get: function() {
            return Z.CellType
        }
    });
    var J = requireCell();
    Object.defineProperty(C, "Cell", {
        enumerable: !0,
        get: function() {
            return J.Cell
        }
    });
    var ie = requireDictionary();
    Object.defineProperty(C, "Dictionary", {
        enumerable: !0,
        get: function() {
            return ie.Dictionary
        }
    });
    var oe = exoticMerkleProof$1;
    Object.defineProperty(C, "exoticMerkleProof", {
        enumerable: !0,
        get: function() {
            return oe.exoticMerkleProof
        }
    });
    var ae = exoticMerkleUpdate$1;
    Object.defineProperty(C, "exoticMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return ae.exoticMerkleUpdate
        }
    });
    var se = exoticPruned$1;
    Object.defineProperty(C, "exoticPruned", {
        enumerable: !0,
        get: function() {
            return se.exoticPruned
        }
    });
    var le = requireGenerateMerkleProof();
    Object.defineProperty(C, "generateMerkleProof", {
        enumerable: !0,
        get: function() {
            return le.generateMerkleProof
        }
    });
    var de = requireGenerateMerkleUpdate();
    Object.defineProperty(C, "generateMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return de.generateMerkleUpdate
        }
    });
    var fe = tuple;
    Object.defineProperty(C, "parseTuple", {
        enumerable: !0,
        get: function() {
            return fe.parseTuple
        }
    }),
    Object.defineProperty(C, "serializeTuple", {
        enumerable: !0,
        get: function() {
            return fe.serializeTuple
        }
    });
    var pe = reader;
    Object.defineProperty(C, "TupleReader", {
        enumerable: !0,
        get: function() {
            return pe.TupleReader
        }
    });
    var ge = builder;
    Object.defineProperty(C, "TupleBuilder", {
        enumerable: !0,
        get: function() {
            return ge.TupleBuilder
        }
    }),
    E(_export, C);
    var we = openContract$1;
    Object.defineProperty(C, "openContract", {
        enumerable: !0,
        get: function() {
            return we.openContract
        }
    });
    var Ae = ComputeError$1;
    Object.defineProperty(C, "ComputeError", {
        enumerable: !0,
        get: function() {
            return Ae.ComputeError
        }
    });
    var Se = convert;
    Object.defineProperty(C, "toNano", {
        enumerable: !0,
        get: function() {
            return Se.toNano
        }
    }),
    Object.defineProperty(C, "fromNano", {
        enumerable: !0,
        get: function() {
            return Se.fromNano
        }
    });
    var ue = crc16$6;
    Object.defineProperty(C, "crc16", {
        enumerable: !0,
        get: function() {
            return ue.crc16
        }
    });
    var V = crc32c$4;
    Object.defineProperty(C, "crc32c", {
        enumerable: !0,
        get: function() {
            return V.crc32c
        }
    });
    var W = base32;
    Object.defineProperty(C, "base32Decode", {
        enumerable: !0,
        get: function() {
            return W.base32Decode
        }
    }),
    Object.defineProperty(C, "base32Encode", {
        enumerable: !0,
        get: function() {
            return W.base32Encode
        }
    });
    var D = getMethodId$1;
    Object.defineProperty(C, "getMethodId", {
        enumerable: !0,
        get: function() {
            return D.getMethodId
        }
    });
    var I = safeSign$1;
    Object.defineProperty(C, "safeSign", {
        enumerable: !0,
        get: function() {
            return I.safeSign
        }
    }),
    Object.defineProperty(C, "safeSignVerify", {
        enumerable: !0,
        get: function() {
            return I.safeSignVerify
        }
    })
}
)(dist$4);
var naclUtil = {
    exports: {}
};
(function(C) {
    (function(S, E) {
        C.exports ? C.exports = E() : (S.nacl || (S.nacl = {}),
        S.nacl.util = E())
    }
    )(commonjsGlobal, function() {
        var S = {};
        function E(M) {
            if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(M))
                throw new TypeError("invalid encoding")
        }
        return S.decodeUTF8 = function(M) {
            if (typeof M != "string")
                throw new TypeError("expected string");
            var T, $ = unescape(encodeURIComponent(M)), B = new Uint8Array($.length);
            for (T = 0; T < $.length; T++)
                B[T] = $.charCodeAt(T);
            return B
        }
        ,
        S.encodeUTF8 = function(M) {
            var T, $ = [];
            for (T = 0; T < M.length; T++)
                $.push(String.fromCharCode(M[T]));
            return decodeURIComponent(escape($.join("")))
        }
        ,
        typeof atob > "u" ? typeof Buffer.from < "u" ? (S.encodeBase64 = function(M) {
            return Buffer.from(M).toString("base64")
        }
        ,
        S.decodeBase64 = function(M) {
            return E(M),
            new Uint8Array(Array.prototype.slice.call(Buffer.from(M, "base64"), 0))
        }
        ) : (S.encodeBase64 = function(M) {
            return new Buffer(M).toString("base64")
        }
        ,
        S.decodeBase64 = function(M) {
            return E(M),
            new Uint8Array(Array.prototype.slice.call(new Buffer(M,"base64"), 0))
        }
        ) : (S.encodeBase64 = function(M) {
            var T, $ = [], B = M.length;
            for (T = 0; T < B; T++)
                $.push(String.fromCharCode(M[T]));
            return btoa($.join(""))
        }
        ,
        S.decodeBase64 = function(M) {
            E(M);
            var T, $ = atob(M), B = new Uint8Array($.length);
            for (T = 0; T < $.length; T++)
                B[T] = $.charCodeAt(T);
            return B
        }
        ),
        S
    })
}
)(naclUtil);
var naclUtilExports = naclUtil.exports;
const nacl$5 = getDefaultExportFromCjs$1(naclUtilExports);
var CONNECT_EVENT_ERROR_CODES;
(function(C) {
    C[C.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    C[C.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    C[C.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR",
    C[C.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR",
    C[C.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    C[C.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    C[C.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(C) {
    C[C.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    C[C.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(C) {
    C[C.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    C[C.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    C[C.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    C[C.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    C[C.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(C) {
    C[C.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    C[C.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    C[C.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    C[C.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    C[C.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(C) {
    C[C.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    C[C.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    C[C.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    C[C.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(C) {
    C.MAINNET = "-239",
    C.TESTNET = "-3"
}
)(CHAIN || (CHAIN = {}));
function encodeUint8Array(C, S) {
    const E = nacl$5.encodeBase64(C);
    return S ? encodeURIComponent(E) : E
}
function decodeToUint8Array(C, S) {
    return S && (C = decodeURIComponent(C)),
    nacl$5.decodeBase64(C)
}
function encode$2(C, S=!1) {
    let E;
    return C instanceof Uint8Array ? E = C : (typeof C != "string" && (C = JSON.stringify(C)),
    E = nacl$5.decodeUTF8(C)),
    encodeUint8Array(E, S)
}
function decode$1(C, S=!1) {
    const E = decodeToUint8Array(C, S);
    return {
        toString() {
            return nacl$5.encodeUTF8(E)
        },
        toObject() {
            try {
                return JSON.parse(nacl$5.encodeUTF8(E))
            } catch {
                return null
            }
        },
        toUint8Array() {
            return E
        }
    }
}
const Base64 = {
    encode: encode$2,
    decode: decode$1
};
function concatUint8Arrays(C, S) {
    const E = new Uint8Array(C.length + S.length);
    return E.set(C),
    E.set(S, C.length),
    E
}
function splitToUint8Arrays(C, S) {
    if (S >= C.length)
        throw new Error("Index is out of buffer");
    const E = C.slice(0, S)
      , M = C.slice(S);
    return [E, M]
}
function toHexString(C) {
    let S = "";
    return C.forEach(E=>{
        S += ("0" + (E & 255).toString(16)).slice(-2)
    }
    ),
    S
}
function hexToByteArray(C) {
    if (C.length % 2 !== 0)
        throw new Error(`Cannot convert ${C} to bytesArray`);
    const S = new Uint8Array(C.length / 2);
    for (let E = 0; E < C.length; E += 2)
        S[E / 2] = parseInt(C.slice(E, E + 2), 16);
    return S
}
class SessionCrypto {
    constructor(S) {
        this.nonceLength = 24,
        this.keyPair = S ? this.createKeypairFromString(S) : this.createKeypair(),
        this.sessionId = toHexString(this.keyPair.publicKey)
    }
    createKeypair() {
        return nacl$1$1.box.keyPair()
    }
    createKeypairFromString(S) {
        return {
            publicKey: hexToByteArray(S.publicKey),
            secretKey: hexToByteArray(S.secretKey)
        }
    }
    createNonce() {
        return nacl$1$1.randomBytes(this.nonceLength)
    }
    encrypt(S, E) {
        const M = new TextEncoder().encode(S)
          , T = this.createNonce()
          , $ = nacl$1$1.box(M, T, E, this.keyPair.secretKey);
        return concatUint8Arrays(T, $)
    }
    decrypt(S, E) {
        const [M,T] = splitToUint8Arrays(S, this.nonceLength)
          , $ = nacl$1$1.box.open(T, M, E, this.keyPair.secretKey);
        if (!$)
            throw new Error(`Decryption error: 
 message: ${S.toString()} 
 sender pubkey: ${E.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        return new TextDecoder().decode($)
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        }
    }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest$5(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
}
function __awaiter$2(C, S, E, M) {
    function T($) {
        return $ instanceof E ? $ : new E(function(B) {
            B($)
        }
        )
    }
    return new (E || (E = Promise))(function($, B) {
        function O(U) {
            try {
                N(M.next(U))
            } catch (H) {
                B(H)
            }
        }
        function F(U) {
            try {
                N(M.throw(U))
            } catch (H) {
                B(H)
            }
        }
        function N(U) {
            U.done ? $(U.value) : T(U.value).then(O, F)
        }
        N((M = M.apply(C, S || [])).next())
    }
    )
}
class TonConnectError extends Error {
    constructor(S, E) {
        super(S, E),
        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${S ? `
` + S : ""}`,
        Object.setPrototypeOf(this, TonConnectError.prototype)
    }
    get info() {
        return ""
    }
}
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
class DappMetadataError extends TonConnectError {
    get info() {
        return "Passed DappMetadata is in incorrect format."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, DappMetadataError.prototype)
    }
}
class ManifestContentErrorError extends TonConnectError {
    get info() {
        return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, ManifestContentErrorError.prototype)
    }
}
class ManifestNotFoundError extends TonConnectError {
    get info() {
        return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, ManifestNotFoundError.prototype)
    }
}
class WalletAlreadyConnectedError extends TonConnectError {
    get info() {
        return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype)
    }
}
class WalletNotConnectedError extends TonConnectError {
    get info() {
        return "Send transaction or other protocol methods called while wallet is not connected."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, WalletNotConnectedError.prototype)
    }
}
function isWalletConnectionSourceJS(C) {
    return "jsBridgeKey"in C
}
class UserRejectsError extends TonConnectError {
    get info() {
        return "User rejects the action in the wallet."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, UserRejectsError.prototype)
    }
}
class BadRequestError extends TonConnectError {
    get info() {
        return "Request to the wallet contains errors."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, BadRequestError.prototype)
    }
}
class UnknownAppError extends TonConnectError {
    get info() {
        return "App tries to send rpc request to the injected wallet while not connected."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, UnknownAppError.prototype)
    }
}
class WalletNotInjectedError extends TonConnectError {
    get info() {
        return "There is an attempt to connect to the injected wallet while it is not exists in the webpage."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, WalletNotInjectedError.prototype)
    }
}
class FetchWalletsError extends TonConnectError {
    get info() {
        return "An error occurred while fetching the wallets list."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, FetchWalletsError.prototype)
    }
}
class WrongAddressError extends TonConnectError {
    get info() {
        return "Passed address is in incorrect format."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, WrongAddressError.prototype)
    }
}
class ParseHexError extends TonConnectError {
    get info() {
        return "Passed hex is in incorrect format."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, ParseHexError.prototype)
    }
}
class UnknownError extends TonConnectError {
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, UnknownError.prototype)
    }
}
const connectEventErrorsCodes = {
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
class ConnectErrorsParser {
    parseError(S) {
        let E = UnknownError;
        return S.code in connectEventErrorsCodes && (E = connectEventErrorsCodes[S.code] || UnknownError),
        new E(S.message)
    }
}
const connectErrorsParser = new ConnectErrorsParser;
class RpcParser {
    isError(S) {
        return "error"in S
    }
}
const sendTransactionErrors = {
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
class SendTransactionParser extends RpcParser {
    convertToRpcRequest(S) {
        return {
            method: "sendTransaction",
            params: [JSON.stringify(S)]
        }
    }
    parseAndThrowError(S) {
        let E = UnknownError;
        throw S.error.code in sendTransactionErrors && (E = sendTransactionErrors[S.error.code] || UnknownError),
        new E(S.error.message)
    }
    convertFromRpcResponse(S) {
        return {
            boc: S.result
        }
    }
}
const sendTransactionParser = new SendTransactionParser;
class HttpBridgeGatewayStorage {
    constructor(S, E) {
        this.storage = S,
        this.storeKey = "ton-connect-storage_http-bridge-gateway::" + E
    }
    storeLastEventId(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return this.storage.setItem(this.storeKey, S)
        })
    }
    removeLastEventId() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getLastEventId() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.storage.getItem(this.storeKey);
            return S || null
        })
    }
}
function removeUrlLastSlash(C) {
    return C.slice(-1) === "/" ? C.slice(0, -1) : C
}
function addPathToUrl(C, S) {
    return removeUrlLastSlash(C) + "/" + S
}
function isTelegramUrl(C) {
    if (!C)
        return !1;
    const S = new URL(C);
    return S.protocol === "tg:" || S.hostname === "t.me"
}
function encodeTelegramUrlParameters(C) {
    return C.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--")
}
class BridgeGateway {
    constructor(S, E, M, T, $) {
        this.bridgeUrl = E,
        this.sessionId = M,
        this.listener = T,
        this.errorsListener = $,
        this.ssePath = "events",
        this.postPath = "message",
        this.heartbeatMessage = "heartbeat",
        this.defaultTtl = 300,
        this.isClosed = !1,
        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(S,E)
    }
    registerSession(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const E = new URL(addPathToUrl(this.bridgeUrl, this.ssePath));
            E.searchParams.append("client_id", this.sessionId);
            const M = yield this.bridgeGatewayStorage.getLastEventId();
            if (!this.isClosed)
                return M && E.searchParams.append("last_event_id", M),
                this.eventSource = new EventSource(E.toString()),
                new Promise((T,$)=>{
                    const B = S != null && S.openingDeadlineMS ? setTimeout(()=>{
                        var O;
                        ((O = this.eventSource) === null || O === void 0 ? void 0 : O.readyState) !== EventSource.OPEN && ($(new TonConnectError("Bridge connection timeout")),
                        this.close())
                    }
                    , S.openingDeadlineMS) : void 0;
                    this.eventSource.onerror = ()=>$,
                    this.eventSource.onopen = ()=>{
                        clearTimeout(B),
                        this.isClosed = !1,
                        this.eventSource.onerror = this.errorsHandler.bind(this),
                        this.eventSource.onmessage = this.messagesHandler.bind(this),
                        T()
                    }
                }
                )
        })
    }
    send(S, E, M, T) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const $ = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
            $.searchParams.append("client_id", this.sessionId),
            $.searchParams.append("to", E),
            $.searchParams.append("ttl", (T || this.defaultTtl).toString()),
            $.searchParams.append("topic", M);
            const B = yield fetch($, {
                method: "post",
                body: Base64.encode(S)
            });
            if (!B.ok)
                throw new TonConnectError(`Bridge send failed, status ${B.status}`)
        })
    }
    pause() {
        var S;
        (S = this.eventSource) === null || S === void 0 || S.close()
    }
    unPause() {
        return this.registerSession()
    }
    close() {
        var S;
        this.isClosed = !0,
        (S = this.eventSource) === null || S === void 0 || S.close()
    }
    setListener(S) {
        this.listener = S
    }
    setErrorsListener(S) {
        this.errorsListener = S
    }
    errorsHandler(S) {
        var E, M;
        if (!this.isClosed) {
            if (((E = this.eventSource) === null || E === void 0 ? void 0 : E.readyState) === EventSource.CLOSED) {
                this.eventSource.close(),
                this.registerSession();
                return
            }
            if (((M = this.eventSource) === null || M === void 0 ? void 0 : M.readyState) === EventSource.CONNECTING) {
                console.debug("[TON_CONNET_SDK_ERROR]: Bridge error", JSON.stringify(S));
                return
            }
            this.errorsListener(S)
        }
    }
    messagesHandler(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (S.data !== this.heartbeatMessage && (yield this.bridgeGatewayStorage.storeLastEventId(S.lastEventId),
            !this.isClosed)) {
                let E;
                try {
                    E = JSON.parse(S.data)
                } catch (M) {
                    throw new TonConnectError(`Bridge message parse failed, message ${M.data}`)
                }
                this.listener(E)
            }
        })
    }
}
function isPendingConnectionHttp(C) {
    return !("connectEvent"in C)
}
class BridgeConnectionStorage {
    constructor(S) {
        this.storage = S,
        this.storeKey = "ton-connect-storage_bridge-connection"
    }
    storeConnection(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (S.type === "injected")
                return this.storage.setItem(this.storeKey, JSON.stringify(S));
            if (!isPendingConnectionHttp(S)) {
                const M = {
                    sessionKeyPair: S.session.sessionCrypto.stringifyKeypair(),
                    walletPublicKey: S.session.walletPublicKey,
                    bridgeUrl: S.session.bridgeUrl
                }
                  , T = {
                    type: "http",
                    connectEvent: S.connectEvent,
                    session: M,
                    lastWalletEventId: S.lastWalletEventId,
                    nextRpcRequestId: S.nextRpcRequestId
                };
                return this.storage.setItem(this.storeKey, JSON.stringify(T))
            }
            const E = {
                type: "http",
                connectionSource: S.connectionSource,
                sessionCrypto: S.sessionCrypto.stringifyKeypair()
            };
            return this.storage.setItem(this.storeKey, JSON.stringify(E))
        })
    }
    removeConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.storage.getItem(this.storeKey);
            if (!S)
                return null;
            const E = JSON.parse(S);
            if (E.type === "injected")
                return E;
            if ("connectEvent"in E) {
                const M = new SessionCrypto(E.session.sessionKeyPair);
                return {
                    type: "http",
                    connectEvent: E.connectEvent,
                    lastWalletEventId: E.lastWalletEventId,
                    nextRpcRequestId: E.nextRpcRequestId,
                    session: {
                        sessionCrypto: M,
                        bridgeUrl: E.session.bridgeUrl,
                        walletPublicKey: E.session.walletPublicKey
                    }
                }
            }
            return {
                type: "http",
                sessionCrypto: new SessionCrypto(E.sessionCrypto),
                connectionSource: E.connectionSource
            }
        })
    }
    getHttpConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            if (!S)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (S.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            return S
        })
    }
    getHttpPendingConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            if (!S)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (S.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            if (!isPendingConnectionHttp(S))
                throw new TonConnectError("Trying to read HTTP-pending connection while http connection is stored");
            return S
        })
    }
    getInjectedConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            if (!S)
                throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
            if ((S == null ? void 0 : S.type) === "http")
                throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
            return S
        })
    }
    storedConnectionType() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.storage.getItem(this.storeKey);
            return S ? JSON.parse(S).type : null
        })
    }
    storeLastWalletEventId(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const E = yield this.getConnection();
            if (E && E.type === "http" && !isPendingConnectionHttp(E))
                return E.lastWalletEventId = S,
                this.storeConnection(E)
        })
    }
    getLastWalletEventId() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            if (S && "lastWalletEventId"in S)
                return S.lastWalletEventId
        })
    }
    increaseNextRpcRequestId() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            if (S && "nextRpcRequestId"in S) {
                const E = S.nextRpcRequestId || 0;
                return S.nextRpcRequestId = E + 1,
                this.storeConnection(S)
            }
        })
    }
    getNextRpcRequestId() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = yield this.getConnection();
            return S && "nextRpcRequestId"in S && S.nextRpcRequestId || 0
        })
    }
}
const PROTOCOL_VERSION = 2;
function logDebug(...C) {
    try {
        console.debug("[TON_CONNECT_SDK]", ...C)
    } catch {}
}
function logError$1(...C) {
    try {
        console.error("[TON_CONNECT_SDK]", ...C)
    } catch {}
}
function logWarning$1(...C) {
    try {
        console.warn("[TON_CONNECT_SDK]", ...C)
    } catch {}
}
class BridgeProvider {
    constructor(S, E) {
        this.storage = S,
        this.walletConnectionSource = E,
        this.type = "http",
        this.standardUniversalLink = "tc://",
        this.pendingRequests = new Map,
        this.session = null,
        this.gateway = null,
        this.pendingGateways = [],
        this.listeners = [],
        this.connectionStorage = new BridgeConnectionStorage(S)
    }
    static fromStorage(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const M = yield new BridgeConnectionStorage(S).getHttpConnection();
            return isPendingConnectionHttp(M) ? new BridgeProvider(S,M.connectionSource) : new BridgeProvider(S,{
                bridgeUrl: M.session.bridgeUrl
            })
        })
    }
    connect(S) {
        this.closeGateways();
        const E = new SessionCrypto;
        this.session = {
            sessionCrypto: E,
            bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        },
        this.connectionStorage.storeConnection({
            type: "http",
            connectionSource: this.walletConnectionSource,
            sessionCrypto: E
        }).then(()=>this.openGateways(E));
        const M = "universalLink"in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
        return this.generateUniversalLink(M, S)
    }
    restoreConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.closeGateways();
            const S = yield this.connectionStorage.getHttpConnection();
            if (S) {
                if (isPendingConnectionHttp(S))
                    return this.session = {
                        sessionCrypto: S.sessionCrypto,
                        bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                    },
                    this.openGateways(S.sessionCrypto, {
                        openingDeadlineMS: 5e3
                    });
                if (Array.isArray(this.walletConnectionSource))
                    throw new TonConnectError("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
                this.session = S.session,
                this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,S.session.sessionCrypto.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this));
                try {
                    yield this.gateway.registerSession({
                        openingDeadlineMS: 5e3
                    })
                } catch {
                    yield this.disconnect();
                    return
                }
                this.listeners.forEach(E=>E(S.connectEvent))
            }
        })
    }
    sendRequest(S, E) {
        return new Promise((M,T)=>__awaiter$2(this, void 0, void 0, function*() {
            if (!this.gateway || !this.session || !("walletPublicKey"in this.session))
                throw new TonConnectError("Trying to send bridge request without session");
            const $ = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug("Send http-bridge request:", Object.assign(Object.assign({}, S), {
                id: $
            }));
            const B = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, S), {
                id: $
            })), hexToByteArray(this.session.walletPublicKey));
            try {
                yield this.gateway.send(B, this.session.walletPublicKey, S.method),
                E == null || E(),
                this.pendingRequests.set($.toString(), M)
            } catch (O) {
                T(O)
            }
        }))
    }
    closeConnection() {
        this.closeGateways(),
        this.listeners = [],
        this.session = null,
        this.gateway = null
    }
    disconnect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return new Promise(S=>__awaiter$2(this, void 0, void 0, function*() {
                let E = !1;
                const M = ()=>{
                    E = !0,
                    this.removeBridgeAndSession().then(S)
                }
                ;
                try {
                    yield this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, M)
                } catch (T) {
                    console.debug(T),
                    E || this.removeBridgeAndSession().then(S)
                }
            }))
        })
    }
    listen(S) {
        return this.listeners.push(S),
        ()=>this.listeners = this.listeners.filter(E=>E !== S)
    }
    pause() {
        var S;
        (S = this.gateway) === null || S === void 0 || S.pause(),
        this.pendingGateways.forEach(E=>E.pause())
    }
    unPause() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const S = this.pendingGateways.map(E=>E.unPause());
            this.gateway && S.push(this.gateway.unPause()),
            yield Promise.all(S)
        })
    }
    pendingGatewaysListener(S, E, M) {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (!this.pendingGateways.includes(S)) {
                S.close();
                return
            }
            return this.closeGateways({
                except: S
            }),
            this.session.bridgeUrl = E,
            this.gateway = S,
            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)),
            this.gateway.setListener(this.gatewayListener.bind(this)),
            this.gatewayListener(M)
        })
    }
    gatewayListener(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const E = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(S.message).toUint8Array(), hexToByteArray(S.from)));
            if (logDebug("Wallet message received:", E),
            !("event"in E)) {
                const T = E.id.toString()
                  , $ = this.pendingRequests.get(T);
                if (!$) {
                    logDebug(`Response id ${T} doesn't match any request's id`);
                    return
                }
                $(E),
                this.pendingRequests.delete(T);
                return
            }
            if (E.id !== void 0) {
                const T = yield this.connectionStorage.getLastWalletEventId();
                if (T !== void 0 && E.id <= T) {
                    logError$1(`Received event id (=${E.id}) must be greater than stored last wallet event id (=${T}) `);
                    return
                }
                E.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(E.id))
            }
            const M = this.listeners;
            E.event === "connect" && (yield this.updateSession(E, S.from)),
            E.event === "disconnect" && (yield this.removeBridgeAndSession()),
            M.forEach(T=>T(E))
        })
    }
    gatewayErrorsListener(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            throw new TonConnectError(`Bridge error ${JSON.stringify(S)}`)
        })
    }
    updateSession(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.session = Object.assign(Object.assign({}, this.session), {
                walletPublicKey: E
            });
            const M = S.payload.items.find($=>$.name === "ton_addr")
              , T = Object.assign(Object.assign({}, S), {
                payload: Object.assign(Object.assign({}, S.payload), {
                    items: [M]
                })
            });
            yield this.connectionStorage.storeConnection({
                type: "http",
                session: this.session,
                lastWalletEventId: S.id,
                connectEvent: T,
                nextRpcRequestId: 0
            })
        })
    }
    removeBridgeAndSession() {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.closeConnection(),
            yield this.connectionStorage.removeConnection()
        })
    }
    generateUniversalLink(S, E) {
        return isTelegramUrl(S) ? this.generateTGUniversalLink(S, E) : this.generateRegularUniversalLink(S, E)
    }
    generateRegularUniversalLink(S, E) {
        const M = new URL(S);
        return M.searchParams.append("v", PROTOCOL_VERSION.toString()),
        M.searchParams.append("id", this.session.sessionCrypto.sessionId),
        M.searchParams.append("r", JSON.stringify(E)),
        M.toString()
    }
    generateTGUniversalLink(S, E) {
        const T = this.generateRegularUniversalLink("about:blank", E).split("?")[1]
          , $ = "tonconnect-" + encodeTelegramUrlParameters(T)
          , B = this.convertToDirectLink(S)
          , O = new URL(B);
        return O.searchParams.append("startapp", $),
        O.toString()
    }
    convertToDirectLink(S) {
        const E = new URL(S);
        return E.searchParams.has("attach") && (E.searchParams.delete("attach"),
        E.pathname += "/start"),
        E.toString()
    }
    openGateways(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (Array.isArray(this.walletConnectionSource)) {
                this.pendingGateways = this.walletConnectionSource.map(M=>{
                    const T = new BridgeGateway(this.storage,M.bridgeUrl,S.sessionId,()=>{}
                    ,$=>{
                        console.error($)
                    }
                    );
                    return T.setListener($=>this.pendingGatewaysListener(T, M.bridgeUrl, $)),
                    T
                }
                ),
                yield Promise.allSettled(this.pendingGateways.map(M=>M.registerSession(E)));
                return
            } else
                return this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,S.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
                this.gateway.registerSession(E)
        })
    }
    closeGateways(S) {
        var E;
        (E = this.gateway) === null || E === void 0 || E.close(),
        this.pendingGateways.filter(M=>M !== (S == null ? void 0 : S.except)).forEach(M=>M.close()),
        this.pendingGateways = []
    }
}
function hasProperty(C, S) {
    return hasProperties(C, [S])
}
function hasProperties(C, S) {
    return !C || typeof C != "object" ? !1 : S.every(E=>E in C)
}
function isJSBridgeWithMetadata(C) {
    try {
        return !hasProperty(C, "tonconnect") || !hasProperty(C.tonconnect, "walletInfo") ? !1 : hasProperties(C.tonconnect.walletInfo, ["name", "app_name", "image", "about_url", "platforms"])
    } catch {
        return !1
    }
}
let InMemoryStorage$1 = class _r {
    constructor() {
        this.storage = {}
    }
    static getInstance() {
        return _r.instance || (_r.instance = new _r),
        _r.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(S) {
        var E;
        return (E = this.storage[S]) !== null && E !== void 0 ? E : null
    }
    key(S) {
        var E;
        const M = Object.keys(this.storage);
        return S < 0 || S >= M.length ? null : (E = M[S]) !== null && E !== void 0 ? E : null
    }
    removeItem(S) {
        delete this.storage[S]
    }
    setItem(S, E) {
        this.storage[S] = E
    }
}
;
function getWindow$2() {
    if (!(typeof window > "u"))
        return window
}
function tryGetWindowKeys() {
    const C = getWindow$2();
    if (!C)
        return [];
    try {
        return Object.keys(C)
    } catch {
        return []
    }
}
function getDocument() {
    if (!(typeof document > "u"))
        return document
}
function getWebPageManifest() {
    var C;
    const S = (C = getWindow$2()) === null || C === void 0 ? void 0 : C.location.origin;
    return S ? S + "/tonconnect-manifest.json" : ""
}
function tryGetLocalStorage$1() {
    if (isLocalStorageAvailable$1())
        return localStorage;
    if (isNodeJs$1())
        throw new TonConnectError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage$1.getInstance()
}
function isLocalStorageAvailable$1() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs$1() {
    return typeof process$1 < "u" && process$1.versions != null && process$1.versions.node != null
}
class InjectedProvider {
    constructor(S, E) {
        this.injectedWalletKey = E,
        this.type = "injected",
        this.unsubscribeCallback = null,
        this.listenSubscriptions = !1,
        this.listeners = [];
        const M = InjectedProvider.window;
        if (!InjectedProvider.isWindowContainsWallet(M, E))
            throw new WalletNotInjectedError;
        this.connectionStorage = new BridgeConnectionStorage(S),
        this.injectedWallet = M[E].tonconnect
    }
    static fromStorage(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const M = yield new BridgeConnectionStorage(S).getInjectedConnection();
            return new InjectedProvider(S,M.jsBridgeKey)
        })
    }
    static isWalletInjected(S) {
        return InjectedProvider.isWindowContainsWallet(this.window, S)
    }
    static isInsideWalletBrowser(S) {
        return InjectedProvider.isWindowContainsWallet(this.window, S) ? this.window[S].tonconnect.isWalletBrowser : !1
    }
    static getCurrentlyInjectedWallets() {
        return this.window ? tryGetWindowKeys().filter(([M,T])=>isJSBridgeWithMetadata(T)).map(([M,T])=>({
            name: T.tonconnect.walletInfo.name,
            appName: T.tonconnect.walletInfo.app_name,
            aboutUrl: T.tonconnect.walletInfo.about_url,
            imageUrl: T.tonconnect.walletInfo.image,
            tondns: T.tonconnect.walletInfo.tondns,
            jsBridgeKey: M,
            injected: !0,
            embedded: T.tonconnect.isWalletBrowser,
            platforms: T.tonconnect.walletInfo.platforms
        })) : []
    }
    static isWindowContainsWallet(S, E) {
        return !!S && E in S && typeof S[E] == "object" && "tonconnect"in S[E]
    }
    connect(S) {
        this._connect(PROTOCOL_VERSION, S)
    }
    restoreConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            try {
                logDebug("Injected Provider restoring connection...");
                const S = yield this.injectedWallet.restoreConnection();
                logDebug("Injected Provider restoring connection response", S),
                S.event === "connect" ? (this.makeSubscriptions(),
                this.listeners.forEach(E=>E(S))) : yield this.connectionStorage.removeConnection()
            } catch (S) {
                yield this.connectionStorage.removeConnection(),
                console.error(S)
            }
        })
    }
    closeConnection() {
        this.listenSubscriptions && this.injectedWallet.disconnect(),
        this.closeAllListeners()
    }
    disconnect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return new Promise(S=>{
                const E = ()=>{
                    this.closeAllListeners(),
                    this.connectionStorage.removeConnection().then(S)
                }
                ;
                try {
                    this.injectedWallet.disconnect(),
                    E()
                } catch (M) {
                    logDebug(M),
                    this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, E)
                }
            }
            )
        })
    }
    closeAllListeners() {
        var S;
        this.listenSubscriptions = !1,
        this.listeners = [],
        (S = this.unsubscribeCallback) === null || S === void 0 || S.call(this)
    }
    listen(S) {
        return this.listeners.push(S),
        ()=>this.listeners = this.listeners.filter(E=>E !== S)
    }
    sendRequest(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const M = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug("Send injected-bridge request:", Object.assign(Object.assign({}, S), {
                id: M
            }));
            const T = this.injectedWallet.send(Object.assign(Object.assign({}, S), {
                id: M
            }));
            return T.then($=>logDebug("Wallet message received:", $)),
            E == null || E(),
            T
        })
    }
    _connect(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            try {
                logDebug(`Injected Provider connect request: protocolVersion: ${S}, message:`, E);
                const M = yield this.injectedWallet.connect(S, E);
                logDebug("Injected Provider connect response:", M),
                M.event === "connect" && (yield this.updateSession(),
                this.makeSubscriptions()),
                this.listeners.forEach(T=>T(M))
            } catch (M) {
                logDebug(M);
                const T = {
                    event: "connect_error",
                    payload: {
                        code: 0,
                        message: M == null ? void 0 : M.toString()
                    }
                };
                this.listeners.forEach($=>$(T))
            }
        })
    }
    makeSubscriptions() {
        this.listenSubscriptions = !0,
        this.unsubscribeCallback = this.injectedWallet.listen(S=>{
            logDebug("Wallet message received:", S),
            this.listenSubscriptions && this.listeners.forEach(E=>E(S)),
            S.event === "disconnect" && this.disconnect()
        }
        )
    }
    updateSession() {
        return this.connectionStorage.storeConnection({
            type: "injected",
            jsBridgeKey: this.injectedWalletKey,
            nextRpcRequestId: 0
        })
    }
}
InjectedProvider.window = getWindow$2();
class DefaultStorage {
    constructor() {
        this.localStorage = tryGetLocalStorage$1()
    }
    getItem(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return this.localStorage.getItem(S)
        })
    }
    removeItem(S) {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.localStorage.removeItem(S)
        })
    }
    setItem(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.localStorage.setItem(S, E)
        })
    }
}
function isWalletInfoCurrentlyInjected(C) {
    return isWalletInfoInjectable(C) && C.injected
}
function isWalletInfoCurrentlyEmbedded(C) {
    return isWalletInfoCurrentlyInjected(C) && C.embedded
}
function isWalletInfoInjectable(C) {
    return "jsBridgeKey"in C
}
function isWalletInfoRemote(C) {
    return "bridgeUrl"in C
}
const FALLBACK_WALLETS_LIST = [{
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }],
    platforms: ["ios", "android", "macos", "windows", "linux"]
}, {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }, {
        type: "js",
        key: "tonkeeper"
    }],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
}, {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [{
        type: "js",
        key: "openmask"
    }],
    platforms: ["chrome"]
}, {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [{
        type: "js",
        key: "mytonwallet"
    }, {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
    }],
    platforms: ["chrome", "windows", "macos", "linux"]
}, {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [{
        type: "js",
        key: "tonhub"
    }, {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
    }],
    platforms: ["ios", "android"]
}, {
    app_name: "tonflow",
    name: "TonFlow",
    image: "https://tonflow.net/assets/images/tonflow_ico_192.png",
    about_url: "https://tonflow.net",
    bridge: [{
        type: "js",
        key: "tonflow"
    }],
    platforms: ["chrome"]
}, {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://app.delabwallet.com/logo_black.png",
    about_url: "https://delabwallet.com",
    bridge: [{
        type: "js",
        key: "dewallet"
    }],
    platforms: ["chrome"]
}, {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [{
        type: "js",
        key: "xtonwallet"
    }],
    platforms: ["chrome", "firefox"]
}, {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [{
        type: "js",
        key: "tonwallet"
    }],
    platforms: ["chrome"]
}];
class WalletsListManager {
    constructor(S) {
        this.walletsListCache = null,
        this.walletsListCacheCreationTimestamp = null,
        this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json",
        S != null && S.walletsListSource && (this.walletsListSource = S.walletsListSource),
        S != null && S.cacheTTLMs && (this.cacheTTLMs = S.cacheTTLMs)
    }
    getWallets() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null),
            this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(),
            this.walletsListCache.then(()=>{
                this.walletsListCacheCreationTimestamp = Date.now()
            }
            ).catch(()=>{
                this.walletsListCache = null,
                this.walletsListCacheCreationTimestamp = null
            }
            )),
            this.walletsListCache
        })
    }
    getEmbeddedWallet() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const E = (yield this.getWallets()).filter(isWalletInfoCurrentlyEmbedded);
            return E.length !== 1 ? null : E[0]
        })
    }
    fetchWalletsList() {
        return __awaiter$2(this, void 0, void 0, function*() {
            let S = [];
            try {
                if (S = yield(yield fetch(this.walletsListSource)).json(),
                !Array.isArray(S))
                    throw new FetchWalletsError("Wrong wallets list format, wallets list must be an array.");
                const T = S.filter($=>!this.isCorrectWalletConfigDTO($));
                T.length && (logError$1(`Wallet(s) ${T.map($=>$.name).join(", ")} config format is wrong. They were removed from the wallets list.`),
                S = S.filter($=>this.isCorrectWalletConfigDTO($)))
            } catch (M) {
                logError$1(M),
                S = FALLBACK_WALLETS_LIST
            }
            let E = [];
            try {
                E = InjectedProvider.getCurrentlyInjectedWallets()
            } catch (M) {
                logError$1(M)
            }
            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(S), E)
        })
    }
    walletConfigDTOListToWalletConfigList(S) {
        return S.map(E=>{
            const T = {
                name: E.name,
                appName: E.app_name,
                imageUrl: E.image,
                aboutUrl: E.about_url,
                tondns: E.tondns,
                platforms: E.platforms
            };
            return E.bridge.forEach($=>{
                if ($.type === "sse" && (T.bridgeUrl = $.url,
                T.universalLink = E.universal_url,
                T.deepLink = E.deepLink),
                $.type === "js") {
                    const B = $.key;
                    T.jsBridgeKey = B,
                    T.injected = InjectedProvider.isWalletInjected(B),
                    T.embedded = InjectedProvider.isInsideWalletBrowser(B)
                }
            }
            ),
            T
        }
        )
    }
    mergeWalletsLists(S, E) {
        return [...new Set(S.concat(E).map(T=>T.name)).values()].map(T=>{
            const $ = S.find(O=>O.name === T)
              , B = E.find(O=>O.name === T);
            return Object.assign(Object.assign({}, $ && Object.assign({}, $)), B && Object.assign({}, B))
        }
        )
    }
    isCorrectWalletConfigDTO(S) {
        if (!S || typeof S != "object")
            return !1;
        const E = "name"in S
          , M = "app_name"in S
          , T = "image"in S
          , $ = "about_url"in S
          , B = "platforms"in S;
        if (!E || !T || !$ || !B || !M || !S.platforms || !Array.isArray(S.platforms) || !S.platforms.length || !("bridge"in S) || !Array.isArray(S.bridge) || !S.bridge.length)
            return !1;
        const O = S.bridge;
        if (O.some(U=>!U || typeof U != "object" || !("type"in U)))
            return !1;
        const F = O.find(U=>U.type === "sse");
        if (F && (!("url"in F) || !F.url || !S.universal_url))
            return !1;
        const N = O.find(U=>U.type === "js");
        return !(N && (!("key"in N) || !N.key))
    }
}
class WalletNotSupportFeatureError extends TonConnectError {
    get info() {
        return "Wallet doesn't support requested feature method."
    }
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype)
    }
}
function checkSendTransactionSupport(C, S) {
    const E = C.includes("SendTransaction")
      , M = C.find(T=>T && typeof T == "object" && T.name === "SendTransaction");
    if (!E && !M)
        throw new WalletNotSupportFeatureError("Wallet doesn't support SendTransaction feature.");
    if (M && M.maxMessages !== void 0) {
        if (M.maxMessages < S.requiredMessagesNumber)
            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${M.maxMessages}, but ${S.requiredMessagesNumber} is required.`);
        return
    }
    logWarning$1("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")
}
class TonConnect {
    constructor(S) {
        if (this.walletsList = new WalletsListManager,
        this._wallet = null,
        this.provider = null,
        this.statusChangeSubscriptions = [],
        this.statusChangeErrorSubscriptions = [],
        this.dappSettings = {
            manifestUrl: (S == null ? void 0 : S.manifestUrl) || getWebPageManifest(),
            storage: (S == null ? void 0 : S.storage) || new DefaultStorage
        },
        this.walletsList = new WalletsListManager({
            walletsListSource: S == null ? void 0 : S.walletsListSource,
            cacheTTLMs: S == null ? void 0 : S.walletsListCacheTTLMs
        }),
        !this.dappSettings.manifestUrl)
            throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage),
        S != null && S.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions()
    }
    static getWallets() {
        return this.walletsList.getWallets()
    }
    get connected() {
        return this._wallet !== null
    }
    get account() {
        var S;
        return ((S = this._wallet) === null || S === void 0 ? void 0 : S.account) || null
    }
    get wallet() {
        return this._wallet
    }
    set wallet(S) {
        this._wallet = S,
        this.statusChangeSubscriptions.forEach(E=>E(this._wallet))
    }
    getWallets() {
        return this.walletsList.getWallets()
    }
    onStatusChange(S, E) {
        return this.statusChangeSubscriptions.push(S),
        E && this.statusChangeErrorSubscriptions.push(E),
        ()=>{
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(M=>M !== S),
            E && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(M=>M !== E))
        }
    }
    connect(S, E) {
        var M;
        if (this.connected)
            throw new WalletAlreadyConnectedError;
        return (M = this.provider) === null || M === void 0 || M.closeConnection(),
        this.provider = this.createProvider(S),
        this.provider.connect(this.createConnectRequest(E))
    }
    restoreConnection() {
        return __awaiter$2(this, void 0, void 0, function*() {
            const [S,E] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);
            try {
                switch (S) {
                case "http":
                    this.provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);
                    break;
                case "injected":
                    this.provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);
                    break;
                default:
                    if (E)
                        this.provider = yield this.createProvider(E);
                    else
                        return
                }
            } catch {
                yield this.bridgeConnectionStorage.removeConnection(),
                this.provider = null;
                return
            }
            return this.provider.listen(this.walletEventsListener.bind(this)),
            this.provider.restoreConnection()
        })
    }
    sendTransaction(S, E) {
        return __awaiter$2(this, void 0, void 0, function*() {
            this.checkConnection(),
            checkSendTransactionSupport(this.wallet.device.features, {
                requiredMessagesNumber: S.messages.length
            });
            const {validUntil: M} = S
              , T = __rest$5(S, ["validUntil"])
              , $ = S.from || this.account.address
              , B = S.network || this.account.chain
              , O = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, T), {
                valid_until: M,
                from: $,
                network: B
            })), E);
            return sendTransactionParser.isError(O) ? sendTransactionParser.parseAndThrowError(O) : sendTransactionParser.convertFromRpcResponse(O)
        })
    }
    disconnect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (!this.connected)
                throw new WalletNotConnectedError;
            yield this.provider.disconnect(),
            this.onWalletDisconnected()
        })
    }
    pauseConnection() {
        var S;
        ((S = this.provider) === null || S === void 0 ? void 0 : S.type) === "http" && this.provider.pause()
    }
    unPauseConnection() {
        var S;
        return ((S = this.provider) === null || S === void 0 ? void 0 : S.type) !== "http" ? Promise.resolve() : this.provider.unPause()
    }
    addWindowFocusAndBlurSubscriptions() {
        const S = getDocument();
        if (S)
            try {
                S.addEventListener("visibilitychange", ()=>{
                    S.hidden ? this.pauseConnection() : this.unPauseConnection()
                }
                )
            } catch (E) {
                console.error("Cannot subscribe to the document.visibilitychange: ", E)
            }
    }
    createProvider(S) {
        let E;
        return !Array.isArray(S) && isWalletConnectionSourceJS(S) ? E = new InjectedProvider(this.dappSettings.storage,S.jsBridgeKey) : E = new BridgeProvider(this.dappSettings.storage,S),
        E.listen(this.walletEventsListener.bind(this)),
        E
    }
    walletEventsListener(S) {
        switch (S.event) {
        case "connect":
            this.onWalletConnected(S.payload);
            break;
        case "connect_error":
            this.onWalletConnectError(S.payload);
            break;
        case "disconnect":
            this.onWalletDisconnected()
        }
    }
    onWalletConnected(S) {
        const E = S.items.find($=>$.name === "ton_addr")
          , M = S.items.find($=>$.name === "ton_proof");
        if (!E)
            throw new TonConnectError("ton_addr connection item was not found");
        const T = {
            device: S.device,
            provider: this.provider.type,
            account: {
                address: E.address,
                chain: E.network,
                walletStateInit: E.walletStateInit,
                publicKey: E.publicKey
            }
        };
        M && (T.connectItems = {
            tonProof: M
        }),
        this.wallet = T
    }
    onWalletConnectError(S) {
        const E = connectErrorsParser.parseError(S);
        if (this.statusChangeErrorSubscriptions.forEach(M=>M(E)),
        console.debug(E),
        E instanceof ManifestNotFoundError || E instanceof ManifestContentErrorError)
            throw console.error(E),
            E
    }
    onWalletDisconnected() {
        this.wallet = null
    }
    checkConnection() {
        if (!this.connected)
            throw new WalletNotConnectedError
    }
    createConnectRequest(S) {
        const E = [{
            name: "ton_addr"
        }];
        return S != null && S.tonProof && E.push({
            name: "ton_proof",
            payload: S.tonProof
        }),
        {
            manifestUrl: this.dappSettings.manifestUrl,
            items: E
        }
    }
}
TonConnect.walletsList = new WalletsListManager;
TonConnect.isWalletInjected = C=>InjectedProvider.isWalletInjected(C);
TonConnect.isInsideWalletBrowser = C=>InjectedProvider.isInsideWalletBrowser(C);
const noBounceableTag = 81
  , testOnlyTag = 128;
function toUserFriendlyAddress(C, S=!1) {
    const {wc: E, hex: M} = parseHexAddress(C);
    let T = noBounceableTag;
    S && (T |= testOnlyTag);
    const $ = new Int8Array(34);
    $[0] = T,
    $[1] = E,
    $.set(M, 2);
    const B = new Uint8Array(36);
    return B.set($),
    B.set(crc16$3($), 34),
    Base64.encode(B).replace(/\+/g, "-").replace(/\//g, "_")
}
function parseHexAddress(C) {
    if (!C.includes(":"))
        throw new WrongAddressError(`Wrong address ${C}. Address must include ":".`);
    const S = C.split(":");
    if (S.length !== 2)
        throw new WrongAddressError(`Wrong address ${C}. Address must include ":" only once.`);
    const E = parseInt(S[0]);
    if (E !== 0 && E !== -1)
        throw new WrongAddressError(`Wrong address ${C}. WC must be eq 0 or -1, but ${E} received.`);
    const M = S[1];
    if ((M == null ? void 0 : M.length) !== 64)
        throw new WrongAddressError(`Wrong address ${C}. Hex part must be 64bytes length, but ${M == null ? void 0 : M.length} received.`);
    return {
        wc: E,
        hex: hexToBytes$8(M)
    }
}
function crc16$3(C) {
    let E = 0;
    const M = new Uint8Array(C.length + 2);
    M.set(C);
    for (let T of M) {
        let $ = 128;
        for (; $ > 0; )
            E <<= 1,
            T & $ && (E += 1),
            $ >>= 1,
            E > 65535 && (E &= 65535,
            E ^= 4129)
    }
    return new Uint8Array([Math.floor(E / 256), E % 256])
}
const toByteMap = {};
for (let C = 0; C <= 255; C++) {
    let S = C.toString(16);
    S.length < 2 && (S = "0" + S),
    toByteMap[S] = C
}
function hexToBytes$8(C) {
    C = C.toLowerCase();
    const S = C.length;
    if (S % 2 !== 0)
        throw new ParseHexError("Hex string must have length a multiple of 2: " + C);
    const E = S / 2
      , M = new Uint8Array(E);
    for (let T = 0; T < E; T++) {
        const $ = T * 2
          , B = C.substring($, $ + 2);
        if (!toByteMap.hasOwnProperty(B))
            throw new ParseHexError("Invalid hex character: " + B);
        M[T] = toByteMap[B]
    }
    return M
}
var uaParser = {
    exports: {}
};
(function(C, S) {
    (function(E, M) {
        var T = "1.0.37"
          , $ = ""
          , B = "?"
          , O = "function"
          , F = "undefined"
          , N = "object"
          , U = "string"
          , H = "major"
          , Z = "model"
          , J = "name"
          , ie = "type"
          , oe = "vendor"
          , ae = "version"
          , se = "architecture"
          , le = "console"
          , de = "mobile"
          , fe = "tablet"
          , pe = "smarttv"
          , ge = "wearable"
          , we = "embedded"
          , Ae = 500
          , Se = "Amazon"
          , ue = "Apple"
          , V = "ASUS"
          , W = "BlackBerry"
          , D = "Browser"
          , I = "Chrome"
          , L = "Edge"
          , K = "Firefox"
          , X = "Google"
          , Y = "Huawei"
          , j = "LG"
          , G = "Microsoft"
          , ne = "Motorola"
          , te = "Opera"
          , ce = "Samsung"
          , Ee = "Sharp"
          , Re = "Sony"
          , Te = "Xiaomi"
          , xe = "Zebra"
          , ve = "Facebook"
          , Me = "Chromium OS"
          , Fe = "Mac OS"
          , be = function(je, $e) {
            var Ie = {};
            for (var He in je)
                $e[He] && $e[He].length % 2 === 0 ? Ie[He] = $e[He].concat(je[He]) : Ie[He] = je[He];
            return Ie
        }
          , Ce = function(je) {
            for (var $e = {}, Ie = 0; Ie < je.length; Ie++)
                $e[je[Ie].toUpperCase()] = je[Ie];
            return $e
        }
          , ze = function(je, $e) {
            return typeof je === U ? Ge($e).indexOf(Ge(je)) !== -1 : !1
        }
          , Ge = function(je) {
            return je.toLowerCase()
        }
          , nt = function(je) {
            return typeof je === U ? je.replace(/[^\d\.]/g, $).split(".")[0] : M
        }
          , bt = function(je, $e) {
            if (typeof je === U)
                return je = je.replace(/^\s\s*/, $),
                typeof $e === F ? je : je.substring(0, Ae)
        }
          , ct = function(je, $e) {
            for (var Ie = 0, He, qe, Ne, at, Ye, it; Ie < $e.length && !Ye; ) {
                var At = $e[Ie]
                  , pt = $e[Ie + 1];
                for (He = qe = 0; He < At.length && !Ye && At[He]; )
                    if (Ye = At[He++].exec(je),
                    Ye)
                        for (Ne = 0; Ne < pt.length; Ne++)
                            it = Ye[++qe],
                            at = pt[Ne],
                            typeof at === N && at.length > 0 ? at.length === 2 ? typeof at[1] == O ? this[at[0]] = at[1].call(this, it) : this[at[0]] = at[1] : at.length === 3 ? typeof at[1] === O && !(at[1].exec && at[1].test) ? this[at[0]] = it ? at[1].call(this, it, at[2]) : M : this[at[0]] = it ? it.replace(at[1], at[2]) : M : at.length === 4 && (this[at[0]] = it ? at[3].call(this, it.replace(at[1], at[2])) : M) : this[at] = it || M;
                Ie += 2
            }
        }
          , De = function(je, $e) {
            for (var Ie in $e)
                if (typeof $e[Ie] === N && $e[Ie].length > 0) {
                    for (var He = 0; He < $e[Ie].length; He++)
                        if (ze($e[Ie][He], je))
                            return Ie === B ? M : Ie
                } else if (ze($e[Ie], je))
                    return Ie === B ? M : Ie;
            return je
        }
          , Ue = {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
        }
          , We = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            "8.1": "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , Xe = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [ae, [J, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [ae, [J, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [J, ae], [/opios[\/ ]+([\w\.]+)/i], [ae, [J, te + " Mini"]], [/\bopr\/([\w\.]+)/i], [ae, [J, te]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [ae, [J, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [J, ae], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [ae, [J, "UC" + D]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [ae, [J, "WeChat"]], [/konqueror\/([\w\.]+)/i], [ae, [J, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [ae, [J, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [ae, [J, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [ae, [J, "Smart Lenovo " + D]], [/(avast|avg)\/([\w\.]+)/i], [[J, /(.+)/, "$1 Secure " + D], ae], [/\bfocus\/([\w\.]+)/i], [ae, [J, K + " Focus"]], [/\bopt\/([\w\.]+)/i], [ae, [J, te + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [ae, [J, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [ae, [J, "Dolphin"]], [/coast\/([\w\.]+)/i], [ae, [J, te + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [ae, [J, "MIUI " + D]], [/fxios\/([-\w\.]+)/i], [ae, [J, K]], [/\bqihu|(qi?ho?o?|360)browser/i], [[J, "360 " + D]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[J, /(.+)/, "$1 " + D], ae], [/samsungbrowser\/([\w\.]+)/i], [ae, [J, ce + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[J, /_/g, " "], ae], [/metasr[\/ ]?([\d\.]+)/i], [ae, [J, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[J, "Sogou Mobile"], ae], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [J, ae], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [J], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[J, ve], ae], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [J, ae], [/\bgsa\/([\w\.]+) .*safari\//i], [ae, [J, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [ae, [J, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [ae, [J, I + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[J, I + " WebView"], ae], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [ae, [J, "Android " + D]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [J, ae], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [ae, [J, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [ae, J], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [J, [ae, De, Ue]], [/(webkit|khtml)\/([\w\.]+)/i], [J, ae], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[J, "Netscape"], ae], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [ae, [J, K + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [J, ae], [/(cobalt)\/([\w\.]+)/i], [J, [ae, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[se, "amd64"]], [/(ia32(?=;))/i], [[se, Ge]], [/((?:i[346]|x)86)[;\)]/i], [[se, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[se, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[se, "armhf"]], [/windows (ce|mobile); ppc;/i], [[se, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[se, /ower/, $, Ge]], [/(sun4\w)[;\)]/i], [[se, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[se, Ge]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [Z, [oe, ce], [ie, fe]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [Z, [oe, ce], [ie, de]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [Z, [oe, ue], [ie, de]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [Z, [oe, ue], [ie, fe]], [/(macintosh);/i], [Z, [oe, ue]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [Z, [oe, Ee], [ie, de]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [Z, [oe, Y], [ie, fe]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [Z, [oe, Y], [ie, de]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[Z, /_/g, " "], [oe, Te], [ie, de]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[Z, /_/g, " "], [oe, Te], [ie, fe]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [Z, [oe, "OPPO"], [ie, de]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [Z, [oe, "Vivo"], [ie, de]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [Z, [oe, "Realme"], [ie, de]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [Z, [oe, ne], [ie, de]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [Z, [oe, ne], [ie, fe]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [Z, [oe, j], [ie, fe]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [Z, [oe, j], [ie, de]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [Z, [oe, "Lenovo"], [ie, fe]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[Z, /_/g, " "], [oe, "Nokia"], [ie, de]], [/(pixel c)\b/i], [Z, [oe, X], [ie, fe]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [Z, [oe, X], [ie, de]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [Z, [oe, Re], [ie, de]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[Z, "Xperia Tablet"], [oe, Re], [ie, fe]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [Z, [oe, "OnePlus"], [ie, de]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [Z, [oe, Se], [ie, fe]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[Z, /(.+)/g, "Fire Phone $1"], [oe, Se], [ie, de]], [/(playbook);[-\w\),; ]+(rim)/i], [Z, oe, [ie, fe]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [Z, [oe, W], [ie, de]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [Z, [oe, V], [ie, fe]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [Z, [oe, V], [ie, de]], [/(nexus 9)/i], [Z, [oe, "HTC"], [ie, fe]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [oe, [Z, /_/g, " "], [ie, de]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [Z, [oe, "Acer"], [ie, fe]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [Z, [oe, "Meizu"], [ie, de]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [Z, [oe, "Ulefone"], [ie, de]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [oe, Z, [ie, de]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [oe, Z, [ie, fe]], [/(surface duo)/i], [Z, [oe, G], [ie, fe]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [Z, [oe, "Fairphone"], [ie, de]], [/(u304aa)/i], [Z, [oe, "AT&T"], [ie, de]], [/\bsie-(\w*)/i], [Z, [oe, "Siemens"], [ie, de]], [/\b(rct\w+) b/i], [Z, [oe, "RCA"], [ie, fe]], [/\b(venue[\d ]{2,7}) b/i], [Z, [oe, "Dell"], [ie, fe]], [/\b(q(?:mv|ta)\w+) b/i], [Z, [oe, "Verizon"], [ie, fe]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [Z, [oe, "Barnes & Noble"], [ie, fe]], [/\b(tm\d{3}\w+) b/i], [Z, [oe, "NuVision"], [ie, fe]], [/\b(k88) b/i], [Z, [oe, "ZTE"], [ie, fe]], [/\b(nx\d{3}j) b/i], [Z, [oe, "ZTE"], [ie, de]], [/\b(gen\d{3}) b.+49h/i], [Z, [oe, "Swiss"], [ie, de]], [/\b(zur\d{3}) b/i], [Z, [oe, "Swiss"], [ie, fe]], [/\b((zeki)?tb.*\b) b/i], [Z, [oe, "Zeki"], [ie, fe]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[oe, "Dragon Touch"], Z, [ie, fe]], [/\b(ns-?\w{0,9}) b/i], [Z, [oe, "Insignia"], [ie, fe]], [/\b((nxa|next)-?\w{0,9}) b/i], [Z, [oe, "NextBook"], [ie, fe]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[oe, "Voice"], Z, [ie, de]], [/\b(lvtel\-)?(v1[12]) b/i], [[oe, "LvTel"], Z, [ie, de]], [/\b(ph-1) /i], [Z, [oe, "Essential"], [ie, de]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [Z, [oe, "Envizen"], [ie, fe]], [/\b(trio[-\w\. ]+) b/i], [Z, [oe, "MachSpeed"], [ie, fe]], [/\btu_(1491) b/i], [Z, [oe, "Rotor"], [ie, fe]], [/(shield[\w ]+) b/i], [Z, [oe, "Nvidia"], [ie, fe]], [/(sprint) (\w+)/i], [oe, Z, [ie, de]], [/(kin\.[onetw]{3})/i], [[Z, /\./g, " "], [oe, G], [ie, de]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [Z, [oe, xe], [ie, fe]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [Z, [oe, xe], [ie, de]], [/smart-tv.+(samsung)/i], [oe, [ie, pe]], [/hbbtv.+maple;(\d+)/i], [[Z, /^/, "SmartTV"], [oe, ce], [ie, pe]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[oe, j], [ie, pe]], [/(apple) ?tv/i], [oe, [Z, ue + " TV"], [ie, pe]], [/crkey/i], [[Z, I + "cast"], [oe, X], [ie, pe]], [/droid.+aft(\w+)( bui|\))/i], [Z, [oe, Se], [ie, pe]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [Z, [oe, Ee], [ie, pe]], [/(bravia[\w ]+)( bui|\))/i], [Z, [oe, Re], [ie, pe]], [/(mitv-\w{5}) bui/i], [Z, [oe, Te], [ie, pe]], [/Hbbtv.*(technisat) (.*);/i], [oe, Z, [ie, pe]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[oe, bt], [Z, bt], [ie, pe]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[ie, pe]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [oe, Z, [ie, le]], [/droid.+; (shield) bui/i], [Z, [oe, "Nvidia"], [ie, le]], [/(playstation [345portablevi]+)/i], [Z, [oe, Re], [ie, le]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [Z, [oe, G], [ie, le]], [/((pebble))app/i], [oe, Z, [ie, ge]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [Z, [oe, ue], [ie, ge]], [/droid.+; (glass) \d/i], [Z, [oe, X], [ie, ge]], [/droid.+; (wt63?0{2,3})\)/i], [Z, [oe, xe], [ie, ge]], [/(quest( 2| pro)?)/i], [Z, [oe, ve], [ie, ge]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [oe, [ie, we]], [/(aeobc)\b/i], [Z, [oe, Se], [ie, we]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [Z, [ie, de]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [Z, [ie, fe]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[ie, fe]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[ie, de]], [/(android[-\w\. ]{0,9});.+buil/i], [Z, [oe, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [ae, [J, L + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [ae, [J, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [J, ae], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [ae, J]],
            os: [[/microsoft (windows) (vista|xp)/i], [J, ae], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [J, [ae, De, We]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[ae, De, We], [J, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[ae, /_/g, "."], [J, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[J, Fe], [ae, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [ae, J], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [J, ae], [/\(bb(10);/i], [ae, [J, W]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [ae, [J, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [ae, [J, K + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [ae, [J, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [ae, [J, "watchOS"]], [/crkey\/([\d\.]+)/i], [ae, [J, I + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[J, Me], ae], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [J, ae], [/(sunos) ?([\w\.\d]*)/i], [[J, "Solaris"], ae], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [J, ae]]
        }
          , ht = function(je, $e) {
            if (typeof je === N && ($e = je,
            je = M),
            !(this instanceof ht))
                return new ht(je,$e).getResult();
            var Ie = typeof E !== F && E.navigator ? E.navigator : M
              , He = je || (Ie && Ie.userAgent ? Ie.userAgent : $)
              , qe = Ie && Ie.userAgentData ? Ie.userAgentData : M
              , Ne = $e ? be(Xe, $e) : Xe
              , at = Ie && Ie.userAgent == He;
            return this.getBrowser = function() {
                var Ye = {};
                return Ye[J] = M,
                Ye[ae] = M,
                ct.call(Ye, He, Ne.browser),
                Ye[H] = nt(Ye[ae]),
                at && Ie && Ie.brave && typeof Ie.brave.isBrave == O && (Ye[J] = "Brave"),
                Ye
            }
            ,
            this.getCPU = function() {
                var Ye = {};
                return Ye[se] = M,
                ct.call(Ye, He, Ne.cpu),
                Ye
            }
            ,
            this.getDevice = function() {
                var Ye = {};
                return Ye[oe] = M,
                Ye[Z] = M,
                Ye[ie] = M,
                ct.call(Ye, He, Ne.device),
                at && !Ye[ie] && qe && qe.mobile && (Ye[ie] = de),
                at && Ye[Z] == "Macintosh" && Ie && typeof Ie.standalone !== F && Ie.maxTouchPoints && Ie.maxTouchPoints > 2 && (Ye[Z] = "iPad",
                Ye[ie] = fe),
                Ye
            }
            ,
            this.getEngine = function() {
                var Ye = {};
                return Ye[J] = M,
                Ye[ae] = M,
                ct.call(Ye, He, Ne.engine),
                Ye
            }
            ,
            this.getOS = function() {
                var Ye = {};
                return Ye[J] = M,
                Ye[ae] = M,
                ct.call(Ye, He, Ne.os),
                at && !Ye[J] && qe && qe.platform != "Unknown" && (Ye[J] = qe.platform.replace(/chrome os/i, Me).replace(/macos/i, Fe)),
                Ye
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return He
            }
            ,
            this.setUA = function(Ye) {
                return He = typeof Ye === U && Ye.length > Ae ? bt(Ye, Ae) : Ye,
                this
            }
            ,
            this.setUA(He),
            this
        };
        ht.VERSION = T,
        ht.BROWSER = Ce([J, ae, H]),
        ht.CPU = Ce([se]),
        ht.DEVICE = Ce([Z, oe, ie, le, de, pe, fe, ge, we]),
        ht.ENGINE = ht.OS = Ce([J, ae]),
        C.exports && (S = C.exports = ht),
        S.UAParser = ht;
        var Je = typeof E !== F && (E.jQuery || E.Zepto);
        if (Je && !Je.ua) {
            var ot = new ht;
            Je.ua = ot.getResult(),
            Je.ua.get = function() {
                return ot.getUA()
            }
            ,
            Je.ua.set = function(je) {
                ot.setUA(je);
                var $e = ot.getResult();
                for (var Ie in $e)
                    Je.ua[Ie] = $e[Ie]
            }
        }
    }
    )(typeof window == "object" ? window : commonjsGlobal)
}
)(uaParser, uaParser.exports);
var uaParserExports = uaParser.exports;
const UAParser = getDefaultExportFromCjs$1(uaParserExports);
var isMergeableObject = function C(S) {
    return isNonNullObject(S) && !isSpecial(S)
};
function isNonNullObject(C) {
    return !!C && typeof C == "object"
}
function isSpecial(C) {
    var S = Object.prototype.toString.call(C);
    return S === "[object RegExp]" || S === "[object Date]" || isReactElement(C)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(C) {
    return C.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(C) {
    return Array.isArray(C) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(C, S) {
    return S.clone !== !1 && S.isMergeableObject(C) ? deepmerge$2(emptyTarget(C), C, S) : C
}
function defaultArrayMerge(C, S, E) {
    return C.concat(S).map(function(M) {
        return cloneUnlessOtherwiseSpecified(M, E)
    })
}
function getMergeFunction(C, S) {
    if (!S.customMerge)
        return deepmerge$2;
    var E = S.customMerge(C);
    return typeof E == "function" ? E : deepmerge$2
}
function getEnumerableOwnPropertySymbols(C) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(C).filter(function(S) {
        return Object.propertyIsEnumerable.call(C, S)
    }) : []
}
function getKeys(C) {
    return Object.keys(C).concat(getEnumerableOwnPropertySymbols(C))
}
function propertyIsOnObject(C, S) {
    try {
        return S in C
    } catch {
        return !1
    }
}
function propertyIsUnsafe(C, S) {
    return propertyIsOnObject(C, S) && !(Object.hasOwnProperty.call(C, S) && Object.propertyIsEnumerable.call(C, S))
}
function mergeObject(C, S, E) {
    var M = {};
    return E.isMergeableObject(C) && getKeys(C).forEach(function(T) {
        M[T] = cloneUnlessOtherwiseSpecified(C[T], E)
    }),
    getKeys(S).forEach(function(T) {
        propertyIsUnsafe(C, T) || (propertyIsOnObject(C, T) && E.isMergeableObject(S[T]) ? M[T] = getMergeFunction(T, E)(C[T], S[T], E) : M[T] = cloneUnlessOtherwiseSpecified(S[T], E))
    }),
    M
}
function deepmerge$2(C, S, E) {
    E = E || {},
    E.arrayMerge = E.arrayMerge || defaultArrayMerge,
    E.isMergeableObject = E.isMergeableObject || isMergeableObject,
    E.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var M = Array.isArray(S)
      , T = Array.isArray(C)
      , $ = M === T;
    return $ ? M ? E.arrayMerge(C, S, E) : mergeObject(C, S, E) : cloneUnlessOtherwiseSpecified(S, E)
}
deepmerge$2.all = function C(S, E) {
    if (!Array.isArray(S))
        throw new Error("first argument should be an array");
    return S.reduce(function(M, T) {
        return deepmerge$2(M, T, E)
    }, {})
}
;
var deepmerge_1 = deepmerge$2
  , cjs = deepmerge_1;
const deepmerge$3 = getDefaultExportFromCjs$1(cjs);
var classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(C) {
    (function() {
        var S = {}.hasOwnProperty;
        function E() {
            for (var $ = "", B = 0; B < arguments.length; B++) {
                var O = arguments[B];
                O && ($ = T($, M(O)))
            }
            return $
        }
        function M($) {
            if (typeof $ == "string" || typeof $ == "number")
                return $;
            if (typeof $ != "object")
                return "";
            if (Array.isArray($))
                return E.apply(null, $);
            if ($.toString !== Object.prototype.toString && !$.toString.toString().includes("[native code]"))
                return $.toString();
            var B = "";
            for (var O in $)
                S.call($, O) && $[O] && (B = T(B, O));
            return B
        }
        function T($, B) {
            return B ? $ ? $ + " " + B : $ + B : $
        }
        C.exports ? (E.default = E,
        C.exports = E) : window.classNames = E
    }
    )()
}
)(classnames);
var classnamesExports = classnames.exports;
const classNames = getDefaultExportFromCjs$1(classnamesExports);
var __defProp$1 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (C,S,E)=>S in C ? __defProp$1(C, S, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: E
}) : C[S] = E, __spreadValues$1 = (C,S)=>{
    for (var E in S || (S = {}))
        __hasOwnProp$1.call(S, E) && __defNormalProp$1(C, E, S[E]);
    if (__getOwnPropSymbols$1)
        for (var E of __getOwnPropSymbols$1(S))
            __propIsEnum$1.call(S, E) && __defNormalProp$1(C, E, S[E]);
    return C
}
, __spreadProps = (C,S)=>__defProps(C, __getOwnPropDescs(S)), __publicField = (C,S,E)=>(__defNormalProp$1(C, typeof S != "symbol" ? S + "" : S, E),
E), __async = (C,S,E)=>new Promise((M,T)=>{
    var $ = F=>{
        try {
            O(E.next(F))
        } catch (N) {
            T(N)
        }
    }
      , B = F=>{
        try {
            O(E.throw(F))
        } catch (N) {
            T(N)
        }
    }
      , O = F=>F.done ? M(F.value) : Promise.resolve(F.value).then($, B);
    O((E = E.apply(C, S)).next())
}
), _a, _b, _c, _d, _e, _f, _g, _h;
const sharedConfig = {};
function setHydrateContext(C) {
    sharedConfig.context = C
}
const equalFn = (C,S)=>C === S
  , $PROXY = Symbol("solid-proxy")
  , $TRACK = Symbol("solid-track")
  , signalOptions = {
    equals: equalFn
};
let runEffects = runQueue;
const STALE = 1
  , PENDING = 2
  , UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
}
  , NO_INIT = {};
var Owner = null;
let Transition$1$1 = null
  , Listener = null
  , Updates = null
  , Effects = null
  , ExecCount = 0;
function createRoot$1(C, S) {
    const E = Listener
      , M = Owner
      , T = C.length === 0
      , $ = T ? UNOWNED : {
        owned: null,
        cleanups: null,
        context: null,
        owner: S === void 0 ? M : S
    }
      , B = T ? C : ()=>C(()=>untrack(()=>cleanNode($)));
    Owner = $,
    Listener = null;
    try {
        return runUpdates(B, !0)
    } finally {
        Listener = E,
        Owner = M
    }
}
function createSignal(C, S) {
    S = S ? Object.assign({}, signalOptions, S) : signalOptions;
    const E = {
        value: C,
        observers: null,
        observerSlots: null,
        comparator: S.equals || void 0
    }
      , M = T=>(typeof T == "function" && (T = T(E.value)),
    writeSignal(E, T));
    return [readSignal.bind(E), M]
}
function createComputed(C, S, E) {
    const M = createComputation(C, S, !0, STALE);
    updateComputation(M)
}
function createRenderEffect(C, S, E) {
    const M = createComputation(C, S, !1, STALE);
    updateComputation(M)
}
function createEffect(C, S, E) {
    runEffects = runUserEffects;
    const M = createComputation(C, S, !1, STALE);
    M.user = !0,
    Effects ? Effects.push(M) : updateComputation(M)
}
function createMemo(C, S, E) {
    E = E ? Object.assign({}, signalOptions, E) : signalOptions;
    const M = createComputation(C, S, !0, 0);
    return M.observers = null,
    M.observerSlots = null,
    M.comparator = E.equals || void 0,
    updateComputation(M),
    readSignal.bind(M)
}
function createResource(C, S, E) {
    let M, T, $;
    arguments.length === 2 && typeof S == "object" || arguments.length === 1 ? (M = !0,
    T = C,
    $ = S || {}) : (M = C,
    T = S,
    $ = E || {});
    let B = null
      , O = NO_INIT
      , F = null
      , N = !1
      , U = "initialValue"in $
      , H = typeof M == "function" && createMemo(M);
    const Z = new Set
      , [J,ie] = ($.storage || createSignal)($.initialValue)
      , [oe,ae] = createSignal(void 0)
      , [se,le] = createSignal(void 0, {
        equals: !1
    })
      , [de,fe] = createSignal(U ? "ready" : "unresolved");
    if (sharedConfig.context) {
        F = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
        let Se;
        $.ssrLoadFrom === "initial" ? O = $.initialValue : sharedConfig.load && (Se = sharedConfig.load(F)) && (O = Se[0])
    }
    function pe(Se, ue, V, W) {
        return B === Se && (B = null,
        U = !0,
        (Se === O || ue === O) && $.onHydrated && queueMicrotask(()=>$.onHydrated(W, {
            value: ue
        })),
        O = NO_INIT,
        ge(ue, V)),
        ue
    }
    function ge(Se, ue) {
        runUpdates(()=>{
            ue === void 0 && ie(()=>Se),
            fe(ue !== void 0 ? "errored" : "ready"),
            ae(ue);
            for (const V of Z.keys())
                V.decrement();
            Z.clear()
        }
        , !1)
    }
    function we() {
        const Se = SuspenseContext
          , ue = J()
          , V = oe();
        if (V !== void 0 && !B)
            throw V;
        return Listener && !Listener.user && Se && createComputed(()=>{
            se(),
            B && (Se.resolved || Z.has(Se) || (Se.increment(),
            Z.add(Se)))
        }
        ),
        ue
    }
    function Ae(Se=!0) {
        if (Se !== !1 && N)
            return;
        N = !1;
        const ue = H ? H() : M;
        if (ue == null || ue === !1) {
            pe(B, untrack(J));
            return
        }
        const V = O !== NO_INIT ? O : untrack(()=>T(ue, {
            value: J(),
            refetching: Se
        }));
        return typeof V != "object" || !(V && "then"in V) ? (pe(B, V, void 0, ue),
        V) : (B = V,
        N = !0,
        queueMicrotask(()=>N = !1),
        runUpdates(()=>{
            fe(U ? "refreshing" : "pending"),
            le()
        }
        , !1),
        V.then(W=>pe(V, W, void 0, ue), W=>pe(V, void 0, castError(W), ue)))
    }
    return Object.defineProperties(we, {
        state: {
            get: ()=>de()
        },
        error: {
            get: ()=>oe()
        },
        loading: {
            get() {
                const Se = de();
                return Se === "pending" || Se === "refreshing"
            }
        },
        latest: {
            get() {
                if (!U)
                    return we();
                const Se = oe();
                if (Se && !B)
                    throw Se;
                return J()
            }
        }
    }),
    H ? createComputed(()=>Ae(!1)) : Ae(!1),
    [we, {
        refetch: Ae,
        mutate: ie
    }]
}
function batch(C) {
    return runUpdates(C, !1)
}
function untrack(C) {
    if (Listener === null)
        return C();
    const S = Listener;
    Listener = null;
    try {
        return C()
    } finally {
        Listener = S
    }
}
function on(C, S, E) {
    const M = Array.isArray(C);
    let T, $ = E && E.defer;
    return B=>{
        let O;
        if (M) {
            O = Array(C.length);
            for (let N = 0; N < C.length; N++)
                O[N] = C[N]()
        } else
            O = C();
        if ($) {
            $ = !1;
            return
        }
        const F = untrack(()=>S(O, T, B));
        return T = O,
        F
    }
}
function onMount(C) {
    createEffect(()=>untrack(C))
}
function onCleanup(C) {
    return Owner === null || (Owner.cleanups === null ? Owner.cleanups = [C] : Owner.cleanups.push(C)),
    C
}
function getListener() {
    return Listener
}
function getOwner() {
    return Owner
}
function createContext(C, S) {
    const E = Symbol("context");
    return {
        id: E,
        Provider: createProvider$2(E),
        defaultValue: C
    }
}
function useContext(C) {
    let S;
    return (S = lookup(Owner, C.id)) !== void 0 ? S : C.defaultValue
}
function children(C) {
    const S = createMemo(C)
      , E = createMemo(()=>resolveChildren(S()));
    return E.toArray = ()=>{
        const M = E();
        return Array.isArray(M) ? M : M != null ? [M] : []
    }
    ,
    E
}
let SuspenseContext;
function readSignal() {
    const C = Transition$1$1;
    if (this.sources && (this.state || C))
        if (this.state === STALE || C)
            updateComputation(this);
        else {
            const S = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(this), !1),
            Updates = S
        }
    if (Listener) {
        const S = this.observers ? this.observers.length : 0;
        Listener.sources ? (Listener.sources.push(this),
        Listener.sourceSlots.push(S)) : (Listener.sources = [this],
        Listener.sourceSlots = [S]),
        this.observers ? (this.observers.push(Listener),
        this.observerSlots.push(Listener.sources.length - 1)) : (this.observers = [Listener],
        this.observerSlots = [Listener.sources.length - 1])
    }
    return this.value
}
function writeSignal(C, S, E) {
    let M = C.value;
    return (!C.comparator || !C.comparator(M, S)) && (C.value = S,
    C.observers && C.observers.length && runUpdates(()=>{
        for (let T = 0; T < C.observers.length; T += 1) {
            const $ = C.observers[T]
              , B = Transition$1$1 && Transition$1$1.running;
            B && Transition$1$1.disposed.has($),
            (B && !$.tState || !B && !$.state) && ($.pure ? Updates.push($) : Effects.push($),
            $.observers && markDownstream($)),
            B || ($.state = STALE)
        }
        if (Updates.length > 1e6)
            throw Updates = [],
            new Error
    }
    , !1)),
    S
}
function updateComputation(C) {
    if (!C.fn)
        return;
    cleanNode(C);
    const S = Owner
      , E = Listener
      , M = ExecCount;
    Listener = Owner = C,
    runComputation(C, C.value, M),
    Listener = E,
    Owner = S
}
function runComputation(C, S, E) {
    let M;
    try {
        M = C.fn(S)
    } catch (T) {
        C.pure && (C.state = STALE,
        C.owned && C.owned.forEach(cleanNode),
        C.owned = null),
        handleError(T)
    }
    (!C.updatedAt || C.updatedAt <= E) && (C.updatedAt != null && "observers"in C ? writeSignal(C, M) : C.value = M,
    C.updatedAt = E)
}
function createComputation(C, S, E, M=STALE, T) {
    const $ = {
        fn: C,
        state: M,
        updatedAt: null,
        owned: null,
        sources: null,
        sourceSlots: null,
        cleanups: null,
        value: S,
        owner: Owner,
        context: null,
        pure: E
    };
    return Owner === null || Owner !== UNOWNED && (Owner.owned ? Owner.owned.push($) : Owner.owned = [$]),
    $
}
function runTop(C) {
    const S = Transition$1$1;
    if (C.state === 0 || S)
        return;
    if (C.state === PENDING || S)
        return lookUpstream(C);
    if (C.suspense && untrack(C.suspense.inFallback))
        return C.suspense.effects.push(C);
    const E = [C];
    for (; (C = C.owner) && (!C.updatedAt || C.updatedAt < ExecCount); )
        (C.state || S) && E.push(C);
    for (let M = E.length - 1; M >= 0; M--)
        if (C = E[M],
        C.state === STALE || S)
            updateComputation(C);
        else if (C.state === PENDING || S) {
            const T = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(C, E[0]), !1),
            Updates = T
        }
}
function runUpdates(C, S) {
    if (Updates)
        return C();
    let E = !1;
    S || (Updates = []),
    Effects ? E = !0 : Effects = [],
    ExecCount++;
    try {
        const M = C();
        return completeUpdates(E),
        M
    } catch (M) {
        E || (Effects = null),
        Updates = null,
        handleError(M)
    }
}
function completeUpdates(C) {
    if (Updates && (runQueue(Updates),
    Updates = null),
    C)
        return;
    const S = Effects;
    Effects = null,
    S.length && runUpdates(()=>runEffects(S), !1)
}
function runQueue(C) {
    for (let S = 0; S < C.length; S++)
        runTop(C[S])
}
function runUserEffects(C) {
    let S, E = 0;
    for (S = 0; S < C.length; S++) {
        const M = C[S];
        M.user ? C[E++] = M : runTop(M)
    }
    for (sharedConfig.context && setHydrateContext(),
    S = 0; S < E; S++)
        runTop(C[S])
}
function lookUpstream(C, S) {
    const E = Transition$1$1;
    C.state = 0;
    for (let M = 0; M < C.sources.length; M += 1) {
        const T = C.sources[M];
        T.sources && (T.state === STALE || E ? T !== S && runTop(T) : (T.state === PENDING || E) && lookUpstream(T, S))
    }
}
function markDownstream(C) {
    const S = Transition$1$1;
    for (let E = 0; E < C.observers.length; E += 1) {
        const M = C.observers[E];
        (!M.state || S) && (M.state = PENDING,
        M.pure ? Updates.push(M) : Effects.push(M),
        M.observers && markDownstream(M))
    }
}
function cleanNode(C) {
    let S;
    if (C.sources)
        for (; C.sources.length; ) {
            const E = C.sources.pop()
              , M = C.sourceSlots.pop()
              , T = E.observers;
            if (T && T.length) {
                const $ = T.pop()
                  , B = E.observerSlots.pop();
                M < T.length && ($.sourceSlots[B] = M,
                T[M] = $,
                E.observerSlots[M] = B)
            }
        }
    if (C.owned) {
        for (S = 0; S < C.owned.length; S++)
            cleanNode(C.owned[S]);
        C.owned = null
    }
    if (C.cleanups) {
        for (S = 0; S < C.cleanups.length; S++)
            C.cleanups[S]();
        C.cleanups = null
    }
    C.state = 0,
    C.context = null
}
function castError(C) {
    return C instanceof Error || typeof C == "string" ? C : new Error("Unknown error")
}
function handleError(C) {
    throw C = castError(C),
    C
}
function lookup(C, S) {
    return C ? C.context && C.context[S] !== void 0 ? C.context[S] : lookup(C.owner, S) : void 0
}
function resolveChildren(C) {
    if (typeof C == "function" && !C.length)
        return resolveChildren(C());
    if (Array.isArray(C)) {
        const S = [];
        for (let E = 0; E < C.length; E++) {
            const M = resolveChildren(C[E]);
            Array.isArray(M) ? S.push.apply(S, M) : S.push(M)
        }
        return S
    }
    return C
}
function createProvider$2(C, S) {
    return function(M) {
        let T;
        return createRenderEffect(()=>T = untrack(()=>(Owner.context = {
            [C]: M.value
        },
        children(()=>M.children))), void 0),
        T
    }
}
const FALLBACK = Symbol("fallback");
function dispose(C) {
    for (let S = 0; S < C.length; S++)
        C[S]()
}
function mapArray(C, S, E={}) {
    let M = []
      , T = []
      , $ = []
      , B = 0
      , O = S.length > 1 ? [] : null;
    return onCleanup(()=>dispose($)),
    ()=>{
        let F = C() || [], N, U;
        return F[$TRACK],
        untrack(()=>{
            let Z = F.length, J, ie, oe, ae, se, le, de, fe, pe;
            if (Z === 0)
                B !== 0 && (dispose($),
                $ = [],
                M = [],
                T = [],
                B = 0,
                O && (O = [])),
                E.fallback && (M = [FALLBACK],
                T[0] = createRoot$1(ge=>($[0] = ge,
                E.fallback())),
                B = 1);
            else if (B === 0) {
                for (T = new Array(Z),
                U = 0; U < Z; U++)
                    M[U] = F[U],
                    T[U] = createRoot$1(H);
                B = Z
            } else {
                for (oe = new Array(Z),
                ae = new Array(Z),
                O && (se = new Array(Z)),
                le = 0,
                de = Math.min(B, Z); le < de && M[le] === F[le]; le++)
                    ;
                for (de = B - 1,
                fe = Z - 1; de >= le && fe >= le && M[de] === F[fe]; de--,
                fe--)
                    oe[fe] = T[de],
                    ae[fe] = $[de],
                    O && (se[fe] = O[de]);
                for (J = new Map,
                ie = new Array(fe + 1),
                U = fe; U >= le; U--)
                    pe = F[U],
                    N = J.get(pe),
                    ie[U] = N === void 0 ? -1 : N,
                    J.set(pe, U);
                for (N = le; N <= de; N++)
                    pe = M[N],
                    U = J.get(pe),
                    U !== void 0 && U !== -1 ? (oe[U] = T[N],
                    ae[U] = $[N],
                    O && (se[U] = O[N]),
                    U = ie[U],
                    J.set(pe, U)) : $[N]();
                for (U = le; U < Z; U++)
                    U in oe ? (T[U] = oe[U],
                    $[U] = ae[U],
                    O && (O[U] = se[U],
                    O[U](U))) : T[U] = createRoot$1(H);
                T = T.slice(0, B = Z),
                M = F.slice(0)
            }
            return T
        }
        );
        function H(Z) {
            if ($[U] = Z,
            O) {
                const [J,ie] = createSignal(U);
                return O[U] = ie,
                S(F[U], J)
            }
            return S(F[U])
        }
    }
}
function createComponent(C, S) {
    return untrack(()=>C(S || {}))
}
function trueFn() {
    return !0
}
const propTraps = {
    get(C, S, E) {
        return S === $PROXY ? E : C.get(S)
    },
    has(C, S) {
        return S === $PROXY ? !0 : C.has(S)
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(C, S) {
        return {
            configurable: !0,
            enumerable: !0,
            get() {
                return C.get(S)
            },
            set: trueFn,
            deleteProperty: trueFn
        }
    },
    ownKeys(C) {
        return C.keys()
    }
};
function resolveSource(C) {
    return (C = typeof C == "function" ? C() : C) ? C : {}
}
function mergeProps(...C) {
    let S = !1;
    for (let M = 0; M < C.length; M++) {
        const T = C[M];
        S = S || !!T && $PROXY in T,
        C[M] = typeof T == "function" ? (S = !0,
        createMemo(T)) : T
    }
    if (S)
        return new Proxy({
            get(M) {
                for (let T = C.length - 1; T >= 0; T--) {
                    const $ = resolveSource(C[T])[M];
                    if ($ !== void 0)
                        return $
                }
            },
            has(M) {
                for (let T = C.length - 1; T >= 0; T--)
                    if (M in resolveSource(C[T]))
                        return !0;
                return !1
            },
            keys() {
                const M = [];
                for (let T = 0; T < C.length; T++)
                    M.push(...Object.keys(resolveSource(C[T])));
                return [...new Set(M)]
            }
        },propTraps);
    const E = {};
    for (let M = C.length - 1; M >= 0; M--)
        if (C[M]) {
            const T = Object.getOwnPropertyDescriptors(C[M]);
            for (const $ in T)
                $ in E || Object.defineProperty(E, $, {
                    enumerable: !0,
                    get() {
                        for (let B = C.length - 1; B >= 0; B--) {
                            const O = (C[B] || {})[$];
                            if (O !== void 0)
                                return O
                        }
                    }
                })
        }
    return E
}
function splitProps$1(C, ...S) {
    const E = new Set(S.flat());
    if ($PROXY in C) {
        const T = S.map($=>new Proxy({
            get(B) {
                return $.includes(B) ? C[B] : void 0
            },
            has(B) {
                return $.includes(B) && B in C
            },
            keys() {
                return $.filter(B=>B in C)
            }
        },propTraps));
        return T.push(new Proxy({
            get($) {
                return E.has($) ? void 0 : C[$]
            },
            has($) {
                return E.has($) ? !1 : $ in C
            },
            keys() {
                return Object.keys(C).filter($=>!E.has($))
            }
        },propTraps)),
        T
    }
    const M = Object.getOwnPropertyDescriptors(C);
    return S.push(Object.keys(M).filter(T=>!E.has(T))),
    S.map(T=>{
        const $ = {};
        for (let B = 0; B < T.length; B++) {
            const O = T[B];
            O in C && Object.defineProperty($, O, M[O] ? M[O] : {
                get() {
                    return C[O]
                },
                set() {
                    return !0
                },
                enumerable: !0
            })
        }
        return $
    }
    )
}
function For(C) {
    const S = "fallback"in C && {
        fallback: ()=>C.fallback
    };
    return createMemo(mapArray(()=>C.each, C.children, S || void 0))
}
function Show(C) {
    let S = !1;
    const E = C.keyed
      , M = createMemo(()=>C.when, void 0, {
        equals: (T,$)=>S ? T === $ : !T == !$
    });
    return createMemo(()=>{
        const T = M();
        if (T) {
            const $ = C.children
              , B = typeof $ == "function" && $.length > 0;
            return S = E || B,
            B ? untrack(()=>$(T)) : $
        }
        return C.fallback
    }
    , void 0, void 0)
}
function Switch(C) {
    let S = !1
      , E = !1;
    const M = (B,O)=>B[0] === O[0] && (S ? B[1] === O[1] : !B[1] == !O[1]) && B[2] === O[2]
      , T = children(()=>C.children)
      , $ = createMemo(()=>{
        let B = T();
        Array.isArray(B) || (B = [B]);
        for (let O = 0; O < B.length; O++) {
            const F = B[O].when;
            if (F)
                return E = !!B[O].keyed,
                [O, F, B[O]]
        }
        return [-1]
    }
    , void 0, {
        equals: M
    });
    return createMemo(()=>{
        const [B,O,F] = $();
        if (B < 0)
            return C.fallback;
        const N = F.children
          , U = typeof N == "function" && N.length > 0;
        return S = E || U,
        U ? untrack(()=>N(O)) : N
    }
    , void 0, void 0)
}
function Match(C) {
    return C
}
const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"]
  , Properties = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans])
  , ChildProperties = new Set(["innerHTML", "textContent", "innerText", "children"])
  , Aliases = Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for"
})
  , PropAliases = Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly"
})
  , DelegatedEvents = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"])
  , SVGElements = new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"])
  , SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(C, S, E) {
    let M = E.length
      , T = S.length
      , $ = M
      , B = 0
      , O = 0
      , F = S[T - 1].nextSibling
      , N = null;
    for (; B < T || O < $; ) {
        if (S[B] === E[O]) {
            B++,
            O++;
            continue
        }
        for (; S[T - 1] === E[$ - 1]; )
            T--,
            $--;
        if (T === B) {
            const U = $ < M ? O ? E[O - 1].nextSibling : E[$ - O] : F;
            for (; O < $; )
                C.insertBefore(E[O++], U)
        } else if ($ === O)
            for (; B < T; )
                (!N || !N.has(S[B])) && S[B].remove(),
                B++;
        else if (S[B] === E[$ - 1] && E[O] === S[T - 1]) {
            const U = S[--T].nextSibling;
            C.insertBefore(E[O++], S[B++].nextSibling),
            C.insertBefore(E[--$], U),
            S[T] = E[$]
        } else {
            if (!N) {
                N = new Map;
                let H = O;
                for (; H < $; )
                    N.set(E[H], H++)
            }
            const U = N.get(S[B]);
            if (U != null)
                if (O < U && U < $) {
                    let H = B, Z = 1, J;
                    for (; ++H < T && H < $ && !((J = N.get(S[H])) == null || J !== U + Z); )
                        Z++;
                    if (Z > U - O) {
                        const ie = S[B];
                        for (; O < U; )
                            C.insertBefore(E[O++], ie)
                    } else
                        C.replaceChild(E[O++], S[B++])
                } else
                    B++;
            else
                S[B++].remove()
        }
    }
}
const $$EVENTS = "_$DX_DELEGATE";
function render$1(C, S, E, M={}) {
    let T;
    return createRoot$1($=>{
        T = $,
        S === document ? C() : insert$1(S, C(), S.firstChild ? null : void 0, E)
    }
    , M.owner),
    ()=>{
        T(),
        S.textContent = ""
    }
}
function template$1(C, S, E) {
    if (typeof window > "u")
        return null;
    const M = document.createElement("template");
    M.innerHTML = C;
    let T = M.content.firstChild;
    return E && (T = T.firstChild),
    T
}
function delegateEvents(C, S=window.document) {
    const E = S[$$EVENTS] || (S[$$EVENTS] = new Set);
    for (let M = 0, T = C.length; M < T; M++) {
        const $ = C[M];
        E.has($) || (E.add($),
        S.addEventListener($, eventHandler))
    }
}
function setAttribute(C, S, E) {
    E == null ? C.removeAttribute(S) : C.setAttribute(S, E)
}
function setAttributeNS(C, S, E, M) {
    M == null ? C.removeAttributeNS(S, E) : C.setAttributeNS(S, E, M)
}
function className(C, S) {
    S == null ? C.removeAttribute("class") : C.className = S
}
function addEventListener(C, S, E, M) {
    if (M)
        Array.isArray(E) ? (C[`$$${S}`] = E[0],
        C[`$$${S}Data`] = E[1]) : C[`$$${S}`] = E;
    else if (Array.isArray(E)) {
        const T = E[0];
        C.addEventListener(S, E[0] = $=>T.call(C, E[1], $))
    } else
        C.addEventListener(S, E)
}
function classList(C, S, E={}) {
    const M = Object.keys(S || {})
      , T = Object.keys(E);
    let $, B;
    for ($ = 0,
    B = T.length; $ < B; $++) {
        const O = T[$];
        !O || O === "undefined" || S[O] || (toggleClassKey(C, O, !1),
        delete E[O])
    }
    for ($ = 0,
    B = M.length; $ < B; $++) {
        const O = M[$]
          , F = !!S[O];
        !O || O === "undefined" || E[O] === F || !F || (toggleClassKey(C, O, !0),
        E[O] = F)
    }
    return E
}
function style$3(C, S, E) {
    if (!S)
        return E ? setAttribute(C, "style") : S;
    const M = C.style;
    if (typeof S == "string")
        return M.cssText = S;
    typeof E == "string" && (M.cssText = E = void 0),
    E || (E = {}),
    S || (S = {});
    let T, $;
    for ($ in E)
        S[$] == null && M.removeProperty($),
        delete E[$];
    for ($ in S)
        T = S[$],
        T !== E[$] && (M.setProperty($, T),
        E[$] = T);
    return E
}
function spread$1(C, S={}, E, M) {
    const T = {};
    return M || createRenderEffect(()=>T.children = insertExpression(C, S.children, T.children)),
    createRenderEffect(()=>S.ref && S.ref(C)),
    createRenderEffect(()=>assign$1(C, S, E, !0, T, !0)),
    T
}
function use(C, S, E) {
    return untrack(()=>C(S, E))
}
function insert$1(C, S, E, M) {
    if (E !== void 0 && !M && (M = []),
    typeof S != "function")
        return insertExpression(C, S, M, E);
    createRenderEffect(T=>insertExpression(C, S(), T, E), M)
}
function assign$1(C, S, E, M, T={}, $=!1) {
    S || (S = {});
    for (const B in T)
        if (!(B in S)) {
            if (B === "children")
                continue;
            T[B] = assignProp(C, B, null, T[B], E, $)
        }
    for (const B in S) {
        if (B === "children") {
            M || insertExpression(C, S.children);
            continue
        }
        const O = S[B];
        T[B] = assignProp(C, B, O, T[B], E, $)
    }
}
function getNextElement(C) {
    let S, E;
    return !sharedConfig.context || !(S = sharedConfig.registry.get(E = getHydrationKey())) ? C.cloneNode(!0) : (sharedConfig.completed && sharedConfig.completed.add(S),
    sharedConfig.registry.delete(E),
    S)
}
function toPropertyName(C) {
    return C.toLowerCase().replace(/-([a-z])/g, (S,E)=>E.toUpperCase())
}
function toggleClassKey(C, S, E) {
    const M = S.trim().split(/\s+/);
    for (let T = 0, $ = M.length; T < $; T++)
        C.classList.toggle(M[T], E)
}
function assignProp(C, S, E, M, T, $) {
    let B, O, F;
    if (S === "style")
        return style$3(C, E, M);
    if (S === "classList")
        return classList(C, E, M);
    if (E === M)
        return M;
    if (S === "ref")
        $ || E(C);
    else if (S.slice(0, 3) === "on:") {
        const N = S.slice(3);
        M && C.removeEventListener(N, M),
        E && C.addEventListener(N, E)
    } else if (S.slice(0, 10) === "oncapture:") {
        const N = S.slice(10);
        M && C.removeEventListener(N, M, !0),
        E && C.addEventListener(N, E, !0)
    } else if (S.slice(0, 2) === "on") {
        const N = S.slice(2).toLowerCase()
          , U = DelegatedEvents.has(N);
        if (!U && M) {
            const H = Array.isArray(M) ? M[0] : M;
            C.removeEventListener(N, H)
        }
        (U || E) && (addEventListener(C, N, E, U),
        U && delegateEvents([N]))
    } else if ((F = ChildProperties.has(S)) || !T && (PropAliases[S] || (O = Properties.has(S))) || (B = C.nodeName.includes("-")))
        S === "class" || S === "className" ? className(C, E) : B && !O && !F ? C[toPropertyName(S)] = E : C[PropAliases[S] || S] = E;
    else {
        const N = T && S.indexOf(":") > -1 && SVGNamespace[S.split(":")[0]];
        N ? setAttributeNS(C, N, S, E) : setAttribute(C, Aliases[S] || S, E)
    }
    return E
}
function eventHandler(C) {
    const S = `$$${C.type}`;
    let E = C.composedPath && C.composedPath()[0] || C.target;
    for (C.target !== E && Object.defineProperty(C, "target", {
        configurable: !0,
        value: E
    }),
    Object.defineProperty(C, "currentTarget", {
        configurable: !0,
        get() {
            return E || document
        }
    }),
    sharedConfig.registry && !sharedConfig.done && (sharedConfig.done = !0,
    document.querySelectorAll("[id^=pl-]").forEach(M=>{
        for (; M && M.nodeType !== 8 && M.nodeValue !== "pl-" + C; ) {
            let T = M.nextSibling;
            M.remove(),
            M = T
        }
        M && M.remove()
    }
    )); E; ) {
        const M = E[S];
        if (M && !E.disabled) {
            const T = E[`${S}Data`];
            if (T !== void 0 ? M.call(E, T, C) : M.call(E, C),
            C.cancelBubble)
                return
        }
        E = E._$host || E.parentNode || E.host
    }
}
function insertExpression(C, S, E, M, T) {
    for (sharedConfig.context && !E && (E = [...C.childNodes]); typeof E == "function"; )
        E = E();
    if (S === E)
        return E;
    const $ = typeof S
      , B = M !== void 0;
    if (C = B && E[0] && E[0].parentNode || C,
    $ === "string" || $ === "number") {
        if (sharedConfig.context)
            return E;
        if ($ === "number" && (S = S.toString()),
        B) {
            let O = E[0];
            O && O.nodeType === 3 ? O.data = S : O = document.createTextNode(S),
            E = cleanChildren(C, E, M, O)
        } else
            E !== "" && typeof E == "string" ? E = C.firstChild.data = S : E = C.textContent = S
    } else if (S == null || $ === "boolean") {
        if (sharedConfig.context)
            return E;
        E = cleanChildren(C, E, M)
    } else {
        if ($ === "function")
            return createRenderEffect(()=>{
                let O = S();
                for (; typeof O == "function"; )
                    O = O();
                E = insertExpression(C, O, E, M)
            }
            ),
            ()=>E;
        if (Array.isArray(S)) {
            const O = []
              , F = E && Array.isArray(E);
            if (normalizeIncomingArray(O, S, E, T))
                return createRenderEffect(()=>E = insertExpression(C, O, E, M, !0)),
                ()=>E;
            if (sharedConfig.context) {
                if (!O.length)
                    return E;
                for (let N = 0; N < O.length; N++)
                    if (O[N].parentNode)
                        return E = O
            }
            if (O.length === 0) {
                if (E = cleanChildren(C, E, M),
                B)
                    return E
            } else
                F ? E.length === 0 ? appendNodes(C, O, M) : reconcileArrays(C, E, O) : (E && cleanChildren(C),
                appendNodes(C, O));
            E = O
        } else if (S instanceof Node) {
            if (sharedConfig.context && S.parentNode)
                return E = B ? [S] : S;
            if (Array.isArray(E)) {
                if (B)
                    return E = cleanChildren(C, E, M, S);
                cleanChildren(C, E, null, S)
            } else
                E == null || E === "" || !C.firstChild ? C.appendChild(S) : C.replaceChild(S, C.firstChild);
            E = S
        }
    }
    return E
}
function normalizeIncomingArray(C, S, E, M) {
    let T = !1;
    for (let $ = 0, B = S.length; $ < B; $++) {
        let O = S[$]
          , F = E && E[$];
        if (O instanceof Node)
            C.push(O);
        else if (!(O == null || O === !0 || O === !1))
            if (Array.isArray(O))
                T = normalizeIncomingArray(C, O, F) || T;
            else if (typeof O == "function")
                if (M) {
                    for (; typeof O == "function"; )
                        O = O();
                    T = normalizeIncomingArray(C, Array.isArray(O) ? O : [O], Array.isArray(F) ? F : [F]) || T
                } else
                    C.push(O),
                    T = !0;
            else {
                const N = String(O);
                F && F.nodeType === 3 && F.data === N ? C.push(F) : C.push(document.createTextNode(N))
            }
    }
    return T
}
function appendNodes(C, S, E=null) {
    for (let M = 0, T = S.length; M < T; M++)
        C.insertBefore(S[M], E)
}
function cleanChildren(C, S, E, M) {
    if (E === void 0)
        return C.textContent = "";
    const T = M || document.createTextNode("");
    if (S.length) {
        let $ = !1;
        for (let B = S.length - 1; B >= 0; B--) {
            const O = S[B];
            if (T !== O) {
                const F = O.parentNode === C;
                !$ && !B ? F ? C.replaceChild(T, O) : C.insertBefore(T, E) : F && O.remove()
            } else
                $ = !0
        }
    } else
        C.insertBefore(T, E);
    return [T]
}
function getHydrationKey() {
    const C = sharedConfig.context;
    return `${C.id}${C.count++}`
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(C, S=!1) {
    return S ? document.createElementNS(SVG_NAMESPACE, C) : document.createElement(C)
}
function Portal$1(C) {
    const {useShadow: S} = C
      , E = document.createTextNode("")
      , M = C.mount || document.body;
    function T() {
        if (sharedConfig.context) {
            const [$,B] = createSignal(!1);
            return queueMicrotask(()=>B(!0)),
            ()=>$() && C.children
        } else
            return ()=>C.children
    }
    if (M instanceof HTMLHeadElement) {
        const [$,B] = createSignal(!1)
          , O = ()=>B(!0);
        createRoot$1(F=>insert$1(M, ()=>$() ? F() : T()(), null)),
        onCleanup(()=>{
            sharedConfig.context ? queueMicrotask(O) : O()
        }
        )
    } else {
        const $ = createElement(C.isSVG ? "g" : "div", C.isSVG)
          , B = S && $.attachShadow ? $.attachShadow({
            mode: "open"
        }) : $;
        Object.defineProperty($, "_$host", {
            get() {
                return E.parentNode
            },
            configurable: !0
        }),
        insert$1(B, T()),
        M.appendChild($),
        C.ref && C.ref($),
        onCleanup(()=>M.removeChild($))
    }
    return E
}
function Dynamic(C) {
    const [S,E] = splitProps$1(C, ["component"])
      , M = createMemo(()=>S.component);
    return createMemo(()=>{
        const T = M();
        switch (typeof T) {
        case "function":
            return untrack(()=>T(E));
        case "string":
            const $ = SVGElements.has(T)
              , B = sharedConfig.context ? getNextElement() : createElement(T, $);
            return spread$1(B, E, $),
            B
        }
    }
    )
}
var THEME = (C=>(C.DARK = "DARK",
C.LIGHT = "LIGHT",
C))(THEME || {});
let e$2 = {
    data: ""
}
  , t$4 = C=>typeof window == "object" ? ((C ? C.querySelector("#_goober") : window._goober) || Object.assign((C || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : C || e$2
  , l$3 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , a = /\/\*[^]*?\*\/|  +/g
  , n$3 = /\n+/g
  , o = (C,S)=>{
    let E = ""
      , M = ""
      , T = "";
    for (let $ in C) {
        let B = C[$];
        $[0] == "@" ? $[1] == "i" ? E = $ + " " + B + ";" : M += $[1] == "f" ? o(B, $) : $ + "{" + o(B, $[1] == "k" ? "" : S) + "}" : typeof B == "object" ? M += o(B, S ? S.replace(/([^,])+/g, O=>$.replace(/(^:.*)|([^,])+/g, F=>/&/.test(F) ? F.replace(/&/g, O) : O ? O + " " + F : F)) : $) : B != null && ($ = /^--/.test($) ? $ : $.replace(/[A-Z]/g, "-$&").toLowerCase(),
        T += o.p ? o.p($, B) : $ + ":" + B + ";")
    }
    return E + (S && T ? S + "{" + T + "}" : T) + M
}
  , c$2 = {}
  , s$1 = C=>{
    if (typeof C == "object") {
        let S = "";
        for (let E in C)
            S += E + s$1(C[E]);
        return S
    }
    return C
}
  , i = (C,S,E,M,T)=>{
    let $ = s$1(C)
      , B = c$2[$] || (c$2[$] = (F=>{
        let N = 0
          , U = 11;
        for (; N < F.length; )
            U = 101 * U + F.charCodeAt(N++) >>> 0;
        return "go" + U
    }
    )($));
    if (!c$2[B]) {
        let F = $ !== C ? C : (N=>{
            let U, H, Z = [{}];
            for (; U = l$3.exec(N.replace(a, "")); )
                U[4] ? Z.shift() : U[3] ? (H = U[3].replace(n$3, " ").trim(),
                Z.unshift(Z[0][H] = Z[0][H] || {})) : Z[0][U[1]] = U[2].replace(n$3, " ").trim();
            return Z[0]
        }
        )(C);
        c$2[B] = o(T ? {
            ["@keyframes " + B]: F
        } : F, E ? "" : "." + B)
    }
    let O = E && c$2.g ? c$2.g : null;
    return E && (c$2.g = c$2[B]),
    ((F,N,U,H)=>{
        H ? N.data = N.data.replace(H, F) : N.data.indexOf(F) === -1 && (N.data = U ? F + N.data : N.data + F)
    }
    )(c$2[B], S, M, O),
    B
}
  , p$2 = (C,S,E)=>C.reduce((M,T,$)=>{
    let B = S[$];
    if (B && B.call) {
        let O = B(E)
          , F = O && O.props && O.props.className || /^go/.test(O) && O;
        B = F ? "." + F : O && typeof O == "object" ? O.props ? "" : o(O, "") : O === !1 ? "" : O
    }
    return M + T + (B ?? "")
}
, "");
function u$1(C) {
    let S = this || {}
      , E = C.call ? C(S.p) : C;
    return i(E.unshift ? E.raw ? p$2(E, [].slice.call(arguments, 1), S.p) : E.reduce((M,T)=>Object.assign(M, T && T.call ? T(S.p) : T), {}) : E, t$4(S.target), S.g, S.o, S.k)
}
u$1.bind({
    g: 1
});
let h$2 = u$1.bind({
    k: 1
});
const ThemeContext$1 = createContext();
function ThemeProvider(C) {
    return createComponent(ThemeContext$1.Provider, {
        value: C.theme,
        get children() {
            return C.children
        }
    })
}
function useTheme$4() {
    return useContext(ThemeContext$1)
}
function makeStyled(C) {
    let S = this || {};
    return (...E)=>{
        const M = T=>{
            const $ = useContext(ThemeContext$1)
              , B = mergeProps(T, {
                theme: $
            })
              , O = mergeProps(B, {
                get class() {
                    const J = B.class
                      , ie = "class"in B && /^go[0-9]+/.test(J);
                    let oe = u$1.apply({
                        target: S.target,
                        o: ie,
                        p: B,
                        g: S.g
                    }, E);
                    return [J, oe].filter(Boolean).join(" ")
                }
            })
              , [F,N] = splitProps$1(O, ["as", "theme"])
              , U = N
              , H = F.as || C;
            let Z;
            return typeof H == "function" ? Z = H(U) : S.g == 1 ? (Z = document.createElement(H),
            spread$1(Z, U)) : Z = Dynamic(mergeProps({
                component: H
            }, U)),
            Z
        }
        ;
        return M.class = T=>untrack(()=>u$1.apply({
            target: S.target,
            p: T,
            g: S.g
        }, E)),
        M
    }
}
const styled$2 = new Proxy(makeStyled,{
    get(C, S) {
        return C(S)
    }
});
function createGlobalStyles() {
    const C = makeStyled.call({
        g: 1
    }, "div").apply(null, arguments);
    return function(E) {
        return C(E),
        null
    }
}
const globalStylesTag = "tc-root"
  , disableScrollClass = "tc-disable-scroll"
  , usingMouseClass = "tc-using-mouse"
  , GlobalStyles$1 = ()=>{
    document.body.addEventListener("mousedown", ()=>document.body.classList.add(usingMouseClass)),
    document.body.addEventListener("keydown", S=>{
        S.key === "Tab" && document.body.classList.remove(usingMouseClass)
    }
    );
    const C = createGlobalStyles`
    ${globalStylesTag} * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;        
        -webkit-tap-highlight-color: transparent;
    }
    
    ${globalStylesTag} img {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }   
 
    ${globalStylesTag} *:focus {
        outline: #08f auto 2px;
    }
    
    ${globalStylesTag} li {
        list-style: none;
    }
    
    ${globalStylesTag} button {
        outline: none;
    }
    
    body.${disableScrollClass} {
        position: fixed; 
        overflow-y: scroll;
        right: 0;
        left: 0;
    }
    
    body.${usingMouseClass} ${globalStylesTag} *:focus {
        outline: none;
    }
`;
    return createComponent(C, {})
}
;
function hexToRgb$1(C) {
    C[0] === "#" && (C = C.slice(1));
    const S = parseInt(C, 16)
      , E = S >> 16 & 255
      , M = S >> 8 & 255
      , T = S & 255;
    return [E, M, T].join(",")
}
function rgba(C, S) {
    return C[0] === "#" && (C = hexToRgb$1(C)),
    `rgba(${C}, ${S})`
}
function toPx(C) {
    return C.toString() + "px"
}
const _InMemoryStorage = class {
    constructor() {
        __publicField(this, "storage", {})
    }
    static getInstance() {
        return _InMemoryStorage.instance || (_InMemoryStorage.instance = new _InMemoryStorage),
        _InMemoryStorage.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(C) {
        var S;
        return (S = this.storage[C]) != null ? S : null
    }
    key(C) {
        var S;
        const E = Object.keys(this.storage);
        return C < 0 || C >= E.length ? null : (S = E[C]) != null ? S : null
    }
    removeItem(C) {
        delete this.storage[C]
    }
    setItem(C, S) {
        this.storage[C] = S
    }
}
;
let InMemoryStorage = _InMemoryStorage;
__publicField(InMemoryStorage, "instance");
class TonConnectUIError extends TonConnectError {
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, TonConnectUIError.prototype)
    }
}
function openLink$1(C, S="_self") {
    window.open(C, S, "noopener noreferrer")
}
function openLinkBlank(C) {
    openLink$1(C, "_blank")
}
function openDeeplinkWithFallback(C, S) {
    const E = ()=>{
        isBrowser$1("safari") || S()
    }
      , M = setTimeout(()=>E(), 200);
    window.addEventListener("blur", ()=>clearTimeout(M), {
        once: !0
    }),
    openLink$1(C, "_self")
}
function getSystemTheme() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? THEME.LIGHT : THEME.DARK
}
function subscribeToThemeChange(C) {
    const S = E=>C(E.matches ? THEME.DARK : THEME.LIGHT);
    return window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", S),
    ()=>window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", S)
}
function disableScroll() {
    document.documentElement.scrollHeight !== document.documentElement.clientHeight && (document.body.style.top = toPx(-document.documentElement.scrollTop),
    document.body.classList.add(disableScrollClass))
}
function enableScroll() {
    document.body.classList.remove(disableScrollClass),
    document.documentElement.scrollTo({
        top: -parseFloat(getComputedStyle(document.body).top)
    }),
    document.body.style.top = "auto"
}
function fixMobileSafariActiveTransition() {
    document.body.hasAttribute("ontouchstart") || document.body.setAttribute("ontouchstart", "")
}
function defineStylesRoot() {
    customElements.define(globalStylesTag, class extends HTMLElement {
    }
    )
}
function createMacrotask(C) {
    return __async(this, null, function*() {
        yield new Promise(S=>requestAnimationFrame(S)),
        C()
    })
}
function preloadImages(C) {
    document.readyState !== "complete" ? window.addEventListener("load", ()=>createMacrotask(()=>preloadImages(C)), {
        once: !0
    }) : C.forEach(S=>{
        const E = new window.Image;
        E.src = S
    }
    )
}
function getWindow$1() {
    if (typeof window < "u")
        return window
}
function tryGetLocalStorage() {
    if (isLocalStorageAvailable())
        return localStorage;
    if (isNodeJs())
        throw new TonConnectUIError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage.getInstance()
}
function isLocalStorageAvailable() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs() {
    return typeof process$1 < "u" && process$1.versions != null && process$1.versions.node != null
}
function getUserAgent() {
    var C, S;
    const E = new UAParser().getResult()
      , M = (C = E.os.name) == null ? void 0 : C.toLowerCase();
    let T;
    switch (!0) {
    case M === "ios":
        T = "ios";
        break;
    case M === "android":
        T = "android";
        break;
    case M === "mac os":
        T = "macos";
        break;
    case M === "linux":
        T = "linux";
        break;
    case (M == null ? void 0 : M.includes("windows")):
        T = "windows";
        break
    }
    const $ = (S = E.browser.name) == null ? void 0 : S.toLowerCase();
    let B;
    switch (!0) {
    case $ === "chrome":
        B = "chrome";
        break;
    case $ === "firefox":
        B = "firefox";
        break;
    case ($ == null ? void 0 : $.includes("safari")):
        B = "safari";
        break
    }
    return {
        os: T,
        browser: B
    }
}
function isOS(...C) {
    return C.includes(getUserAgent().os)
}
function isBrowser$1(...C) {
    return C.includes(getUserAgent().browser)
}
function toDeeplink(C, S) {
    const E = new URL(C);
    return S + E.search
}
class WalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setWalletInfo(S) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(S))
    }
    getWalletInfo() {
        const S = this.localStorage.getItem(this.storageKey);
        return S ? JSON.parse(S) : null
    }
    removeWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
class PreferredWalletStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_preferred-wallet"),
        this.localStorage = tryGetLocalStorage()
    }
    setPreferredWalletAppName(S) {
        this.localStorage.setItem(this.storageKey, S)
    }
    getPreferredWalletAppName() {
        return this.localStorage.getItem(this.storageKey) || void 0
    }
}
class LastSelectedWalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_last-selected-wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setLastSelectedWalletInfo(S) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(S))
    }
    getLastSelectedWalletInfo() {
        const S = this.localStorage.getItem(this.storageKey);
        return S ? JSON.parse(S) : null
    }
    removeLastSelectedWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
const [walletsModalState,setWalletsModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getWalletsModalIsOpened = createMemo(()=>walletsModalState().status === "opened");
let lastSelectedWalletInfoStorage = typeof window < "u" ? new LastSelectedWalletInfoStorage : void 0;
const [lastSelectedWalletInfo,_setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null)
  , setLastSelectedWalletInfo = C=>{
    lastSelectedWalletInfoStorage || (lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage),
    C ? lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(C) : lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo(),
    _setLastSelectedWalletInfo(C)
}
  , [action,setAction] = createSignal(null)
  , common$1$1 = {
    close: "Close",
    openWallet: "Open wallet",
    copyLink: "Copy Link",
    linkCopied: "Link Copied",
    copied: "Copied",
    yourWallet: "Your Wallet",
    retry: "Retry",
    get: "GET",
    mobile: "Mobile",
    browserExtension: "Browser Extension",
    desktop: "Desktop"
}
  , button$1 = {
    connectWallet: "Connect Wallet",
    dropdown: {
        copy: "Copy address",
        copied: "Address copied!",
        disconnect: "Disconnect"
    }
}
  , notifications$1 = {
    confirm: {
        header: "Open {{ name }} toconfirm thetransaction."
    },
    transactionSent: {
        header: "Transaction sent",
        text: "Your transactionwill beprocessed inafew seconds."
    },
    transactionCanceled: {
        header: "Transaction canceled",
        text: "There will be no changes toyour account."
    }
}
  , walletItem$1 = {
    walletOn: "Wallet On",
    recent: "Recent",
    installed: "Installed",
    popular: "Popular"
}
  , walletModal$1 = {
    loading: "Loading wallets",
    wallets: "Wallets",
    mobileUniversalModal: {
        connectYourWallet: "Connect your wallet",
        openWalletOnTelegramOrSelect: "Open Wallet in Telegram or select your wallet to connect",
        openWalletOnTelegram: "Open Wallet in Telegram",
        openLink: "Open Link",
        scan: "Scan with your mobile wallet"
    },
    desktopUniversalModal: {
        connectYourWallet: "Connect your wallet",
        scan: "Scan with your mobile wallet",
        availableWallets: "Available wallets"
    },
    mobileConnectionModal: {
        showQR: "Show QR Code",
        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
        continueIn: "Continue in {{ name }}",
        connectionDeclined: "Connection declined"
    },
    desktopConnectionModal: {
        scanQR: "Scan theQR code below with your phonesor{{ name }}s camera",
        continueInExtension: "Continue in{{ name }} browser extension",
        dontHaveExtension: "Seems you don't have installed {{ name }}browserextension",
        getWallet: "Get {{ name }}",
        continueOnDesktop: "Continue in{{ name }} on desktop",
        openWalletOnTelegram: "Open Wallet in Telegram on desktop",
        connectionDeclined: "Connection declined"
    },
    infoModal: {
        whatIsAWallet: "What is a wallet",
        secureDigitalAssets: "Secure digital assets storage",
        walletProtects: "A wallet protects and manages your digital assetsincluding TON, tokens and collectables.",
        controlIdentity: "Control your Web3 identity",
        manageIdentity: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.",
        effortlessCryptoTransactions: "Effortless crypto transactions",
        easilySend: "Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.",
        getAWallet: "Get a Wallet"
    }
}
  , actionModal$1 = {
    confirmTransaction: {
        header: "Confirm thetransaction in{{ name }}",
        text: "It will only take amoment."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , en$1 = {
    common: common$1$1,
    button: button$1,
    notifications: notifications$1,
    walletItem: walletItem$1,
    walletModal: walletModal$1,
    actionModal: actionModal$1
}
  , common$2 = {
    close: "",
    openWallet: " ",
    copyLink: " ",
    linkCopied: " ",
    copied: " ",
    yourWallet: " ",
    retry: "",
    get: "",
    mobile: "",
    browserExtension: "",
    desktop: ""
}
  , button$2 = {
    connectWallet: " ",
    dropdown: {
        copy: " ",
        copied: " !",
        disconnect: " "
    }
}
  , notifications = {
    confirm: {
        header: " {{ name }},  ."
    },
    transactionSent: {
        header: " ",
        text: "    ."
    },
    transactionCanceled: {
        header: " ",
        text: "   ."
    }
}
  , walletItem = {
    walletOn: "Wallet ",
    recent: "",
    installed: "",
    popular: ""
}
  , walletModal = {
    loading: " ",
    wallets: "",
    mobileUniversalModal: {
        connectYourWallet: " ",
        openWalletOnTelegramOrSelect: " Wallet Telegram   ",
        openWalletOnTelegram: " Wallet  Telegram",
        openLink: " ",
        scan: "  "
    },
    desktopUniversalModal: {
        connectYourWallet: " ",
        scan: " QR-  ",
        availableWallets: " "
    },
    mobileConnectionModal: {
        showQR: " QR-",
        scanQR: " QR-    {{ name }},  ",
        continueIn: "  {{ name }}",
        connectionDeclined: " "
    },
    desktopConnectionModal: {
        scanQR: " QR-    {{ name }},  ",
        continueInExtension: "   {{ name }}",
        dontHaveExtension: ",    {{ name }}",
        getWallet: " {{ name }}",
        continueOnDesktop: " {{ name }} ",
        openWalletOnTelegram: " Wallet Telegram",
        connectionDeclined: " "
    },
    infoModal: {
        whatIsAWallet: "  ?",
        secureDigitalAssets: "   ",
        walletProtects: "    ,  TON,   ,  .",
        controlIdentity: "   Web3",
        manageIdentity: "        .       .",
        effortlessCryptoTransactions: " ",
        easilySend: " ,    .      .",
        getAWallet: " "
    }
}
  , actionModal = {
    confirmTransaction: {
        header: "  {{ name }}",
        text: "   ."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , ru = {
    common: common$2,
    button: button$2,
    notifications,
    walletItem,
    walletModal,
    actionModal
}
  , i18nDictionary = {
    en: parseDictionary(en$1),
    ru: parseDictionary(ru)
};
function parseDictionary(C) {
    const S = "$"
      , E = M=>{
        Object.entries(M).forEach(([T,$])=>{
            if (typeof $ == "object" && $)
                return E($);
            if (typeof $ == "string") {
                if ($[0] === S) {
                    const B = $.slice(1).split(".");
                    let O = C;
                    B.forEach(F=>{
                        if (F in O)
                            O = O[F];
                        else
                            throw new Error(`Cannot parse translations: there is no property ${F} in translation`)
                    }
                    ),
                    M[T] = O
                }
                $.slice(0, 2) === `\\${S}` && (M[T] = $.slice(1))
            }
        }
        )
    }
    ;
    return E(C),
    C
}
const ConnectorContext = createContext()
  , $RAW = Symbol("store-raw")
  , $NODE = Symbol("store-node")
  , $NAME = Symbol("store-name");
function wrap$1(C, S) {
    let E = C[$PROXY];
    if (!E && (Object.defineProperty(C, $PROXY, {
        value: E = new Proxy(C,proxyTraps$1)
    }),
    !Array.isArray(C))) {
        const M = Object.keys(C)
          , T = Object.getOwnPropertyDescriptors(C);
        for (let $ = 0, B = M.length; $ < B; $++) {
            const O = M[$];
            T[O].get && Object.defineProperty(C, O, {
                enumerable: T[O].enumerable,
                get: T[O].get.bind(E)
            })
        }
    }
    return E
}
function isWrappable(C) {
    let S;
    return C != null && typeof C == "object" && (C[$PROXY] || !(S = Object.getPrototypeOf(C)) || S === Object.prototype || Array.isArray(C))
}
function unwrap(C, S=new Set) {
    let E, M, T, $;
    if (E = C != null && C[$RAW])
        return E;
    if (!isWrappable(C) || S.has(C))
        return C;
    if (Array.isArray(C)) {
        Object.isFrozen(C) ? C = C.slice(0) : S.add(C);
        for (let B = 0, O = C.length; B < O; B++)
            T = C[B],
            (M = unwrap(T, S)) !== T && (C[B] = M)
    } else {
        Object.isFrozen(C) ? C = Object.assign({}, C) : S.add(C);
        const B = Object.keys(C)
          , O = Object.getOwnPropertyDescriptors(C);
        for (let F = 0, N = B.length; F < N; F++)
            $ = B[F],
            !O[$].get && (T = C[$],
            (M = unwrap(T, S)) !== T && (C[$] = M))
    }
    return C
}
function getDataNodes(C) {
    let S = C[$NODE];
    return S || Object.defineProperty(C, $NODE, {
        value: S = {}
    }),
    S
}
function getDataNode(C, S, E) {
    return C[S] || (C[S] = createDataNode(E))
}
function proxyDescriptor$1(C, S) {
    const E = Reflect.getOwnPropertyDescriptor(C, S);
    return !E || E.get || !E.configurable || S === $PROXY || S === $NODE || S === $NAME || (delete E.value,
    delete E.writable,
    E.get = ()=>C[$PROXY][S]),
    E
}
function trackSelf(C) {
    if (getListener()) {
        const S = getDataNodes(C);
        (S._ || (S._ = createDataNode()))()
    }
}
function ownKeys$1(C) {
    return trackSelf(C),
    Reflect.ownKeys(C)
}
function createDataNode(C) {
    const [S,E] = createSignal(C, {
        equals: !1,
        internal: !0
    });
    return S.$ = E,
    S
}
const proxyTraps$1 = {
    get(C, S, E) {
        if (S === $RAW)
            return C;
        if (S === $PROXY)
            return E;
        if (S === $TRACK)
            return trackSelf(C),
            E;
        const M = getDataNodes(C)
          , T = M.hasOwnProperty(S);
        let $ = T ? M[S]() : C[S];
        if (S === $NODE || S === "__proto__")
            return $;
        if (!T) {
            const B = Object.getOwnPropertyDescriptor(C, S);
            getListener() && (typeof $ != "function" || C.hasOwnProperty(S)) && !(B && B.get) && ($ = getDataNode(M, S, $)())
        }
        return isWrappable($) ? wrap$1($) : $
    },
    has(C, S) {
        return S === $RAW || S === $PROXY || S === $TRACK || S === $NODE || S === "__proto__" ? !0 : (this.get(C, S, C),
        S in C)
    },
    set() {
        return !0
    },
    deleteProperty() {
        return !0
    },
    ownKeys: ownKeys$1,
    getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(C, S, E, M=!1) {
    if (!M && C[S] === E)
        return;
    const T = C[S]
      , $ = C.length;
    E === void 0 ? delete C[S] : C[S] = E;
    let B = getDataNodes(C), O;
    (O = getDataNode(B, S, T)) && O.$(()=>E),
    Array.isArray(C) && C.length !== $ && (O = getDataNode(B, "length", $)) && O.$(C.length),
    (O = B._) && O.$()
}
function mergeStoreNode(C, S) {
    const E = Object.keys(S);
    for (let M = 0; M < E.length; M += 1) {
        const T = E[M];
        setProperty(C, T, S[T])
    }
}
function updateArray(C, S) {
    if (typeof S == "function" && (S = S(C)),
    S = unwrap(S),
    Array.isArray(S)) {
        if (C === S)
            return;
        let E = 0
          , M = S.length;
        for (; E < M; E++) {
            const T = S[E];
            C[E] !== T && setProperty(C, E, T)
        }
        setProperty(C, "length", M)
    } else
        mergeStoreNode(C, S)
}
function updatePath(C, S, E=[]) {
    let M, T = C;
    if (S.length > 1) {
        M = S.shift();
        const B = typeof M
          , O = Array.isArray(C);
        if (Array.isArray(M)) {
            for (let F = 0; F < M.length; F++)
                updatePath(C, [M[F]].concat(S), E);
            return
        } else if (O && B === "function") {
            for (let F = 0; F < C.length; F++)
                M(C[F], F) && updatePath(C, [F].concat(S), E);
            return
        } else if (O && B === "object") {
            const {from: F=0, to: N=C.length - 1, by: U=1} = M;
            for (let H = F; H <= N; H += U)
                updatePath(C, [H].concat(S), E);
            return
        } else if (S.length > 1) {
            updatePath(C[M], S, [M].concat(E));
            return
        }
        T = C[M],
        E = [M].concat(E)
    }
    let $ = S[0];
    typeof $ == "function" && ($ = $(T, E),
    $ === T) || M === void 0 && $ == null || ($ = unwrap($),
    M === void 0 || isWrappable(T) && isWrappable($) && !Array.isArray($) ? mergeStoreNode(T, $) : setProperty(C, M, $))
}
function createStore(...[C,S]) {
    const E = unwrap(C || {})
      , M = Array.isArray(E)
      , T = wrap$1(E);
    function $(...B) {
        batch(()=>{
            M && B.length === 1 ? updateArray(E, B[0]) : updatePath(E, B)
        }
        )
    }
    return [T, $]
}
const defaultLightColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#0098EA",
    telegramButton: "#0098EA",
    icon: {
        primary: "#0F0F0F",
        secondary: "#7A8999",
        tertiary: "#C1CAD2",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#FFFFFF",
        secondary: "#F1F3F5",
        segment: "#FFFFFF",
        tint: "#F1F3F5",
        qr: "#F1F3F5"
    },
    text: {
        primary: "#0F0F0F",
        secondary: "#6A7785"
    }
}
  , defaultDarkColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#E5E5EA",
    telegramButton: "#31A6F5",
    icon: {
        primary: "#E5E5EA",
        secondary: "#909099",
        tertiary: "#434347",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#121214",
        secondary: "#18181A",
        segment: "#262629",
        tint: "#222224",
        qr: "#FFFFFF"
    },
    text: {
        primary: "#E5E5EA",
        secondary: "#7D7D85"
    }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$4(C) {
    return Object.prototype.toString.call(C) === "[object Object]"
}
function isPlainObject$3(C) {
    var S, E;
    return isObject$4(C) === !1 ? !1 : (S = C.constructor,
    S === void 0 ? !0 : (E = S.prototype,
    !(isObject$4(E) === !1 || E.hasOwnProperty("isPrototypeOf") === !1)))
}
function mergeOptions(C, S) {
    return C ? deepmerge$3(S, C, {
        arrayMerge: (M,T,$)=>T,
        isMergeableObject: isPlainObject$3
    }) : S
}
const [themeState,setThemeState] = createStore({
    theme: THEME.LIGHT,
    colors: defaultLightColorsSet,
    borderRadius: "m"
})
  , themeColorsMappingDefault = {
    [THEME.LIGHT]: defaultLightColorsSet,
    [THEME.DARK]: defaultDarkColorsSet
}
  , themeCustomColors = {
    [THEME.LIGHT]: void 0,
    [THEME.DARK]: void 0
};
function setTheme(C, S) {
    S && (themeCustomColors[THEME.DARK] = mergeOptions(S[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(S[THEME.LIGHT], themeCustomColors[THEME.LIGHT])),
    setThemeState({
        theme: C,
        colors: mergeOptions(themeCustomColors[C], themeColorsMappingDefault[C])
    })
}
function setBorderRadius(C) {
    setThemeState({
        borderRadius: C
    })
}
function setColors(C) {
    themeCustomColors[THEME.DARK] = mergeOptions(C[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(C[THEME.LIGHT], themeCustomColors[THEME.LIGHT]),
    setThemeState(S=>({
        colors: mergeOptions(themeCustomColors[S.theme], themeColorsMappingDefault[S.theme])
    }))
}
const ImagePlaceholder = styled$2.div`
    background-color: ${C=>C.theme.colors.background.secondary};
`
  , Image = C=>{
    let S;
    const [E,M] = createSignal(null);
    return createEffect(()=>{
        const T = new window.Image;
        return T.src = C.src,
        T.alt = C.alt || "",
        T.setAttribute("draggable", "false"),
        C.class && T.classList.add(C.class),
        T.complete ? M(T) : (T.addEventListener("load", ()=>M(T)),
        ()=>T.removeEventListener("load", ()=>M(T)))
    }
    ),
    [createComponent(Show, {
        get when() {
            return E()
        },
        get children() {
            return E()
        }
    }), createComponent(Show, {
        get when() {
            return !E()
        },
        get children() {
            return createComponent(ImagePlaceholder, {
                get class() {
                    return C.class
                },
                ref(T) {
                    const $ = S;
                    typeof $ == "function" ? $(T) : S = T
                }
            })
        }
    })]
}
;
function logError(...C) {
    try {
        console.error("[TON_CONNECT_UI]", ...C)
    } catch {}
}
function logWarning(...C) {
    try {
        console.warn("[TON_CONNECT_UI]", ...C)
    } catch {}
}
let initParams = {};
try {
    let C = location.hash.toString();
    initParams = urlParseHashParams(C)
} catch (C) {}
let tmaPlatform = "unknown";
initParams != null && initParams.tgWebAppPlatform && (tmaPlatform = (_a = initParams.tgWebAppPlatform) != null ? _a : "unknown");
if (tmaPlatform === "unknown") {
    const C = getWindow$1();
    tmaPlatform = (_d = (_c = (_b = C == null ? void 0 : C.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : "unknown"
}
let webAppVersion = "6.0";
initParams != null && initParams.tgWebAppVersion && (webAppVersion = initParams.tgWebAppVersion);
if (!webAppVersion) {
    const C = getWindow$1();
    webAppVersion = (_g = (_f = (_e = C == null ? void 0 : C.Telegram) == null ? void 0 : _e.WebApp) == null ? void 0 : _f.version) != null ? _g : "6.0"
}
function isTmaPlatform(...C) {
    return C.includes(tmaPlatform)
}
function isInTMA() {
    var C;
    return tmaPlatform !== "unknown" || !!((C = getWindow$1()) != null && C.TelegramWebviewProxy)
}
function sendExpand() {
    postEvent("web_app_expand", {})
}
function sendOpenTelegramLink(C) {
    const S = new URL(C);
    if (S.protocol !== "http:" && S.protocol !== "https:")
        throw new TonConnectUIError(`Url protocol is not supported: ${S}`);
    if (S.hostname !== "t.me")
        throw new TonConnectUIError(`Url host is not supported: ${S}`);
    const E = S.pathname + S.search;
    isIframe() || versionAtLeast("6.1") ? postEvent("web_app_open_tg_link", {
        path_full: E
    }) : openLinkBlank("https://t.me" + E)
}
function isIframe() {
    try {
        const C = getWindow$1();
        return C ? C.parent != null && C !== C.parent : !1
    } catch {
        return !1
    }
}
function postEvent(C, S) {
    try {
        const E = getWindow$1();
        if (!E)
            throw new TonConnectUIError("Can't post event to parent window: window is not defined");
        if (E.TelegramWebviewProxy !== void 0)
            E.TelegramWebviewProxy.postEvent(C, JSON.stringify(S));
        else if (E.external && "notify"in E.external)
            E.external.notify(JSON.stringify({
                eventType: C,
                eventData: S
            }));
        else if (isIframe()) {
            const M = "*"
              , T = JSON.stringify({
                eventType: C,
                eventData: S
            });
            E.parent.postMessage(T, M)
        } else
            throw new TonConnectUIError("Can't post event to TMA")
    } catch (E) {
        logError(`Can't post event to parent window: ${E}`)
    }
}
function urlParseHashParams(C) {
    C = C.replace(/^#/, "");
    let S = {};
    if (!C.length)
        return S;
    if (C.indexOf("=") < 0 && C.indexOf("?") < 0)
        return S._path = urlSafeDecode(C),
        S;
    let E = C.indexOf("?");
    if (E >= 0) {
        let T = C.substr(0, E);
        S._path = urlSafeDecode(T),
        C = C.substr(E + 1)
    }
    let M = urlParseQueryString(C);
    for (let T in M)
        S[T] = M[T];
    return S
}
function urlSafeDecode(C) {
    try {
        return C = C.replace(/\+/g, "%20"),
        decodeURIComponent(C)
    } catch {
        return C
    }
}
function urlParseQueryString(C) {
    let S = {};
    if (!C.length)
        return S;
    let E = C.split("&"), M, T, $, B;
    for (M = 0; M < E.length; M++)
        T = E[M].split("="),
        $ = urlSafeDecode(T[0]),
        B = T[1] == null ? null : urlSafeDecode(T[1]),
        S[$] = B;
    return S
}
function versionCompare(C, S) {
    typeof C != "string" && (C = ""),
    typeof S != "string" && (S = "");
    let E = C.replace(/^\s+|\s+$/g, "").split("."), M = S.replace(/^\s+|\s+$/g, "").split("."), T, $, B, O;
    for (T = Math.max(E.length, M.length),
    $ = 0; $ < T; $++)
        if (B = parseInt(E[$]) || 0,
        O = parseInt(M[$]) || 0,
        B !== O)
            return B > O ? 1 : -1;
    return 0
}
function versionAtLeast(C) {
    return versionCompare(webAppVersion, C) >= 0
}
const maxWidth$1 = {
    mobile: 440,
    tablet: 1020
};
function isDevice(C) {
    const S = getWindow$1();
    if (!S)
        return C === "desktop";
    if (isTmaPlatform("weba"))
        return !0;
    const E = S.innerWidth;
    switch (C) {
    case "desktop":
        return E > maxWidth$1.tablet;
    case "tablet":
        return E > maxWidth$1.mobile;
    default:
    case "mobile":
        return E <= maxWidth$1.mobile
    }
}
function media(C) {
    switch (C) {
    case "mobile":
        return `@media (max-width: ${maxWidth$1.mobile}px)`;
    case "tablet":
        return `@media (max-width: ${maxWidth$1.tablet}px) (min-width: ${maxWidth$1.mobile}px)`;
    default:
    case "desktop":
        return `@media (min-width: ${maxWidth$1.tablet}px)`
    }
}
const mediaTouch = "@media (hover: none)"
  , mediaNotTouch = "@media not all and (hover: none)"
  , borders$5 = {
    m: "100vh",
    s: "8px",
    none: "0"
}
  , scaleValues = {
    s: .02,
    m: .04
}
  , ButtonStyled$1 = styled$2.button`
    display: ${C=>C.leftIcon || C.rightIcon ? "flex" : "inline-block"};
    gap: ${C=>C.leftIcon || C.rightIcon ? "6px" : "unset"};
    align-items: ${C=>C.leftIcon || C.rightIcon ? "center" : "unset"};
    justify-content: ${C=>C.leftIcon || C.rightIcon ? "space-between" : "unset"};
    background-color: ${C=>C.appearance === "flat" ? "transparent" : C.appearance === "secondary" ? C.theme.colors.background.tint : rgba(C.theme.colors.accent, .12)};
    color: ${C=>C.appearance === "secondary" ? C.theme.colors.text.primary : C.theme.colors.accent};

    padding: ${C=>C.appearance === "flat" ? "0" : "9px 16px"};
    padding-left: ${C=>C.leftIcon && C.appearance !== "flat" ? "12px" : "16px"};
    padding-right: ${C=>C.rightIcon && C.appearance !== "flat" ? "12px" : "16px"};
    border: none;
    border-radius: ${C=>borders$5[C.theme.borderRadius]};
    cursor: ${C=>C.disabled ? "not-allowed" : "pointer"};

    font-size: 14px;
    font-weight: 590;
    line-height: 18px;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: ${C=>C.disabled ? "unset" : `scale(${1 + scaleValues[C.scale]})`};
        }
    }

    &:active {
        transform: ${C=>C.disabled ? "unset" : `scale(${1 - scaleValues[C.scale]})`};
    }

    ${mediaTouch} {
        &:active {
            transform: ${C=>C.disabled ? "unset" : `scale(${1 - scaleValues[C.scale] * 2})`};
        }
    }
`;
function useDataAttributes(C) {
    const S = untrack(()=>Object.keys(C).filter(M=>M.startsWith("data-")))
      , [E] = splitProps$1(C, S);
    return E
}
const Button = C=>{
    const S = useDataAttributes(C);
    return createComponent(ButtonStyled$1, mergeProps({
        get appearance() {
            return C.appearance || "primary"
        },
        get class() {
            return C.class
        },
        onClick: E=>{
            var M;
            return (M = C.onClick) == null ? void 0 : M.call(C, E)
        }
        ,
        onMouseEnter: E=>{
            var M;
            return (M = C.onMouseEnter) == null ? void 0 : M.call(C, E)
        }
        ,
        onMouseLeave: E=>{
            var M;
            return (M = C.onMouseLeave) == null ? void 0 : M.call(C, E)
        }
        ,
        ref(E) {
            const M = C.ref;
            typeof M == "function" ? M(E) : C.ref = E
        },
        get disabled() {
            return C.disabled
        },
        get scale() {
            return C.scale || "m"
        },
        get leftIcon() {
            return !!C.leftIcon
        },
        get rightIcon() {
            return !!C.rightIcon
        },
        "data-tc-button": "true"
    }, S, {
        get children() {
            return [createMemo(()=>C.leftIcon), createMemo(()=>C.children), createMemo(()=>C.rightIcon)]
        }
    }))
}
;
function nextFrame(C) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(C)
    }
    )
}
const Transition$2 = C=>{
    let S, E = !0;
    const [M,T] = createSignal()
      , [$,B] = createSignal()
      , O = children(()=>C.children)
      , {onBeforeEnter: F, onEnter: N, onAfterEnter: U, onBeforeExit: H, onExit: Z, onAfterExit: J} = C
      , ie = createMemo(()=>{
        const se = C.name || "s";
        return {
            enterActiveClass: C.enterActiveClass || se + "-enter-active",
            enterClass: C.enterClass || se + "-enter",
            enterToClass: C.enterToClass || se + "-enter-to",
            exitActiveClass: C.exitActiveClass || se + "-exit-active",
            exitClass: C.exitClass || se + "-exit",
            exitToClass: C.exitToClass || se + "-exit-to"
        }
    }
    );
    function oe(se, le) {
        if (!E || C.appear) {
            let de = function(we) {
                se && (!we || we.target === se) && (se.removeEventListener("transitionend", de),
                se.removeEventListener("animationend", de),
                se.classList.remove(...pe),
                se.classList.remove(...ge),
                batch(()=>{
                    M() !== se && T(se),
                    $() === se && B(void 0)
                }
                ),
                U && U(se),
                C.mode === "inout" && ae(se, le))
            };
            const fe = ie().enterClass.split(" ")
              , pe = ie().enterActiveClass.split(" ")
              , ge = ie().enterToClass.split(" ");
            F && F(se),
            se.classList.add(...fe),
            se.classList.add(...pe),
            nextFrame(()=>{
                se.classList.remove(...fe),
                se.classList.add(...ge),
                N && N(se, ()=>de()),
                (!N || N.length < 2) && (se.addEventListener("transitionend", de),
                se.addEventListener("animationend", de))
            }
            )
        }
        le && !C.mode ? B(se) : T(se)
    }
    function ae(se, le) {
        const de = ie().exitClass.split(" ")
          , fe = ie().exitActiveClass.split(" ")
          , pe = ie().exitToClass.split(" ");
        if (!le.parentNode)
            return ge();
        H && H(le),
        le.classList.add(...de),
        le.classList.add(...fe),
        nextFrame(()=>{
            le.classList.remove(...de),
            le.classList.add(...pe)
        }
        ),
        Z && Z(le, ()=>ge()),
        (!Z || Z.length < 2) && (le.addEventListener("transitionend", ge),
        le.addEventListener("animationend", ge));
        function ge(we) {
            (!we || we.target === le) && (le.removeEventListener("transitionend", ge),
            le.removeEventListener("animationend", ge),
            le.classList.remove(...fe),
            le.classList.remove(...pe),
            M() === le && T(void 0),
            J && J(le),
            C.mode === "outin" && oe(se, le))
        }
    }
    return createComputed(se=>{
        for (S = O(); typeof S == "function"; )
            S = S();
        return untrack(()=>(S && S !== se && (C.mode !== "outin" ? oe(S, se) : E && T(S)),
        se && se !== S && C.mode !== "inout" && ae(S, se),
        E = !1,
        S))
    }
    ),
    [M, $]
}
;
function getRect(C) {
    const {top: S, bottom: E, left: M, right: T, width: $, height: B} = C.getBoundingClientRect()
      , O = C.parentNode.getBoundingClientRect();
    return {
        top: S - O.top,
        bottom: E,
        left: M - O.left,
        right: T,
        width: $,
        height: B
    }
}
const TransitionGroup$2 = C=>{
    const S = children(()=>C.children)
      , E = createMemo(()=>{
        const J = C.name || "s";
        return {
            enterActiveClass: C.enterActiveClass || J + "-enter-active",
            enterClass: C.enterClass || J + "-enter",
            enterToClass: C.enterToClass || J + "-enter-to",
            exitActiveClass: C.exitActiveClass || J + "-exit-active",
            exitClass: C.exitClass || J + "-exit",
            exitToClass: C.exitToClass || J + "-exit-to",
            moveClass: C.moveClass || J + "-move"
        }
    }
    )
      , {onBeforeEnter: M, onEnter: T, onAfterEnter: $, onBeforeExit: B, onExit: O, onAfterExit: F} = C
      , [N,U] = createSignal();
    let H = []
      , Z = !0;
    return createComputed(()=>{
        const J = S()
          , ie = [...J]
          , oe = new Set(J)
          , ae = new Set(H)
          , se = E().enterClass.split(" ")
          , le = E().enterActiveClass.split(" ")
          , de = E().enterToClass.split(" ")
          , fe = E().exitClass.split(" ")
          , pe = E().exitActiveClass.split(" ")
          , ge = E().exitToClass.split(" ");
        for (let we = 0; we < J.length; we++) {
            const Ae = J[we];
            if (!Z && !ae.has(Ae)) {
                let Se = function(ue) {
                    Ae && (!ue || ue.target === Ae) && (Ae.removeEventListener("transitionend", Se),
                    Ae.removeEventListener("animationend", Se),
                    Ae.classList.remove(...le),
                    Ae.classList.remove(...de),
                    $ && $(Ae))
                };
                M && M(Ae),
                Ae.classList.add(...se),
                Ae.classList.add(...le),
                nextFrame(()=>{
                    Ae.classList.remove(...se),
                    Ae.classList.add(...de),
                    T && T(Ae, ()=>Se()),
                    (!T || T.length < 2) && (Ae.addEventListener("transitionend", Se),
                    Ae.addEventListener("animationend", Se))
                }
                )
            }
        }
        for (let we = 0; we < H.length; we++) {
            const Ae = H[we];
            if (!oe.has(Ae) && Ae.parentNode) {
                let Se = function(ue) {
                    (!ue || ue.target === Ae) && (Ae.removeEventListener("transitionend", Se),
                    Ae.removeEventListener("animationend", Se),
                    Ae.classList.remove(...pe),
                    Ae.classList.remove(...ge),
                    F && F(Ae),
                    H = H.filter(V=>V !== Ae),
                    U(H))
                };
                ie.splice(we, 0, Ae),
                B && B(Ae),
                Ae.classList.add(...fe),
                Ae.classList.add(...pe),
                nextFrame(()=>{
                    Ae.classList.remove(...fe),
                    Ae.classList.add(...ge)
                }
                ),
                O && O(Ae, ()=>Se()),
                (!O || O.length < 2) && (Ae.addEventListener("transitionend", Se),
                Ae.addEventListener("animationend", Se))
            }
        }
        H = ie,
        U(ie)
    }
    ),
    createEffect(J=>{
        const ie = N();
        return ie.forEach(oe=>{
            let ae;
            (ae = J.get(oe)) ? ae.new && (ae.new = !1,
            ae.newPos = getRect(oe)) : J.set(oe, ae = {
                pos: getRect(oe),
                new: !Z
            }),
            ae.new && oe.addEventListener("transitionend", ()=>{
                ae.new = !1,
                oe.parentNode && (ae.newPos = getRect(oe))
            }
            , {
                once: !0
            }),
            ae.newPos && (ae.pos = ae.newPos),
            ae.newPos = getRect(oe)
        }
        ),
        Z ? (Z = !1,
        J) : (ie.forEach(oe=>{
            const ae = J.get(oe)
              , se = ae.pos
              , le = ae.newPos
              , de = se.left - le.left
              , fe = se.top - le.top;
            if (de || fe) {
                ae.moved = !0;
                const pe = oe.style;
                pe.transform = `translate(${de}px,${fe}px)`,
                pe.transitionDuration = "0s"
            }
        }
        ),
        document.body.offsetHeight,
        ie.forEach(oe=>{
            const ae = J.get(oe);
            if (ae.moved) {
                let se = function(fe) {
                    fe && fe.target !== oe || !oe.parentNode || (!fe || /transform$/.test(fe.propertyName)) && (oe.removeEventListener("transitionend", se),
                    oe.classList.remove(...de))
                };
                ae.moved = !1;
                const le = oe.style
                  , de = E().moveClass.split(" ");
                oe.classList.add(...de),
                le.transform = le.transitionDuration = "",
                oe.addEventListener("transitionend", se)
            }
        }
        ),
        J)
    }
    , new Map),
    N
}
;
function clickOutside$1(C, S) {
    const E = M=>{
        var T;
        return !C.contains(M.target) && ((T = S()) == null ? void 0 : T())
    }
    ;
    document.body.addEventListener("click", E),
    onCleanup(()=>document.body.removeEventListener("click", E))
}
function escPressed(C, S) {
    const E = M=>{
        var T, $;
        M.key === "Escape" && ((T = document.activeElement) == null || T.blur(),
        ($ = S()) == null || $())
    }
    ;
    document.body.addEventListener("keydown", E),
    onCleanup(()=>document.body.removeEventListener("keydown", E))
}
function androidBackHandler$1(C, S) {
    const {isEnabled: E, onClose: M} = S();
    if (!E || !(getUserAgent().os === "android"))
        return;
    window.history.pushState(ROUTE_STATE, "");
    const $ = B=>{
        B.preventDefault(),
        M()
    }
    ;
    window.addEventListener("popstate", $, {
        once: !0
    }),
    onCleanup(()=>{
        window.removeEventListener("popstate", $),
        createMacrotask(()=>{
            var B;
            ((B = window.history.state) == null ? void 0 : B[ROUTE_STATE_KEY]) === !0 && window.history.back()
        }
        )
    }
    )
}
const ROUTE_STATE_KEY = "androidBackHandler"
  , ROUTE_STATE = {
    [ROUTE_STATE_KEY]: !0
}
  , _tmpl$$v = template$1('<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z"></path></svg>', 4, !0)
  , rotationDegrees = {
    left: 0,
    top: 90,
    right: 180,
    bottom: 270
}
  , ArrowIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary
      , M = ()=>C.direction || "left"
      , T = styled$2("svg")`
        transform: rotate(${$=>rotationDegrees[$.svgDirection]}deg);
        transition: transform 0.1s ease-in-out;
    `;
    return createComponent(T, {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        get svgDirection() {
            return M()
        },
        get children() {
            const $ = _tmpl$$v.cloneNode(!0);
            return createRenderEffect(()=>setAttribute($, "fill", E())),
            $
        }
    })
}
  , _tmpl$$u = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z"></path></svg>')
  , CloseIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$u.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , IconButtonStyled = styled$2.button`
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: ${C=>C.theme.colors.background.tint};
    border: none;
    cursor: pointer;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , IconButton$2 = C=>{
    const S = useDataAttributes(C)
      , E = ()=>C.icon || "close";
    return createComponent(IconButtonStyled, mergeProps({
        get class() {
            return C.class
        },
        onClick: ()=>C.onClick(),
        "data-tc-icon-button": "true"
    }, S, {
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !!C.children
                },
                get children() {
                    return C.children
                }
            }), createComponent(Show, {
                get when() {
                    return !C.children
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return E() === "close"
                                },
                                get children() {
                                    return createComponent(CloseIcon, {
                                        get fill() {
                                            return C.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return E() === "arrow"
                                },
                                get children() {
                                    return createComponent(ArrowIcon, {
                                        get fill() {
                                            return C.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return E() === "question"
                                },
                                get children() {
                                    return createComponent(QuestionIcon, {
                                        get fill() {
                                            return C.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return typeof E() != "string"
                                },
                                get children() {
                                    return E()
                                }
                            })]
                        }
                    })
                }
            })]
        }
    }))
}
  , borders$4 = {
    m: "24px",
    s: "16px",
    none: "0"
}
  , ModalBackgroundStyled = styled$2.div`
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 20px 0;
    overflow-y: auto;

    ${media("mobile")} {
        padding-bottom: 0;
    }
`
  , ModalWrapperClass = u$1`
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);
    width: fit-content;
    margin: auto;

    ${media("mobile")} {
        width: 100%;
        height: fit-content;
        margin: auto 0 0 0;
    }
`
  , ModalBodyStyled = styled$2.div`
    position: relative;
    min-height: 100px;
    width: 416px;
    padding: 44px 56px 24px;

    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);

    background-color: ${C=>C.theme.colors.background.primary};
    border-radius: ${C=>borders$4[C.theme.borderRadius]};

    ${media("mobile")} {
        width: 100%;
    }
`
  , CloseButtonStyled = styled$2(IconButton$2)`
    position: absolute;
    right: 16px;
    top: 16px;
`
  , ModalFooterStyled = styled$2.div`
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 16px 16px 18px;
    border-radius: 0 0 ${C=>borders$4[C.theme.borderRadius]}
        ${C=>borders$4[C.theme.borderRadius]};
`
  , QuestionButtonStyled = styled$2(IconButton$2)`
    background-color: ${C=>rgba(C.theme.colors.icon.secondary, .12)};
`;
class AnimationTimelineNoop {
    constructor() {
        __publicField(this, "currentTime", 0)
    }
}
const _AnimationNoop = class {
    constructor() {
        __publicField(this, "currentTime", 0),
        __publicField(this, "playbackRate", 1),
        __publicField(this, "startTime", null),
        __publicField(this, "timeline", new AnimationTimelineNoop),
        __publicField(this, "finished", Promise.resolve(this)),
        __publicField(this, "effect", null),
        __publicField(this, "id", ""),
        __publicField(this, "pending", !1),
        __publicField(this, "playState", "finished"),
        __publicField(this, "replaceState", "active"),
        __publicField(this, "ready", Promise.resolve(this)),
        __publicField(this, "oncancel", null),
        __publicField(this, "onfinish", null),
        __publicField(this, "onremove", null)
    }
    static create() {
        return _AnimationNoop._instance || (logWarning("Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API."),
        _AnimationNoop._instance = new _AnimationNoop),
        _AnimationNoop._instance
    }
    cancel() {}
    finish() {}
    pause() {}
    play() {}
    reverse() {}
    addEventListener(C, S, E) {}
    dispatchEvent(C) {
        return !1
    }
    removeEventListener(C, S, E) {}
    updatePlaybackRate(C) {}
    commitStyles() {}
    persist() {}
}
;
let AnimationNoop = _AnimationNoop;
__publicField(AnimationNoop, "_instance", null);
function animate(C, S, E) {
    return "animate"in C ? C.animate(S, E) : AnimationNoop.create()
}
const _tmpl$$t = template$1("<div></div>")
  , clickOutside = clickOutside$1
  , keyPressed = escPressed
  , androidBackHandler = androidBackHandler$1
  , Modal$2 = C=>{
    const S = useTheme$4()
      , E = useDataAttributes(C);
    return createEffect(()=>{
        C.opened ? disableScroll() : enableScroll()
    }
    ),
    createComponent(Transition$2, {
        onBeforeEnter: M=>{
            const T = isDevice("mobile") ? 200 : 100;
            animate(M, [{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: T
            }),
            isDevice("mobile") && animate(M.firstElementChild, [{
                transform: "translateY(390px)"
            }, {
                transform: "translateY(0)"
            }], {
                duration: T
            })
        }
        ,
        onExit: (M,T)=>{
            const $ = isDevice("mobile") ? 200 : 100
              , B = animate(M, [{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: $
            });
            if (isDevice("mobile")) {
                const O = animate(M.firstElementChild, [{
                    transform: "translateY(0)"
                }, {
                    transform: "translateY(390px)"
                }], {
                    duration: $
                });
                Promise.all([B.finished, O.finished]).then(T)
            } else
                B.finished.then(T)
        }
        ,
        get children() {
            return createComponent(Show, {
                get when() {
                    return C.opened
                },
                get children() {
                    return createComponent(ModalBackgroundStyled, mergeProps({
                        "data-tc-modal": "true"
                    }, E, {
                        get children() {
                            const M = _tmpl$$t.cloneNode(!0);
                            return use(androidBackHandler, M, ()=>({
                                isEnabled: C.enableAndroidBackHandler,
                                onClose: ()=>C.onClose()
                            })),
                            use(keyPressed, M, ()=>()=>C.onClose()),
                            use(clickOutside, M, ()=>()=>C.onClose()),
                            insert$1(M, createComponent(ModalBodyStyled, {
                                get class() {
                                    return C.class
                                },
                                get children() {
                                    return [createComponent(CloseButtonStyled, {
                                        icon: "close",
                                        onClick: ()=>C.onClose()
                                    }), createMemo(()=>C.children)]
                                }
                            }), null),
                            insert$1(M, createComponent(Show, {
                                get when() {
                                    return C.onClickQuestion
                                },
                                get children() {
                                    return createComponent(ModalFooterStyled, {
                                        get children() {
                                            return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {
                                                get onClick() {
                                                    return C.onClickQuestion
                                                },
                                                icon: "question"
                                            })]
                                        }
                                    })
                                }
                            }), null),
                            createRenderEffect(()=>className(M, classNames(ModalWrapperClass, u$1`
                                border-radius: ${borders$4[S.borderRadius]};
                                background-color: ${S.colors.background.tint};

                                ${media("mobile")} {
                                    border-radius: ${borders$4[S.borderRadius]}
                                        ${borders$4[S.borderRadius]} 0 0;
                                }
                            `))),
                            M
                        }
                    }))
                }
            })
        }
    })
}
  , wrapperBorderRadius = {
    m: "22px",
    s: "12px",
    none: "0"
}
  , sliderBorderRadius = {
    m: "18px",
    s: "8px",
    none: "0"
}
  , TabBarStyled = styled$2.div`
    display: grid;
    grid-template: 1fr / 1fr 1fr;
    width: fit-content;
    justify-items: center;
    gap: 4px;

    position: relative;
    padding: 4px;
    border-radius: ${C=>wrapperBorderRadius[C.theme.borderRadius]};

    background-color: ${C=>C.theme.colors.background.secondary};
`
  , SliderStyled = styled$2.div`
    position: absolute;
    top: 4px;
    left: 4px;

    height: calc(100% - 8px);
    width: calc(50% - 4px);

    border-radius: ${C=>sliderBorderRadius[C.theme.borderRadius]};
    background-color: ${C=>C.theme.colors.background.segment};

    transform: ${C=>C.right ? "translateX(100%)" : "translateX(0)"};

    transition: transform 0.13s ease-in-out;
`
  , InputStyled = styled$2.input`
    display: none;
`
  , LabelStyled = styled$2.label`
    padding: 9px 12px;
    z-index: 1;

    cursor: ${C=>C.isActive ? "default" : "pointer"};

    transition: transform 0.13s ease-in-out;

    &:hover {
        transform: ${C=>C.isActive ? "none" : "scale(1.025)"};
    }

    > * {
        ${C=>C.isActive ? "" : `color: ${C.theme.colors.text.secondary};`}
    }
`
  , TabBar = C=>{
    const S = "tabBar" + Math.floor(Math.random() * 1e4);
    return createComponent(TabBarStyled, {
        get class() {
            return C.class
        },
        "data-tc-tab-bar": "true",
        get children() {
            return [createComponent(SliderStyled, {
                get right() {
                    return C.selectedTabIndex === 1
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return C.selectedTabIndex === 0
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        name: S,
                        get checked() {
                            return C.selectedTabIndex === 0
                        },
                        onInput: ()=>{
                            var E;
                            return (E = C.onSelectedTabIndexChange) == null ? void 0 : E.call(C, 0)
                        }
                    }), createMemo(()=>C.tab1)]
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return C.selectedTabIndex === 1
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        get checked() {
                            return C.selectedTabIndex === 1
                        },
                        name: S,
                        onInput: ()=>{
                            var E;
                            return (E = C.onSelectedTabIndexChange) == null ? void 0 : E.call(C, 1)
                        }
                    }), createMemo(()=>C.tab2)]
                }
            })]
        }
    })
}
  , backgroundBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , imageBorders = {
    m: "12px",
    s: "8px",
    none: "0"
}
  , qrNormalSize = 256
  , imgSizeDefault = 60
  , picSizeDefault = 48
  , qrPaddingTop = 24
  , CopyIconButton = styled$2.div`
    width: 52px;
    height: 52px;
    background: transparent;
    position: absolute;
    right: 0;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.125s ease-in-out;
`
  , QrCodeBackground = styled$2.button`
    display: flex;
    align-items: center;
    position: relative;
    background-color: ${C=>C.theme.colors.background.qr};
    border-radius: ${C=>backgroundBorders[C.theme.borderRadius]};
    padding: ${toPx(qrPaddingTop)} 0;
    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};
    width: 100%;

    overflow: hidden;
    cursor: pointer;
    border: none;

    ${mediaNotTouch} {
        &:hover {
            ${CopyIconButton.class} {
                transform: scale(1.04);
            }
        }
    }

    &:active {
        ${CopyIconButton.class} {
            transform: scale(0.96);
        }
    }

    ${mediaTouch} {
        &:active {
            ${CopyIconButton.class} {
                transform: scale(0.92);
            }
        }
    }
`
  , QrCodeWrapper$2 = styled$2.div`
    position: relative;

    width: fit-content;
    margin: 0 auto;

    > div:first-child {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    rect {
        fill: transparent;
    }

    path {
        fill: ${C=>C.theme.colors.constant.black};
    }
`
  , ImageBackground = styled$2.div`
    position: absolute;
    width: ${toPx(imgSizeDefault)};
    height: ${toPx(imgSizeDefault)};
    background: ${C=>C.theme.colors.background.qr};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , ImageStyled$3 = styled$2(Image)`
    width: ${C=>toPx(C.size)};
    height: ${C=>toPx(C.size)};
    border-radius: ${C=>imageBorders[C.theme.borderRadius]};
    background-color: ${C=>C.theme.colors.background.qr};
`
  , CopiedBoxStyled = styled$2.div`
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translate(-50%, 0);

    display: flex;
    gap: 6px;
    align-items: center;
    border-radius: 18px;
    min-width: 126px;
    padding: 9px 16px 9px 10px;

    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));
    background-color: ${C=>C.theme.colors.background.segment};
`;
var qrcode$1 = {
    exports: {}
};
(function(C, S) {
    var E = function() {
        var M = function(pe, ge) {
            var we = 236
              , Ae = 17
              , Se = pe
              , ue = $[ge]
              , V = null
              , W = 0
              , D = null
              , I = []
              , L = {}
              , K = function(ve, Me) {
                W = Se * 4 + 17,
                V = function(Fe) {
                    for (var be = new Array(Fe), Ce = 0; Ce < Fe; Ce += 1) {
                        be[Ce] = new Array(Fe);
                        for (var ze = 0; ze < Fe; ze += 1)
                            be[Ce][ze] = null
                    }
                    return be
                }(W),
                X(0, 0),
                X(W - 7, 0),
                X(0, W - 7),
                G(),
                j(),
                te(ve, Me),
                Se >= 7 && ne(ve),
                D == null && (D = Re(Se, ue, I)),
                ce(D, Me)
            }
              , X = function(ve, Me) {
                for (var Fe = -1; Fe <= 7; Fe += 1)
                    if (!(ve + Fe <= -1 || W <= ve + Fe))
                        for (var be = -1; be <= 7; be += 1)
                            Me + be <= -1 || W <= Me + be || (0 <= Fe && Fe <= 6 && (be == 0 || be == 6) || 0 <= be && be <= 6 && (Fe == 0 || Fe == 6) || 2 <= Fe && Fe <= 4 && 2 <= be && be <= 4 ? V[ve + Fe][Me + be] = !0 : V[ve + Fe][Me + be] = !1)
            }
              , Y = function() {
                for (var ve = 0, Me = 0, Fe = 0; Fe < 8; Fe += 1) {
                    K(!0, Fe);
                    var be = O.getLostPoint(L);
                    (Fe == 0 || ve > be) && (ve = be,
                    Me = Fe)
                }
                return Me
            }
              , j = function() {
                for (var ve = 8; ve < W - 8; ve += 1)
                    V[ve][6] == null && (V[ve][6] = ve % 2 == 0);
                for (var Me = 8; Me < W - 8; Me += 1)
                    V[6][Me] == null && (V[6][Me] = Me % 2 == 0)
            }
              , G = function() {
                for (var ve = O.getPatternPosition(Se), Me = 0; Me < ve.length; Me += 1)
                    for (var Fe = 0; Fe < ve.length; Fe += 1) {
                        var be = ve[Me]
                          , Ce = ve[Fe];
                        if (V[be][Ce] == null)
                            for (var ze = -2; ze <= 2; ze += 1)
                                for (var Ge = -2; Ge <= 2; Ge += 1)
                                    ze == -2 || ze == 2 || Ge == -2 || Ge == 2 || ze == 0 && Ge == 0 ? V[be + ze][Ce + Ge] = !0 : V[be + ze][Ce + Ge] = !1
                    }
            }
              , ne = function(ve) {
                for (var Me = O.getBCHTypeNumber(Se), Fe = 0; Fe < 18; Fe += 1) {
                    var be = !ve && (Me >> Fe & 1) == 1;
                    V[Math.floor(Fe / 3)][Fe % 3 + W - 8 - 3] = be
                }
                for (var Fe = 0; Fe < 18; Fe += 1) {
                    var be = !ve && (Me >> Fe & 1) == 1;
                    V[Fe % 3 + W - 8 - 3][Math.floor(Fe / 3)] = be
                }
            }
              , te = function(ve, Me) {
                for (var Fe = ue << 3 | Me, be = O.getBCHTypeInfo(Fe), Ce = 0; Ce < 15; Ce += 1) {
                    var ze = !ve && (be >> Ce & 1) == 1;
                    Ce < 6 ? V[Ce][8] = ze : Ce < 8 ? V[Ce + 1][8] = ze : V[W - 15 + Ce][8] = ze
                }
                for (var Ce = 0; Ce < 15; Ce += 1) {
                    var ze = !ve && (be >> Ce & 1) == 1;
                    Ce < 8 ? V[8][W - Ce - 1] = ze : Ce < 9 ? V[8][15 - Ce - 1 + 1] = ze : V[8][15 - Ce - 1] = ze
                }
                V[W - 8][8] = !ve
            }
              , ce = function(ve, Me) {
                for (var Fe = -1, be = W - 1, Ce = 7, ze = 0, Ge = O.getMaskFunction(Me), nt = W - 1; nt > 0; nt -= 2)
                    for (nt == 6 && (nt -= 1); ; ) {
                        for (var bt = 0; bt < 2; bt += 1)
                            if (V[be][nt - bt] == null) {
                                var ct = !1;
                                ze < ve.length && (ct = (ve[ze] >>> Ce & 1) == 1);
                                var De = Ge(be, nt - bt);
                                De && (ct = !ct),
                                V[be][nt - bt] = ct,
                                Ce -= 1,
                                Ce == -1 && (ze += 1,
                                Ce = 7)
                            }
                        if (be += Fe,
                        be < 0 || W <= be) {
                            be -= Fe,
                            Fe = -Fe;
                            break
                        }
                    }
            }
              , Ee = function(ve, Me) {
                for (var Fe = 0, be = 0, Ce = 0, ze = new Array(Me.length), Ge = new Array(Me.length), nt = 0; nt < Me.length; nt += 1) {
                    var bt = Me[nt].dataCount
                      , ct = Me[nt].totalCount - bt;
                    be = Math.max(be, bt),
                    Ce = Math.max(Ce, ct),
                    ze[nt] = new Array(bt);
                    for (var De = 0; De < ze[nt].length; De += 1)
                        ze[nt][De] = 255 & ve.getBuffer()[De + Fe];
                    Fe += bt;
                    var Ue = O.getErrorCorrectPolynomial(ct)
                      , We = N(ze[nt], Ue.getLength() - 1)
                      , Xe = We.mod(Ue);
                    Ge[nt] = new Array(Ue.getLength() - 1);
                    for (var De = 0; De < Ge[nt].length; De += 1) {
                        var ht = De + Xe.getLength() - Ge[nt].length;
                        Ge[nt][De] = ht >= 0 ? Xe.getAt(ht) : 0
                    }
                }
                for (var Je = 0, De = 0; De < Me.length; De += 1)
                    Je += Me[De].totalCount;
                for (var ot = new Array(Je), je = 0, De = 0; De < be; De += 1)
                    for (var nt = 0; nt < Me.length; nt += 1)
                        De < ze[nt].length && (ot[je] = ze[nt][De],
                        je += 1);
                for (var De = 0; De < Ce; De += 1)
                    for (var nt = 0; nt < Me.length; nt += 1)
                        De < Ge[nt].length && (ot[je] = Ge[nt][De],
                        je += 1);
                return ot
            }
              , Re = function(ve, Me, Fe) {
                for (var be = U.getRSBlocks(ve, Me), Ce = H(), ze = 0; ze < Fe.length; ze += 1) {
                    var Ge = Fe[ze];
                    Ce.put(Ge.getMode(), 4),
                    Ce.put(Ge.getLength(), O.getLengthInBits(Ge.getMode(), ve)),
                    Ge.write(Ce)
                }
                for (var nt = 0, ze = 0; ze < be.length; ze += 1)
                    nt += be[ze].dataCount;
                if (Ce.getLengthInBits() > nt * 8)
                    throw "code length overflow. (" + Ce.getLengthInBits() + ">" + nt * 8 + ")";
                for (Ce.getLengthInBits() + 4 <= nt * 8 && Ce.put(0, 4); Ce.getLengthInBits() % 8 != 0; )
                    Ce.putBit(!1);
                for (; !(Ce.getLengthInBits() >= nt * 8 || (Ce.put(we, 8),
                Ce.getLengthInBits() >= nt * 8)); )
                    Ce.put(Ae, 8);
                return Ee(Ce, be)
            };
            L.addData = function(ve, Me) {
                Me = Me || "Byte";
                var Fe = null;
                switch (Me) {
                case "Numeric":
                    Fe = Z(ve);
                    break;
                case "Alphanumeric":
                    Fe = J(ve);
                    break;
                case "Byte":
                    Fe = ie(ve);
                    break;
                case "Kanji":
                    Fe = oe(ve);
                    break;
                default:
                    throw "mode:" + Me
                }
                I.push(Fe),
                D = null
            }
            ,
            L.isDark = function(ve, Me) {
                if (ve < 0 || W <= ve || Me < 0 || W <= Me)
                    throw ve + "," + Me;
                return V[ve][Me]
            }
            ,
            L.getModuleCount = function() {
                return W
            }
            ,
            L.make = function() {
                if (Se < 1) {
                    for (var ve = 1; ve < 40; ve++) {
                        for (var Me = U.getRSBlocks(ve, ue), Fe = H(), be = 0; be < I.length; be++) {
                            var Ce = I[be];
                            Fe.put(Ce.getMode(), 4),
                            Fe.put(Ce.getLength(), O.getLengthInBits(Ce.getMode(), ve)),
                            Ce.write(Fe)
                        }
                        for (var ze = 0, be = 0; be < Me.length; be++)
                            ze += Me[be].dataCount;
                        if (Fe.getLengthInBits() <= ze * 8)
                            break
                    }
                    Se = ve
                }
                K(!1, Y())
            }
            ,
            L.createTableTag = function(ve, Me) {
                ve = ve || 2,
                Me = typeof Me > "u" ? ve * 4 : Me;
                var Fe = "";
                Fe += '<table style="',
                Fe += " border-width: 0px; border-style: none;",
                Fe += " border-collapse: collapse;",
                Fe += " padding: 0px; margin: " + Me + "px;",
                Fe += '">',
                Fe += "<tbody>";
                for (var be = 0; be < L.getModuleCount(); be += 1) {
                    Fe += "<tr>";
                    for (var Ce = 0; Ce < L.getModuleCount(); Ce += 1)
                        Fe += '<td style="',
                        Fe += " border-width: 0px; border-style: none;",
                        Fe += " border-collapse: collapse;",
                        Fe += " padding: 0px; margin: 0px;",
                        Fe += " width: " + ve + "px;",
                        Fe += " height: " + ve + "px;",
                        Fe += " background-color: ",
                        Fe += L.isDark(be, Ce) ? "#000000" : "#ffffff",
                        Fe += ";",
                        Fe += '"/>';
                    Fe += "</tr>"
                }
                return Fe += "</tbody>",
                Fe += "</table>",
                Fe
            }
            ,
            L.createSvgTag = function(ve, Me, Fe, be) {
                var Ce = {};
                typeof arguments[0] == "object" && (Ce = arguments[0],
                ve = Ce.cellSize,
                Me = Ce.margin,
                Fe = Ce.alt,
                be = Ce.title),
                ve = ve || 2,
                Me = typeof Me > "u" ? ve * 4 : Me,
                Fe = typeof Fe == "string" ? {
                    text: Fe
                } : Fe || {},
                Fe.text = Fe.text || null,
                Fe.id = Fe.text ? Fe.id || "qrcode-description" : null,
                be = typeof be == "string" ? {
                    text: be
                } : be || {},
                be.text = be.text || null,
                be.id = be.text ? be.id || "qrcode-title" : null;
                var ze = L.getModuleCount() * ve + Me * 2, Ge, nt, bt, ct, De = "", Ue;
                for (Ue = "l" + ve + ",0 0," + ve + " -" + ve + ",0 0,-" + ve + "z ",
                De += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                De += Ce.scalable ? "" : ' width="' + ze + 'px" height="' + ze + 'px"',
                De += ' viewBox="0 0 ' + ze + " " + ze + '" ',
                De += ' preserveAspectRatio="xMinYMin meet"',
                De += be.text || Fe.text ? ' role="img" aria-labelledby="' + Te([be.id, Fe.id].join(" ").trim()) + '"' : "",
                De += ">",
                De += be.text ? '<title id="' + Te(be.id) + '">' + Te(be.text) + "</title>" : "",
                De += Fe.text ? '<description id="' + Te(Fe.id) + '">' + Te(Fe.text) + "</description>" : "",
                De += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                De += '<path d="',
                bt = 0; bt < L.getModuleCount(); bt += 1)
                    for (ct = bt * ve + Me,
                    Ge = 0; Ge < L.getModuleCount(); Ge += 1)
                        L.isDark(bt, Ge) && (nt = Ge * ve + Me,
                        De += "M" + nt + "," + ct + Ue);
                return De += '" stroke="transparent" fill="black"/>',
                De += "</svg>",
                De
            }
            ,
            L.createDataURL = function(ve, Me) {
                ve = ve || 2,
                Me = typeof Me > "u" ? ve * 4 : Me;
                var Fe = L.getModuleCount() * ve + Me * 2
                  , be = Me
                  , Ce = Fe - Me;
                return fe(Fe, Fe, function(ze, Ge) {
                    if (be <= ze && ze < Ce && be <= Ge && Ge < Ce) {
                        var nt = Math.floor((ze - be) / ve)
                          , bt = Math.floor((Ge - be) / ve);
                        return L.isDark(bt, nt) ? 0 : 1
                    } else
                        return 1
                })
            }
            ,
            L.createImgTag = function(ve, Me, Fe) {
                ve = ve || 2,
                Me = typeof Me > "u" ? ve * 4 : Me;
                var be = L.getModuleCount() * ve + Me * 2
                  , Ce = "";
                return Ce += "<img",
                Ce += ' src="',
                Ce += L.createDataURL(ve, Me),
                Ce += '"',
                Ce += ' width="',
                Ce += be,
                Ce += '"',
                Ce += ' height="',
                Ce += be,
                Ce += '"',
                Fe && (Ce += ' alt="',
                Ce += Te(Fe),
                Ce += '"'),
                Ce += "/>",
                Ce
            }
            ;
            var Te = function(ve) {
                for (var Me = "", Fe = 0; Fe < ve.length; Fe += 1) {
                    var be = ve.charAt(Fe);
                    switch (be) {
                    case "<":
                        Me += "&lt;";
                        break;
                    case ">":
                        Me += "&gt;";
                        break;
                    case "&":
                        Me += "&amp;";
                        break;
                    case '"':
                        Me += "&quot;";
                        break;
                    default:
                        Me += be;
                        break
                    }
                }
                return Me
            }
              , xe = function(ve) {
                var Me = 1;
                ve = typeof ve > "u" ? Me * 2 : ve;
                var Fe = L.getModuleCount() * Me + ve * 2, be = ve, Ce = Fe - ve, ze, Ge, nt, bt, ct, De = {
                    "": "",
                    " ": "",
                    " ": "",
                    "  ": " "
                }, Ue = {
                    "": "",
                    " ": "",
                    " ": " ",
                    "  ": " "
                }, We = "";
                for (ze = 0; ze < Fe; ze += 2) {
                    for (nt = Math.floor((ze - be) / Me),
                    bt = Math.floor((ze + 1 - be) / Me),
                    Ge = 0; Ge < Fe; Ge += 1)
                        ct = "",
                        be <= Ge && Ge < Ce && be <= ze && ze < Ce && L.isDark(nt, Math.floor((Ge - be) / Me)) && (ct = " "),
                        be <= Ge && Ge < Ce && be <= ze + 1 && ze + 1 < Ce && L.isDark(bt, Math.floor((Ge - be) / Me)) ? ct += " " : ct += "",
                        We += ve < 1 && ze + 1 >= Ce ? Ue[ct] : De[ct];
                    We += `
`
                }
                return Fe % 2 && ve > 0 ? We.substring(0, We.length - Fe - 1) + Array(Fe + 1).join("") : We.substring(0, We.length - 1)
            };
            return L.createASCII = function(ve, Me) {
                if (ve = ve || 1,
                ve < 2)
                    return xe(Me);
                ve -= 1,
                Me = typeof Me > "u" ? ve * 2 : Me;
                var Fe = L.getModuleCount() * ve + Me * 2, be = Me, Ce = Fe - Me, ze, Ge, nt, bt, ct = Array(ve + 1).join(""), De = Array(ve + 1).join("  "), Ue = "", We = "";
                for (ze = 0; ze < Fe; ze += 1) {
                    for (nt = Math.floor((ze - be) / ve),
                    We = "",
                    Ge = 0; Ge < Fe; Ge += 1)
                        bt = 1,
                        be <= Ge && Ge < Ce && be <= ze && ze < Ce && L.isDark(nt, Math.floor((Ge - be) / ve)) && (bt = 0),
                        We += bt ? ct : De;
                    for (nt = 0; nt < ve; nt += 1)
                        Ue += We + `
`
                }
                return Ue.substring(0, Ue.length - 1)
            }
            ,
            L.renderTo2dContext = function(ve, Me) {
                Me = Me || 2;
                for (var Fe = L.getModuleCount(), be = 0; be < Fe; be++)
                    for (var Ce = 0; Ce < Fe; Ce++)
                        ve.fillStyle = L.isDark(be, Ce) ? "black" : "white",
                        ve.fillRect(be * Me, Ce * Me, Me, Me)
            }
            ,
            L
        };
        M.stringToBytesFuncs = {
            default: function(pe) {
                for (var ge = [], we = 0; we < pe.length; we += 1) {
                    var Ae = pe.charCodeAt(we);
                    ge.push(Ae & 255)
                }
                return ge
            }
        },
        M.stringToBytes = M.stringToBytesFuncs.default,
        M.createStringToBytes = function(pe, ge) {
            var we = function() {
                for (var Se = le(pe), ue = function() {
                    var j = Se.read();
                    if (j == -1)
                        throw "eof";
                    return j
                }, V = 0, W = {}; ; ) {
                    var D = Se.read();
                    if (D == -1)
                        break;
                    var I = ue()
                      , L = ue()
                      , K = ue()
                      , X = String.fromCharCode(D << 8 | I)
                      , Y = L << 8 | K;
                    W[X] = Y,
                    V += 1
                }
                if (V != ge)
                    throw V + " != " + ge;
                return W
            }()
              , Ae = 63;
            return function(Se) {
                for (var ue = [], V = 0; V < Se.length; V += 1) {
                    var W = Se.charCodeAt(V);
                    if (W < 128)
                        ue.push(W);
                    else {
                        var D = we[Se.charAt(V)];
                        typeof D == "number" ? (D & 255) == D ? ue.push(D) : (ue.push(D >>> 8),
                        ue.push(D & 255)) : ue.push(Ae)
                    }
                }
                return ue
            }
        }
        ;
        var T = {
            MODE_NUMBER: 1,
            MODE_ALPHA_NUM: 2,
            MODE_8BIT_BYTE: 4,
            MODE_KANJI: 8
        }
          , $ = {
            L: 1,
            M: 0,
            Q: 3,
            H: 2
        }
          , B = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        }
          , O = function() {
            var pe = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]]
              , ge = 1335
              , we = 7973
              , Ae = 21522
              , Se = {}
              , ue = function(V) {
                for (var W = 0; V != 0; )
                    W += 1,
                    V >>>= 1;
                return W
            };
            return Se.getBCHTypeInfo = function(V) {
                for (var W = V << 10; ue(W) - ue(ge) >= 0; )
                    W ^= ge << ue(W) - ue(ge);
                return (V << 10 | W) ^ Ae
            }
            ,
            Se.getBCHTypeNumber = function(V) {
                for (var W = V << 12; ue(W) - ue(we) >= 0; )
                    W ^= we << ue(W) - ue(we);
                return V << 12 | W
            }
            ,
            Se.getPatternPosition = function(V) {
                return pe[V - 1]
            }
            ,
            Se.getMaskFunction = function(V) {
                switch (V) {
                case B.PATTERN000:
                    return function(W, D) {
                        return (W + D) % 2 == 0
                    }
                    ;
                case B.PATTERN001:
                    return function(W, D) {
                        return W % 2 == 0
                    }
                    ;
                case B.PATTERN010:
                    return function(W, D) {
                        return D % 3 == 0
                    }
                    ;
                case B.PATTERN011:
                    return function(W, D) {
                        return (W + D) % 3 == 0
                    }
                    ;
                case B.PATTERN100:
                    return function(W, D) {
                        return (Math.floor(W / 2) + Math.floor(D / 3)) % 2 == 0
                    }
                    ;
                case B.PATTERN101:
                    return function(W, D) {
                        return W * D % 2 + W * D % 3 == 0
                    }
                    ;
                case B.PATTERN110:
                    return function(W, D) {
                        return (W * D % 2 + W * D % 3) % 2 == 0
                    }
                    ;
                case B.PATTERN111:
                    return function(W, D) {
                        return (W * D % 3 + (W + D) % 2) % 2 == 0
                    }
                    ;
                default:
                    throw "bad maskPattern:" + V
                }
            }
            ,
            Se.getErrorCorrectPolynomial = function(V) {
                for (var W = N([1], 0), D = 0; D < V; D += 1)
                    W = W.multiply(N([1, F.gexp(D)], 0));
                return W
            }
            ,
            Se.getLengthInBits = function(V, W) {
                if (1 <= W && W < 10)
                    switch (V) {
                    case T.MODE_NUMBER:
                        return 10;
                    case T.MODE_ALPHA_NUM:
                        return 9;
                    case T.MODE_8BIT_BYTE:
                        return 8;
                    case T.MODE_KANJI:
                        return 8;
                    default:
                        throw "mode:" + V
                    }
                else if (W < 27)
                    switch (V) {
                    case T.MODE_NUMBER:
                        return 12;
                    case T.MODE_ALPHA_NUM:
                        return 11;
                    case T.MODE_8BIT_BYTE:
                        return 16;
                    case T.MODE_KANJI:
                        return 10;
                    default:
                        throw "mode:" + V
                    }
                else if (W < 41)
                    switch (V) {
                    case T.MODE_NUMBER:
                        return 14;
                    case T.MODE_ALPHA_NUM:
                        return 13;
                    case T.MODE_8BIT_BYTE:
                        return 16;
                    case T.MODE_KANJI:
                        return 12;
                    default:
                        throw "mode:" + V
                    }
                else
                    throw "type:" + W
            }
            ,
            Se.getLostPoint = function(V) {
                for (var W = V.getModuleCount(), D = 0, I = 0; I < W; I += 1)
                    for (var L = 0; L < W; L += 1) {
                        for (var K = 0, X = V.isDark(I, L), Y = -1; Y <= 1; Y += 1)
                            if (!(I + Y < 0 || W <= I + Y))
                                for (var j = -1; j <= 1; j += 1)
                                    L + j < 0 || W <= L + j || Y == 0 && j == 0 || X == V.isDark(I + Y, L + j) && (K += 1);
                        K > 5 && (D += 3 + K - 5)
                    }
                for (var I = 0; I < W - 1; I += 1)
                    for (var L = 0; L < W - 1; L += 1) {
                        var G = 0;
                        V.isDark(I, L) && (G += 1),
                        V.isDark(I + 1, L) && (G += 1),
                        V.isDark(I, L + 1) && (G += 1),
                        V.isDark(I + 1, L + 1) && (G += 1),
                        (G == 0 || G == 4) && (D += 3)
                    }
                for (var I = 0; I < W; I += 1)
                    for (var L = 0; L < W - 6; L += 1)
                        V.isDark(I, L) && !V.isDark(I, L + 1) && V.isDark(I, L + 2) && V.isDark(I, L + 3) && V.isDark(I, L + 4) && !V.isDark(I, L + 5) && V.isDark(I, L + 6) && (D += 40);
                for (var L = 0; L < W; L += 1)
                    for (var I = 0; I < W - 6; I += 1)
                        V.isDark(I, L) && !V.isDark(I + 1, L) && V.isDark(I + 2, L) && V.isDark(I + 3, L) && V.isDark(I + 4, L) && !V.isDark(I + 5, L) && V.isDark(I + 6, L) && (D += 40);
                for (var ne = 0, L = 0; L < W; L += 1)
                    for (var I = 0; I < W; I += 1)
                        V.isDark(I, L) && (ne += 1);
                var te = Math.abs(100 * ne / W / W - 50) / 5;
                return D += te * 10,
                D
            }
            ,
            Se
        }()
          , F = function() {
            for (var pe = new Array(256), ge = new Array(256), we = 0; we < 8; we += 1)
                pe[we] = 1 << we;
            for (var we = 8; we < 256; we += 1)
                pe[we] = pe[we - 4] ^ pe[we - 5] ^ pe[we - 6] ^ pe[we - 8];
            for (var we = 0; we < 255; we += 1)
                ge[pe[we]] = we;
            var Ae = {};
            return Ae.glog = function(Se) {
                if (Se < 1)
                    throw "glog(" + Se + ")";
                return ge[Se]
            }
            ,
            Ae.gexp = function(Se) {
                for (; Se < 0; )
                    Se += 255;
                for (; Se >= 256; )
                    Se -= 255;
                return pe[Se]
            }
            ,
            Ae
        }();
        function N(pe, ge) {
            if (typeof pe.length > "u")
                throw pe.length + "/" + ge;
            var we = function() {
                for (var Se = 0; Se < pe.length && pe[Se] == 0; )
                    Se += 1;
                for (var ue = new Array(pe.length - Se + ge), V = 0; V < pe.length - Se; V += 1)
                    ue[V] = pe[V + Se];
                return ue
            }()
              , Ae = {};
            return Ae.getAt = function(Se) {
                return we[Se]
            }
            ,
            Ae.getLength = function() {
                return we.length
            }
            ,
            Ae.multiply = function(Se) {
                for (var ue = new Array(Ae.getLength() + Se.getLength() - 1), V = 0; V < Ae.getLength(); V += 1)
                    for (var W = 0; W < Se.getLength(); W += 1)
                        ue[V + W] ^= F.gexp(F.glog(Ae.getAt(V)) + F.glog(Se.getAt(W)));
                return N(ue, 0)
            }
            ,
            Ae.mod = function(Se) {
                if (Ae.getLength() - Se.getLength() < 0)
                    return Ae;
                for (var ue = F.glog(Ae.getAt(0)) - F.glog(Se.getAt(0)), V = new Array(Ae.getLength()), W = 0; W < Ae.getLength(); W += 1)
                    V[W] = Ae.getAt(W);
                for (var W = 0; W < Se.getLength(); W += 1)
                    V[W] ^= F.gexp(F.glog(Se.getAt(W)) + ue);
                return N(V, 0).mod(Se)
            }
            ,
            Ae
        }
        var U = function() {
            var pe = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
              , ge = function(Se, ue) {
                var V = {};
                return V.totalCount = Se,
                V.dataCount = ue,
                V
            }
              , we = {}
              , Ae = function(Se, ue) {
                switch (ue) {
                case $.L:
                    return pe[(Se - 1) * 4 + 0];
                case $.M:
                    return pe[(Se - 1) * 4 + 1];
                case $.Q:
                    return pe[(Se - 1) * 4 + 2];
                case $.H:
                    return pe[(Se - 1) * 4 + 3];
                default:
                    return
                }
            };
            return we.getRSBlocks = function(Se, ue) {
                var V = Ae(Se, ue);
                if (typeof V > "u")
                    throw "bad rs block @ typeNumber:" + Se + "/errorCorrectionLevel:" + ue;
                for (var W = V.length / 3, D = [], I = 0; I < W; I += 1)
                    for (var L = V[I * 3 + 0], K = V[I * 3 + 1], X = V[I * 3 + 2], Y = 0; Y < L; Y += 1)
                        D.push(ge(K, X));
                return D
            }
            ,
            we
        }()
          , H = function() {
            var pe = []
              , ge = 0
              , we = {};
            return we.getBuffer = function() {
                return pe
            }
            ,
            we.getAt = function(Ae) {
                var Se = Math.floor(Ae / 8);
                return (pe[Se] >>> 7 - Ae % 8 & 1) == 1
            }
            ,
            we.put = function(Ae, Se) {
                for (var ue = 0; ue < Se; ue += 1)
                    we.putBit((Ae >>> Se - ue - 1 & 1) == 1)
            }
            ,
            we.getLengthInBits = function() {
                return ge
            }
            ,
            we.putBit = function(Ae) {
                var Se = Math.floor(ge / 8);
                pe.length <= Se && pe.push(0),
                Ae && (pe[Se] |= 128 >>> ge % 8),
                ge += 1
            }
            ,
            we
        }
          , Z = function(pe) {
            var ge = T.MODE_NUMBER
              , we = pe
              , Ae = {};
            Ae.getMode = function() {
                return ge
            }
            ,
            Ae.getLength = function(V) {
                return we.length
            }
            ,
            Ae.write = function(V) {
                for (var W = we, D = 0; D + 2 < W.length; )
                    V.put(Se(W.substring(D, D + 3)), 10),
                    D += 3;
                D < W.length && (W.length - D == 1 ? V.put(Se(W.substring(D, D + 1)), 4) : W.length - D == 2 && V.put(Se(W.substring(D, D + 2)), 7))
            }
            ;
            var Se = function(V) {
                for (var W = 0, D = 0; D < V.length; D += 1)
                    W = W * 10 + ue(V.charAt(D));
                return W
            }
              , ue = function(V) {
                if ("0" <= V && V <= "9")
                    return V.charCodeAt(0) - 48;
                throw "illegal char :" + V
            };
            return Ae
        }
          , J = function(pe) {
            var ge = T.MODE_ALPHA_NUM
              , we = pe
              , Ae = {};
            Ae.getMode = function() {
                return ge
            }
            ,
            Ae.getLength = function(ue) {
                return we.length
            }
            ,
            Ae.write = function(ue) {
                for (var V = we, W = 0; W + 1 < V.length; )
                    ue.put(Se(V.charAt(W)) * 45 + Se(V.charAt(W + 1)), 11),
                    W += 2;
                W < V.length && ue.put(Se(V.charAt(W)), 6)
            }
            ;
            var Se = function(ue) {
                if ("0" <= ue && ue <= "9")
                    return ue.charCodeAt(0) - 48;
                if ("A" <= ue && ue <= "Z")
                    return ue.charCodeAt(0) - 65 + 10;
                switch (ue) {
                case " ":
                    return 36;
                case "$":
                    return 37;
                case "%":
                    return 38;
                case "*":
                    return 39;
                case "+":
                    return 40;
                case "-":
                    return 41;
                case ".":
                    return 42;
                case "/":
                    return 43;
                case ":":
                    return 44;
                default:
                    throw "illegal char :" + ue
                }
            };
            return Ae
        }
          , ie = function(pe) {
            var ge = T.MODE_8BIT_BYTE
              , we = M.stringToBytes(pe)
              , Ae = {};
            return Ae.getMode = function() {
                return ge
            }
            ,
            Ae.getLength = function(Se) {
                return we.length
            }
            ,
            Ae.write = function(Se) {
                for (var ue = 0; ue < we.length; ue += 1)
                    Se.put(we[ue], 8)
            }
            ,
            Ae
        }
          , oe = function(pe) {
            var ge = T.MODE_KANJI
              , we = M.stringToBytesFuncs.SJIS;
            if (!we)
                throw "sjis not supported.";
            (function(ue, V) {
                var W = we(ue);
                if (W.length != 2 || (W[0] << 8 | W[1]) != V)
                    throw "sjis not supported."
            }
            )("", 38726);
            var Ae = we(pe)
              , Se = {};
            return Se.getMode = function() {
                return ge
            }
            ,
            Se.getLength = function(ue) {
                return ~~(Ae.length / 2)
            }
            ,
            Se.write = function(ue) {
                for (var V = Ae, W = 0; W + 1 < V.length; ) {
                    var D = (255 & V[W]) << 8 | 255 & V[W + 1];
                    if (33088 <= D && D <= 40956)
                        D -= 33088;
                    else if (57408 <= D && D <= 60351)
                        D -= 49472;
                    else
                        throw "illegal char at " + (W + 1) + "/" + D;
                    D = (D >>> 8 & 255) * 192 + (D & 255),
                    ue.put(D, 13),
                    W += 2
                }
                if (W < V.length)
                    throw "illegal char at " + (W + 1)
            }
            ,
            Se
        }
          , ae = function() {
            var pe = []
              , ge = {};
            return ge.writeByte = function(we) {
                pe.push(we & 255)
            }
            ,
            ge.writeShort = function(we) {
                ge.writeByte(we),
                ge.writeByte(we >>> 8)
            }
            ,
            ge.writeBytes = function(we, Ae, Se) {
                Ae = Ae || 0,
                Se = Se || we.length;
                for (var ue = 0; ue < Se; ue += 1)
                    ge.writeByte(we[ue + Ae])
            }
            ,
            ge.writeString = function(we) {
                for (var Ae = 0; Ae < we.length; Ae += 1)
                    ge.writeByte(we.charCodeAt(Ae))
            }
            ,
            ge.toByteArray = function() {
                return pe
            }
            ,
            ge.toString = function() {
                var we = "";
                we += "[";
                for (var Ae = 0; Ae < pe.length; Ae += 1)
                    Ae > 0 && (we += ","),
                    we += pe[Ae];
                return we += "]",
                we
            }
            ,
            ge
        }
          , se = function() {
            var pe = 0
              , ge = 0
              , we = 0
              , Ae = ""
              , Se = {}
              , ue = function(W) {
                Ae += String.fromCharCode(V(W & 63))
            }
              , V = function(W) {
                if (!(W < 0)) {
                    if (W < 26)
                        return 65 + W;
                    if (W < 52)
                        return 97 + (W - 26);
                    if (W < 62)
                        return 48 + (W - 52);
                    if (W == 62)
                        return 43;
                    if (W == 63)
                        return 47
                }
                throw "n:" + W
            };
            return Se.writeByte = function(W) {
                for (pe = pe << 8 | W & 255,
                ge += 8,
                we += 1; ge >= 6; )
                    ue(pe >>> ge - 6),
                    ge -= 6
            }
            ,
            Se.flush = function() {
                if (ge > 0 && (ue(pe << 6 - ge),
                pe = 0,
                ge = 0),
                we % 3 != 0)
                    for (var W = 3 - we % 3, D = 0; D < W; D += 1)
                        Ae += "="
            }
            ,
            Se.toString = function() {
                return Ae
            }
            ,
            Se
        }
          , le = function(pe) {
            var ge = pe
              , we = 0
              , Ae = 0
              , Se = 0
              , ue = {};
            ue.read = function() {
                for (; Se < 8; ) {
                    if (we >= ge.length) {
                        if (Se == 0)
                            return -1;
                        throw "unexpected end of file./" + Se
                    }
                    var W = ge.charAt(we);
                    if (we += 1,
                    W == "=")
                        return Se = 0,
                        -1;
                    if (W.match(/^\s$/))
                        continue;
                    Ae = Ae << 6 | V(W.charCodeAt(0)),
                    Se += 6
                }
                var D = Ae >>> Se - 8 & 255;
                return Se -= 8,
                D
            }
            ;
            var V = function(W) {
                if (65 <= W && W <= 90)
                    return W - 65;
                if (97 <= W && W <= 122)
                    return W - 97 + 26;
                if (48 <= W && W <= 57)
                    return W - 48 + 52;
                if (W == 43)
                    return 62;
                if (W == 47)
                    return 63;
                throw "c:" + W
            };
            return ue
        }
          , de = function(pe, ge) {
            var we = pe
              , Ae = ge
              , Se = new Array(pe * ge)
              , ue = {};
            ue.setPixel = function(I, L, K) {
                Se[L * we + I] = K
            }
            ,
            ue.write = function(I) {
                I.writeString("GIF87a"),
                I.writeShort(we),
                I.writeShort(Ae),
                I.writeByte(128),
                I.writeByte(0),
                I.writeByte(0),
                I.writeByte(0),
                I.writeByte(0),
                I.writeByte(0),
                I.writeByte(255),
                I.writeByte(255),
                I.writeByte(255),
                I.writeString(","),
                I.writeShort(0),
                I.writeShort(0),
                I.writeShort(we),
                I.writeShort(Ae),
                I.writeByte(0);
                var L = 2
                  , K = W(L);
                I.writeByte(L);
                for (var X = 0; K.length - X > 255; )
                    I.writeByte(255),
                    I.writeBytes(K, X, 255),
                    X += 255;
                I.writeByte(K.length - X),
                I.writeBytes(K, X, K.length - X),
                I.writeByte(0),
                I.writeString(";")
            }
            ;
            var V = function(I) {
                var L = I
                  , K = 0
                  , X = 0
                  , Y = {};
                return Y.write = function(j, G) {
                    if (j >>> G)
                        throw "length over";
                    for (; K + G >= 8; )
                        L.writeByte(255 & (j << K | X)),
                        G -= 8 - K,
                        j >>>= 8 - K,
                        X = 0,
                        K = 0;
                    X = j << K | X,
                    K = K + G
                }
                ,
                Y.flush = function() {
                    K > 0 && L.writeByte(X)
                }
                ,
                Y
            }
              , W = function(I) {
                for (var L = 1 << I, K = (1 << I) + 1, X = I + 1, Y = D(), j = 0; j < L; j += 1)
                    Y.add(String.fromCharCode(j));
                Y.add(String.fromCharCode(L)),
                Y.add(String.fromCharCode(K));
                var G = ae()
                  , ne = V(G);
                ne.write(L, X);
                var te = 0
                  , ce = String.fromCharCode(Se[te]);
                for (te += 1; te < Se.length; ) {
                    var Ee = String.fromCharCode(Se[te]);
                    te += 1,
                    Y.contains(ce + Ee) ? ce = ce + Ee : (ne.write(Y.indexOf(ce), X),
                    Y.size() < 4095 && (Y.size() == 1 << X && (X += 1),
                    Y.add(ce + Ee)),
                    ce = Ee)
                }
                return ne.write(Y.indexOf(ce), X),
                ne.write(K, X),
                ne.flush(),
                G.toByteArray()
            }
              , D = function() {
                var I = {}
                  , L = 0
                  , K = {};
                return K.add = function(X) {
                    if (K.contains(X))
                        throw "dup key:" + X;
                    I[X] = L,
                    L += 1
                }
                ,
                K.size = function() {
                    return L
                }
                ,
                K.indexOf = function(X) {
                    return I[X]
                }
                ,
                K.contains = function(X) {
                    return typeof I[X] < "u"
                }
                ,
                K
            };
            return ue
        }
          , fe = function(pe, ge, we) {
            for (var Ae = de(pe, ge), Se = 0; Se < ge; Se += 1)
                for (var ue = 0; ue < pe; ue += 1)
                    Ae.setPixel(ue, Se, we(ue, Se));
            var V = ae();
            Ae.write(V);
            for (var W = se(), D = V.toByteArray(), I = 0; I < D.length; I += 1)
                W.writeByte(D[I]);
            return W.flush(),
            "data:image/gif;base64," + W
        };
        return M
    }();
    (function() {
        E.stringToBytesFuncs["UTF-8"] = function(M) {
            function T($) {
                for (var B = [], O = 0; O < $.length; O++) {
                    var F = $.charCodeAt(O);
                    F < 128 ? B.push(F) : F < 2048 ? B.push(192 | F >> 6, 128 | F & 63) : F < 55296 || F >= 57344 ? B.push(224 | F >> 12, 128 | F >> 6 & 63, 128 | F & 63) : (O++,
                    F = 65536 + ((F & 1023) << 10 | $.charCodeAt(O) & 1023),
                    B.push(240 | F >> 18, 128 | F >> 12 & 63, 128 | F >> 6 & 63, 128 | F & 63))
                }
                return B
            }
            return T(M)
        }
    }
    )(),
    function(M) {
        C.exports = M()
    }(function() {
        return E
    })
}
)(qrcode$1);
const qrcode = qrcode$1.exports;
function copyToClipboard(C) {
    return __async(this, null, function*() {
        try {
            if (!(navigator != null && navigator.clipboard))
                throw new TonConnectUIError("Clipboard API not available");
            return yield navigator.clipboard.writeText(C)
        } catch {}
        fallbackCopyTextToClipboard(C)
    })
}
function fallbackCopyTextToClipboard(C) {
    const S = document.createElement("textarea");
    S.value = C,
    S.style.top = "0",
    S.style.left = "0",
    S.style.position = "fixed",
    document.body.appendChild(S),
    S.focus(),
    S.select();
    try {
        document.execCommand("copy")
    } finally {
        document.body.removeChild(S)
    }
}
const _tmpl$$s = template$1("<div></div>")
  , QRCode = C=>{
    let S, E, M;
    const [T,$] = createSignal(!1)
      , [B,O] = createSignal(picSizeDefault);
    createEffect(()=>{
        const Z = qrcode(0, "L");
        Z.addData(C.sourceUrl),
        Z.make(),
        S.innerHTML = Z.createSvgTag(4, 0);
        const J = S.firstElementChild.clientWidth
          , ie = Math.round(qrNormalSize / J * 1e5) / 1e5;
        if (M) {
            const oe = Math.ceil(imgSizeDefault / (ie * 4)) * 4
              , ae = toPx(Math.ceil((J - oe) / (2 * 4)) * 4);
            M.style.top = ae,
            M.style.left = ae,
            M.style.height = toPx(oe),
            M.style.width = toPx(oe),
            O(Math.round(picSizeDefault / ie))
        }
        E.style.transform = `scale(${ie})`
    }
    );
    let F = null;
    return createComponent(QrCodeBackground, {
        get class() {
            return C.class
        },
        onClick: ()=>{
            $(!0),
            copyToClipboard(C.sourceUrl),
            F != null && clearTimeout(F),
            F = setTimeout(()=>$(!1), 1500)
        }
        ,
        get children() {
            return [createComponent(QrCodeWrapper$2, {
                ref(U) {
                    const H = E;
                    typeof H == "function" ? H(U) : E = U
                },
                get children() {
                    return [(()=>{
                        const U = _tmpl$$s.cloneNode(!0)
                          , H = S;
                        return typeof H == "function" ? use(H, U) : S = U,
                        U
                    }
                    )(), createComponent(Show, {
                        get when() {
                            return C.imageUrl
                        },
                        get children() {
                            return createComponent(ImageBackground, {
                                ref(U) {
                                    const H = M;
                                    typeof H == "function" ? H(U) : M = U
                                },
                                get children() {
                                    return createComponent(ImageStyled$3, {
                                        get src() {
                                            return C.imageUrl
                                        },
                                        alt: "",
                                        get size() {
                                            return B()
                                        }
                                    })
                                }
                            })
                        }
                    })]
                }
            }), createComponent(Transition$2, {
                onBeforeEnter: U=>{
                    animate(U, [{
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }, {
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    })
                }
                ,
                onExit: (U,H)=>{
                    animate(U, [{
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }, {
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    }).finished.then(()=>{
                        H()
                    }
                    )
                }
                ,
                get children() {
                    return createComponent(Show, {
                        get when() {
                            return T() && !C.disableCopy
                        },
                        get children() {
                            return createComponent(CopiedBoxStyled, {
                                get children() {
                                    return [createComponent(SuccessIcon, {
                                        size: "xs"
                                    }), createComponent(Text$1, {
                                        translationKey: "common.linkCopied",
                                        children: "Link Copied"
                                    })]
                                }
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !C.disableCopy
                },
                get children() {
                    return createComponent(CopyIconButton, {
                        get children() {
                            return createComponent(CopyLightIcon, {})
                        }
                    })
                }
            })]
        }
    })
}
;
var deepReadObject = (C,S,E)=>{
    const M = S.trim().split(".").reduce((T,$)=>T ? T[$] : void 0, C);
    return M !== void 0 ? M : E
}
  , template = (C,S,E=/{{(.*?)}}/g)=>C.replace(E, (M,T)=>deepReadObject(S, T, ""))
  , createI18nContext = (C={},S=navigator.language in C ? navigator.language : Object.keys(C)[0])=>{
    const [E,M] = createSignal(S)
      , [T,$] = createStore(C);
    return [(F,N,U)=>{
        const H = deepReadObject(T[E()], F, U || "");
        return typeof H == "function" ? H(N) : typeof H == "string" ? template(H, N || {}) : H
    }
    , {
        add(F, N) {
            $(F, U=>Object.assign(U || {}, N))
        },
        locale: F=>F ? M(F) : E(),
        dict: F=>deepReadObject(T, F)
    }]
}
  , I18nContext = createContext({})
  , useI18n = ()=>useContext(I18nContext);
const TextStyled$3 = styled$2.div`
    font-style: normal;
    font-weight: ${C=>C.fontWeight};
    font-size: ${C=>C.fontSize};
    line-height: ${C=>C.lineHeight};

    color: ${C=>C.color};
`
  , Text$1 = C=>{
    const S = useTheme$4()
      , [E] = useI18n();
    let M;
    const T = ()=>C.color || S.colors.text.primary
      , $ = mergeProps({
        fontSize: "14px",
        fontWeight: "510",
        lineHeight: "130%"
    }, C);
    return createEffect(()=>{
        M && $.cursor !== "unset" && getComputedStyle(M).cursor !== "pointer" && (M.style.cursor = "default")
    }
    ),
    createComponent(TextStyled$3, {
        get fontSize() {
            return $.fontSize
        },
        get fontWeight() {
            return $.fontWeight
        },
        get lineHeight() {
            return $.lineHeight
        },
        get color() {
            return T()
        },
        get class() {
            return $.class
        },
        ref(B) {
            const O = M;
            typeof O == "function" ? O(B) : M = B
        },
        "data-tc-text": "true",
        get children() {
            var B;
            return createMemo(()=>!!$.translationKey)() ? E($.translationKey, $.translationValues, (B = $.children) == null ? void 0 : B.toString()) : $.children
        }
    })
}
  , ImageContainer = styled$2.div`
    position: relative;

    &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border: 0.5px solid rgba(0, 0, 0, 0.08);

        border-radius: inherit;
    }
`
  , ImageStyled$2 = styled$2(Image)`
    width: 100%;
    height: 100%;
    border-radius: inherit;
`
  , WalletImage = C=>createComponent(ImageContainer, {
    get class() {
        return C.class
    },
    get children() {
        return createComponent(ImageStyled$2, {
            get src() {
                return C.src
            }
        })
    }
})
  , borders$3 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , badgeBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , WalletItemStyled = styled$2.button`
    position: relative;
    cursor: pointer;
    border: none;
    background-color: unset;
    padding: 8px 4px;
    width: 92px;
    display: flex;
    flex-direction: column;
    align-items: center;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${media("mobile")} {
        padding: 8px 4px;
        width: 82px;
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , ImageStyled$1 = styled$2(WalletImage)`
    width: 60px;
    height: 60px;
    border-radius: ${C=>borders$3[C.theme.borderRadius]};

    margin-bottom: 8px;
`
  , BadgeStyled = styled$2(Image)`
    position: absolute;
    right: 10px;
    top: 50px;
    width: 24px;
    height: 24px;
    border-radius: ${C=>badgeBorders[C.theme.borderRadius]};
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
`
  , StyledText = styled$2(Text$1)`
    max-width: 90px;
    font-weight: 590;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , StyledSecondLine = styled$2(Text$1)`
    font-weight: 510;
    max-width: 90px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    color: ${C=>C.colorPrimary ? C.theme.colors.text.primary : C.theme.colors.text.secondary};

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , WalletItem = C=>createComponent(WalletItemStyled, {
    get class() {
        return C.class
    },
    onClick: ()=>C.onClick(),
    "data-tc-wallet-item": "true",
    get children() {
        return [createMemo(()=>createMemo(()=>typeof C.icon == "string")() ? createComponent(ImageStyled$1, {
            get src() {
                return C.icon
            }
        }) : C.icon), createMemo(()=>createMemo(()=>!!C.badgeUrl)() && createComponent(BadgeStyled, {
            get src() {
                return C.badgeUrl
            }
        })), createComponent(StyledText, {
            get children() {
                return C.name
            }
        }), createMemo(()=>createMemo(()=>!!C.secondLine)() && createComponent(StyledSecondLine, {
            get colorPrimary() {
                var S;
                return (S = C.secondLineColorPrimary) != null ? S : !0
            },
            get children() {
                return C.secondLine
            }
        }))]
    }
})
  , H1Styled$9 = styled$2.h1`
    font-style: normal;
    font-weight: 700;
    font-size: 20px;
    line-height: 28px;

    text-align: center;

    color: ${C=>C.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H1 = C=>{
    const [S] = useI18n();
    return createComponent(H1Styled$9, {
        get class() {
            return C.class
        },
        "data-tc-h1": "true",
        get children() {
            var E;
            return createMemo(()=>!!C.translationKey)() ? S(C.translationKey, C.translationValues, (E = C.children) == null ? void 0 : E.toString()) : C.children
        }
    })
}
  , H2Styled$5 = styled$2.h2`
    font-style: normal;
    font-weight: 510;
    font-size: 16px;
    line-height: 22px;

    text-align: center;

    color: ${C=>C.theme.colors.text.secondary};

    margin-top: 0;
    margin-bottom: 32px;

    cursor: default;
`
  , H2 = C=>{
    const [S] = useI18n();
    return createComponent(H2Styled$5, {
        get class() {
            return C.class
        },
        "data-tc-h2": "true",
        get children() {
            var E;
            return createMemo(()=>!!C.translationKey)() ? S(C.translationKey, C.translationValues, (E = C.children) == null ? void 0 : E.toString()) : C.children
        }
    })
}
  , H3Styled$1 = styled$2.h3`
    font-style: normal;
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;

    color: ${C=>C.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H3 = C=>{
    const [S] = useI18n();
    return createComponent(H3Styled$1, {
        "data-tc-h3": "true",
        get class() {
            return C.class
        },
        get children() {
            var E;
            return createMemo(()=>!!C.translationKey)() ? S(C.translationKey, C.translationValues, (E = C.children) == null ? void 0 : E.toString()) : C.children
        }
    })
}
  , _tmpl$$r = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.75 7.5C9.33579 7.5 9 7.16421 9 6.75C9 6.33579 9.33579 6 9.75 6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 18.6642 21.6642 19 21.25 19C20.8358 19 20.5 18.6642 20.5 18.25V8.56066L6.28033 22.7803C5.98744 23.0732 5.51256 23.0732 5.21967 22.7803C4.92678 22.4874 4.92678 22.0126 5.21967 21.7197L19.4393 7.5H9.75Z"></path></svg>')
  , LongArrowIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$r.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = E()
              , O = E();
            return B !== $._v$ && setAttribute(M, "fill", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$q = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z"></path></svg>')
  , TonIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$q.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$p = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><g clip-path="url(#clip0_3783_2045)"><circle cx="8" cy="8.00098" r="8"></circle><path d="M4.75 8.50098L7 10.751L11.75 6.00098" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_3783_2045"><rect width="16" height="16" fill="white" transform="translate(0 0.000976562)"></rect></clipPath></defs></svg>')
  , _tmpl$2$3 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z"></path></svg>')
  , _tmpl$3$2 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z"></path></svg>')
  , SuccessIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.size || "s"
      , M = ()=>C.fill || S.colors.icon.success;
    return createMemo((()=>{
        const T = createMemo(()=>E() === "xs");
        return ()=>T() ? (()=>{
            const $ = _tmpl$$p.cloneNode(!0)
              , B = $.firstChild
              , O = B.firstChild
              , F = O.nextSibling;
            return createRenderEffect(N=>{
                const U = C.class
                  , H = M()
                  , Z = S.colors.constant.white;
                return U !== N._v$ && setAttribute($, "class", N._v$ = U),
                H !== N._v$2 && setAttribute(O, "fill", N._v$2 = H),
                Z !== N._v$3 && setAttribute(F, "stroke", N._v$3 = Z),
                N
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            $
        }
        )() : (()=>{
            const $ = createMemo(()=>E() === "s");
            return ()=>$() ? (()=>{
                const B = _tmpl$2$3.cloneNode(!0)
                  , O = B.firstChild
                  , F = O.nextSibling;
                return createRenderEffect(N=>{
                    const U = C.class
                      , H = M()
                      , Z = S.colors.constant.white;
                    return U !== N._v$4 && setAttribute(B, "class", N._v$4 = U),
                    H !== N._v$5 && setAttribute(O, "fill", N._v$5 = H),
                    Z !== N._v$6 && setAttribute(F, "fill", N._v$6 = Z),
                    N
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                B
            }
            )() : (()=>{
                const B = _tmpl$3$2.cloneNode(!0)
                  , O = B.firstChild
                  , F = O.nextSibling;
                return createRenderEffect(N=>{
                    const U = C.class
                      , H = M()
                      , Z = S.colors.constant.white;
                    return U !== N._v$7 && setAttribute(B, "class", N._v$7 = U),
                    H !== N._v$8 && setAttribute(O, "fill", N._v$8 = H),
                    Z !== N._v$9 && setAttribute(F, "fill", N._v$9 = Z),
                    N
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                B
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$o = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z"></path></svg>')
  , _tmpl$2$2 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><circle cx="24" cy="24.001" r="22"></circle><path d="M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , _tmpl$3$1 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z"></path></svg>')
  , ErrorIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.size || "m"
      , M = ()=>C.fill || S.colors.icon.error;
    return createMemo((()=>{
        const T = createMemo(()=>E() === "m");
        return ()=>T() ? (()=>{
            const $ = _tmpl$$o.cloneNode(!0)
              , B = $.firstChild
              , O = B.nextSibling;
            return createRenderEffect(F=>{
                const N = C.class
                  , U = M()
                  , H = S.colors.constant.white;
                return N !== F._v$ && setAttribute($, "class", F._v$ = N),
                U !== F._v$2 && setAttribute(B, "fill", F._v$2 = U),
                H !== F._v$3 && setAttribute(O, "fill", F._v$3 = H),
                F
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            $
        }
        )() : (()=>{
            const $ = createMemo(()=>E() === "s");
            return ()=>$() ? (()=>{
                const B = _tmpl$2$2.cloneNode(!0)
                  , O = B.firstChild
                  , F = O.nextSibling;
                return createRenderEffect(N=>{
                    const U = C.class
                      , H = M()
                      , Z = S.colors.constant.white;
                    return U !== N._v$4 && setAttribute(B, "class", N._v$4 = U),
                    H !== N._v$5 && setAttribute(O, "fill", N._v$5 = H),
                    Z !== N._v$6 && setAttribute(F, "stroke", N._v$6 = Z),
                    N
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                B
            }
            )() : (()=>{
                const B = _tmpl$3$1.cloneNode(!0)
                  , O = B.firstChild
                  , F = O.nextSibling;
                return createRenderEffect(N=>{
                    const U = C.class
                      , H = M()
                      , Z = S.colors.constant.white;
                    return U !== N._v$7 && setAttribute(B, "class", N._v$7 = U),
                    H !== N._v$8 && setAttribute(O, "fill", N._v$8 = H),
                    Z !== N._v$9 && setAttribute(F, "fill", N._v$9 = Z),
                    N
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                B
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$n = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z"></path></svg>')
  , _tmpl$2$1 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z"></path></svg>')
  , _tmpl$3 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , LoaderIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.size || "xs"
      , M = ()=>C.fill || S.colors.icon.tertiary
      , T = h$2`
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
    `
      , $ = u$1`
        animation: ${T} 1s linear infinite;
    `;
    return createMemo((()=>{
        const B = createMemo(()=>E() === "xs");
        return ()=>B() ? (()=>{
            const O = _tmpl$$n.cloneNode(!0)
              , F = O.firstChild;
            return createRenderEffect(N=>{
                const U = classNames($, C.class)
                  , H = M();
                return U !== N._v$ && setAttribute(O, "class", N._v$ = U),
                H !== N._v$2 && setAttribute(F, "fill", N._v$2 = H),
                N
            }
            , {
                _v$: void 0,
                _v$2: void 0
            }),
            O
        }
        )() : (()=>{
            const O = createMemo(()=>E() === "s");
            return ()=>O() ? (()=>{
                const F = _tmpl$2$1.cloneNode(!0)
                  , N = F.firstChild;
                return createRenderEffect(U=>{
                    const H = classNames($, C.class)
                      , Z = M();
                    return H !== U._v$3 && setAttribute(F, "class", U._v$3 = H),
                    Z !== U._v$4 && setAttribute(N, "fill", U._v$4 = Z),
                    U
                }
                , {
                    _v$3: void 0,
                    _v$4: void 0
                }),
                F
            }
            )() : (()=>{
                const F = _tmpl$3.cloneNode(!0)
                  , N = F.firstChild;
                return createRenderEffect(U=>{
                    const H = classNames($, C.class)
                      , Z = M();
                    return H !== U._v$5 && setAttribute(F, "class", U._v$5 = H),
                    Z !== U._v$6 && setAttribute(N, "stroke", U._v$6 = Z),
                    U
                }
                , {
                    _v$5: void 0,
                    _v$6: void 0
                }),
                F
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$m = template$1('<svg width="158" height="28" viewBox="0 0 158 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z" fill="#0098EA"></path><path d="M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z"></path></svg>')
  , TonConnectBrand = ()=>{
    const C = useTheme$4()
      , S = ()=>C.theme === THEME.DARK ? C.colors.constant.white : C.colors.constant.black;
    return (()=>{
        const E = _tmpl$$m.cloneNode(!0)
          , M = E.firstChild
          , T = M.nextSibling
          , $ = T.nextSibling;
        return createRenderEffect(()=>setAttribute($, "fill", S())),
        E
    }
    )()
}
  , _tmpl$$l = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z"></path></svg>')
  , QuestionIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$l.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$k = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z"></path></svg>')
  , BrowserIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$k.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$j = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z"></path></svg>')
  , MobileIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$j.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$i = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z"></path></svg>')
  , DesktopIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$i.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$h = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1603)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z"></path></g><defs><clipPath id="clip0_3676_1603"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000488281)"></rect></clipPath></defs></svg>')
  , RetryIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.accent;
    return (()=>{
        const M = _tmpl$$h.cloneNode(!0)
          , T = M.firstChild
          , $ = T.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$g = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z"></path></svg>')
  , LinkIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.accent;
    return (()=>{
        const M = _tmpl$$g.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$f = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1274)"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z"></path></g><defs><clipPath id="clip0_3676_1274"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000976562)"></rect></clipPath></defs></svg>')
  , WalletIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.accent;
    return (()=>{
        const M = _tmpl$$f.cloneNode(!0)
          , T = M.firstChild
          , $ = T.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", E())),
        M
    }
    )()
}
  , _tmpl$$e = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z"></path></svg>')
  , SecurityIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$e.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$d = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z"></path></svg>')
  , PersonalityIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$d.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$c = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z"></path></svg>')
  , SwapIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$c.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$b = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="29" viewBox="0 0 28 29" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z"></path></svg>')
  , AtWalletIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.constant.white;
    return (()=>{
        const M = _tmpl$$b.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$a = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.7803 7.21967C25.0732 7.51256 25.0732 7.98744 24.7803 8.28033L11.5303 21.5303C11.2374 21.8232 10.7626 21.8232 10.4697 21.5303L4.21967 15.2803C3.92678 14.9874 3.92678 14.5126 4.21967 14.2197C4.51256 13.9268 4.98744 13.9268 5.28033 14.2197L11 19.9393L23.7197 7.21967C24.0126 6.92678 24.4874 6.92678 24.7803 7.21967Z"></path></svg>')
  , DoneIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$a.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$9 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z"></path></svg>')
  , CopyLightIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$9.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = E()
              , O = E();
            return B !== $._v$ && setAttribute(M, "fill", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$8 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" viewBox="0 0 16 17" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z"></path></svg>')
  , QRIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.secondary;
    return (()=>{
        const M = _tmpl$$8.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect(()=>setAttribute(T, "fill", E())),
        M
    }
    )()
}
  , containerBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , walletBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , FourWalletsCard = styled$2.div`
    width: 60px;
    height: 60px;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: ${C=>containerBorders[C.theme.borderRadius]};
    background-color: ${C=>C.theme.colors.background.tint};
    display: grid;
    grid-template: 1fr 1fr / 1fr 1fr;
    gap: 4px;
`
  , FourWalletsImage = styled$2(WalletImage)`
    width: 20px;
    height: 20px;
    border-radius: ${C=>walletBorders[C.theme.borderRadius]};
`
  , FourWalletsItem = C=>createComponent(WalletItem, {
    get name() {
        return C.labelLine1
    },
    get secondLine() {
        return C.labelLine2
    },
    get icon() {
        return createComponent(FourWalletsCard, {
            get children() {
                return createComponent(For, {
                    each: [0, 1, 2, 3],
                    children: S=>createComponent(FourWalletsImage, {
                        get src() {
                            return C.images[S]
                        }
                    })
                })
            }
        })
    },
    onClick: ()=>C.onClick()
})
  , AT_WALLET_APP_NAME = "telegram-wallet"
  , IMG = {
    TON: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png",
    TG: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png"
}
  , WalletLabeledItem = C=>{
    const [S] = useI18n()
      , E = ()=>{
        if (C.wallet.appName !== AT_WALLET_APP_NAME) {
            if ("isPreferred"in C.wallet && C.wallet.isPreferred)
                return S("walletItem.recent", {}, "Recent");
            if (isWalletInfoCurrentlyInjected(C.wallet))
                return S("walletItem.installed", {}, "Installed");
            if (C.wallet.name === "Tonkeeper")
                return S("walletItem.popular", {}, "Popular")
        }
    }
    ;
    return createMemo((()=>{
        const M = createMemo(()=>C.wallet.appName === AT_WALLET_APP_NAME);
        return ()=>M() ? createComponent(WalletItem, {
            get icon() {
                return C.wallet.imageUrl
            },
            get name() {
                return S("walletItem.walletOn", {}, "Wallet On")
            },
            secondLine: "Telegram",
            get badgeUrl() {
                return IMG.TG
            },
            onClick: ()=>C.onClick()
        }) : createComponent(WalletItem, {
            get icon() {
                return C.wallet.imageUrl
            },
            get name() {
                return C.wallet.name
            },
            get secondLine() {
                return E()
            },
            secondLineColorPrimary: !1,
            onClick: ()=>C.onClick()
        })
    }
    )())
}
  , ScrollContainerStyled = styled$2.div`
    width: 100%;
    overflow-y: auto;
    max-height: ${C=>C.maxHeight};

    scrollbar-width: none;
    &&::-webkit-scrollbar {
        display: none;
    }

    &&::-webkit-scrollbar-track {
        background: transparent;
    }

    &&::-webkit-scrollbar-thumb {
        display: none;
    }
`
  , ScrollDivider = styled$2.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.08;
    background: ${C=>C.isShown ? C.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
        margin: 0;
    }
`
  , [windowHeight,setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);
getWindow$1() && window.addEventListener("resize", ()=>setWindowHeight(window.innerHeight));
const [isMobile$1,setIsMobile] = createSignal(isDevice("mobile"))
  , updateIsMobile = ()=>setIsMobile(isDevice("mobile"));
getWindow$1() && (window.addEventListener("resize", ()=>updateIsMobile()),
window.addEventListener("load", ()=>updateIsMobile(), {
    once: !0
}));
const ScrollContainer = C=>{
    const [S,E] = createSignal(!1)
      , M = B=>{
        E(B.target.scrollTop > 0)
    }
      , T = ()=>isMobile$1() ? 150 : 200
      , $ = ()=>C.maxHeight !== void 0 ? `${C.maxHeight}px` : `${windowHeight() - T()}px`;
    return [createComponent(ScrollDivider, {
        get isShown() {
            return S()
        }
    }), createComponent(ScrollContainerStyled, {
        get maxHeight() {
            return $()
        },
        onScroll: M,
        get class() {
            return C.class
        },
        get children() {
            return C.children
        }
    })]
}
  , AStyled = styled$2.a`
    display: block;
    text-decoration: unset;
`
  , Link = C=>createComponent(AStyled, mergeProps({
    get href() {
        return C.href
    },
    get target() {
        return C.blank ? "_blank" : "_self"
    },
    get class() {
        return C.class
    }
}, ()=>C.blank ? {
    rel: "noreferrer noopener"
} : {}, {
    get children() {
        return C.children
    }
}))
  , TonConnectUiContext = createContext()
  , _tmpl$$7 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z"></path></svg>')
  , CopyIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$7.cloneNode(!0)
          , T = M.firstChild;
        return createRenderEffect($=>{
            const B = C.class
              , O = E();
            return B !== $._v$ && setAttribute(M, "class", $._v$ = B),
            O !== $._v$2 && setAttribute(T, "fill", $._v$2 = O),
            $
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , _tmpl$$6 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z"></path><path d="M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z"></path></svg>')
  , DisconnectIcon = C=>{
    const S = useTheme$4()
      , E = ()=>C.fill || S.colors.icon.primary;
    return (()=>{
        const M = _tmpl$$6.cloneNode(!0)
          , T = M.firstChild
          , $ = T.nextSibling;
        return createRenderEffect(B=>{
            const O = E()
              , F = E();
            return O !== B._v$ && setAttribute(T, "fill", B._v$ = O),
            F !== B._v$2 && setAttribute($, "fill", B._v$2 = F),
            B
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        M
    }
    )()
}
  , hoverBorders$1 = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , dropdownBorders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , AccountButtonDropdownStyled = styled$2.div`
    width: 256px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${C=>dropdownBorders[C.theme.borderRadius]};

    background-color: ${C=>C.theme.colors.background.primary}
           
    color: ${C=>C.theme.colors.text.primary}
`
  , UlStyled$1 = styled$2.ul`
    background-color: ${C=>C.theme.colors.background.primary};
    padding: 8px;
`
  , MenuButtonStyled = styled$2.button`
    display: flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding-left: 8px;
    width: 100%;

    background-color: ${C=>C.theme.colors.background.primary};
    border: none;
    border-radius: ${C=>hoverBorders$1[C.theme.borderRadius]};
    cursor: pointer;

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${C=>C.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`
  , _tmpl$$5 = template$1("<li></li>")
  , MenuItemText = C=>createComponent(Text$1, {
    get translationKey() {
        return C.translationKey
    },
    fontSize: "15px",
    fontWeight: "590",
    get children() {
        return C.children
    }
})
  , AccountButtonDropdown = C=>{
    const S = useContext(TonConnectUiContext)
      , [E,M] = createSignal(!1)
      , T = ()=>__async(void 0, null, function*() {
        const B = toUserFriendlyAddress(S.account.address, S.account.chain === CHAIN.TESTNET);
        yield copyToClipboard(B),
        M(!0),
        setTimeout(()=>M(!1), 1e3)
    })
      , $ = ()=>{
        S.disconnect(),
        C.onClose()
    }
    ;
    return createComponent(AccountButtonDropdownStyled, {
        ref(B) {
            const O = C.ref;
            typeof O == "function" ? O(B) : C.ref = B
        },
        get class() {
            return C.class
        },
        "data-tc-dropdown": "true",
        get children() {
            return createComponent(UlStyled$1, {
                get children() {
                    return [(()=>{
                        const B = _tmpl$$5.cloneNode(!0);
                        return insert$1(B, createComponent(MenuButtonStyled, {
                            onClick: ()=>T(),
                            get children() {
                                return [createComponent(CopyIcon, {}), createComponent(Show, {
                                    get when() {
                                        return !E()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copy",
                                            children: "Copy address"
                                        })
                                    }
                                }), createComponent(Show, {
                                    get when() {
                                        return E()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copied",
                                            children: "Address copied!"
                                        })
                                    }
                                })]
                            }
                        })),
                        B
                    }
                    )(), (()=>{
                        const B = _tmpl$$5.cloneNode(!0);
                        return insert$1(B, createComponent(MenuButtonStyled, {
                            onClick: ()=>$(),
                            get children() {
                                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {
                                    translationKey: "button.dropdown.disconnect",
                                    children: "Disconnect"
                                })]
                            }
                        })),
                        B
                    }
                    )()]
                }
            })
        }
    })
}
  , borders$2 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , NotificationStyled = styled$2.div`
    width: 256px;
    padding: 12px 16px;
    display: flex;
    gap: 9px;

    background-color: ${C=>C.theme.colors.background.primary};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${C=>borders$2[C.theme.borderRadius]};
`
  , NotificationContentStyled = styled$2.div`
    width: 192px;

    > h3 {
        font-size: 15px;
    }
`
  , TextStyled$2 = styled$2(Text$1)`
    margin-top: 4px;
    color: ${C=>C.theme.colors.text.secondary};
`
  , Notification$1 = C=>{
    const S = useDataAttributes(C);
    return createComponent(NotificationStyled, mergeProps({
        get class() {
            return C.class
        },
        "data-tc-notification": "true"
    }, S, {
        get children() {
            return [createComponent(NotificationContentStyled, {
                get children() {
                    return [createComponent(H3, {
                        get translationKey() {
                            return C.header.translationKey
                        },
                        get translationValues() {
                            return C.header.translationValues
                        },
                        get children() {
                            return C.children
                        }
                    }), createComponent(Show, {
                        get when() {
                            return C.text
                        },
                        get children() {
                            return createComponent(TextStyled$2, {
                                get translationKey() {
                                    return C.text.translationKey
                                },
                                get translationValues() {
                                    return C.text.translationValues
                                }
                            })
                        }
                    })]
                }
            }), createMemo(()=>C.icon)]
        }
    }))
}
  , LoaderIconStyled$1 = styled$2(LoaderIcon)`
    align-self: center;
`
  , ConfirmOperationNotification = C=>{
    const S = useContext(TonConnectUiContext)
      , [E] = useI18n()
      , M = ()=>S.wallet && "name"in S.wallet ? S.wallet.name : E("common.yourWallet", {}, "Your wallet");
    return createComponent(Notification$1, {
        get header() {
            return {
                translationKey: "notifications.confirm.header",
                translationValues: {
                    name: M()
                }
            }
        },
        get class() {
            return C.class
        },
        get icon() {
            return createComponent(LoaderIconStyled$1, {})
        },
        "data-tc-notification-confirm": "true",
        children: "Confirm operation in your wallet"
    })
}
  , ErrorIconStyled$2 = styled$2(ErrorIcon)`
    margin-top: 2px;
`
  , ErrorTransactionNotification = C=>createComponent(Notification$1, {
    header: {
        translationKey: "notifications.transactionCanceled.header"
    },
    text: {
        translationKey: "notifications.transactionCanceled.text"
    },
    get icon() {
        return createComponent(ErrorIconStyled$2, {
            size: "xs"
        })
    },
    get class() {
        return C.class
    },
    "data-tc-notification-tx-cancelled": "true",
    children: "Transaction cancelled"
})
  , SuccessIconStyled = styled$2(SuccessIcon)`
    margin-top: 2px;
`
  , SuccessTransactionNotification = C=>createComponent(Notification$1, {
    header: {
        translationKey: "notifications.transactionSent.header"
    },
    text: {
        translationKey: "notifications.transactionSent.text"
    },
    get icon() {
        return createComponent(SuccessIconStyled, {})
    },
    get class() {
        return C.class
    },
    "data-tc-notification-tx-sent": "true",
    children: "Transaction sent"
})
  , NotificationClass = u$1`
    transform: translateY(-8px);
    margin-bottom: 12px;
`
  , defaultConfig$1 = {
    timeout: 4500
}
  , [latestAction,setLatestAction] = createSignal(null);
function useOpenedNotifications(C) {
    const {timeout: S} = __spreadValues$1(__spreadValues$1({}, defaultConfig$1), C)
      , [E,M] = createSignal([])
      , [T,$] = createSignal([]);
    return createEffect(on(action, B=>{
        if (!B || !B.showNotification || latestAction() === B)
            return;
        setLatestAction(B),
        M(N=>N.filter(U=>U.action !== "confirm-transaction"));
        const O = {
            action: B.name
        };
        M(N=>[...N, O]);
        const F = setTimeout(()=>{
            M(N=>N.filter(U=>U !== O)),
            $(N=>N.filter(U=>U !== F))
        }
        , S);
        $(N=>[...N, F])
    }
    )),
    onCleanup(()=>{
        T().forEach(B=>clearTimeout(B))
    }
    ),
    E
}
const _tmpl$$4 = template$1('<div data-tc-list-notifications="true"></div>')
  , Notifications$1 = C=>{
    const S = useOpenedNotifications();
    return (()=>{
        const E = _tmpl$$4.cloneNode(!0);
        return insert$1(E, createComponent(TransitionGroup$2, {
            onBeforeEnter: M=>{
                animate(M, [{
                    opacity: 0,
                    transform: "translateY(0)"
                }, {
                    opacity: 1,
                    transform: "translateY(-8px)"
                }], {
                    duration: 200
                })
            }
            ,
            onExit: (M,T)=>{
                animate(M, [{
                    opacity: 1,
                    transform: "translateY(-8px)"
                }, {
                    opacity: 0,
                    transform: "translateY(-30px)"
                }], {
                    duration: 200
                }).finished.then(T)
            }
            ,
            get children() {
                return createComponent(For, {
                    get each() {
                        return S()
                    },
                    children: M=>createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return M.action === "transaction-sent"
                                },
                                get children() {
                                    return createComponent(SuccessTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return M.action === "transaction-canceled"
                                },
                                get children() {
                                    return createComponent(ErrorTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return M.action === "confirm-transaction"
                                },
                                get children() {
                                    return createComponent(ConfirmOperationNotification, {
                                        class: NotificationClass
                                    })
                                }
                            })]
                        }
                    })
                })
            }
        })),
        createRenderEffect(()=>className(E, C.class)),
        E
    }
    )()
}
  , AccountButtonStyled = styled$2(Button)`
    background-color: ${C=>C.theme.colors.connectButton.background};
    color: ${C=>C.theme.colors.connectButton.foreground};
    box-shadow: ${C=>`0 4px 24px ${rgba(C.theme.colors.constant.black, .16)}`};
    padding: 8px 16px 8px 12px;

    display: flex;
    align-items: center;
    gap: 4px;
    height: 40px;
`
  , DropdownButtonStyled = styled$2(AccountButtonStyled)`
    padding: 12px 16px;
    min-width: 148px;
    justify-content: center;
    background-color: ${C=>C.theme.colors.background.primary};
`
  , LoaderButtonStyled = styled$2(Button)`
    min-width: 148px;
    height: 40px;

    background-color: ${C=>C.theme.colors.background.primary};
    color: ${C=>C.theme.colors.connectButton.foreground};
    box-shadow: ${C=>`0 4px 24px ${rgba(C.theme.colors.constant.black, .16)}`};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , LoaderIconStyled = styled$2(LoaderIcon)`
    height: 18px;
    width: 18px;
`
  , DropdownContainerStyled = styled$2.div`
    width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
`
  , DropdownStyled = styled$2(AccountButtonDropdown)`
    box-sizing: border-box;
    overflow: hidden;
    margin-top: 12px;
`
  , NotificationsStyled = styled$2(Notifications$1)`
    > div:first-child {
        margin-top: 20px;
    }
`;
function getSide(C) {
    return C.split("-")[0]
}
function getAlignment(C) {
    return C.split("-")[1]
}
function getMainAxisFromPlacement(C) {
    return ["top", "bottom"].includes(getSide(C)) ? "x" : "y"
}
function getLengthFromAxis(C) {
    return C === "y" ? "height" : "width"
}
function computeCoordsFromPlacement(C, S, E) {
    let {reference: M, floating: T} = C;
    const $ = M.x + M.width / 2 - T.width / 2
      , B = M.y + M.height / 2 - T.height / 2
      , O = getMainAxisFromPlacement(S)
      , F = getLengthFromAxis(O)
      , N = M[F] / 2 - T[F] / 2
      , U = getSide(S)
      , H = O === "x";
    let Z;
    switch (U) {
    case "top":
        Z = {
            x: $,
            y: M.y - T.height
        };
        break;
    case "bottom":
        Z = {
            x: $,
            y: M.y + M.height
        };
        break;
    case "right":
        Z = {
            x: M.x + M.width,
            y: B
        };
        break;
    case "left":
        Z = {
            x: M.x - T.width,
            y: B
        };
        break;
    default:
        Z = {
            x: M.x,
            y: M.y
        }
    }
    switch (getAlignment(S)) {
    case "start":
        Z[O] -= N * (E && H ? -1 : 1);
        break;
    case "end":
        Z[O] += N * (E && H ? -1 : 1);
        break
    }
    return Z
}
const computePosition$1 = (C,S,E)=>__async(void 0, null, function*() {
    const {placement: M="bottom", strategy: T="absolute", middleware: $=[], platform: B} = E
      , O = $.filter(Boolean)
      , F = yield B.isRTL == null ? void 0 : B.isRTL(S);
    if ({}.NODE_ENV !== "production") {
        if (B == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")),
        O.filter(oe=>{
            let {name: ae} = oe;
            return ae === "autoPlacement" || ae === "flip"
        }
        ).length > 1)
            throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
        (!C || !S) && console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "))
    }
    let N = yield B.getElementRects({
        reference: C,
        floating: S,
        strategy: T
    })
      , {x: U, y: H} = computeCoordsFromPlacement(N, M, F)
      , Z = M
      , J = {}
      , ie = 0;
    for (let oe = 0; oe < O.length; oe++) {
        const {name: ae, fn: se} = O[oe]
          , {x: le, y: de, data: fe, reset: pe} = yield se({
            x: U,
            y: H,
            initialPlacement: M,
            placement: Z,
            strategy: T,
            middlewareData: J,
            rects: N,
            platform: B,
            elements: {
                reference: C,
                floating: S
            }
        });
        if (U = le ?? U,
        H = de ?? H,
        J = __spreadProps(__spreadValues$1({}, J), {
            [ae]: __spreadValues$1(__spreadValues$1({}, J[ae]), fe)
        }),
        {}.NODE_ENV !== "production" && ie > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")),
        pe && ie <= 50) {
            ie++,
            typeof pe == "object" && (pe.placement && (Z = pe.placement),
            pe.rects && (N = pe.rects === !0 ? yield B.getElementRects({
                reference: C,
                floating: S,
                strategy: T
            }) : pe.rects),
            {x: U, y: H} = computeCoordsFromPlacement(N, Z, F)),
            oe = -1;
            continue
        }
    }
    return {
        x: U,
        y: H,
        placement: Z,
        strategy: T,
        middlewareData: J
    }
});
function rectToClientRect(C) {
    return __spreadProps(__spreadValues$1({}, C), {
        top: C.y,
        left: C.x,
        right: C.x + C.width,
        bottom: C.y + C.height
    })
}
function getWindow(C) {
    var S;
    return ((S = C.ownerDocument) == null ? void 0 : S.defaultView) || window
}
function getComputedStyle$1(C) {
    return getWindow(C).getComputedStyle(C)
}
function getNodeName(C) {
    return isNode(C) ? (C.nodeName || "").toLowerCase() : ""
}
let uaString;
function getUAString() {
    if (uaString)
        return uaString;
    const C = navigator.userAgentData;
    return C && Array.isArray(C.brands) ? (uaString = C.brands.map(S=>S.brand + "/" + S.version).join(" "),
    uaString) : navigator.userAgent
}
function isHTMLElement$1(C) {
    return C instanceof getWindow(C).HTMLElement
}
function isElement(C) {
    return C instanceof getWindow(C).Element
}
function isNode(C) {
    return C instanceof getWindow(C).Node
}
function isShadowRoot(C) {
    if (typeof ShadowRoot > "u")
        return !1;
    const S = getWindow(C).ShadowRoot;
    return C instanceof S || C instanceof ShadowRoot
}
function isOverflowElement(C) {
    const {overflow: S, overflowX: E, overflowY: M, display: T} = getComputedStyle$1(C);
    return /auto|scroll|overlay|hidden/.test(S + M + E) && !["inline", "contents"].includes(T)
}
function isTableElement(C) {
    return ["table", "td", "th"].includes(getNodeName(C))
}
function isContainingBlock(C) {
    const S = /firefox/i.test(getUAString())
      , E = getComputedStyle$1(C)
      , M = E.backdropFilter || E.WebkitBackdropFilter;
    return E.transform !== "none" || E.perspective !== "none" || (M ? M !== "none" : !1) || S && E.willChange === "filter" || S && (E.filter ? E.filter !== "none" : !1) || ["transform", "perspective"].some(T=>E.willChange.includes(T)) || ["paint", "layout", "strict", "content"].some(T=>{
        const $ = E.contain;
        return $ != null ? $.includes(T) : !1
    }
    )
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function isLastTraversableNode(C) {
    return ["html", "body", "#document"].includes(getNodeName(C))
}
const min = Math.min
  , max = Math.max
  , round$1 = Math.round
  , FALLBACK_SCALE = {
    x: 1,
    y: 1
};
function getScale$1(C) {
    const S = !isElement(C) && C.contextElement ? C.contextElement : isElement(C) ? C : null;
    if (!S)
        return FALLBACK_SCALE;
    const E = S.getBoundingClientRect()
      , M = getComputedStyle$1(S);
    if (M.boxSizing !== "border-box")
        return isHTMLElement$1(S) ? {
            x: S.offsetWidth > 0 && round$1(E.width) / S.offsetWidth || 1,
            y: S.offsetHeight > 0 && round$1(E.height) / S.offsetHeight || 1
        } : FALLBACK_SCALE;
    let T = E.width / parseFloat(M.width)
      , $ = E.height / parseFloat(M.height);
    return (!T || !Number.isFinite(T)) && (T = 1),
    (!$ || !Number.isFinite($)) && ($ = 1),
    {
        x: T,
        y: $
    }
}
function getBoundingClientRect(C, S, E, M) {
    var T, $, B, O;
    S === void 0 && (S = !1),
    E === void 0 && (E = !1);
    const F = C.getBoundingClientRect();
    let N = FALLBACK_SCALE;
    S && (M ? isElement(M) && (N = getScale$1(M)) : N = getScale$1(C));
    const U = isElement(C) ? getWindow(C) : window
      , H = !isLayoutViewport() && E
      , Z = (F.left + (H && (T = ($ = U.visualViewport) == null ? void 0 : $.offsetLeft) != null ? T : 0)) / N.x
      , J = (F.top + (H && (B = (O = U.visualViewport) == null ? void 0 : O.offsetTop) != null ? B : 0)) / N.y
      , ie = F.width / N.x
      , oe = F.height / N.y;
    return {
        width: ie,
        height: oe,
        top: J,
        right: Z + ie,
        bottom: J + oe,
        left: Z,
        x: Z,
        y: J
    }
}
function getDocumentElement(C) {
    return ((isNode(C) ? C.ownerDocument : C.document) || window.document).documentElement
}
function getNodeScroll(C) {
    return isElement(C) ? {
        scrollLeft: C.scrollLeft,
        scrollTop: C.scrollTop
    } : {
        scrollLeft: C.pageXOffset,
        scrollTop: C.pageYOffset
    }
}
function getWindowScrollBarX(C) {
    return getBoundingClientRect(getDocumentElement(C)).left + getNodeScroll(C).scrollLeft
}
function getRectRelativeToOffsetParent(C, S, E) {
    const M = isHTMLElement$1(S)
      , T = getDocumentElement(S)
      , $ = getBoundingClientRect(C, !0, E === "fixed", S);
    let B = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const O = {
        x: 0,
        y: 0
    };
    if (M || !M && E !== "fixed")
        if ((getNodeName(S) !== "body" || isOverflowElement(T)) && (B = getNodeScroll(S)),
        isHTMLElement$1(S)) {
            const F = getBoundingClientRect(S, !0);
            O.x = F.x + S.clientLeft,
            O.y = F.y + S.clientTop
        } else
            T && (O.x = getWindowScrollBarX(T));
    return {
        x: $.left + B.scrollLeft - O.x,
        y: $.top + B.scrollTop - O.y,
        width: $.width,
        height: $.height
    }
}
function getParentNode(C) {
    if (getNodeName(C) === "html")
        return C;
    const S = C.assignedSlot || C.parentNode || (isShadowRoot(C) ? C.host : null) || getDocumentElement(C);
    return isShadowRoot(S) ? S.host : S
}
function getTrueOffsetParent(C) {
    return !isHTMLElement$1(C) || getComputedStyle$1(C).position === "fixed" ? null : C.offsetParent
}
function getContainingBlock(C) {
    let S = getParentNode(C);
    for (; isHTMLElement$1(S) && !isLastTraversableNode(S); ) {
        if (isContainingBlock(S))
            return S;
        S = getParentNode(S)
    }
    return null
}
function getOffsetParent(C) {
    const S = getWindow(C);
    let E = getTrueOffsetParent(C);
    for (; E && isTableElement(E) && getComputedStyle$1(E).position === "static"; )
        E = getTrueOffsetParent(E);
    return E && (getNodeName(E) === "html" || getNodeName(E) === "body" && getComputedStyle$1(E).position === "static" && !isContainingBlock(E)) ? S : E || getContainingBlock(C) || S
}
function getDimensions(C) {
    if (isHTMLElement$1(C))
        return {
            width: C.offsetWidth,
            height: C.offsetHeight
        };
    const S = getBoundingClientRect(C);
    return {
        width: S.width,
        height: S.height
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(C) {
    let {rect: S, offsetParent: E, strategy: M} = C;
    const T = isHTMLElement$1(E)
      , $ = getDocumentElement(E);
    if (E === $)
        return S;
    let B = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , O = {
        x: 1,
        y: 1
    };
    const F = {
        x: 0,
        y: 0
    };
    if ((T || !T && M !== "fixed") && ((getNodeName(E) !== "body" || isOverflowElement($)) && (B = getNodeScroll(E)),
    isHTMLElement$1(E))) {
        const N = getBoundingClientRect(E);
        O = getScale$1(E),
        F.x = N.x + E.clientLeft,
        F.y = N.y + E.clientTop
    }
    return {
        width: S.width * O.x,
        height: S.height * O.y,
        x: S.x * O.x - B.scrollLeft * O.x + F.x,
        y: S.y * O.y - B.scrollTop * O.y + F.y
    }
}
function getViewportRect(C, S) {
    const E = getWindow(C)
      , M = getDocumentElement(C)
      , T = E.visualViewport;
    let $ = M.clientWidth
      , B = M.clientHeight
      , O = 0
      , F = 0;
    if (T) {
        $ = T.width,
        B = T.height;
        const N = isLayoutViewport();
        (N || !N && S === "fixed") && (O = T.offsetLeft,
        F = T.offsetTop)
    }
    return {
        width: $,
        height: B,
        x: O,
        y: F
    }
}
function getDocumentRect(C) {
    var S;
    const E = getDocumentElement(C)
      , M = getNodeScroll(C)
      , T = (S = C.ownerDocument) == null ? void 0 : S.body
      , $ = max(E.scrollWidth, E.clientWidth, T ? T.scrollWidth : 0, T ? T.clientWidth : 0)
      , B = max(E.scrollHeight, E.clientHeight, T ? T.scrollHeight : 0, T ? T.clientHeight : 0);
    let O = -M.scrollLeft + getWindowScrollBarX(C);
    const F = -M.scrollTop;
    return getComputedStyle$1(T || E).direction === "rtl" && (O += max(E.clientWidth, T ? T.clientWidth : 0) - $),
    {
        width: $,
        height: B,
        x: O,
        y: F
    }
}
function getNearestOverflowAncestor(C) {
    const S = getParentNode(C);
    return isLastTraversableNode(S) ? C.ownerDocument.body : isHTMLElement$1(S) && isOverflowElement(S) ? S : getNearestOverflowAncestor(S)
}
function getOverflowAncestors(C, S) {
    var E;
    S === void 0 && (S = []);
    const M = getNearestOverflowAncestor(C)
      , T = M === ((E = C.ownerDocument) == null ? void 0 : E.body)
      , $ = getWindow(M);
    return T ? S.concat($, $.visualViewport || [], isOverflowElement(M) ? M : []) : S.concat(M, getOverflowAncestors(M))
}
function getInnerBoundingClientRect(C, S) {
    const E = getBoundingClientRect(C, !0, S === "fixed")
      , M = E.top + C.clientTop
      , T = E.left + C.clientLeft
      , $ = isHTMLElement$1(C) ? getScale$1(C) : {
        x: 1,
        y: 1
    }
      , B = C.clientWidth * $.x
      , O = C.clientHeight * $.y
      , F = T * $.x
      , N = M * $.y;
    return {
        top: N,
        left: F,
        right: F + B,
        bottom: N + O,
        x: F,
        y: N,
        width: B,
        height: O
    }
}
function getClientRectFromClippingAncestor(C, S, E) {
    return S === "viewport" ? rectToClientRect(getViewportRect(C, E)) : isElement(S) ? getInnerBoundingClientRect(S, E) : rectToClientRect(getDocumentRect(getDocumentElement(C)))
}
function getClippingElementAncestors(C, S) {
    const E = S.get(C);
    if (E)
        return E;
    let M = getOverflowAncestors(C).filter(O=>isElement(O) && getNodeName(O) !== "body")
      , T = null;
    const $ = getComputedStyle$1(C).position === "fixed";
    let B = $ ? getParentNode(C) : C;
    for (; isElement(B) && !isLastTraversableNode(B); ) {
        const O = getComputedStyle$1(B)
          , F = isContainingBlock(B);
        ($ ? !F && !T : !F && O.position === "static" && !!T && ["absolute", "fixed"].includes(T.position)) ? M = M.filter(U=>U !== B) : T = O,
        B = getParentNode(B)
    }
    return S.set(C, M),
    M
}
function getClippingRect(C) {
    let {element: S, boundary: E, rootBoundary: M, strategy: T} = C;
    const B = [...E === "clippingAncestors" ? getClippingElementAncestors(S, this._c) : [].concat(E), M]
      , O = B[0]
      , F = B.reduce((N,U)=>{
        const H = getClientRectFromClippingAncestor(S, U, T);
        return N.top = max(H.top, N.top),
        N.right = min(H.right, N.right),
        N.bottom = min(H.bottom, N.bottom),
        N.left = max(H.left, N.left),
        N
    }
    , getClientRectFromClippingAncestor(S, O, T));
    return {
        width: F.right - F.left,
        height: F.bottom - F.top,
        x: F.left,
        y: F.top
    }
}
const platform$2 = {
    getClippingRect,
    convertOffsetParentRelativeRectToViewportRelativeRect,
    isElement,
    getDimensions,
    getOffsetParent,
    getDocumentElement,
    getScale: getScale$1,
    getElementRects(C) {
        return __async(this, null, function*() {
            let {reference: S, floating: E, strategy: M} = C;
            const T = this.getOffsetParent || getOffsetParent
              , $ = this.getDimensions;
            return {
                reference: getRectRelativeToOffsetParent(S, yield T(E), M),
                floating: __spreadValues$1({
                    x: 0,
                    y: 0
                }, yield $(E))
            }
        })
    },
    getClientRects: C=>Array.from(C.getClientRects()),
    isRTL: C=>getComputedStyle$1(C).direction === "rtl"
};
function autoUpdate(C, S, E, M) {
    M === void 0 && (M = {});
    const {ancestorScroll: T=!0, ancestorResize: $=!0, elementResize: B=!0, animationFrame: O=!1} = M
      , F = T && !O
      , N = F || $ ? [...isElement(C) ? getOverflowAncestors(C) : C.contextElement ? getOverflowAncestors(C.contextElement) : [], ...getOverflowAncestors(S)] : [];
    N.forEach(ie=>{
        F && ie.addEventListener("scroll", E, {
            passive: !0
        }),
        $ && ie.addEventListener("resize", E)
    }
    );
    let U = null;
    if (B) {
        let ie = !0;
        U = new ResizeObserver(()=>{
            ie || E(),
            ie = !1
        }
        ),
        isElement(C) && !O && U.observe(C),
        !isElement(C) && C.contextElement && !O && U.observe(C.contextElement),
        U.observe(S)
    }
    let H, Z = O ? getBoundingClientRect(C) : null;
    O && J();
    function J() {
        const ie = getBoundingClientRect(C);
        Z && (ie.x !== Z.x || ie.y !== Z.y || ie.width !== Z.width || ie.height !== Z.height) && E(),
        Z = ie,
        H = requestAnimationFrame(J)
    }
    return E(),
    ()=>{
        var ie;
        N.forEach(oe=>{
            F && oe.removeEventListener("scroll", E),
            $ && oe.removeEventListener("resize", E)
        }
        ),
        (ie = U) == null || ie.disconnect(),
        U = null,
        O && cancelAnimationFrame(H)
    }
}
const computePosition = (C,S,E)=>{
    const M = new Map
      , T = __spreadValues$1({
        platform: platform$2
    }, E)
      , $ = __spreadProps(__spreadValues$1({}, T.platform), {
        _c: M
    });
    return computePosition$1(C, S, __spreadProps(__spreadValues$1({}, T), {
        platform: $
    }))
}
;
function P(C, S, E) {
    let M = ()=>{
        var H;
        return (H = E == null ? void 0 : E.placement) != null ? H : "bottom"
    }
      , T = ()=>{
        var H;
        return (H = E == null ? void 0 : E.strategy) != null ? H : "absolute"
    }
      , [$,B] = createSignal({
        x: null,
        y: null,
        placement: M(),
        strategy: T(),
        middlewareData: {}
    })
      , [O,F] = createSignal();
    createEffect(()=>{
        let H = O();
        if (H)
            throw H.value
    }
    );
    let N = createMemo(()=>(C(),
    S(),
    {}));
    function U() {
        let H = C()
          , Z = S();
        if (H && Z) {
            let J = N();
            computePosition(H, Z, {
                middleware: E == null ? void 0 : E.middleware,
                placement: M(),
                strategy: T()
            }).then(ie=>{
                J === N() && B(ie)
            }
            , ie=>{
                F(ie)
            }
            )
        }
    }
    return createEffect(()=>{
        let H = C()
          , Z = S();
        if (E == null || E.middleware,
        M(),
        T(),
        H && Z)
            if (E != null && E.whileElementsMounted) {
                let J = E.whileElementsMounted(H, Z, U);
                J && onCleanup(J)
            } else
                U()
    }
    ),
    {
        get x() {
            return $().x
        },
        get y() {
            return $().y
        },
        get placement() {
            return $().placement
        },
        get strategy() {
            return $().strategy
        },
        get middlewareData() {
            return $().middlewareData
        },
        update: U
    }
}
const _tmpl$$3 = template$1('<tc-root data-tc-dropdown-container="true"></tc-root>')
  , AccountButton = ()=>{
    const C = useTheme$4()
      , S = useContext(ConnectorContext)
      , E = useContext(TonConnectUiContext)
      , [M,T] = createSignal(!1)
      , [$,B] = createSignal(S.account)
      , [O,F] = createSignal(!0);
    let N;
    const [U,H] = createSignal()
      , [Z,J] = createSignal()
      , ie = P(Z, U, {
        whileElementsMounted: autoUpdate,
        placement: "bottom-end"
    })
      , oe = ()=>{
        const le = $();
        if (le) {
            const de = toUserFriendlyAddress(le.address, le.chain === CHAIN.TESTNET);
            return de.slice(0, 4) + "" + de.slice(-4)
        }
        return ""
    }
    ;
    E.connectionRestored.then(()=>F(!1));
    const ae = S.onStatusChange(le=>{
        if (!le) {
            T(!1),
            B(null);
            return
        }
        B(le.account)
    }
    )
      , se = le=>{
        if (!$() || !M())
            return;
        const de = Z().contains(le.target)
          , fe = N.contains(le.target);
        !de && !fe && T(!1)
    }
    ;
    return onMount(()=>{
        document.body.addEventListener("click", se)
    }
    ),
    onCleanup(()=>{
        document.body.removeEventListener("click", se),
        ae()
    }
    ),
    createComponent(Dynamic, {
        component: globalStylesTag,
        get children() {
            return [createComponent(Show, {
                get when() {
                    return O()
                },
                get children() {
                    return createComponent(LoaderButtonStyled, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !O()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return !$()
                        },
                        get children() {
                            return createComponent(AccountButtonStyled, {
                                onClick: ()=>E.openModal(),
                                "data-tc-connect-button": "true",
                                scale: "s",
                                get children() {
                                    return [createComponent(TonIcon, {
                                        get fill() {
                                            return C.colors.connectButton.foreground
                                        }
                                    }), createComponent(Text$1, {
                                        translationKey: "button.connectWallet",
                                        fontSize: "15px",
                                        lineHeight: "18px",
                                        fontWeight: "590",
                                        get color() {
                                            return C.colors.connectButton.foreground
                                        },
                                        children: "Connect wallet"
                                    })]
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return $()
                        },
                        get children() {
                            return createComponent(DropdownContainerStyled, {
                                get children() {
                                    return [createComponent(DropdownButtonStyled, {
                                        onClick: ()=>T(le=>!le),
                                        ref: J,
                                        "data-tc-dropdown-button": "true",
                                        scale: "s",
                                        get children() {
                                            return [createComponent(Text$1, {
                                                fontSize: "15px",
                                                fontWeight: "590",
                                                lineHeight: "18px",
                                                get children() {
                                                    return oe()
                                                }
                                            }), createComponent(ArrowIcon, {
                                                direction: "bottom"
                                            })]
                                        }
                                    }), createComponent(Portal$1, {
                                        get children() {
                                            const le = untrack(()=>document.importNode(_tmpl$$3, !0));
                                            return use(H, le),
                                            le.style.setProperty("z-index", "999"),
                                            le._$owner = getOwner(),
                                            insert$1(le, createComponent(Transition$2, {
                                                onBeforeEnter: de=>{
                                                    animate(de, [{
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }, {
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }], {
                                                        duration: 150
                                                    })
                                                }
                                                ,
                                                onExit: (de,fe)=>{
                                                    animate(de, [{
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }, {
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }], {
                                                        duration: 150
                                                    }).finished.then(fe)
                                                }
                                                ,
                                                get children() {
                                                    return createComponent(Show, {
                                                        get when() {
                                                            return M()
                                                        },
                                                        get children() {
                                                            return createComponent(DropdownStyled, {
                                                                get hidden() {
                                                                    return !M()
                                                                },
                                                                onClose: ()=>T(!1),
                                                                ref(de) {
                                                                    const fe = N;
                                                                    typeof fe == "function" ? fe(de) : N = de
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            }), null),
                                            insert$1(le, createComponent(NotificationsStyled, {}), null),
                                            createRenderEffect(de=>{
                                                var fe, pe;
                                                const ge = ie.strategy
                                                  , we = `${(fe = ie.y) != null ? fe : 0}px`
                                                  , Ae = `${(pe = ie.x) != null ? pe : 0}px`;
                                                return ge !== de._v$ && le.style.setProperty("position", de._v$ = ge),
                                                we !== de._v$2 && le.style.setProperty("top", de._v$2 = we),
                                                Ae !== de._v$3 && le.style.setProperty("left", de._v$3 = Ae),
                                                de
                                            }
                                            , {
                                                _v$: void 0,
                                                _v$2: void 0,
                                                _v$3: void 0
                                            }),
                                            le
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , StyledModal = styled$2(Modal$2)`
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 18px;
    padding-bottom: 0;

    ${media("mobile")} {
        padding-left: 0;
        padding-right: 0;

        min-height: 364px;
    }
`
  , H1Styled$8 = styled$2(H1)`
    margin-top: 12px;

    ${media("mobile")} {
        padding: 0 10px;
    }
`
  , LoaderContainerStyled = styled$2.div`
    margin: 30px 0;
    width: 100%;
    display: flex;
    justify-content: center;

    ${media("mobile")} {
        height: 160px;
        align-items: center;
    }
`;
styled$2(Text$1)`
    min-width: 84px;
    text-align: center;
    font-weight: 590;
`;
styled$2(TabBar)`
    margin: 0 auto 22px;
`;
const [appState,setAppState] = createStore({
    buttonRootId: null,
    language: "en",
    returnStrategy: "back",
    twaReturnUrl: void 0,
    walletsListConfiguration: {},
    enableAndroidBackHandler: !0
});
function uniq(C) {
    return [...new Set(C)]
}
function mergeConcat(C, S, E) {
    return S.map(M=>{
        const T = E.find($=>$[C] === M[C]);
        return E = E.filter($=>$[C] !== M[C]),
        T === void 0 ? M : T
    }
    ).concat(E)
}
function uiWalletToWalletInfo(C) {
    return "jsBridgeKey"in C ? __spreadProps(__spreadValues$1({}, C), {
        injected: TonConnect.isWalletInjected(C.jsBridgeKey),
        embedded: TonConnect.isInsideWalletBrowser(C.jsBridgeKey)
    }) : C
}
function applyWalletsListConfiguration(C, S) {
    var E;
    return S && (E = S.includeWallets) != null && E.length && (C = mergeConcat("name", C, S.includeWallets.map(uiWalletToWalletInfo))),
    C
}
function supportsDesktop(C) {
    return C.platforms.some(S=>["macos", "linux", "windows"].includes(S))
}
function supportsMobile(C) {
    return C.platforms.some(S=>["ios", "android"].includes(S))
}
function supportsExtension(C) {
    return C.platforms.some(S=>["chrome", "firefox", "safari"].includes(S))
}
function eqWalletName(C, S) {
    return S ? C.name.toLowerCase() === S.toLowerCase() || C.appName.toLowerCase() === S.toLowerCase() : !1
}
const DesktopSelectWalletModalStyled = styled$2.div`
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , H1Styled$7 = styled$2(H1)`
    margin-bottom: 18px;
`;
styled$2.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.12;
    background: ${C=>C.isShown ? C.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
    }
`;
const WalletsUl = styled$2.ul`
    display: grid;
    grid-template-columns: repeat(auto-fit, 92px);
    grid-template-rows: auto;
    align-content: flex-start;
    justify-content: center;
    row-gap: 8px;
    width: 100%;
    padding: 0 0 16px;
    align-self: flex-start;
    max-width: 400px;
    margin: 0 auto;

    > li {
        display: block;
        height: fit-content;
    }

    ${media("mobile")} {
        grid-template-columns: repeat(auto-fit, 82px);
    }
`;
styled$2(Button)`
    display: block;
    margin: 0 auto 1px;
    font-size: 15px;
`;
const StyledIconButton$3 = styled$2(IconButton$2)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , WalletLabeledItemStyled = styled$2(WalletLabeledItem)`
    height: 100%;
`
  , _tmpl$$2 = template$1("<li></li>")
  , AllWalletsListModal = C=>{
    const S = ()=>isMobile$1() ? void 0 : 510
      , E = ()=>isMobile$1() ? C.walletsList.filter(supportsMobile) : C.walletsList;
    return createComponent(DesktopSelectWalletModalStyled, {
        "data-tc-wallets-modal-list": "true",
        get children() {
            return [createComponent(StyledIconButton$3, {
                icon: "arrow",
                onClick: ()=>C.onBack()
            }), createComponent(H1Styled$7, {
                translationKey: "walletModal.wallets",
                children: "Wallets"
            }), createComponent(ScrollContainer, {
                get maxHeight() {
                    return S()
                },
                get children() {
                    return createComponent(WalletsUl, {
                        get children() {
                            return createComponent(For, {
                                get each() {
                                    return E()
                                },
                                children: M=>(()=>{
                                    const T = _tmpl$$2.cloneNode(!0);
                                    return insert$1(T, createComponent(WalletLabeledItemStyled, {
                                        wallet: M,
                                        onClick: ()=>C.onSelect(M)
                                    })),
                                    T
                                }
                                )()
                            })
                        }
                    })
                }
            })]
        }
    })
}
  , tgButtonBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgIconBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , DesktopConnectionModalStyled = styled$2.div`
    display: flex;
    flex-direction: column;
`
  , BodyStyled$1 = styled$2.div`
    flex: 1;
    margin-top: ${C=>C.qr ? "0" : "18px"};
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , QRCodeStyled$1 = styled$2(QRCode)`
    margin-bottom: 24px;
`
  , H1Styled$6 = styled$2(H1)`
    max-width: 288px;
    margin: 0 auto 2px;
`
  , H2Styled$4 = styled$2(H2)`
    max-width: 288px;
    text-align: center;
    margin: 0 auto 20px;
`
  , StyledIconButton$2 = styled$2(IconButton$2)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , ButtonsContainerStyled$1 = styled$2.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , BottomButtonsContainerStyled = styled$2(ButtonsContainerStyled$1)`
    padding-bottom: 0;
`
  , FooterButton$1 = styled$2(Button)`
    margin-bottom: 24px;
`
  , LoaderStyled$1 = styled$2(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled$1 = styled$2(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled$1 = styled$2(H2)`
    color: ${C=>C.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , TgButtonStyled = styled$2(Button)`
    margin-top: -8px;
    margin-bottom: 24px;
    width: 100%;
    padding: 12px 12px 12px 20px;
    border-radius: ${C=>tgButtonBorders[C.theme.borderRadius]};
    font-size: 16px;
    line-height: 20px;
`
  , TgImageStyled = styled$2(Image)`
    width: 32px;
    height: 32px;
    border-radius: ${C=>tgIconBorders[C.theme.borderRadius]};
`
  , Translation = C=>{
    const [S] = useI18n();
    return createMemo(()=>{
        var E;
        return S(C.translationKey, C.translationValues, (E = C.children) == null ? void 0 : E.toString())
    }
    )
}
;
function addReturnStrategy$1(C, S) {
    let E;
    typeof S == "string" ? E = S : E = isInTMA() ? S.twaReturnUrl || S.returnStrategy : "none";
    const M = addQueryParameter(C, "ret", E);
    if (!isTelegramUrl(C))
        return M;
    const T = M.slice(M.lastIndexOf("&") + 1);
    return M.slice(0, M.lastIndexOf("&")) + "-" + encodeTelegramUrlParameters(T)
}
function redirectToTelegram(C, S) {
    S = __spreadValues$1({}, S);
    const E = convertToTGDirectLink(C)
      , M = new URL(E);
    if (M.searchParams.has("startapp") || M.searchParams.append("startapp", "tonconnect"),
    isInTMA())
        isTmaPlatform("ios", "android") ? (S.returnStrategy = "back",
        S.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy$1(M.toString(), S))) : isTmaPlatform("macos", "tdesktop") || isTmaPlatform("weba") ? sendOpenTelegramLink(addReturnStrategy$1(M.toString(), S)) : isTmaPlatform("web") ? (S.returnStrategy = "back",
        S.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy$1(M.toString(), S))) : openLinkBlank(addReturnStrategy$1(M.toString(), S));
    else if (isOS("ios", "android"))
        S.returnStrategy = "none",
        openLinkBlank(addReturnStrategy$1(M.toString(), S.returnStrategy));
    else if (isOS("macos", "windows", "linux"))
        if (S.returnStrategy = "none",
        S.twaReturnUrl = void 0,
        S.forceRedirect)
            openLinkBlank(addReturnStrategy$1(M.toString(), S));
        else {
            const T = addReturnStrategy$1(M.toString(), S)
              , $ = convertToTGDeepLink(T);
            openDeeplinkWithFallback($, ()=>openLinkBlank(T))
        }
    else
        openLinkBlank(addReturnStrategy$1(M.toString(), S))
}
function addQueryParameter(C, S, E) {
    const M = new URL(C);
    return M.searchParams.append(S, E),
    M.toString()
}
function convertToTGDirectLink(C) {
    const S = new URL(C);
    return S.searchParams.has("attach") && (S.searchParams.delete("attach"),
    S.pathname += "/start"),
    S.toString()
}
function convertToTGDeepLink(C) {
    const S = new URL(C)
      , [,E,M] = S.pathname.split("/")
      , T = S.searchParams.get("startapp");
    return `tg://resolve?domain=${E}&appname=${M}&startapp=${T}`
}
let openDesktopDeeplinkAttempts = 0;
const DesktopConnectionModal = C=>{
    const [S,E] = createSignal("mobile")
      , [M,T] = createSignal(!1)
      , [$,B] = createSignal()
      , [O,F] = createSignal(!0)
      , N = useContext(ConnectorContext)
      , U = N.onStatusChange(()=>{}
    , ()=>{
        C.wallet.appName !== AT_WALLET_APP_NAME && T(!0)
    }
    );
    onCleanup(U);
    const H = ()=>{
        B(N.connect({
            universalLink: C.wallet.universalLink,
            bridgeUrl: C.wallet.bridgeUrl
        }, C.additionalRequest))
    }
    ;
    createEffect(()=>{
        untrack(S) !== "extension" && (supportsMobile(C.wallet) || supportsDesktop(C.wallet)) && H()
    }
    );
    const Z = ()=>{
        T(!1),
        S() === "extension" && H(),
        E("mobile"),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "qrcode"
        }))
    }
      , J = ()=>{
        T(!1),
        S() === "extension" && H(),
        E("desktop");
        const ae = addReturnStrategy$1($(), appState.returnStrategy)
          , se = isBrowser$1("safari") && openDesktopDeeplinkAttempts >= 1;
        C.wallet.deepLink && !se ? (openDesktopDeeplinkAttempts++,
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "custom-deeplink"
        })),
        openDeeplinkWithFallback(toDeeplink(ae, C.wallet.deepLink), ()=>{
            setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
                openMethod: "universal-link"
            })),
            openLinkBlank(ae)
        }
        )) : (setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "universal-link"
        })),
        openLinkBlank(ae))
    }
      , ie = ()=>{
        const ae = !O();
        F(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram($(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: ae
        })
    }
      , oe = ()=>{
        T(!1),
        E("extension"),
        isWalletInfoCurrentlyInjected(C.wallet) && (setLastSelectedWalletInfo(C.wallet),
        N.connect({
            jsBridgeKey: C.wallet.jsBridgeKey
        }, C.additionalRequest))
    }
    ;
    return supportsMobile(C.wallet) ? Z() : supportsExtension(C.wallet) ? oe() : J(),
    createComponent(DesktopConnectionModalStyled, {
        "data-tc-wallets-modal-connection-desktop": "true",
        get children() {
            return [createComponent(StyledIconButton$2, {
                icon: "arrow",
                onClick: ()=>C.onBackClick()
            }), createComponent(H1Styled$6, {
                get children() {
                    return C.wallet.name
                }
            }), createComponent(Show, {
                get when() {
                    return S() === "mobile"
                },
                get children() {
                    return createComponent(H2Styled$4, {
                        translationKey: "walletModal.desktopConnectionModal.scanQR",
                        get translationValues() {
                            return {
                                name: C.wallet.name
                            }
                        },
                        get children() {
                            return ["Scan the QR code below with your phones or ", createMemo(()=>C.wallet.name), "s camera"]
                        }
                    })
                }
            }), createComponent(BodyStyled$1, {
                get qr() {
                    return S() === "mobile"
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return S() === "mobile"
                                },
                                get children() {
                                    return createComponent(QRCodeStyled$1, {
                                        disableCopy: !1,
                                        get sourceUrl() {
                                            return addReturnStrategy$1($(), "none")
                                        },
                                        get imageUrl() {
                                            return C.wallet.imageUrl
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return M()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled$1, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                get onClick() {
                                                    return S() === "extension" ? oe : J
                                                },
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            })
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return S() === "extension"
                                },
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return isWalletInfoCurrentlyInjected(C.wallet)
                                        },
                                        get children() {
                                            return [createComponent(LoaderStyled$1, {
                                                size: "s"
                                            }), createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.continueInExtension",
                                                get translationValues() {
                                                    return {
                                                        name: C.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Continue in ", createMemo(()=>C.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Button, {
                                                        get leftIcon() {
                                                            return createComponent(RetryIcon, {})
                                                        },
                                                        onClick: oe,
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "common.retry",
                                                                children: "Retry"
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    }), createComponent(Show, {
                                        get when() {
                                            return !isWalletInfoCurrentlyInjected(C.wallet)
                                        },
                                        get children() {
                                            return [createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.dontHaveExtension",
                                                get translationValues() {
                                                    return {
                                                        name: C.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Seems you don't have installed ", createMemo(()=>C.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Link, {
                                                        get href() {
                                                            return C.wallet.aboutUrl
                                                        },
                                                        blank: !0,
                                                        get children() {
                                                            return createComponent(Button, {
                                                                get rightIcon() {
                                                                    return createComponent(LinkIcon, {})
                                                                },
                                                                onClick: oe,
                                                                get children() {
                                                                    return createComponent(Translation, {
                                                                        translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                        get translationValues() {
                                                                            return {
                                                                                name: C.wallet.name
                                                                            }
                                                                        },
                                                                        get children() {
                                                                            return ["Get ", createMemo(()=>C.wallet.name)]
                                                                        }
                                                                    })
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return S() === "desktop"
                                },
                                get children() {
                                    return [createComponent(LoaderIcon, {
                                        size: "m"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.continueOnDesktop",
                                        get translationValues() {
                                            return {
                                                name: C.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>C.wallet.name), " on desktop"]
                                        }
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: J,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Link, {
                                                get href() {
                                                    return C.wallet.aboutUrl
                                                },
                                                blank: !0,
                                                get children() {
                                                    return createComponent(Button, {
                                                        get rightIcon() {
                                                            return createComponent(LinkIcon, {})
                                                        },
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                get translationValues() {
                                                                    return {
                                                                        name: C.wallet.name
                                                                    }
                                                                },
                                                                get children() {
                                                                    return ["Get ", createMemo(()=>C.wallet.name)]
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return C.wallet.appName === AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(TgButtonStyled, {
                        get rightIcon() {
                            return createComponent(TgImageStyled, {
                                get src() {
                                    return IMG.TG
                                }
                            })
                        },
                        scale: "s",
                        onClick: ie,
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "walletModal.desktopConnectionModal.openWalletOnTelegram",
                                children: "Open Wallet in Telegram on desktop"
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return C.wallet.appName !== AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(BottomButtonsContainerStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return createMemo(()=>S() !== "mobile")() && supportsMobile(C.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(MobileIcon, {})
                                        },
                                        onClick: Z,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.mobile",
                                                children: "Mobile"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>S() !== "extension")() && supportsExtension(C.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(BrowserIcon, {})
                                        },
                                        onClick: oe,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.browserExtension",
                                                children: "Browser Extension"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>S() !== "desktop")() && supportsDesktop(C.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(DesktopIcon, {})
                                        },
                                        onClick: J,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.desktop",
                                                children: "Desktop"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })
                }
            })]
        }
    })
}
  , InfoModalStyled = styled$2.div``
  , StyledIconButton$1 = styled$2(IconButton$2)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$5 = styled$2(H1)`
    margin-bottom: 18px;
`
  , InfoBlock$1 = styled$2.div`
    padding: 16px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , InfoBlockIconClass = u$1`
    margin-bottom: 12px;
`
  , H3Styled = styled$2(H3)`
    text-align: center;
    margin-bottom: 4px;
`
  , TextStyled$1 = styled$2(Text$1)`
    text-align: center;
    max-width: 352px;
    color: ${C=>C.theme.colors.text.secondary};
`
  , ButtonsBlock = styled$2.div`
    padding: 16px 24px 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
`
  , LINKS = {
    GET_A_WALLET: "https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1"
}
  , InfoModal = C=>createComponent(InfoModalStyled, {
    "data-tc-wallets-modal-info": "true",
    get children() {
        return [createComponent(StyledIconButton$1, {
            icon: "arrow",
            onClick: ()=>C.onBackClick()
        }), createComponent(H1Styled$5, {
            translationKey: "walletModal.infoModal.whatIsAWallet",
            children: "What is a wallet"
        }), createComponent(ScrollContainer, {
            get children() {
                return [createComponent(InfoBlock$1, {
                    get children() {
                        return [createComponent(SecurityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.secureDigitalAssets",
                            children: "Secure digital assets storage"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.walletProtects",
                            children: "A wallet protects and manages your digital assets including TON, tokens and collectables."
                        })]
                    }
                }), createComponent(InfoBlock$1, {
                    get children() {
                        return [createComponent(PersonalityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.controlIdentity",
                            children: "Control your Web3 identity"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.manageIdentity",
                            children: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem."
                        })]
                    }
                }), createComponent(InfoBlock$1, {
                    get children() {
                        return [createComponent(SwapIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.effortlessCryptoTransactions",
                            children: "Effortless crypto transactions"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.easilySend",
                            children: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications."
                        })]
                    }
                }), createComponent(ButtonsBlock, {
                    get children() {
                        return createComponent(Link, {
                            get href() {
                                return LINKS.GET_A_WALLET
                            },
                            blank: !0,
                            get children() {
                                return createComponent(Button, {
                                    get rightIcon() {
                                        return createComponent(WalletIcon, {})
                                    },
                                    get children() {
                                        return createComponent(Translation, {
                                            translationKey: "walletModal.infoModal.getAWallet",
                                            children: "Get a Wallet"
                                        })
                                    }
                                })
                            }
                        })
                    }
                })]
            }
        })]
    }
})
  , MobileConnectionModalStyled = styled$2.div``
  , BodyStyled = styled$2.div`
    flex: 1;
    margin-top: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , H1Styled$4 = styled$2(H1)`
    max-width: 262px;
    margin: 0 auto 8px;
`
  , StyledIconButton = styled$2(IconButton$2)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , FooterStyled = styled$2.div`
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-top: 0.5px solid ${C=>rgba(C.theme.colors.icon.secondary, .2)};
`
  , ImageStyled = styled$2(Image)`
    width: 36px;
    height: 36px;
    border-radius: 10px;
`
  , FooterButton = styled$2(Link)`
    margin-left: auto;
`
  , LoaderStyled = styled$2(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled = styled$2(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled = styled$2(H2)`
    color: ${C=>C.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , ButtonsContainerStyled = styled$2.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , H1Styled$3 = styled$2(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$3 = styled$2(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
    min-height: 44px;
`
  , QrCodeWrapper$1 = styled$2.div`
    padding: 0 24px 24px;
`
  , MobileConnectionQR = C=>[createComponent(H1Styled$3, {
    get children() {
        return C.walletInfo.name
    }
}), createComponent(H2Styled$3, {
    translationKey: "walletModal.mobileConnectionModal.scanQR",
    get translationValues() {
        return {
            name: C.walletInfo.name
        }
    },
    get children() {
        return ["Scan the QR code below with your phones or ", createMemo(()=>C.walletInfo.name), "s camera"]
    }
}), createComponent(QrCodeWrapper$1, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return C.walletInfo.imageUrl
            },
            get sourceUrl() {
                return addReturnStrategy$1(C.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})]
  , MobileConnectionModal = C=>{
    const S = useTheme$4()
      , [E,M] = createSignal(!1)
      , [T,$] = createSignal(!1)
      , B = useContext(ConnectorContext)
      , O = B.onStatusChange(()=>{}
    , ()=>{
        $(!0)
    }
    )
      , F = createMemo(()=>B.connect({
        universalLink: C.wallet.universalLink,
        bridgeUrl: C.wallet.bridgeUrl
    }, C.additionalRequest))
      , N = ()=>{
        $(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "universal-link"
        })),
        openLinkBlank(addReturnStrategy$1(F(), appState.returnStrategy))
    }
      , U = ()=>{
        $(!1),
        M(!0),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "qrcode"
        }))
    }
      , H = ()=>{
        M(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, C.wallet), {
            openMethod: "universal-link"
        }))
    }
      , Z = ()=>{
        E() ? H() : C.onBackClick()
    }
    ;
    return onCleanup(O),
    N(),
    createComponent(MobileConnectionModalStyled, {
        "data-tc-wallets-modal-connection-mobile": "true",
        get children() {
            return [createComponent(StyledIconButton, {
                icon: "arrow",
                onClick: Z
            }), createComponent(Show, {
                get when() {
                    return E()
                },
                get children() {
                    return createComponent(MobileConnectionQR, {
                        get universalLink() {
                            return F()
                        },
                        get walletInfo() {
                            return C.wallet
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !E()
                },
                get children() {
                    return [createComponent(H1Styled$4, {
                        get children() {
                            return C.wallet.name
                        }
                    }), createComponent(BodyStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return T()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: N,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return S.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: U,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return !T()
                                },
                                get children() {
                                    return [createComponent(LoaderStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.continueIn",
                                        get translationValues() {
                                            return {
                                                name: C.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>C.wallet.name), ""]
                                        }
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: N,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return S.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: U,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    }), createComponent(FooterStyled, {
                        get children() {
                            return [createComponent(ImageStyled, {
                                get src() {
                                    return C.wallet.imageUrl
                                }
                            }), createComponent(H3, {
                                get children() {
                                    return C.wallet.name
                                }
                            }), createComponent(FooterButton, {
                                get href() {
                                    return C.wallet.aboutUrl
                                },
                                blank: !0,
                                get children() {
                                    return createComponent(Button, {
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.get",
                                                children: "GET"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })]
                }
            })]
        }
    })
}
  , borders$1 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , UlStyled = styled$2.ul`
    display: flex;
    justify-content: space-between;
    margin: 0 auto;
    width: fit-content;
    max-width: 100%;
    min-width: 100%;
    height: fit-content;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0 13px 24px;

    &&::-webkit-scrollbar {
        display: none;
    }

    -ms-overflow-style: none;
    scrollbar-width: none;

    > li {
        height: fit-content;
    }
`
  , OtherOptionButton = styled$2.li`
    width: 82px;
    min-width: 82px;
    height: 124px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;

    text-align: center;
    cursor: pointer;

    transition: transform 0.1s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , Divider = styled$2.div`
    width: 1px;
    margin: 0 10px;
    height: 24px;
    position: relative;
    top: 26px;

    background-color: ${C=>C.theme.colors.icon.secondary};
    opacity: 0.2;
`
  , IconContainer = styled$2.div`
    width: 60px;
    height: 60px;
    border-radius: ${C=>borders$1[C.theme.borderRadius]};
    display: flex;
    align-items: center;
    justify-content: center;

    background-color: ${C=>C.theme.colors.background.tint};
    margin-bottom: 8px;
`
  , H1Styled$2 = styled$2(H1)`
    margin-top: 38px;
    margin-bottom: 4px;
    padding: 0 24px;
`
  , H2Styled$2 = styled$2(H2)`
    margin-bottom: 24px;
    padding: 0 24px;
    min-height: 44px;
`;
styled$2(Button)`
    display: block;
    margin: 0 auto;
`;
const TelegramButtonStyled = styled$2(Button)`
    margin: 0 24px 24px;
    width: calc(100% - 48px);
    border-radius: ${C=>borders$1[C.theme.borderRadius]};
    padding: 14px 16px 14px 14px;
    background-color: ${C=>C.theme.colors.telegramButton};

    color: ${C=>C.theme.colors.constant.white};
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;
`
  , TGImageStyled = styled$2(Image)`
    border-radius: ${C=>tgBorders[C.theme.borderRadius]};
    width: 24px;
    height: 24px;
`
  , StyledLeftActionButton = styled$2(IconButton$2)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$1 = styled$2(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$1 = styled$2(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
`
  , QrCodeWrapper = styled$2.div`
    padding: 0 24px 24px;
`
  , MobileUniversalQR = C=>[createComponent(H1Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
    children: "Connect your wallet"
}), createComponent(H2Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.scan",
    children: "Scan with your mobile wallet"
}), createComponent(QrCodeWrapper, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return IMG.TON
            },
            get sourceUrl() {
                return addReturnStrategy$1(C.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})]
  , _tmpl$$1 = template$1("<li></li>")
  , _tmpl$2 = template$1('<div data-tc-wallets-modal-universal-mobile="true"></div>')
  , MobileUniversalModal = C=>{
    const [S,E] = createSignal(!1)
      , [M,T] = createSignal(!0)
      , $ = appState.connector
      , B = ()=>C.walletsList.filter(se=>supportsMobile(se) && se.appName !== AT_WALLET_APP_NAME)
      , O = ()=>B().length > 7
      , F = ()=>[...new Set(C.walletsList.filter(isWalletInfoRemote).map(se=>se.bridgeUrl)).values()].map(se=>({
        bridgeUrl: se
    }))
      , N = ()=>$.connect(F(), C.additionalRequest);
    setLastSelectedWalletInfo({
        openMethod: "universal-link"
    });
    const [U,H] = createSignal(void 0)
      , Z = ()=>__async(void 0, null, function*() {
        U() !== void 0 && clearTimeout(U()),
        yield copyToClipboard(N());
        const se = setTimeout(()=>H(void 0), 1500);
        H(se)
    })
      , J = ()=>{
        openLinkBlank(addReturnStrategy$1(N(), appState.returnStrategy))
    }
      , ie = ()=>{
        const se = C.walletsList.find(fe=>fe.appName === AT_WALLET_APP_NAME);
        if (!se || !isWalletInfoRemote(se))
            throw new TonConnectUIError("@wallet bot not found in the wallets list");
        const le = $.connect({
            bridgeUrl: se.bridgeUrl,
            universalLink: se.universalLink
        }, C.additionalRequest)
          , de = !M();
        T(!1),
        redirectToTelegram(le, {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: de
        })
    }
      , oe = ()=>{
        E(!0),
        setLastSelectedWalletInfo({
            openMethod: "qrcode"
        })
    }
      , ae = ()=>{
        E(!1),
        setLastSelectedWalletInfo({
            openMethod: "universal-link"
        })
    }
    ;
    return (()=>{
        const se = _tmpl$2.cloneNode(!0);
        return insert$1(se, createComponent(Show, {
            get when() {
                return S()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    icon: "arrow",
                    onClick: ae
                }), createComponent(MobileUniversalQR, {
                    get universalLink() {
                        return N()
                    }
                })]
            }
        }), null),
        insert$1(se, createComponent(Show, {
            get when() {
                return !S()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    get icon() {
                        return createComponent(QRIcon, {})
                    },
                    onClick: oe
                }), createComponent(H1Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                    children: "Connect your wallet"
                }), createComponent(H2Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect",
                    children: "Open Wallet in Telegram or select your wallet to connect"
                }), createComponent(TelegramButtonStyled, {
                    get leftIcon() {
                        return createComponent(AtWalletIcon, {})
                    },
                    get rightIcon() {
                        return createComponent(TGImageStyled, {
                            get src() {
                                return IMG.TG
                            }
                        })
                    },
                    onClick: ie,
                    scale: "s",
                    get children() {
                        return createComponent(Translation, {
                            translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegram",
                            children: "Open Wallet in Telegram"
                        })
                    }
                }), createComponent(UlStyled, {
                    get children() {
                        return [createComponent(For, {
                            get each() {
                                return createMemo(()=>!!O())() ? B().slice(0, 4) : B()
                            },
                            children: le=>(()=>{
                                const de = _tmpl$$1.cloneNode(!0);
                                return insert$1(de, createComponent(WalletItem, {
                                    get icon() {
                                        return le.imageUrl
                                    },
                                    get name() {
                                        return le.name
                                    },
                                    onClick: ()=>C.onSelect(le)
                                })),
                                de
                            }
                            )()
                        }), createComponent(Show, {
                            get when() {
                                return O()
                            },
                            get children() {
                                const le = _tmpl$$1.cloneNode(!0);
                                return insert$1(le, createComponent(FourWalletsItem, {
                                    labelLine1: "View all",
                                    labelLine2: "wallets",
                                    get images() {
                                        return B().slice(3, 7).map(de=>de.imageUrl)
                                    },
                                    onClick: ()=>C.onSelectAllWallets()
                                })),
                                le
                            }
                        }), createComponent(Divider, {
                            children: ""
                        }), createComponent(OtherOptionButton, {
                            onClick: J,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createComponent(LongArrowIcon, {})
                                    }
                                }), createComponent(Text$1, {
                                    fontWeight: 590,
                                    translationKey: "walletModal.mobileUniversalModal.openLink",
                                    children: "Open Link"
                                })]
                            }
                        }), createComponent(OtherOptionButton, {
                            onClick: Z,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createMemo(()=>U() !== void 0)() ? createComponent(DoneIcon, {}) : createComponent(CopyLightIcon, {})
                                    }
                                }), createComponent(Text$1, {
                                    fontWeight: 590,
                                    get translationKey() {
                                        return U() !== void 0 ? "common.copied" : "common.copyLink"
                                    },
                                    get children() {
                                        return U() !== void 0 ? "Copied" : "Copy Link"
                                    }
                                })]
                            }
                        })]
                    }
                })]
            }
        }), null),
        se
    }
    )()
}
  , borders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , hoverBorders = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , DesktopUniversalModalStyled = styled$2.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 16px;
`
  , H2Styled = styled$2(H2)`
    max-width: 320px;
    margin-top: 2px;
    margin-bottom: 20px;
`
  , H2AvailableWalletsStyled = styled$2(H2)`
    margin-bottom: 16px;
`
  , QRCodeStyled = styled$2(QRCode)`
    margin-bottom: 24px;
`
  , WalletsContainerStyled = styled$2.ul`
    display: flex;
`;
styled$2.div`
    display: flex;
    gap: 16px;
    width: 100%;
`;
styled$2(Button)`
    position: relative;
    font-size: 16px;
    line-height: 20px;
    width: 100%;
    padding: 0 16px;
    height: 56px;
    border-radius: ${C=>borders[C.theme.borderRadius]};

    &:hover {
        ${C=>C.disableEventsAnimation ? "transform: unset;" : ""}
    }

    &:active {
        ${C=>C.disableEventsAnimation ? "transform: unset;" : ""}
    }
`;
styled$2.ul`
    position: absolute;
    bottom: 100%;
    left: 0;
    margin: 0;
    padding: 8px;
    width: 188px;
    transform: translateY(-16px);

    background-color: ${C=>C.theme.colors.background.primary};
    border-radius: ${C=>borders[C.theme.borderRadius]};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
`;
styled$2.li`
    padding: 8px;

    display: flex;
    align-items: center;
    gap: 8px;

    cursor: pointer;
    border-radius: ${C=>hoverBorders[C.theme.borderRadius]};

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${C=>C.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`;
styled$2(Image)`
    width: 24px;
    height: 24px;

    border-radius: 6px;
`;
styled$2.div`
    margin-top: 23px;
    margin-bottom: 1px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`;
styled$2(Text$1)`
    color: ${C=>C.theme.colors.text.secondary};
    font-size: 16px;
`;
const _tmpl$ = template$1("<li></li>")
  , DesktopUniversalModal = C=>{
    const [S,E] = createSignal(!1)
      , M = appState.connector
      , T = ()=>[...new Set(C.walletsList.filter(isWalletInfoRemote).map(B=>B.bridgeUrl)).values()].map(B=>({
        bridgeUrl: B
    }));
    setLastSelectedWalletInfo({
        openMethod: "qrcode"
    });
    const $ = createMemo(()=>M.connect(T(), C.additionalRequest));
    return createComponent(DesktopUniversalModalStyled, {
        onClick: ()=>E(!1),
        "data-tc-wallets-modal-universal-desktop": "true",
        get children() {
            return [createComponent(H1, {
                translationKey: "walletModal.desktopUniversalModal.connectYourWallet",
                children: "Connect your wallet"
            }), createComponent(H2Styled, {
                translationKey: "walletModal.desktopUniversalModal.scan",
                children: "Scan with your mobile wallet"
            }), createComponent(QRCodeStyled, {
                get sourceUrl() {
                    return addReturnStrategy$1($(), "none")
                },
                get disableCopy() {
                    return S()
                },
                get imageUrl() {
                    return IMG.TON
                }
            }), createComponent(H2AvailableWalletsStyled, {
                translationKey: "walletModal.desktopUniversalModal.availableWallets",
                children: "Available wallets"
            }), createComponent(WalletsContainerStyled, {
                get children() {
                    return [createComponent(For, {
                        get each() {
                            return C.walletsList.slice(0, 3)
                        },
                        children: B=>(()=>{
                            const O = _tmpl$.cloneNode(!0);
                            return insert$1(O, createComponent(WalletLabeledItem, {
                                wallet: B,
                                onClick: ()=>C.onSelect(B)
                            })),
                            O
                        }
                        )()
                    }), createComponent(FourWalletsItem, {
                        labelLine1: "View all",
                        labelLine2: "wallets",
                        get images() {
                            return C.walletsList.slice(3, 7).map(B=>B.imageUrl)
                        },
                        onClick: ()=>C.onSelectAllWallets()
                    })]
                }
            })]
        }
    })
}
  , WalletsModal = ()=>{
    const {locale: C} = useI18n()[1];
    createEffect(()=>C(appState.language)),
    createEffect(()=>{
        getWalletsModalIsOpened() && updateIsMobile()
    }
    );
    const S = useContext(ConnectorContext)
      , E = useContext(TonConnectUiContext)
      , [M] = createResource(()=>E.getWallets())
      , [T,$] = createSignal(null)
      , [B,O] = createSignal("universal")
      , [F,N] = createSignal(!1)
      , U = createMemo(()=>{
        if (M.state !== "ready")
            return null;
        let oe = applyWalletsListConfiguration(M(), appState.walletsListConfiguration);
        const ae = oe.filter(isWalletInfoCurrentlyInjected)
          , se = oe.filter(ge=>!isWalletInfoCurrentlyInjected(ge));
        oe = (ae || []).concat(se);
        const le = appState.preferredWalletAppName
          , de = oe.find(ge=>eqWalletName(ge, le))
          , fe = oe.filter(ge=>eqWalletName(ge, le)).length >= 2;
        le && de && !fe && (oe = [__spreadProps(__spreadValues$1({}, de), {
            isPreferred: !0
        })].concat(oe.filter(ge=>!eqWalletName(ge, le))));
        const pe = oe.find(ge=>eqWalletName(ge, AT_WALLET_APP_NAME));
        return pe && (oe = [pe].concat(oe.filter(ge=>!eqWalletName(ge, AT_WALLET_APP_NAME)))),
        oe
    }
    )
      , H = ()=>{
        var oe;
        return ((oe = appState.connectRequestParameters) == null ? void 0 : oe.state) === "loading"
    }
      , Z = createMemo(()=>{
        var oe;
        if (!H())
            return (oe = appState.connectRequestParameters) == null ? void 0 : oe.value
    }
    )
      , J = oe=>{
        setWalletsModalState({
            status: "closed",
            closeReason: oe
        }),
        $(null),
        N(!1)
    }
      , ie = S.onStatusChange(oe=>{
        oe && J("wallet-selected")
    }
    );
    return onCleanup(ie),
    createComponent(StyledModal, {
        get opened() {
            return getWalletsModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: ()=>J("action-cancelled"),
        onClickQuestion: ()=>N(oe=>!oe),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return F()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: ()=>N(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !F()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return H() || !U()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return createMemo(()=>!H())() && U()
                        },
                        get children() {
                            return createComponent(Switch, {
                                get children() {
                                    return [createComponent(Match, {
                                        get when() {
                                            return T()
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile$1() ? MobileConnectionModal : DesktopConnectionModal
                                                },
                                                get wallet() {
                                                    return T()
                                                },
                                                get additionalRequest() {
                                                    return Z()
                                                },
                                                onBackClick: ()=>$(null)
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return B() === "universal"
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile$1() ? MobileUniversalModal : DesktopUniversalModal
                                                },
                                                onSelect: $,
                                                get walletsList() {
                                                    return U()
                                                },
                                                get additionalRequest() {
                                                    return Z()
                                                },
                                                onSelectAllWallets: ()=>O("all-wallets")
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return B() === "all-wallets"
                                        },
                                        get children() {
                                            return createComponent(AllWalletsListModal, {
                                                get walletsList() {
                                                    return U()
                                                },
                                                onBack: ()=>O("universal"),
                                                onSelect: $
                                            })
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , ActionModalStyled = styled$2.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 8px;
`
  , H1Styled = styled$2(H1)`
    margin-top: 16px;
`
  , TextStyled = styled$2(Text$1)`
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    max-width: 250px;

    color: ${C=>C.theme.colors.text.secondary};
`
  , ButtonStyled = styled$2(Button)`
    margin-top: 32px;
`
  , ActionModal = C=>{
    const S = useDataAttributes(C)
      , E = useContext(TonConnectUiContext)
      , [M,T] = createSignal(!0);
    let $;
    E != null && E.wallet && "universalLink"in E.wallet && (E.wallet.openMethod === "universal-link" || isTelegramUrl(E.wallet.universalLink) && isInTMA()) && ($ = E.wallet.universalLink);
    const B = ()=>{
        const O = action()
          , F = "returnStrategy"in O ? O.returnStrategy : appState.returnStrategy;
        if (isTelegramUrl($)) {
            const N = !M();
            T(!1),
            redirectToTelegram($, {
                returnStrategy: F,
                twaReturnUrl: "twaReturnUrl"in O ? O.twaReturnUrl : appState.twaReturnUrl,
                forceRedirect: N
            })
        } else
            openLinkBlank(addReturnStrategy$1($, F))
    }
    ;
    return createComponent(ActionModalStyled, mergeProps(S, {
        get children() {
            return [createMemo(()=>C.icon), createComponent(H1Styled, {
                get translationKey() {
                    return C.headerTranslationKey
                },
                get translationValues() {
                    return C.headerTranslationValues
                }
            }), createComponent(TextStyled, {
                get translationKey() {
                    return C.textTranslationKey
                },
                get translationValues() {
                    return C.textTranslationValues
                }
            }), createComponent(Show, {
                get when() {
                    return C.showButton !== "open-wallet"
                },
                get children() {
                    return createComponent(ButtonStyled, {
                        onClick: ()=>C.onClose(),
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "common.close",
                                children: "Close"
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return C.showButton === "open-wallet" && $
                },
                get children() {
                    return createComponent(ButtonStyled, {
                        onClick: B,
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "common.openWallet",
                                children: "Open wallet"
                            })
                        }
                    })
                }
            })]
        }
    }))
}
  , ConfirmTransactionModal = C=>{
    const S = useContext(TonConnectUiContext)
      , [E] = useI18n()
      , M = ()=>S.wallet && "name"in S.wallet ? S.wallet.name : E("common.yourWallet", {}, "Your wallet");
    return createComponent(ActionModal, {
        headerTranslationKey: "actionModal.confirmTransaction.header",
        get headerTranslationValues() {
            return {
                name: M()
            }
        },
        textTranslationKey: "actionModal.confirmTransaction.text",
        get icon() {
            return createComponent(LoaderIcon, {
                size: "m"
            })
        },
        onClose: ()=>C.onClose(),
        showButton: "open-wallet",
        "data-tc-confirm-modal": "true"
    })
}
  , TransactionCanceledModal = C=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionCanceled.header",
    textTranslationKey: "actionModal.transactionCanceled.text",
    get icon() {
        return createComponent(ErrorIcon, {
            size: "m"
        })
    },
    onClose: ()=>C.onClose(),
    "data-tc-transaction-canceled-modal": "true"
})
  , TransactionSentModal = C=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionSent.header",
    textTranslationKey: "actionModal.transactionSent.text",
    get icon() {
        return createComponent(SuccessIcon, {
            size: "m"
        })
    },
    onClose: ()=>C.onClose(),
    "data-tc-transaction-sent-modal": "true"
})
  , ActionsModal = ()=>createComponent(Modal$2, {
    get opened() {
        var C;
        return createMemo(()=>action() !== null)() && ((C = action()) == null ? void 0 : C.openModal) === !0
    },
    get enableAndroidBackHandler() {
        return appState.enableAndroidBackHandler
    },
    onClose: ()=>setAction(null),
    "data-tc-actions-modal-container": "true",
    get children() {
        return createComponent(Switch, {
            get children() {
                return [createComponent(Match, {
                    get when() {
                        return action().name === "transaction-sent"
                    },
                    get children() {
                        return createComponent(TransactionSentModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "transaction-canceled"
                    },
                    get children() {
                        return createComponent(TransactionCanceledModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "confirm-transaction"
                    },
                    get children() {
                        return createComponent(ConfirmTransactionModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                })]
            }
        })
    }
})
  , App$1 = C=>{
    const S = createI18nContext(i18nDictionary, appState.language);
    return defineStylesRoot(),
    fixMobileSafariActiveTransition(),
    createComponent(I18nContext.Provider, {
        value: S,
        get children() {
            return createComponent(TonConnectUiContext.Provider, {
                get value() {
                    return C.tonConnectUI
                },
                get children() {
                    return createComponent(ConnectorContext.Provider, {
                        get value() {
                            return appState.connector
                        },
                        get children() {
                            return [createComponent(GlobalStyles$1, {}), createComponent(ThemeProvider, {
                                theme: themeState,
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return appState.buttonRootId
                                        },
                                        get children() {
                                            return createComponent(Portal$1, {
                                                get mount() {
                                                    return document.getElementById(appState.buttonRootId)
                                                },
                                                get children() {
                                                    return createComponent(AccountButton, {})
                                                }
                                            })
                                        }
                                    }), createComponent(Dynamic, {
                                        component: globalStylesTag,
                                        get children() {
                                            return [createComponent(WalletsModal, {}), createComponent(ActionsModal, {})]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            })
        }
    })
}
  , widgetController = {
    openWalletsModal: ()=>void setTimeout(()=>setWalletsModalState({
        status: "opened",
        closeReason: null
    })),
    closeWalletsModal: C=>void setTimeout(()=>setWalletsModalState({
        status: "closed",
        closeReason: C
    })),
    setAction: C=>void setTimeout(()=>setAction(C)),
    clearAction: ()=>void setTimeout(()=>setAction(null)),
    getSelectedWalletInfo: ()=>lastSelectedWalletInfo(),
    removeSelectedWalletInfo: ()=>setLastSelectedWalletInfo(null),
    renderApp: (C,S)=>render$1(()=>createComponent(App$1, {
        tonConnectUI: S
    }), document.getElementById(C))
};
class WalletsModalManager {
    constructor(S) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "state", walletsModalState()),
        this.connector = S.connector,
        this.setConnectRequestParametersCallback = S.setConnectRequestParametersCallback,
        createEffect(()=>{
            const E = walletsModalState();
            this.state = E,
            this.consumers.forEach(M=>M(E))
        }
        )
    }
    open() {
        return __async(this, null, function*() {
            const E = (yield this.connector.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return E ? this.connectEmbeddedWallet(E) : this.connectExternalWallet()
        })
    }
    close() {
        widgetController.closeWalletsModal("action-cancelled")
    }
    onStateChange(S) {
        return this.consumers.push(S),
        ()=>{
            this.consumers = this.consumers.filter(E=>E !== S)
        }
    }
    connectEmbeddedWallet(S) {
        const E = T=>{
            setLastSelectedWalletInfo(S),
            this.connector.connect({
                jsBridgeKey: S.jsBridgeKey
            }, T)
        }
          , M = appState.connectRequestParameters;
        (M == null ? void 0 : M.state) === "loading" ? this.setConnectRequestParametersCallback(E) : E(M == null ? void 0 : M.value)
    }
    connectExternalWallet() {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openWalletsModal(),
            new Promise(S=>{
                const E = this.onStateChange(M=>{
                    const {status: T} = M;
                    T === "opened" && (E(),
                    S())
                }
                )
            }
            )
        })
    }
}
class TransactionModalManager {
    constructor(S) {
        __publicField(this, "connector"),
        __publicField(this, "consumers", []),
        this.connector = S.connector,
        createEffect(()=>{
            const E = action();
            this.consumers.forEach(M=>M(E))
        }
        )
    }
    onStateChange(S) {
        return this.consumers.push(S),
        ()=>{
            this.consumers = this.consumers.filter(E=>E !== S)
        }
    }
}
class TonConnectUI {
    constructor(S) {
        if (__publicField(this, "walletInfoStorage", new WalletInfoStorage),
        __publicField(this, "preferredWalletStorage", new PreferredWalletStorage),
        __publicField(this, "walletInfo", null),
        __publicField(this, "systemThemeChangeUnsubscribe", null),
        __publicField(this, "actionsConfiguration"),
        __publicField(this, "walletsList"),
        __publicField(this, "connectRequestParametersCallback"),
        __publicField(this, "connector"),
        __publicField(this, "modal"),
        __publicField(this, "transactionModal"),
        __publicField(this, "connectionRestored", Promise.resolve(!1)),
        S && "connector"in S && S.connector)
            this.connector = S.connector;
        else if (S && "manifestUrl"in S && S.manifestUrl)
            this.connector = new TonConnect({
                manifestUrl: S.manifestUrl
            });
        else
            throw new TonConnectUIError("You have to specify a `manifestUrl` or a `connector` in the options.");
        this.modal = new WalletsModalManager({
            connector: this.connector,
            setConnectRequestParametersCallback: T=>{
                this.connectRequestParametersCallback = T
            }
        }),
        this.transactionModal = new TransactionModalManager({
            connector: this.connector
        }),
        this.walletsList = this.getWallets(),
        this.walletsList.then(T=>preloadImages(uniq(T.map($=>$.imageUrl))));
        const E = this.normalizeWidgetRoot(S == null ? void 0 : S.widgetRootId);
        this.subscribeToWalletChange(),
        (S == null ? void 0 : S.restoreConnection) !== !1 && (this.connectionRestored = new Promise(T=>__async(this, null, function*() {
            yield this.connector.restoreConnection(),
            this.connector.connected || this.walletInfoStorage.removeWalletInfo(),
            T(this.connector.connected)
        }))),
        this.uiOptions = mergeOptions(S, {
            uiPreferences: {
                theme: "SYSTEM"
            }
        });
        const M = this.preferredWalletStorage.getPreferredWalletAppName();
        setAppState({
            connector: this.connector,
            preferredWalletAppName: M
        }),
        widgetController.renderApp(E, this)
    }
    static getWallets() {
        return TonConnect.getWallets()
    }
    get connected() {
        return this.connector.connected
    }
    get account() {
        return this.connector.account
    }
    get wallet() {
        return this.connector.wallet ? __spreadValues$1(__spreadValues$1({}, this.connector.wallet), this.walletInfo) : null
    }
    set uiOptions(S) {
        var E, M, T, $, B;
        this.checkButtonRootExist(S.buttonRootId),
        this.actionsConfiguration = S.actionsConfiguration,
        (E = S.uiPreferences) != null && E.theme ? ((M = S.uiPreferences) == null ? void 0 : M.theme) !== "SYSTEM" ? ((T = this.systemThemeChangeUnsubscribe) == null || T.call(this),
        setTheme(S.uiPreferences.theme, S.uiPreferences.colorsSet)) : (setTheme(getSystemTheme(), S.uiPreferences.colorsSet),
        this.systemThemeChangeUnsubscribe || (this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme))) : ($ = S.uiPreferences) != null && $.colorsSet && setColors(S.uiPreferences.colorsSet),
        (B = S.uiPreferences) != null && B.borderRadius && setBorderRadius(S.uiPreferences.borderRadius),
        setAppState(O=>{
            var F, N;
            const U = mergeOptions(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, S.language && {
                language: S.language
            }), !!((F = S.actionsConfiguration) != null && F.returnStrategy) && {
                returnStrategy: S.actionsConfiguration.returnStrategy
            }), !!((N = S.actionsConfiguration) != null && N.twaReturnUrl) && {
                twaReturnUrl: S.actionsConfiguration.twaReturnUrl
            }), !!S.walletsListConfiguration && {
                walletsListConfiguration: S.walletsListConfiguration
            }), unwrap(O));
            return S.buttonRootId !== void 0 && (U.buttonRootId = S.buttonRootId),
            S.enableAndroidBackHandler !== void 0 && (U.enableAndroidBackHandler = S.enableAndroidBackHandler),
            U
        }
        )
    }
    setConnectRequestParameters(S) {
        var E;
        setAppState({
            connectRequestParameters: S
        }),
        ((S == null ? void 0 : S.state) === "ready" || !S) && ((E = this.connectRequestParametersCallback) == null || E.call(this, S == null ? void 0 : S.value))
    }
    getWallets() {
        return __async(this, null, function*() {
            return this.connector.getWallets()
        })
    }
    onStatusChange(S, E) {
        return this.connector.onStatusChange(M=>__async(this, null, function*() {
            if (M) {
                const T = yield this.getSelectedWalletInfo(M);
                S(__spreadValues$1(__spreadValues$1({}, M), T || this.walletInfoStorage.getWalletInfo()))
            } else
                S(M)
        }), E)
    }
    openModal() {
        return __async(this, null, function*() {
            return this.modal.open()
        })
    }
    closeModal() {
        this.modal.close()
    }
    onModalStateChange(S) {
        return this.modal.onStateChange(S)
    }
    get modalState() {
        return this.modal.state
    }
    connectWallet() {
        return __async(this, null, function*() {
            const E = (yield this.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return E ? yield this.connectEmbeddedWallet(E) : yield this.connectExternalWallet()
        })
    }
    disconnect() {
        return widgetController.clearAction(),
        widgetController.removeSelectedWalletInfo(),
        this.walletInfoStorage.removeWalletInfo(),
        this.connector.disconnect()
    }
    sendTransaction(S, E) {
        return __async(this, null, function*() {
            if (!this.connected)
                throw new TonConnectUIError("Connect wallet to send a transaction.");
            isInTMA() && sendExpand();
            const {notifications: M, modals: T, returnStrategy: $, twaReturnUrl: B, skipRedirectToWallet: O} = this.getModalsAndNotificationsConfiguration(E);
            widgetController.setAction({
                name: "confirm-transaction",
                showNotification: M.includes("before"),
                openModal: T.includes("before")
            });
            const F = ()=>{
                const H = getUserAgent().os === "ios"
                  , Z = O === "ios" && H || O === "always";
                this.walletInfo && "universalLink"in this.walletInfo && this.walletInfo.openMethod === "universal-link" && !Z && (isTelegramUrl(this.walletInfo.universalLink) ? redirectToTelegram(this.walletInfo.universalLink, {
                    returnStrategy: $,
                    twaReturnUrl: B || appState.twaReturnUrl,
                    forceRedirect: !1
                }) : openLinkBlank(addReturnStrategy$1(this.walletInfo.universalLink, $)))
            }
              , N = new AbortController
              , U = this.onTransactionModalStateChange(H=>{
                H != null && H.openModal || (U(),
                H || N.abort())
            }
            );
            try {
                const H = yield this.waitForSendTransaction({
                    transaction: S,
                    abortSignal: N.signal
                }, F);
                return widgetController.setAction({
                    name: "transaction-sent",
                    showNotification: M.includes("success"),
                    openModal: T.includes("success")
                }),
                H
            } catch (H) {
                throw widgetController.setAction({
                    name: "transaction-canceled",
                    showNotification: M.includes("error"),
                    openModal: T.includes("error")
                }),
                H instanceof TonConnectError ? H : (console.error(H),
                new TonConnectUIError("Unhandled error:" + H))
            } finally {
                U()
            }
        })
    }
    connectEmbeddedWallet(S) {
        return __async(this, null, function*() {
            const E = T=>{
                setLastSelectedWalletInfo(S),
                this.connector.connect({
                    jsBridgeKey: S.jsBridgeKey
                }, T)
            }
              , M = appState.connectRequestParameters;
            return (M == null ? void 0 : M.state) === "loading" ? this.connectRequestParametersCallback = E : E(M == null ? void 0 : M.value),
            yield this.waitForWalletConnection({
                ignoreErrors: !1
            })
        })
    }
    connectExternalWallet() {
        return __async(this, null, function*() {
            const S = new AbortController;
            widgetController.openWalletsModal();
            const E = this.onModalStateChange(M=>{
                const {status: T, closeReason: $} = M;
                T !== "opened" && (E(),
                $ === "action-cancelled" && S.abort())
            }
            );
            return yield this.waitForWalletConnection({
                ignoreErrors: !0,
                abortSignal: S.signal
            })
        })
    }
    waitForWalletConnection(S) {
        return __async(this, null, function*() {
            return new Promise((E,M)=>{
                const {ignoreErrors: T=!1, abortSignal: $=null} = S;
                if ($ && $.aborted)
                    return M(new TonConnectUIError("Wallet was not connected"));
                const B = N=>__async(this, null, function*() {
                    if (N)
                        F(),
                        E(N);
                    else {
                        if (T)
                            return;
                        F(),
                        M(new TonConnectUIError("Wallet was not connected"))
                    }
                })
                  , O = N=>{
                    T || (F(),
                    M(N))
                }
                  , F = this.onStatusChange(N=>B(N), N=>O(N));
                $ && $.addEventListener("abort", ()=>{
                    F(),
                    M(new TonConnectUIError("Wallet was not connected"))
                }
                )
            }
            )
        })
    }
    waitForSendTransaction(S, E) {
        return __async(this, null, function*() {
            return new Promise((M,T)=>{
                const {transaction: $, abortSignal: B} = S;
                if (B.aborted)
                    return T(new TonConnectUIError("Transaction was not sent"));
                const O = N=>__async(this, null, function*() {
                    M(N)
                })
                  , F = N=>{
                    T(N)
                }
                ;
                this.connector.sendTransaction($, E).then(N=>O(N)).catch(N=>F(N)),
                B.addEventListener("abort", ()=>{
                    T(new TonConnectUIError("Transaction was not sent"))
                }
                )
            }
            )
        })
    }
    onTransactionModalStateChange(S) {
        return this.transactionModal.onStateChange(S)
    }
    subscribeToWalletChange() {
        this.connector.onStatusChange(S=>__async(this, null, function*() {
            var E;
            S ? (yield this.updateWalletInfo(S),
            this.setPreferredWalletAppName(((E = this.walletInfo) == null ? void 0 : E.appName) || S.device.appName)) : this.walletInfoStorage.removeWalletInfo()
        }))
    }
    setPreferredWalletAppName(S) {
        this.preferredWalletStorage.setPreferredWalletAppName(S),
        setAppState({
            preferredWalletAppName: S
        })
    }
    getSelectedWalletInfo(S) {
        return __async(this, null, function*() {
            let E = widgetController.getSelectedWalletInfo();
            if (!E)
                return null;
            let M;
            if ("name"in E)
                M = E;
            else {
                const $ = applyWalletsListConfiguration(yield this.walletsList, appState.walletsListConfiguration).find(B=>eqWalletName(B, S.device.appName));
                if (!$)
                    throw new TonConnectUIError(`Cannot find WalletInfo for the '${S.device.appName}' wallet`);
                M = __spreadValues$1(__spreadValues$1({}, $), E)
            }
            return M
        })
    }
    updateWalletInfo(S) {
        return __async(this, null, function*() {
            const E = yield this.getSelectedWalletInfo(S);
            if (E) {
                this.walletInfo = E,
                this.walletInfoStorage.setWalletInfo(E);
                return
            }
            const M = this.walletInfoStorage.getWalletInfo();
            if (M) {
                this.walletInfo = M;
                return
            }
            this.walletInfo = (yield this.walletsList).find(T=>eqWalletName(T, S.device.appName)) || null
        })
    }
    normalizeWidgetRoot(S) {
        if (!S || !document.getElementById(S)) {
            S = "tc-widget-root";
            const E = document.createElement("div");
            E.id = S,
            document.body.appendChild(E)
        }
        return S
    }
    checkButtonRootExist(S) {
        if (S != null && !document.getElementById(S))
            throw new TonConnectUIError(`${S} element not found in the document.`)
    }
    getModalsAndNotificationsConfiguration(S) {
        var E, M, T, $, B, O;
        const F = ["before", "success", "error"];
        let N = F;
        (E = this.actionsConfiguration) != null && E.notifications && ((M = this.actionsConfiguration) == null ? void 0 : M.notifications) !== "all" && (N = this.actionsConfiguration.notifications),
        S != null && S.notifications && (S.notifications === "all" ? N = F : N = S.notifications);
        let U = ["before"];
        (T = this.actionsConfiguration) != null && T.modals && (this.actionsConfiguration.modals === "all" ? U = F : U = this.actionsConfiguration.modals),
        S != null && S.modals && (S.modals === "all" ? U = F : U = S.modals);
        const H = (S == null ? void 0 : S.returnStrategy) || (($ = this.actionsConfiguration) == null ? void 0 : $.returnStrategy) || "back"
          , Z = (S == null ? void 0 : S.twaReturnUrl) || ((B = this.actionsConfiguration) == null ? void 0 : B.twaReturnUrl);
        let J = (S == null ? void 0 : S.skipRedirectToWallet) || ((O = this.actionsConfiguration) == null ? void 0 : O.skipRedirectToWallet) || "ios";
        return isInTMA() && (J = "never"),
        {
            notifications: N,
            modals: U,
            returnStrategy: H,
            twaReturnUrl: Z,
            skipRedirectToWallet: J
        }
    }
}
var __defProp = Object.defineProperty
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (C,S,E)=>S in C ? __defProp(C, S, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: E
}) : C[S] = E
  , __spreadValues = (C,S)=>{
    for (var E in S || (S = {}))
        __hasOwnProp.call(S, E) && __defNormalProp(C, E, S[E]);
    if (__getOwnPropSymbols)
        for (var E of __getOwnPropSymbols(S))
            __propIsEnum.call(S, E) && __defNormalProp(C, E, S[E]);
    return C
}
  , __objRest = (C,S)=>{
    var E = {};
    for (var M in C)
        __hasOwnProp.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && __getOwnPropSymbols)
        for (var M of __getOwnPropSymbols(C))
            S.indexOf(M) < 0 && __propIsEnum.call(C, M) && (E[M] = C[M]);
    return E
}
  , jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min)
        return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var C = React$1
      , S = Symbol.for("react.element")
      , E = Symbol.for("react.fragment")
      , M = Object.prototype.hasOwnProperty
      , T = C.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , $ = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function B(O, F, N) {
        var U, H = {}, Z = null, J = null;
        N !== void 0 && (Z = "" + N),
        F.key !== void 0 && (Z = "" + F.key),
        F.ref !== void 0 && (J = F.ref);
        for (U in F)
            M.call(F, U) && !$.hasOwnProperty(U) && (H[U] = F[U]);
        if (O && O.defaultProps)
            for (U in F = O.defaultProps,
            F)
                H[U] === void 0 && (H[U] = F[U]);
        return {
            $$typeof: S,
            type: O,
            key: Z,
            ref: J,
            props: H,
            _owner: T.current
        }
    }
    return reactJsxRuntime_production_min.Fragment = E,
    reactJsxRuntime_production_min.jsx = B,
    reactJsxRuntime_production_min.jsxs = B,
    reactJsxRuntime_production_min
}
(function(C) {
    C.exports = requireReactJsxRuntime_production_min()
}
)(jsxRuntime);
const jsx = jsxRuntime.exports.jsx;
function isClientSide$1() {
    return typeof window < "u"
}
function isServerSide() {
    return !isClientSide$1()
}
const TonConnectUIContext = reactExports.createContext(null);
let tonConnectUI = null;
const TonConnectUIProvider = C=>{
    var S = C
      , {children: E} = S
      , M = __objRest(S, ["children"]);
    return isClientSide$1() && !tonConnectUI && (tonConnectUI = new TonConnectUI(M)),
    jsx(TonConnectUIContext.Provider, {
        value: tonConnectUI,
        children: E
    })
}
  , TonConnectUIProvider$1 = reactExports.memo(TonConnectUIProvider);
class TonConnectUIReactError extends TonConnectUIError {
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, TonConnectUIReactError.prototype)
    }
}
class TonConnectProviderNotSetError extends TonConnectUIReactError {
    constructor(...S) {
        super(...S),
        Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype)
    }
}
function checkProvider(C) {
    if (!C)
        throw new TonConnectProviderNotSetError("You should add <TonConnectUIProvider> on the top of the app to use TonConnect");
    return !0
}
function useTonConnectUI() {
    const C = reactExports.useContext(TonConnectUIContext)
      , S = reactExports.useCallback(E=>{
        C && (C.uiOptions = E)
    }
    , [C]);
    return isServerSide() ? [null, ()=>{}
    ] : (checkProvider(C),
    [C, S])
}
const buttonRootId = "ton-connect-button"
  , TonConnectButton = ({className: C, style: S})=>{
    const [E,M] = useTonConnectUI();
    return reactExports.useEffect(()=>(M({
        buttonRootId
    }),
    ()=>M({
        buttonRootId: null
    })), [M]),
    jsx("div", {
        id: buttonRootId,
        className: C,
        style: __spreadValues({
            width: "fit-content"
        }, S)
    })
}
;
reactExports.memo(TonConnectButton);
function useTonWallet() {
    const [C] = useTonConnectUI()
      , [S,E] = reactExports.useState((C == null ? void 0 : C.wallet) || null);
    return reactExports.useEffect(()=>{
        if (C)
            return C.onStatusChange(M=>{
                E(M)
            }
            )
    }
    , [C]),
    S
}
function useTonAddress(C=!0) {
    const S = useTonWallet();
    return S ? C ? toUserFriendlyAddress(S.account.address, S.account.chain === CHAIN.TESTNET) : S.account.address : ""
}
function useTonConnectModal() {
    const [C] = useTonConnectUI()
      , [S,E] = reactExports.useState((C == null ? void 0 : C.modal.state) || null);
    return reactExports.useEffect(()=>{
        if (C)
            return C.onModalStateChange(M=>{
                E(M)
            }
            )
    }
    , [C]),
    {
        state: S,
        open: ()=>{
            if (C)
                return C.modal.open()
        }
        ,
        close: ()=>{
            C && C.modal.close()
        }
    }
}
function useIsConnectionRestored() {
    const [C,S] = reactExports.useState(!1)
      , [E] = useTonConnectUI();
    return reactExports.useEffect(()=>{
        E && E.connectionRestored.then(()=>S(!0))
    }
    , [E]),
    C
}
function storeDeploy$1(C) {
    return S=>{
        const E = S;
        E.storeUint(2490013878, 32),
        E.storeUint(C.queryId, 64)
    }
}
function storeBuyPotato(C) {
    return S=>{
        const E = S;
        E.storeUint(332179752, 32),
        E.storeAddress(C.sellerAddress),
        E.storeUint(C.price, 256),
        E.storeUint(C.id, 32)
    }
}
function storeWithdraw$1(C) {
    return S=>{
        const E = S;
        E.storeUint(195467089, 32),
        E.storeCoins(C.amount)
    }
}
function initTonPotato_init_args(C) {
    return S=>{
        S.storeInt(C.id, 257)
    }
}
async function TonPotato_init(C) {
    const S = dist$4.Cell.fromBase64("te6ccgECIAEABbEAART/APSkE/S88sgLAQIBYgIDA3rQAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxVFds88uCCGgQFAgEgExQE4O2i7fsBkjB/4HAh10nCH5UwINcLH94gghATzKkouo65MNMfAYIQE8ypKLry4IH6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIAdP/0x9VIGwT2zx/4CCCEAuml1G64wIgghCUapi2uuMCwAAGBwgJAIDI+EMBzH8BygBVUFBlINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WE/QA9ACBAQHPABLLH4EBAc8Aye1UBGQhggDLwfhBbyQTXwNRRqAUvhPy9MhwAcsfbwABb4xtb4yLNidXmNs8izIHwgjbPAHbPA4OCgsCZjDTHwGCEAuml1G68uCB+gABMVVQ2zz4J28QggiYloChF7YI+EJ/WIBCECNtbW3bPFUEfxARAVAw0x8BghCUapi2uvLggdM/ATHIAYIQr/kPV1jLH8s/yfhCAXBt2zx/DwKSj0P5AYLwUJK13OBxWlfdlp9ftab5MCWgsC6rMpRwyis2XKDX6Tq6jxvbPPhCf/gnbxCCCJiWgKGAQhAjbW1t2zx/2zHgkTDicBARAN7IIcEAmIAtAcsHAaMB3iGCODJ8snNBGdO3qaoduY4gcCBxjhQEeqkMpjAlqBKgBKoHAqQhwABFMOYwM6oCzwGOK28AcI4RI3qpCBJvjAGkA3qpBCDAABTmMyKlA5xTAm+BpjBYywcCpVnkMDHiydAETNs8izIHwgjbPHABbyIByZMhbrOWAW8iWczJ6DHQ2zwScxA0AW1tDg4MDQFCyHAByx9vAAFvjG1vjAHbPG8iAcmTIW6zlgFvIlnMyegxDgEE2zwRALog10oh10mXIMIAIsIAsY5KA28igH8izzGrAqEFqwJRVbYIIMIAnCCqAhXXGFAzzxZAFN5ZbwJTQaHCAJnIAW8CUEShqgKOEjEzwgCZ1DDQINdKIddJknAg4uLoXwMBOm1tIm6zmVsgbvLQgG8iAZEy4hAkcAMEgEJQI9s8EQAS+EJSYMcF8uCEAcrIcQHKAVAHAcoAcAHKAlAFINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WUAP6AnABymgjbrORf5MkbrPilzMzAXABygDjDSFus5x/AcoAASBu8tCAAcyVMXABygDiyQH7ABIAmH8BygDIcAHKAHABygAkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDiJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4nABygACfwHKAALJWMwCEb4o7tnm2eNjDBoVAgEgFhcAAiUCASAYGQIBSB4fAhG22Btnm2eNjDAaGwC5t3owTgudh6ullc9j0J2HOslQo2zQThO6xqWlbI+WZFp15b++LEcwTgQKuANwDOxymcsHVcjktlhwThOy6ctWadluZ0HSzbKM3RSQTggZzq084r86ShYDrC3EyPZQAaztRNDUAfhj0gABjjT6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIAfQE9ASBAQHXANMfgQEB1wBVUGwW4Pgo1wsKgwm68uCJgQEB1wABAdHbPBwBDvgnbxB52zwdABhtbXCCCJiWgPhCUFUA2iDBASHCTbHy0IbIIsEAmIAtAcsHAqMC3n9wbwAEjhsEeqkMIMAAUjCws5twM6YwFG+MBKQEA5Ew4gTkAbOXAoAub4wCpN6OEAN6qQymMBNvjAOkIsAAEDTmMyKlA5pTEm+BAcsHAqUC5GwhydAAEbCvu1E0NIAAYAB1sm7jQ1aXBmczovL1FtUmIyNm9VdThvR1Nzc1dXRWJEdnN1VDNhUXlDUDFoUXlvTWFWb1M0TEVmWmSCA=")
      , E = dist$4.Cell.fromBase64("te6cckECIgEABbsAAQHAAQEFoGk1AgEU/wD0pBP0vPLICwMCAWIQBAIBIA4FAgEgCQYCAUgIBwB1sm7jQ1aXBmczovL1FtUmIyNm9VdThvR1Nzc1dXRWJEdnN1VDNhUXlDUDFoUXlvTWFWb1M0TEVmWmSCAAEbCvu1E0NIAAYAIBIAsKALm3ejBOC52Hq6WVz2PQnYc6yVCjbNBOE7rGpaVsj5ZkWnXlv74sRzBOBAq4A3AM7HKZywdVyOS2WHBOE7Lpy1Zp2W5nQdLNsozdFJBOCBnOrTzivzpKFgOsLcTI9lACEbbYG2ebZ42MMCAMAQ74J28Qeds8DQDaIMEBIcJNsfLQhsgiwQCYgC0BywcCowLef3BvAASOGwR6qQwgwABSMLCzm3AzpjAUb4wEpAQDkTDiBOQBs5cCgC5vjAKk3o4QA3qpDKYwE2+MA6QiwAAQNOYzIqUDmlMSb4EBywcCpQLkbCHJ0AIRviju2ebZ42MMIA8AAiUDetAB0NMDAXGwowH6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIVFBTA28E+GEC+GLbPFUV2zzy4IIgEhEAgMj4QwHMfwHKAFVQUGUg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIzxYT9AD0AIEBAc8AEssfgQEBzwDJ7VQE4O2i7fsBkjB/4HAh10nCH5UwINcLH94gghATzKkouo65MNMfAYIQE8ypKLry4IH6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIAdP/0x9VIGwT2zx/4CCCEAuml1G64wIgghCUapi2uuMCwAAYFhQTApKPQ/kBgvBQkrXc4HFaV92Wn1+1pvkwJaCwLqsylHDKKzZcoNfpOrqPG9s8+EJ/+CdvEIIImJaAoYBCECNtbW3bPH/bMeCRMOJwFxsBUDDTHwGCEJRqmLa68uCB0z8BMcgBghCv+Q9XWMsfyz/J+EIBcG3bPH8VATptbSJus5lbIG7y0IBvIgGRMuIQJHADBIBCUCPbPBsCZjDTHwGCEAuml1G68uCB+gABMVVQ2zz4J28QggiYloChF7YI+EJ/WIBCECNtbW3bPFUEfxcbABL4QlJgxwXy4IQEZCGCAMvB+EFvJBNfA1FGoBS+E/L0yHAByx9vAAFvjG1vjIs2J1eY2zyLMgfCCNs8Ads8Hx8eGQRM2zyLMgfCCNs8cAFvIgHJkyFus5YBbyJZzMnoMdDbPBJzEDQBbW0fHx0aAQTbPBsByshxAcoBUAcBygBwAcoCUAUg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIzxZQA/oCcAHKaCNus5F/kyRus+KXMzMBcAHKAOMNIW6znH8BygABIG7y0IABzJUxcAHKAOLJAfsAHACYfwHKAMhwAcoAcAHKACRus51/AcoABCBu8tCAUATMljQDcAHKAOIkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDicAHKAAJ/AcoAAslYzAFCyHAByx9vAAFvjG1vjAHbPG8iAcmTIW6zlgFvIlnMyegxHwDeyCHBAJiALQHLBwGjAd4hgjgyfLJzQRnTt6mqHbmOIHAgcY4UBHqpDKYwJagSoASqBwKkIcAARTDmMDOqAs8BjitvAHCOESN6qQgSb4wBpAN6qQQgwAAU5jMipQOcUwJvgaYwWMsHAqVZ5DAx4snQALog10oh10mXIMIAIsIAsY5KA28igH8izzGrAqEFqwJRVbYIIMIAnCCqAhXXGFAzzxZAFN5ZbwJTQaHCAJnIAW8CUEShqgKOEjEzwgCZ1DDQINdKIddJknAg4uLoXwMBrO1E0NQB+GPSAAGONPpAASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IgB9AT0BIEBAdcA0x+BAQHXAFVQbBbg+CjXCwqDCbry4ImBAQHXAAEB0ds8IQAYbW1wggiYloD4QlBVCZkW8w==")
      , M = dist$4.beginCell();
    M.storeRef(E),
    M.storeUint(0, 1),
    initTonPotato_init_args({
        $$type: "TonPotato_init_args",
        id: C
    })(M);
    const T = M.endCell();
    return {
        code: S,
        data: T
    }
}
const TonPotato_errors = {
    2: {
        message: "Stack undeflow"
    },
    3: {
        message: "Stack overflow"
    },
    4: {
        message: "Integer overflow"
    },
    5: {
        message: "Integer out of expected range"
    },
    6: {
        message: "Invalid opcode"
    },
    7: {
        message: "Type check error"
    },
    8: {
        message: "Cell overflow"
    },
    9: {
        message: "Cell underflow"
    },
    10: {
        message: "Dictionary error"
    },
    13: {
        message: "Out of gas error"
    },
    32: {
        message: "Method ID not found"
    },
    34: {
        message: "Action is invalid or not supported"
    },
    37: {
        message: "Not enough TON"
    },
    38: {
        message: "Not enough extra-currencies"
    },
    128: {
        message: "Null reference exception"
    },
    129: {
        message: "Invalid serialization prefix"
    },
    130: {
        message: "Invalid incoming message"
    },
    131: {
        message: "Constraints error"
    },
    132: {
        message: "Access denied"
    },
    133: {
        message: "Contract stopped"
    },
    134: {
        message: "Invalid argument"
    },
    135: {
        message: "Code of a contract was not found"
    },
    136: {
        message: "Invalid address"
    },
    137: {
        message: "Masterchain support is not enabled for this contract"
    },
    52161: {
        message: "Message fee is not enough"
    }
}
  , TonPotato_types = [{
    name: "StateInit",
    header: null,
    fields: [{
        name: "code",
        type: {
            kind: "simple",
            type: "cell",
            optional: !1
        }
    }, {
        name: "data",
        type: {
            kind: "simple",
            type: "cell",
            optional: !1
        }
    }]
}, {
    name: "Context",
    header: null,
    fields: [{
        name: "bounced",
        type: {
            kind: "simple",
            type: "bool",
            optional: !1
        }
    }, {
        name: "sender",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }, {
        name: "value",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "raw",
        type: {
            kind: "simple",
            type: "slice",
            optional: !1
        }
    }]
}, {
    name: "SendParameters",
    header: null,
    fields: [{
        name: "bounce",
        type: {
            kind: "simple",
            type: "bool",
            optional: !1
        }
    }, {
        name: "to",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }, {
        name: "value",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "mode",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "body",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }, {
        name: "code",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }, {
        name: "data",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }]
}, {
    name: "Deploy",
    header: 2490013878,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }]
}, {
    name: "DeployOk",
    header: 2952335191,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }]
}, {
    name: "FactoryDeploy",
    header: 1829761339,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "cashback",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "ChangeOwner",
    header: 2174598809,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "newOwner",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "ChangeOwnerOk",
    header: 846932810,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "newOwner",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "BuyPotato",
    header: 332179752,
    fields: [{
        name: "sellerAddress",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }, {
        name: "price",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 256
        }
    }, {
        name: "id",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 32
        }
    }]
}, {
    name: "Cancel",
    header: 906539626,
    fields: [{
        name: "nonce",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 32
        }
    }]
}, {
    name: "Withdraw",
    header: 195467089,
    fields: [{
        name: "amount",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: "coins"
        }
    }]
}]
  , TonPotato_getters = [{
    name: "balance",
    arguments: [],
    returnType: {
        kind: "simple",
        type: "string",
        optional: !1
    }
}, {
    name: "owner",
    arguments: [],
    returnType: {
        kind: "simple",
        type: "address",
        optional: !1
    }
}]
  , TonPotato_receivers = [{
    receiver: "internal",
    message: {
        kind: "typed",
        type: "BuyPotato"
    }
}, {
    receiver: "internal",
    message: {
        kind: "text",
        text: "withdraw all"
    }
}, {
    receiver: "internal",
    message: {
        kind: "typed",
        type: "Withdraw"
    }
}, {
    receiver: "internal",
    message: {
        kind: "typed",
        type: "Deploy"
    }
}];
class TonPotato {
    constructor(S, E) {
        jt(this, "address");
        jt(this, "init");
        jt(this, "abi", {
            types: TonPotato_types,
            getters: TonPotato_getters,
            receivers: TonPotato_receivers,
            errors: TonPotato_errors
        });
        this.address = S,
        this.init = E
    }
    static async init(S) {
        return await TonPotato_init(S)
    }
    static async fromInit(S) {
        const E = await TonPotato_init(S)
          , M = dist$4.contractAddress(0, E);
        return new TonPotato(M,E)
    }
    static fromAddress(S) {
        return new TonPotato(S)
    }
    async send(S, E, M, T) {
        let $ = null;
        if (T && typeof T == "object" && !(T instanceof dist$4.Slice) && T.$$type === "BuyPotato" && ($ = dist$4.beginCell().store(storeBuyPotato(T)).endCell()),
        T === "withdraw all" && ($ = dist$4.beginCell().storeUint(0, 32).storeStringTail(T).endCell()),
        T && typeof T == "object" && !(T instanceof dist$4.Slice) && T.$$type === "Withdraw" && ($ = dist$4.beginCell().store(storeWithdraw$1(T)).endCell()),
        T && typeof T == "object" && !(T instanceof dist$4.Slice) && T.$$type === "Deploy" && ($ = dist$4.beginCell().store(storeDeploy$1(T)).endCell()),
        $ === null)
            throw new Error("Invalid message type");
        await S.internal(E, {
            ...M,
            body: $
        })
    }
    async getBalance(S) {
        const E = new dist$4.TupleBuilder;
        return (await S.get("balance", E.build())).stack.readString()
    }
    async getOwner(S) {
        const E = new dist$4.TupleBuilder;
        return (await S.get("owner", E.build())).stack.readAddress()
    }
}
var OrderStatus = (C=>(C.Open = "open",
C.InProgress = "in_progress",
C.Executed = "executed",
C.Close = "close",
C.Error = "error",
C))(OrderStatus || {});
let HttpClient$1 = class {
    constructor(S={}) {
        jt(this, "baseUrl", "");
        jt(this, "securityData", null);
        jt(this, "securityWorker");
        jt(this, "abortControllers", new Map);
        jt(this, "customFetch", (...S)=>fetch(...S));
        jt(this, "baseApiParams", {
            credentials: "same-origin",
            headers: {},
            redirect: "follow",
            referrerPolicy: "no-referrer"
        });
        jt(this, "setSecurityData", S=>{
            this.securityData = S
        }
        );
        jt(this, "contentFormatters", {
            "application/json": S=>S !== null && (typeof S == "object" || typeof S == "string") ? JSON.stringify(S) : S,
            "text/plain": S=>S !== null && typeof S != "string" ? JSON.stringify(S) : S,
            "multipart/form-data": S=>Object.keys(S || {}).reduce((E,M)=>{
                const T = S[M];
                return E.append(M, T instanceof Blob ? T : typeof T == "object" && T !== null ? JSON.stringify(T) : `${T}`),
                E
            }
            , new FormData),
            "application/x-www-form-urlencoded": S=>this.toQueryString(S)
        });
        jt(this, "createAbortSignal", S=>{
            if (this.abortControllers.has(S)) {
                const M = this.abortControllers.get(S);
                return M ? M.signal : void 0
            }
            const E = new AbortController;
            return this.abortControllers.set(S, E),
            E.signal
        }
        );
        jt(this, "abortRequest", S=>{
            const E = this.abortControllers.get(S);
            E && (E.abort(),
            this.abortControllers.delete(S))
        }
        );
        jt(this, "request", async({body: S, secure: E, path: M, type: T, query: $, format: B, baseUrl: O, cancelToken: F, ...N})=>{
            const U = (typeof E == "boolean" ? E : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {}
              , H = this.mergeRequestParams(N, U)
              , Z = $ && this.toQueryString($)
              , J = this.contentFormatters[T || "application/json"]
              , ie = B || H.format;
            return this.customFetch(`${O || this.baseUrl || ""}${M}${Z ? `?${Z}` : ""}`, {
                ...H,
                headers: {
                    ...H.headers || {},
                    ...T && T !== "multipart/form-data" ? {
                        "Content-Type": T
                    } : {}
                },
                signal: (F ? this.createAbortSignal(F) : H.signal) || null,
                body: typeof S > "u" || S === null ? null : J(S)
            }).then(async oe=>{
                const ae = oe;
                ae.data = null,
                ae.error = null;
                const se = ie ? await oe[ie]().then(le=>(ae.ok ? ae.data = le : ae.error = le,
                ae)).catch(le=>(ae.error = le,
                ae)) : ae;
                if (F && this.abortControllers.delete(F),
                !oe.ok)
                    throw se;
                return se
            }
            )
        }
        );
        Object.assign(this, S)
    }
    encodeQueryParam(S, E) {
        return `${encodeURIComponent(S)}=${encodeURIComponent(typeof E == "number" ? E : `${E}`)}`
    }
    addQueryParam(S, E) {
        return this.encodeQueryParam(E, S[E])
    }
    addArrayQueryParam(S, E) {
        return S[E].map(T=>this.encodeQueryParam(E, T)).join("&")
    }
    toQueryString(S) {
        const E = S || {};
        return Object.keys(E).filter(T=>typeof E[T] < "u").map(T=>Array.isArray(E[T]) ? this.addArrayQueryParam(E, T) : this.addQueryParam(E, T)).join("&")
    }
    addQueryParams(S) {
        const E = this.toQueryString(S);
        return E ? `?${E}` : ""
    }
    mergeRequestParams(S, E) {
        return {
            ...this.baseApiParams,
            ...S,
            ...E || {},
            headers: {
                ...this.baseApiParams.headers || {},
                ...S.headers || {},
                ...E && E.headers || {}
            }
        }
    }
}
  , Api$1 = class extends HttpClient$1 {
    constructor() {
        super(...arguments);
        jt(this, "api", {
            v1TonPayloadList: (E={})=>this.request({
                path: "/api/v1/ton/payload",
                method: "GET",
                secure: !0,
                format: "json",
                ...E
            }),
            v1TonVerifyCreate: (E,M={})=>this.request({
                path: "/api/v1/ton/verify",
                method: "POST",
                body: E,
                secure: !0,
                type: "application/json",
                format: "json",
                ...M
            }),
            v1UsersAllList: (E={})=>this.request({
                path: "/api/v1/users/all",
                method: "GET",
                format: "json",
                ...E
            }),
            v1UsersFieldsList: (E,M={})=>this.request({
                path: "/api/v1/users/fields",
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            v1UsersPotatoList: (E,M={})=>this.request({
                path: "/api/v1/users/potato",
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            v1UsersRefCountList: (E,M={})=>this.request({
                path: "/api/v1/users/ref_count",
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            v1UsersUserDetail: (E,M={})=>this.request({
                path: `/api/v1/users/user/${E}`,
                method: "GET",
                format: "json",
                ...M
            }),
            v1UsersCreateCreate: (E,M={})=>this.request({
                path: "/api/v1/users/create",
                method: "POST",
                body: E,
                type: "application/json",
                format: "json",
                ...M
            }),
            v1LeaderboardDetail: (E,M={})=>this.request({
                path: `/api/v1/leaderboard/${E}`,
                method: "GET",
                format: "json",
                ...M
            }),
            v1OrdersAllList: (E,M={})=>this.request({
                path: "/api/v1/orders/all",
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            v1OrdersActiveList: (E,M={})=>this.request({
                path: "/api/v1/orders/active",
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            v1OrdersActiveDetail: (E,M,T={})=>this.request({
                path: `/api/v1/orders/active/${E}`,
                method: "GET",
                query: M,
                format: "json",
                ...T
            }),
            v1StorageConfigList: (E={})=>this.request({
                path: "/api/v1/storage/config",
                method: "GET",
                format: "json",
                ...E
            }),
            v1OrdersCreateCreate: (E,M={})=>this.request({
                path: "/api/v1/orders/create",
                method: "POST",
                body: E,
                type: "application/json",
                format: "json",
                ...M
            }),
            v1OrdersUpdateCreate: (E,M={})=>this.request({
                path: "/api/v1/orders/update",
                method: "POST",
                body: E,
                type: "application/json",
                format: "json",
                ...M
            }),
            v1OrdersCancelCreate: (E,M={})=>this.request({
                path: "/api/v1/orders/cancel",
                method: "POST",
                body: E,
                type: "application/json",
                format: "json",
                ...M
            }),
            v1OrdersDetail: (E,M={})=>this.request({
                path: `/api/v1/orders/${E}`,
                method: "GET",
                format: "json",
                ...M
            }),
            v1StorageMarketList: (E={})=>this.request({
                path: "/api/v1/storage/market",
                method: "GET",
                format: "json",
                ...E
            }),
            v1OrdersTradeCreate: (E,M={})=>this.request({
                path: "/api/v1/orders/trade",
                method: "POST",
                body: E,
                type: "application/json",
                ...M
            })
        })
    }
}
;
const authKey = "tonpotato-auth-token"
  , appFetch = async(...C)=>{
    const S = re$3()
      , E = localStorage.getItem(authKey)
      , [M,T] = C;
    return await fetch(M, {
        ...T,
        headers: {
            ...T == null ? void 0 : T.headers,
            "X-Telegram-InitData": S.initDataRaw || "",
            Authorization: E ? `Bearer ${E}` : ""
        }
    })
}
  , api = new Api$1({
    customFetch: appFetch
}).api
  , useConnectWallet = ()=>{
    const {open: C} = useTonConnectModal()
      , [S] = useTonConnectUI()
      , E = useTonAddress();
    return {
        connect: reactExports.useCallback(async()=>{
            E ? await S.disconnect() : C()
        }
        , [C, S, E]),
        isConnected: !!E
    }
}
;
var lib$2 = {}
  , nodes = {}
  , g$2 = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof global < "u" && global || {}
  , support = {
    searchParams: "URLSearchParams"in g$2,
    iterable: "Symbol"in g$2 && "iterator"in Symbol,
    blob: "FileReader"in g$2 && "Blob"in g$2 && function() {
        try {
            return new Blob,
            !0
        } catch {
            return !1
        }
    }(),
    formData: "FormData"in g$2,
    arrayBuffer: "ArrayBuffer"in g$2
};
function isDataView(C) {
    return C && DataView.prototype.isPrototypeOf(C)
}
if (support.arrayBuffer)
    var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
      , isArrayBufferView$1 = ArrayBuffer.isView || function(C) {
        return C && viewClasses.indexOf(Object.prototype.toString.call(C)) > -1
    }
    ;
function normalizeName(C) {
    if (typeof C != "string" && (C = String(C)),
    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(C) || C === "")
        throw new TypeError('Invalid character in header field name: "' + C + '"');
    return C.toLowerCase()
}
function normalizeValue$1(C) {
    return typeof C != "string" && (C = String(C)),
    C
}
function iteratorFor(C) {
    var S = {
        next: function() {
            var E = C.shift();
            return {
                done: E === void 0,
                value: E
            }
        }
    };
    return support.iterable && (S[Symbol.iterator] = function() {
        return S
    }
    ),
    S
}
function Headers(C) {
    this.map = {},
    C instanceof Headers ? C.forEach(function(S, E) {
        this.append(E, S)
    }, this) : Array.isArray(C) ? C.forEach(function(S) {
        if (S.length != 2)
            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + S.length);
        this.append(S[0], S[1])
    }, this) : C && Object.getOwnPropertyNames(C).forEach(function(S) {
        this.append(S, C[S])
    }, this)
}
Headers.prototype.append = function(C, S) {
    C = normalizeName(C),
    S = normalizeValue$1(S);
    var E = this.map[C];
    this.map[C] = E ? E + ", " + S : S
}
;
Headers.prototype.delete = function(C) {
    delete this.map[normalizeName(C)]
}
;
Headers.prototype.get = function(C) {
    return C = normalizeName(C),
    this.has(C) ? this.map[C] : null
}
;
Headers.prototype.has = function(C) {
    return this.map.hasOwnProperty(normalizeName(C))
}
;
Headers.prototype.set = function(C, S) {
    this.map[normalizeName(C)] = normalizeValue$1(S)
}
;
Headers.prototype.forEach = function(C, S) {
    for (var E in this.map)
        this.map.hasOwnProperty(E) && C.call(S, this.map[E], E, this)
}
;
Headers.prototype.keys = function() {
    var C = [];
    return this.forEach(function(S, E) {
        C.push(E)
    }),
    iteratorFor(C)
}
;
Headers.prototype.values = function() {
    var C = [];
    return this.forEach(function(S) {
        C.push(S)
    }),
    iteratorFor(C)
}
;
Headers.prototype.entries = function() {
    var C = [];
    return this.forEach(function(S, E) {
        C.push([E, S])
    }),
    iteratorFor(C)
}
;
support.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
function consumed(C) {
    if (!C._noBody) {
        if (C.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
        C.bodyUsed = !0
    }
}
function fileReaderReady(C) {
    return new Promise(function(S, E) {
        C.onload = function() {
            S(C.result)
        }
        ,
        C.onerror = function() {
            E(C.error)
        }
    }
    )
}
function readBlobAsArrayBuffer(C) {
    var S = new FileReader
      , E = fileReaderReady(S);
    return S.readAsArrayBuffer(C),
    E
}
function readBlobAsText(C) {
    var S = new FileReader
      , E = fileReaderReady(S)
      , M = /charset=([A-Za-z0-9_-]+)/.exec(C.type)
      , T = M ? M[1] : "utf-8";
    return S.readAsText(C, T),
    E
}
function readArrayBufferAsText(C) {
    for (var S = new Uint8Array(C), E = new Array(S.length), M = 0; M < S.length; M++)
        E[M] = String.fromCharCode(S[M]);
    return E.join("")
}
function bufferClone(C) {
    if (C.slice)
        return C.slice(0);
    var S = new Uint8Array(C.byteLength);
    return S.set(new Uint8Array(C)),
    S.buffer
}
function Body() {
    return this.bodyUsed = !1,
    this._initBody = function(C) {
        this.bodyUsed = this.bodyUsed,
        this._bodyInit = C,
        C ? typeof C == "string" ? this._bodyText = C : support.blob && Blob.prototype.isPrototypeOf(C) ? this._bodyBlob = C : support.formData && FormData.prototype.isPrototypeOf(C) ? this._bodyFormData = C : support.searchParams && URLSearchParams.prototype.isPrototypeOf(C) ? this._bodyText = C.toString() : support.arrayBuffer && support.blob && isDataView(C) ? (this._bodyArrayBuffer = bufferClone(C.buffer),
        this._bodyInit = new Blob([this._bodyArrayBuffer])) : support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(C) || isArrayBufferView$1(C)) ? this._bodyArrayBuffer = bufferClone(C) : this._bodyText = C = Object.prototype.toString.call(C) : (this._noBody = !0,
        this._bodyText = ""),
        this.headers.get("content-type") || (typeof C == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : support.searchParams && URLSearchParams.prototype.isPrototypeOf(C) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
    }
    ,
    support.blob && (this.blob = function() {
        var C = consumed(this);
        if (C)
            return C;
        if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]))
    }
    ),
    this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
            var C = consumed(this);
            return C || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
        } else {
            if (support.blob)
                return this.blob().then(readBlobAsArrayBuffer);
            throw new Error("could not read as ArrayBuffer")
        }
    }
    ,
    this.text = function() {
        var C = consumed(this);
        if (C)
            return C;
        if (this._bodyBlob)
            return readBlobAsText(this._bodyBlob);
        if (this._bodyArrayBuffer)
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText)
    }
    ,
    support.formData && (this.formData = function() {
        return this.text().then(decode)
    }
    ),
    this.json = function() {
        return this.text().then(JSON.parse)
    }
    ,
    this
}
var methods$1 = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(C) {
    var S = C.toUpperCase();
    return methods$1.indexOf(S) > -1 ? S : C
}
function Request(C, S) {
    if (!(this instanceof Request))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    S = S || {};
    var E = S.body;
    if (C instanceof Request) {
        if (C.bodyUsed)
            throw new TypeError("Already read");
        this.url = C.url,
        this.credentials = C.credentials,
        S.headers || (this.headers = new Headers(C.headers)),
        this.method = C.method,
        this.mode = C.mode,
        this.signal = C.signal,
        !E && C._bodyInit != null && (E = C._bodyInit,
        C.bodyUsed = !0)
    } else
        this.url = String(C);
    if (this.credentials = S.credentials || this.credentials || "same-origin",
    (S.headers || !this.headers) && (this.headers = new Headers(S.headers)),
    this.method = normalizeMethod(S.method || this.method || "GET"),
    this.mode = S.mode || this.mode || null,
    this.signal = S.signal || this.signal || function() {
        if ("AbortController"in g$2) {
            var $ = new AbortController;
            return $.signal
        }
    }(),
    this.referrer = null,
    (this.method === "GET" || this.method === "HEAD") && E)
        throw new TypeError("Body not allowed for GET or HEAD requests");
    if (this._initBody(E),
    (this.method === "GET" || this.method === "HEAD") && (S.cache === "no-store" || S.cache === "no-cache")) {
        var M = /([?&])_=[^&]*/;
        if (M.test(this.url))
            this.url = this.url.replace(M, "$1_=" + new Date().getTime());
        else {
            var T = /\?/;
            this.url += (T.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
        }
    }
}
Request.prototype.clone = function() {
    return new Request(this,{
        body: this._bodyInit
    })
}
;
function decode(C) {
    var S = new FormData;
    return C.trim().split("&").forEach(function(E) {
        if (E) {
            var M = E.split("=")
              , T = M.shift().replace(/\+/g, " ")
              , $ = M.join("=").replace(/\+/g, " ");
            S.append(decodeURIComponent(T), decodeURIComponent($))
        }
    }),
    S
}
function parseHeaders$1(C) {
    var S = new Headers
      , E = C.replace(/\r?\n[\t ]+/g, " ");
    return E.split("\r").map(function(M) {
        return M.indexOf(`
`) === 0 ? M.substr(1, M.length) : M
    }).forEach(function(M) {
        var T = M.split(":")
          , $ = T.shift().trim();
        if ($) {
            var B = T.join(":").trim();
            try {
                S.append($, B)
            } catch (O) {
                console.warn("Response " + O.message)
            }
        }
    }),
    S
}
Body.call(Request.prototype);
function Response$1(C, S) {
    if (!(this instanceof Response$1))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    if (S || (S = {}),
    this.type = "default",
    this.status = S.status === void 0 ? 200 : S.status,
    this.status < 200 || this.status > 599)
        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    this.ok = this.status >= 200 && this.status < 300,
    this.statusText = S.statusText === void 0 ? "" : "" + S.statusText,
    this.headers = new Headers(S.headers),
    this.url = S.url || "",
    this._initBody(C)
}
Body.call(Response$1.prototype);
Response$1.prototype.clone = function() {
    return new Response$1(this._bodyInit,{
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
    })
}
;
Response$1.error = function() {
    var C = new Response$1(null,{
        status: 200,
        statusText: ""
    });
    return C.ok = !1,
    C.status = 0,
    C.type = "error",
    C
}
;
var redirectStatuses = [301, 302, 303, 307, 308];
Response$1.redirect = function(C, S) {
    if (redirectStatuses.indexOf(S) === -1)
        throw new RangeError("Invalid status code");
    return new Response$1(null,{
        status: S,
        headers: {
            location: C
        }
    })
}
;
var DOMException$1 = g$2.DOMException;
try {
    new DOMException$1
} catch (C) {
    DOMException$1 = function(S, E) {
        this.message = S,
        this.name = E;
        var M = Error(S);
        this.stack = M.stack
    }
    ,
    DOMException$1.prototype = Object.create(Error.prototype),
    DOMException$1.prototype.constructor = DOMException$1
}
function fetch$1(C, S) {
    return new Promise(function(E, M) {
        var T = new Request(C,S);
        if (T.signal && T.signal.aborted)
            return M(new DOMException$1("Aborted","AbortError"));
        var $ = new XMLHttpRequest;
        function B() {
            $.abort()
        }
        $.onload = function() {
            var N = {
                statusText: $.statusText,
                headers: parseHeaders$1($.getAllResponseHeaders() || "")
            };
            T.url.indexOf("file://") === 0 && ($.status < 200 || $.status > 599) ? N.status = 200 : N.status = $.status,
            N.url = "responseURL"in $ ? $.responseURL : N.headers.get("X-Request-URL");
            var U = "response"in $ ? $.response : $.responseText;
            setTimeout(function() {
                E(new Response$1(U,N))
            }, 0)
        }
        ,
        $.onerror = function() {
            setTimeout(function() {
                M(new TypeError("Network request failed"))
            }, 0)
        }
        ,
        $.ontimeout = function() {
            setTimeout(function() {
                M(new TypeError("Network request timed out"))
            }, 0)
        }
        ,
        $.onabort = function() {
            setTimeout(function() {
                M(new DOMException$1("Aborted","AbortError"))
            }, 0)
        }
        ;
        function O(N) {
            try {
                return N === "" && g$2.location.href ? g$2.location.href : N
            } catch {
                return N
            }
        }
        if ($.open(T.method, O(T.url), !0),
        T.credentials === "include" ? $.withCredentials = !0 : T.credentials === "omit" && ($.withCredentials = !1),
        "responseType"in $ && (support.blob ? $.responseType = "blob" : support.arrayBuffer && ($.responseType = "arraybuffer")),
        S && typeof S.headers == "object" && !(S.headers instanceof Headers || g$2.Headers && S.headers instanceof g$2.Headers)) {
            var F = [];
            Object.getOwnPropertyNames(S.headers).forEach(function(N) {
                F.push(normalizeName(N)),
                $.setRequestHeader(N, normalizeValue$1(S.headers[N]))
            }),
            T.headers.forEach(function(N, U) {
                F.indexOf(U) === -1 && $.setRequestHeader(U, N)
            })
        } else
            T.headers.forEach(function(N, U) {
                $.setRequestHeader(U, N)
            });
        T.signal && (T.signal.addEventListener("abort", B),
        $.onreadystatechange = function() {
            $.readyState === 4 && T.signal.removeEventListener("abort", B)
        }
        ),
        $.send(typeof T._bodyInit > "u" ? null : T._bodyInit)
    }
    )
}
fetch$1.polyfill = !0;
g$2.fetch || (g$2.fetch = fetch$1,
g$2.Headers = Headers,
g$2.Request = Request,
g$2.Response = Response$1);
self.fetch.bind(self);
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(C, S, E, M) {
    function T($) {
        return $ instanceof E ? $ : new E(function(B) {
            B($)
        }
        )
    }
    return new (E || (E = Promise))(function($, B) {
        function O(U) {
            try {
                N(M.next(U))
            } catch (H) {
                B(H)
            }
        }
        function F(U) {
            try {
                N(M.throw(U))
            } catch (H) {
                B(H)
            }
        }
        function N(U) {
            U.done ? $(U.value) : T(U.value).then(O, F)
        }
        N((M = M.apply(C, S || [])).next())
    }
    )
}
;
Object.defineProperty(nodes, "__esModule", {
    value: !0
});
nodes.Nodes = void 0;
class Nodes {
    constructor() {
        this.nodeIndex = -1,
        this.committee = new Set,
        this.topology = [],
        this.initTime = 0
    }
    init(S) {
        return __awaiter$1(this, void 0, void 0, function*() {
            this.nodeIndex = -1,
            this.committee.clear(),
            this.topology = [],
            this.initTime = Date.now();
            let E = [];
            try {
                E = yield(yield fetch(S)).json()
            } catch (M) {
                throw new Error(`exception in fetch(${S}): ${M}`)
            }
            for (const M of E)
                M.Healthy === "1" && this.topology.push(M);
            if (this.topology.length === 0)
                throw new Error(`no healthy nodes in ${S}`)
        })
    }
    getHealthyFor(S) {
        var E;
        const M = [];
        for (const T of this.topology)
            T.Weight > 0 && (!((E = T.Mngr) === null || E === void 0) && E.health[S]) && M.push(T);
        return M
    }
}
nodes.Nodes = Nodes;
const name$1 = "@orbs-network/ton-access"
  , version$5 = "2.3.3"
  , description = "Unthrottled anonymous RPC access to TON blockchain via a robust decentralized network"
  , source = "lib/index.js"
  , main$1 = "lib/index.js"
  , types$1 = "lib/index.d.ts"
  , files$1 = ["lib/**/*"]
  , scripts$1 = {
    test: "env mocha -r ts-node/register test/**/*.ts",
    "test:v2": "env mocha -r ts-node/register test/ton-v2.ts",
    "test:v4": "env mocha -r ts-node/register test/ton-v4.ts",
    cleanup: "rimraf ./lib",
    "build:web:reg": "esbuild ./lib/web.js --bundle  --sourcemap --target=es2015 --outfile=./dist/index.js",
    "build:web:min": "esbuild ./lib/web.js --bundle  --minify    --target=es2015 --outfile=./dist/index.min.js",
    "build:web": "rimraf ./dist && npm run build:web:reg && npm run build:web:min",
    build: "npm run lint && rimraf ./lib && tsc && npm run build:web",
    format: 'prettier --write "src/**/*.ts"',
    lint: "tslint -p tsconfig.json",
    prepare: "npm run build",
    prepublishOnly: "npm test && npm run lint",
    preversion: "npm run lint",
    version: "npm run format && git add -A src",
    postversion: "git push && git push --tags"
}
  , repository$1 = {
    type: "git",
    url: "git+https://github.com/orbs-network/ton-access.git"
}
  , author$1 = "yuval@orbs.com"
  , license$1 = "MIT"
  , bugs = {
    url: "https://github.com/orbs-network/ton-access/issues"
}
  , homepage = "https://github.com/orbs-network/ton-access#readme"
  , dependencies$1 = {
    "isomorphic-fetch": "^3.0.0"
}
  , devDependencies$1 = {
    "@types/bn.js": "^5.1.1",
    "@types/chai": "^4.3.4",
    "@types/isomorphic-fetch": "^0.0.36",
    "@types/mocha": "^10.0.0",
    buffer: "^6.0.3",
    chai: "^4.3.7",
    esbuild: "^0.15.14",
    mocha: "^10.1.0",
    prettier: "^2.7.1",
    rimraf: "^3.0.2",
    ton: "^12.1.3",
    "ton-lite-client": "npm:@truecarry/ton-lite-client@^1.6.1",
    tonweb: "^0.0.58",
    "ts-node": "^10.9.1",
    tslib: "^2.4.0",
    tslint: "^6.1.3",
    "tslint-config-prettier": "^1.18.0"
}
  , require$$1$4 = {
    name: name$1,
    version: version$5,
    description,
    source,
    main: main$1,
    types: types$1,
    files: files$1,
    scripts: scripts$1,
    repository: repository$1,
    author: author$1,
    license: license$1,
    bugs,
    homepage,
    dependencies: dependencies$1,
    devDependencies: devDependencies$1
};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(C, S, E, M) {
    function T($) {
        return $ instanceof E ? $ : new E(function(B) {
            B($)
        }
        )
    }
    return new (E || (E = Promise))(function($, B) {
        function O(U) {
            try {
                N(M.next(U))
            } catch (H) {
                B(H)
            }
        }
        function F(U) {
            try {
                N(M.throw(U))
            } catch (H) {
                B(H)
            }
        }
        function N(U) {
            U.done ? $(U.value) : T(U.value).then(O, F)
        }
        N((M = M.apply(C, S || [])).next())
    }
    )
}
;
Object.defineProperty(lib$2, "__esModule", {
    value: !0
});
lib$2.getHttpV4Endpoint = lib$2.getHttpV4Endpoints = getHttpEndpoint_1 = lib$2.getHttpEndpoint = lib$2.getHttpEndpoints = lib$2.Access = void 0;
const nodes_1 = nodes;
class Access {
    constructor() {
        this.host = "ton.access.orbs.network",
        this.urlVersion = 1,
        this.nodes = new nodes_1.Nodes
    }
    init() {
        return __awaiter(this, void 0, void 0, function*() {
            const S = require$$1$4;
            yield this.nodes.init(`https://${this.host}/mngr/nodes?npm_version=${S.version}`)
        })
    }
    makeProtonet(S, E) {
        let M = "";
        switch (S) {
        case "toncenter-api-v2":
            M += "v2-";
            break;
        case "ton-api-v4":
            M += "v4-";
            break
        }
        return M += E,
        M
    }
    weightedRandom(S) {
        let E = 0;
        for (const $ of S)
            E += $.Weight;
        const M = Math.floor(Math.random() * E);
        let T = 0;
        for (const $ of S) {
            if (M >= T && M < T + $.Weight)
                return $;
            T += $.Weight
        }
    }
    buildUrls(S, E, M, T) {
        M || (M = ""),
        E || (E = "toncenter-api-v2"),
        S || (S = "mainnet"),
        M.length && (M = M.replace(/^\/+/, ""));
        const $ = []
          , B = this.makeProtonet(E, S);
        let O = this.nodes.getHealthyFor(B);
        if (!(O != null && O.length))
            throw new Error(`no healthy nodes for ${B}`);
        if (T && O.length) {
            const F = this.weightedRandom(O);
            if (F)
                O = [F];
            else
                throw new Error("weightedRandom return empty")
        }
        for (const F of O) {
            let N = `https://${this.host}/${F.NodeId}/${this.urlVersion}/${S}/${E}`;
            M.length && (N += `/${M}`),
            $.push(N)
        }
        return $
    }
}
lib$2.Access = Access;
function getEndpoints(C, S, E, M) {
    return __awaiter(this, void 0, void 0, function*() {
        const T = new Access;
        return yield T.init(),
        T.buildUrls(C, S, E, M)
    })
}
function getHttpEndpoints(C, S) {
    return __awaiter(this, void 0, void 0, function*() {
        const E = C != null && C.network ? C.network : "mainnet";
        let M = "jsonRPC";
        return (C == null ? void 0 : C.protocol) === "rest" && (M = ""),
        yield getEndpoints(E, "toncenter-api-v2", M, S)
    })
}
lib$2.getHttpEndpoints = getHttpEndpoints;
function getHttpEndpoint(C) {
    return __awaiter(this, void 0, void 0, function*() {
        return (yield getHttpEndpoints(C, !0))[0]
    })
}
var getHttpEndpoint_1 = lib$2.getHttpEndpoint = getHttpEndpoint;
function getHttpV4Endpoints(C, S) {
    return __awaiter(this, void 0, void 0, function*() {
        const E = C != null && C.network ? C.network : "mainnet";
        if ((C == null ? void 0 : C.protocol) === "json-rpc")
            throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
        return yield getEndpoints(E, "ton-api-v4", "", S)
    })
}
lib$2.getHttpV4Endpoints = getHttpV4Endpoints;
function getHttpV4Endpoint(C) {
    return __awaiter(this, void 0, void 0, function*() {
        return (yield getHttpV4Endpoints(C, !0))[0]
    })
}
lib$2.getHttpV4Endpoint = getHttpV4Endpoint;
var dist$2 = {}
  , HttpApi$1 = {}
  , TonCache = {};
Object.defineProperty(TonCache, "__esModule", {
    value: !0
});
TonCache.InMemoryCache = void 0;
class InMemoryCache {
    constructor() {
        this.cache = new Map,
        this.set = async(S,E,M)=>{
            M !== null ? this.cache.set(S + "$$" + E, M) : this.cache.delete(S + "$$" + E)
        }
        ,
        this.get = async(S,E)=>{
            let M = this.cache.get(S + "$$" + E);
            return M !== void 0 ? M : null
        }
    }
}
TonCache.InMemoryCache = InMemoryCache;
var DataLoader = function() {
    function C(E, M) {
        if (typeof E != "function")
            throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + E + "."));
        this._batchLoadFn = E,
        this._maxBatchSize = getValidMaxBatchSize(M),
        this._batchScheduleFn = getValidBatchScheduleFn(M),
        this._cacheKeyFn = getValidCacheKeyFn(M),
        this._cacheMap = getValidCacheMap(M),
        this._batch = null,
        this.name = getValidName(M)
    }
    var S = C.prototype;
    return S.load = function(M) {
        if (M == null)
            throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(M) + "."));
        var T = getCurrentBatch(this)
          , $ = this._cacheMap
          , B = this._cacheKeyFn(M);
        if ($) {
            var O = $.get(B);
            if (O) {
                var F = T.cacheHits || (T.cacheHits = []);
                return new Promise(function(U) {
                    F.push(function() {
                        U(O)
                    })
                }
                )
            }
        }
        T.keys.push(M);
        var N = new Promise(function(U, H) {
            T.callbacks.push({
                resolve: U,
                reject: H
            })
        }
        );
        return $ && $.set(B, N),
        N
    }
    ,
    S.loadMany = function(M) {
        if (!isArrayLike$1(M))
            throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + M + "."));
        for (var T = [], $ = 0; $ < M.length; $++)
            T.push(this.load(M[$]).catch(function(B) {
                return B
            }));
        return Promise.all(T)
    }
    ,
    S.clear = function(M) {
        var T = this._cacheMap;
        if (T) {
            var $ = this._cacheKeyFn(M);
            T.delete($)
        }
        return this
    }
    ,
    S.clearAll = function() {
        var M = this._cacheMap;
        return M && M.clear(),
        this
    }
    ,
    S.prime = function(M, T) {
        var $ = this._cacheMap;
        if ($) {
            var B = this._cacheKeyFn(M);
            if ($.get(B) === void 0) {
                var O;
                T instanceof Error ? (O = Promise.reject(T),
                O.catch(function() {})) : O = Promise.resolve(T),
                $.set(B, O)
            }
        }
        return this
    }
    ,
    C
}(), enqueuePostPromiseJob = typeof process$1 == "object" && typeof process$1.nextTick == "function" ? function(C) {
    resolvedPromise || (resolvedPromise = Promise.resolve()),
    resolvedPromise.then(function() {
        process$1.nextTick(C)
    })
}
: typeof setImmediate == "function" ? function(C) {
    setImmediate(C)
}
: function(C) {
    setTimeout(C)
}
, resolvedPromise;
function getCurrentBatch(C) {
    var S = C._batch;
    if (S !== null && !S.hasDispatched && S.keys.length < C._maxBatchSize)
        return S;
    var E = {
        hasDispatched: !1,
        keys: [],
        callbacks: []
    };
    return C._batch = E,
    C._batchScheduleFn(function() {
        dispatchBatch(C, E)
    }),
    E
}
function dispatchBatch(C, S) {
    if (S.hasDispatched = !0,
    S.keys.length === 0) {
        resolveCacheHits(S);
        return
    }
    var E;
    try {
        E = C._batchLoadFn(S.keys)
    } catch (M) {
        return failedDispatch(C, S, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(M) + ".")))
    }
    if (!E || typeof E.then != "function")
        return failedDispatch(C, S, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(E) + ".")));
    E.then(function(M) {
        if (!isArrayLike$1(M))
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(M) + "."));
        if (M.length !== S.keys.length)
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + (`

Keys:
` + String(S.keys)) + (`

Values:
` + String(M)));
        resolveCacheHits(S);
        for (var T = 0; T < S.callbacks.length; T++) {
            var $ = M[T];
            $ instanceof Error ? S.callbacks[T].reject($) : S.callbacks[T].resolve($)
        }
    }).catch(function(M) {
        failedDispatch(C, S, M)
    })
}
function failedDispatch(C, S, E) {
    resolveCacheHits(S);
    for (var M = 0; M < S.keys.length; M++)
        C.clear(S.keys[M]),
        S.callbacks[M].reject(E)
}
function resolveCacheHits(C) {
    if (C.cacheHits)
        for (var S = 0; S < C.cacheHits.length; S++)
            C.cacheHits[S]()
}
function getValidMaxBatchSize(C) {
    var S = !C || C.batch !== !1;
    if (!S)
        return 1;
    var E = C && C.maxBatchSize;
    if (E === void 0)
        return 1 / 0;
    if (typeof E != "number" || E < 1)
        throw new TypeError("maxBatchSize must be a positive number: " + E);
    return E
}
function getValidBatchScheduleFn(C) {
    var S = C && C.batchScheduleFn;
    if (S === void 0)
        return enqueuePostPromiseJob;
    if (typeof S != "function")
        throw new TypeError("batchScheduleFn must be a function: " + S);
    return S
}
function getValidCacheKeyFn(C) {
    var S = C && C.cacheKeyFn;
    if (S === void 0)
        return function(E) {
            return E
        }
        ;
    if (typeof S != "function")
        throw new TypeError("cacheKeyFn must be a function: " + S);
    return S
}
function getValidCacheMap(C) {
    var S = !C || C.cache !== !1;
    if (!S)
        return null;
    var E = C && C.cacheMap;
    if (E === void 0)
        return new Map;
    if (E !== null) {
        var M = ["get", "set", "delete", "clear"]
          , T = M.filter(function($) {
            return E && typeof E[$] != "function"
        });
        if (T.length !== 0)
            throw new TypeError("Custom cacheMap missing methods: " + T.join(", "))
    }
    return E
}
function getValidName(C) {
    return C && C.name ? C.name : null
}
function isArrayLike$1(C) {
    return typeof C == "object" && C !== null && typeof C.length == "number" && (C.length === 0 || C.length > 0 && Object.prototype.hasOwnProperty.call(C, C.length - 1))
}
var dataloader = DataLoader;
function bind(C, S) {
    return function() {
        return C.apply(S, arguments)
    }
}
const {toString} = Object.prototype
  , {getPrototypeOf} = Object
  , kindOf = (C=>S=>{
    const E = toString.call(S);
    return C[E] || (C[E] = E.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , kindOfTest = C=>(C = C.toLowerCase(),
S=>kindOf(S) === C)
  , typeOfTest = C=>S=>typeof S === C
  , {isArray: isArray$1} = Array
  , isUndefined$2 = typeOfTest("undefined");
function isBuffer(C) {
    return C !== null && !isUndefined$2(C) && C.constructor !== null && !isUndefined$2(C.constructor) && isFunction$2(C.constructor.isBuffer) && C.constructor.isBuffer(C)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(C) {
    let S;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? S = ArrayBuffer.isView(C) : S = C && C.buffer && isArrayBuffer(C.buffer),
    S
}
const isString$2 = typeOfTest("string")
  , isFunction$2 = typeOfTest("function")
  , isNumber$1 = typeOfTest("number")
  , isObject$3 = C=>C !== null && typeof C == "object"
  , isBoolean$1 = C=>C === !0 || C === !1
  , isPlainObject$2 = C=>{
    if (kindOf(C) !== "object")
        return !1;
    const S = getPrototypeOf(C);
    return (S === null || S === Object.prototype || Object.getPrototypeOf(S) === null) && !(Symbol.toStringTag in C) && !(Symbol.iterator in C)
}
  , isDate$1 = kindOfTest("Date")
  , isFile = kindOfTest("File")
  , isBlob = kindOfTest("Blob")
  , isFileList = kindOfTest("FileList")
  , isStream = C=>isObject$3(C) && isFunction$2(C.pipe)
  , isFormData = C=>{
    let S;
    return C && (typeof FormData == "function" && C instanceof FormData || isFunction$2(C.append) && ((S = kindOf(C)) === "formdata" || S === "object" && isFunction$2(C.toString) && C.toString() === "[object FormData]"))
}
  , isURLSearchParams = kindOfTest("URLSearchParams")
  , trim$3 = C=>C.trim ? C.trim() : C.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(C, S, {allOwnKeys: E=!1}={}) {
    if (C === null || typeof C > "u")
        return;
    let M, T;
    if (typeof C != "object" && (C = [C]),
    isArray$1(C))
        for (M = 0,
        T = C.length; M < T; M++)
            S.call(null, C[M], M, C);
    else {
        const $ = E ? Object.getOwnPropertyNames(C) : Object.keys(C)
          , B = $.length;
        let O;
        for (M = 0; M < B; M++)
            O = $[M],
            S.call(null, C[O], O, C)
    }
}
function findKey(C, S) {
    S = S.toLowerCase();
    const E = Object.keys(C);
    let M = E.length, T;
    for (; M-- > 0; )
        if (T = E[M],
        S === T.toLowerCase())
            return T;
    return null
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal
  , isContextDefined = C=>!isUndefined$2(C) && C !== _global;
function merge$4() {
    const {caseless: C} = isContextDefined(this) && this || {}
      , S = {}
      , E = (M,T)=>{
        const $ = C && findKey(S, T) || T;
        isPlainObject$2(S[$]) && isPlainObject$2(M) ? S[$] = merge$4(S[$], M) : isPlainObject$2(M) ? S[$] = merge$4({}, M) : isArray$1(M) ? S[$] = M.slice() : S[$] = M
    }
    ;
    for (let M = 0, T = arguments.length; M < T; M++)
        arguments[M] && forEach(arguments[M], E);
    return S
}
const extend = (C,S,E,{allOwnKeys: M}={})=>(forEach(S, (T,$)=>{
    E && isFunction$2(T) ? C[$] = bind(T, E) : C[$] = T
}
, {
    allOwnKeys: M
}),
C)
  , stripBOM = C=>(C.charCodeAt(0) === 65279 && (C = C.slice(1)),
C)
  , inherits = (C,S,E,M)=>{
    C.prototype = Object.create(S.prototype, M),
    C.prototype.constructor = C,
    Object.defineProperty(C, "super", {
        value: S.prototype
    }),
    E && Object.assign(C.prototype, E)
}
  , toFlatObject = (C,S,E,M)=>{
    let T, $, B;
    const O = {};
    if (S = S || {},
    C == null)
        return S;
    do {
        for (T = Object.getOwnPropertyNames(C),
        $ = T.length; $-- > 0; )
            B = T[$],
            (!M || M(B, C, S)) && !O[B] && (S[B] = C[B],
            O[B] = !0);
        C = E !== !1 && getPrototypeOf(C)
    } while (C && (!E || E(C, S)) && C !== Object.prototype);
    return S
}
  , endsWith = (C,S,E)=>{
    C = String(C),
    (E === void 0 || E > C.length) && (E = C.length),
    E -= S.length;
    const M = C.indexOf(S, E);
    return M !== -1 && M === E
}
  , toArray = C=>{
    if (!C)
        return null;
    if (isArray$1(C))
        return C;
    let S = C.length;
    if (!isNumber$1(S))
        return null;
    const E = new Array(S);
    for (; S-- > 0; )
        E[S] = C[S];
    return E
}
  , isTypedArray = (C=>S=>C && S instanceof C)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array))
  , forEachEntry = (C,S)=>{
    const M = (C && C[Symbol.iterator]).call(C);
    let T;
    for (; (T = M.next()) && !T.done; ) {
        const $ = T.value;
        S.call(C, $[0], $[1])
    }
}
  , matchAll = (C,S)=>{
    let E;
    const M = [];
    for (; (E = C.exec(S)) !== null; )
        M.push(E);
    return M
}
  , isHTMLForm = kindOfTest("HTMLFormElement")
  , toCamelCase = C=>C.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(E, M, T) {
    return M.toUpperCase() + T
})
  , hasOwnProperty$1 = (({hasOwnProperty: C})=>(S,E)=>C.call(S, E))(Object.prototype)
  , isRegExp = kindOfTest("RegExp")
  , reduceDescriptors = (C,S)=>{
    const E = Object.getOwnPropertyDescriptors(C)
      , M = {};
    forEach(E, (T,$)=>{
        let B;
        (B = S(T, $, C)) !== !1 && (M[$] = B || T)
    }
    ),
    Object.defineProperties(C, M)
}
  , freezeMethods = C=>{
    reduceDescriptors(C, (S,E)=>{
        if (isFunction$2(C) && ["arguments", "caller", "callee"].indexOf(E) !== -1)
            return !1;
        const M = C[E];
        if (isFunction$2(M)) {
            if (S.enumerable = !1,
            "writable"in S) {
                S.writable = !1;
                return
            }
            S.set || (S.set = ()=>{
                throw Error("Can not rewrite read-only method '" + E + "'")
            }
            )
        }
    }
    )
}
  , toObjectSet = (C,S)=>{
    const E = {}
      , M = T=>{
        T.forEach($=>{
            E[$] = !0
        }
        )
    }
    ;
    return isArray$1(C) ? M(C) : M(String(C).split(S)),
    E
}
  , noop$3 = ()=>{}
  , toFiniteNumber = (C,S)=>(C = +C,
Number.isFinite(C) ? C : S)
  , ALPHA = "abcdefghijklmnopqrstuvwxyz"
  , DIGIT = "0123456789"
  , ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}
  , generateString = (C=16,S=ALPHABET.ALPHA_DIGIT)=>{
    let E = "";
    const {length: M} = S;
    for (; C--; )
        E += S[Math.random() * M | 0];
    return E
}
;
function isSpecCompliantForm(C) {
    return !!(C && isFunction$2(C.append) && C[Symbol.toStringTag] === "FormData" && C[Symbol.iterator])
}
const toJSONObject = C=>{
    const S = new Array(10)
      , E = (M,T)=>{
        if (isObject$3(M)) {
            if (S.indexOf(M) >= 0)
                return;
            if (!("toJSON"in M)) {
                S[T] = M;
                const $ = isArray$1(M) ? [] : {};
                return forEach(M, (B,O)=>{
                    const F = E(B, T + 1);
                    !isUndefined$2(F) && ($[O] = F)
                }
                ),
                S[T] = void 0,
                $
            }
        }
        return M
    }
    ;
    return E(C, 0)
}
  , isAsyncFn = kindOfTest("AsyncFunction")
  , isThenable = C=>C && (isObject$3(C) || isFunction$2(C)) && isFunction$2(C.then) && isFunction$2(C.catch);
var utils$1$1 = {
    isArray: isArray$1,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$2,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject$3,
    isPlainObject: isPlainObject$2,
    isUndefined: isUndefined$2,
    isDate: isDate$1,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$2,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge$4,
    extend,
    trim: trim$3,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty$1,
    hasOwnProp: hasOwnProperty$1,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$3,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};
function AxiosError(C, S, E, M, T) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = C,
    this.name = "AxiosError",
    S && (this.code = S),
    E && (this.config = E),
    M && (this.request = M),
    T && (this.response = T)
}
utils$1$1.inherits(AxiosError, Error, {
    toJSON: function C() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: utils$1$1.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const prototype$1 = AxiosError.prototype
  , descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(C=>{
    descriptors[C] = {
        value: C
    }
}
);
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
    value: !0
});
AxiosError.from = (C,S,E,M,T,$)=>{
    const B = Object.create(prototype$1);
    return utils$1$1.toFlatObject(C, B, function(F) {
        return F !== Error.prototype
    }, O=>O !== "isAxiosError"),
    AxiosError.call(B, C.message, S, E, M, T),
    B.cause = C,
    B.name = C.name,
    $ && Object.assign(B, $),
    B
}
;
var httpAdapter = null;
function isVisitable(C) {
    return utils$1$1.isPlainObject(C) || utils$1$1.isArray(C)
}
function removeBrackets(C) {
    return utils$1$1.endsWith(C, "[]") ? C.slice(0, -2) : C
}
function renderKey(C, S, E) {
    return C ? C.concat(S).map(function(T, $) {
        return T = removeBrackets(T),
        !E && $ ? "[" + T + "]" : T
    }).join(E ? "." : "") : S
}
function isFlatArray(C) {
    return utils$1$1.isArray(C) && !C.some(isVisitable)
}
const predicates = utils$1$1.toFlatObject(utils$1$1, {}, null, function C(S) {
    return /^is[A-Z]/.test(S)
});
function toFormData(C, S, E) {
    if (!utils$1$1.isObject(C))
        throw new TypeError("target must be an object");
    S = S || new FormData,
    E = utils$1$1.toFlatObject(E, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(oe, ae) {
        return !utils$1$1.isUndefined(ae[oe])
    });
    const M = E.metaTokens
      , T = E.visitor || U
      , $ = E.dots
      , B = E.indexes
      , F = (E.Blob || typeof Blob < "u" && Blob) && utils$1$1.isSpecCompliantForm(S);
    if (!utils$1$1.isFunction(T))
        throw new TypeError("visitor must be a function");
    function N(ie) {
        if (ie === null)
            return "";
        if (utils$1$1.isDate(ie))
            return ie.toISOString();
        if (!F && utils$1$1.isBlob(ie))
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        return utils$1$1.isArrayBuffer(ie) || utils$1$1.isTypedArray(ie) ? F && typeof Blob == "function" ? new Blob([ie]) : Buffer.from(ie) : ie
    }
    function U(ie, oe, ae) {
        let se = ie;
        if (ie && !ae && typeof ie == "object") {
            if (utils$1$1.endsWith(oe, "{}"))
                oe = M ? oe : oe.slice(0, -2),
                ie = JSON.stringify(ie);
            else if (utils$1$1.isArray(ie) && isFlatArray(ie) || (utils$1$1.isFileList(ie) || utils$1$1.endsWith(oe, "[]")) && (se = utils$1$1.toArray(ie)))
                return oe = removeBrackets(oe),
                se.forEach(function(de, fe) {
                    !(utils$1$1.isUndefined(de) || de === null) && S.append(B === !0 ? renderKey([oe], fe, $) : B === null ? oe : oe + "[]", N(de))
                }),
                !1
        }
        return isVisitable(ie) ? !0 : (S.append(renderKey(ae, oe, $), N(ie)),
        !1)
    }
    const H = []
      , Z = Object.assign(predicates, {
        defaultVisitor: U,
        convertValue: N,
        isVisitable
    });
    function J(ie, oe) {
        if (!utils$1$1.isUndefined(ie)) {
            if (H.indexOf(ie) !== -1)
                throw Error("Circular reference detected in " + oe.join("."));
            H.push(ie),
            utils$1$1.forEach(ie, function(se, le) {
                (!(utils$1$1.isUndefined(se) || se === null) && T.call(S, se, utils$1$1.isString(le) ? le.trim() : le, oe, Z)) === !0 && J(se, oe ? oe.concat(le) : [le])
            }),
            H.pop()
        }
    }
    if (!utils$1$1.isObject(C))
        throw new TypeError("data must be an object");
    return J(C),
    S
}
function encode$1(C) {
    const S = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(C).replace(/[!'()~]|%20|%00/g, function(M) {
        return S[M]
    })
}
function AxiosURLSearchParams(C, S) {
    this._pairs = [],
    C && toFormData(C, this, S)
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function C(S, E) {
    this._pairs.push([S, E])
}
;
prototype.toString = function C(S) {
    const E = S ? function(M) {
        return S.call(this, M, encode$1)
    }
    : encode$1;
    return this._pairs.map(function(T) {
        return E(T[0]) + "=" + E(T[1])
    }, "").join("&")
}
;
function encode(C) {
    return encodeURIComponent(C).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(C, S, E) {
    if (!S)
        return C;
    const M = E && E.encode || encode
      , T = E && E.serialize;
    let $;
    if (T ? $ = T(S, E) : $ = utils$1$1.isURLSearchParams(S) ? S.toString() : new AxiosURLSearchParams(S,E).toString(M),
    $) {
        const B = C.indexOf("#");
        B !== -1 && (C = C.slice(0, B)),
        C += (C.indexOf("?") === -1 ? "?" : "&") + $
    }
    return C
}
class InterceptorManager {
    constructor() {
        this.handlers = []
    }
    use(S, E, M) {
        return this.handlers.push({
            fulfilled: S,
            rejected: E,
            synchronous: M ? M.synchronous : !1,
            runWhen: M ? M.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(S) {
        this.handlers[S] && (this.handlers[S] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(S) {
        utils$1$1.forEach(this.handlers, function(M) {
            M !== null && S(M)
        })
    }
}
var InterceptorManager$1 = InterceptorManager
  , transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams
  , FormData$1 = typeof FormData < "u" ? FormData : null
  , Blob$1 = typeof Blob < "u" ? Blob : null
  , platform$1 = {
    isBrowser: !0,
    classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window < "u" && typeof document < "u"
  , hasStandardBrowserEnv = (C=>hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(C) < 0)(typeof navigator < "u" && navigator.product)
  , hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
var utils$2 = Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv
})
  , platform = {
    ...utils$2,
    ...platform$1
};
function toURLEncodedForm(C, S) {
    return toFormData(C, new platform.classes.URLSearchParams, Object.assign({
        visitor: function(E, M, T, $) {
            return platform.isNode && utils$1$1.isBuffer(E) ? (this.append(M, E.toString("base64")),
            !1) : $.defaultVisitor.apply(this, arguments)
        }
    }, S))
}
function parsePropPath(C) {
    return utils$1$1.matchAll(/\w+|\[(\w*)]/g, C).map(S=>S[0] === "[]" ? "" : S[1] || S[0])
}
function arrayToObject(C) {
    const S = {}
      , E = Object.keys(C);
    let M;
    const T = E.length;
    let $;
    for (M = 0; M < T; M++)
        $ = E[M],
        S[$] = C[$];
    return S
}
function formDataToJSON(C) {
    function S(E, M, T, $) {
        let B = E[$++];
        if (B === "__proto__")
            return !0;
        const O = Number.isFinite(+B)
          , F = $ >= E.length;
        return B = !B && utils$1$1.isArray(T) ? T.length : B,
        F ? (utils$1$1.hasOwnProp(T, B) ? T[B] = [T[B], M] : T[B] = M,
        !O) : ((!T[B] || !utils$1$1.isObject(T[B])) && (T[B] = []),
        S(E, M, T[B], $) && utils$1$1.isArray(T[B]) && (T[B] = arrayToObject(T[B])),
        !O)
    }
    if (utils$1$1.isFormData(C) && utils$1$1.isFunction(C.entries)) {
        const E = {};
        return utils$1$1.forEachEntry(C, (M,T)=>{
            S(parsePropPath(M), T, E, 0)
        }
        ),
        E
    }
    return null
}
function stringifySafely(C, S, E) {
    if (utils$1$1.isString(C))
        try {
            return (S || JSON.parse)(C),
            utils$1$1.trim(C)
        } catch (M) {
            if (M.name !== "SyntaxError")
                throw M
        }
    return (E || JSON.stringify)(C)
}
const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http"],
    transformRequest: [function C(S, E) {
        const M = E.getContentType() || ""
          , T = M.indexOf("application/json") > -1
          , $ = utils$1$1.isObject(S);
        if ($ && utils$1$1.isHTMLForm(S) && (S = new FormData(S)),
        utils$1$1.isFormData(S))
            return T ? JSON.stringify(formDataToJSON(S)) : S;
        if (utils$1$1.isArrayBuffer(S) || utils$1$1.isBuffer(S) || utils$1$1.isStream(S) || utils$1$1.isFile(S) || utils$1$1.isBlob(S))
            return S;
        if (utils$1$1.isArrayBufferView(S))
            return S.buffer;
        if (utils$1$1.isURLSearchParams(S))
            return E.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            S.toString();
        let O;
        if ($) {
            if (M.indexOf("application/x-www-form-urlencoded") > -1)
                return toURLEncodedForm(S, this.formSerializer).toString();
            if ((O = utils$1$1.isFileList(S)) || M.indexOf("multipart/form-data") > -1) {
                const F = this.env && this.env.FormData;
                return toFormData(O ? {
                    "files[]": S
                } : S, F && new F, this.formSerializer)
            }
        }
        return $ || T ? (E.setContentType("application/json", !1),
        stringifySafely(S)) : S
    }
    ],
    transformResponse: [function C(S) {
        const E = this.transitional || defaults.transitional
          , M = E && E.forcedJSONParsing
          , T = this.responseType === "json";
        if (S && utils$1$1.isString(S) && (M && !this.responseType || T)) {
            const B = !(E && E.silentJSONParsing) && T;
            try {
                return JSON.parse(S)
            } catch (O) {
                if (B)
                    throw O.name === "SyntaxError" ? AxiosError.from(O, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : O
            }
        }
        return S
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
    },
    validateStatus: function C(S) {
        return S >= 200 && S < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils$1$1.forEach(["delete", "get", "head", "post", "put", "patch"], C=>{
    defaults.headers[C] = {}
}
);
var defaults$1 = defaults;
const ignoreDuplicateOf = utils$1$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var parseHeaders = C=>{
    const S = {};
    let E, M, T;
    return C && C.split(`
`).forEach(function(B) {
        T = B.indexOf(":"),
        E = B.substring(0, T).trim().toLowerCase(),
        M = B.substring(T + 1).trim(),
        !(!E || S[E] && ignoreDuplicateOf[E]) && (E === "set-cookie" ? S[E] ? S[E].push(M) : S[E] = [M] : S[E] = S[E] ? S[E] + ", " + M : M)
    }),
    S
}
;
const $internals = Symbol("internals");
function normalizeHeader(C) {
    return C && String(C).trim().toLowerCase()
}
function normalizeValue(C) {
    return C === !1 || C == null ? C : utils$1$1.isArray(C) ? C.map(normalizeValue) : String(C)
}
function parseTokens(C) {
    const S = Object.create(null)
      , E = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let M;
    for (; M = E.exec(C); )
        S[M[1]] = M[2];
    return S
}
const isValidHeaderName = C=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(C.trim());
function matchHeaderValue(C, S, E, M, T) {
    if (utils$1$1.isFunction(M))
        return M.call(this, S, E);
    if (T && (S = E),
    !!utils$1$1.isString(S)) {
        if (utils$1$1.isString(M))
            return S.indexOf(M) !== -1;
        if (utils$1$1.isRegExp(M))
            return M.test(S)
    }
}
function formatHeader(C) {
    return C.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (S,E,M)=>E.toUpperCase() + M)
}
function buildAccessors(C, S) {
    const E = utils$1$1.toCamelCase(" " + S);
    ["get", "set", "has"].forEach(M=>{
        Object.defineProperty(C, M + E, {
            value: function(T, $, B) {
                return this[M].call(this, S, T, $, B)
            },
            configurable: !0
        })
    }
    )
}
class AxiosHeaders {
    constructor(S) {
        S && this.set(S)
    }
    set(S, E, M) {
        const T = this;
        function $(O, F, N) {
            const U = normalizeHeader(F);
            if (!U)
                throw new Error("header name must be a non-empty string");
            const H = utils$1$1.findKey(T, U);
            (!H || T[H] === void 0 || N === !0 || N === void 0 && T[H] !== !1) && (T[H || F] = normalizeValue(O))
        }
        const B = (O,F)=>utils$1$1.forEach(O, (N,U)=>$(N, U, F));
        return utils$1$1.isPlainObject(S) || S instanceof this.constructor ? B(S, E) : utils$1$1.isString(S) && (S = S.trim()) && !isValidHeaderName(S) ? B(parseHeaders(S), E) : S != null && $(E, S, M),
        this
    }
    get(S, E) {
        if (S = normalizeHeader(S),
        S) {
            const M = utils$1$1.findKey(this, S);
            if (M) {
                const T = this[M];
                if (!E)
                    return T;
                if (E === !0)
                    return parseTokens(T);
                if (utils$1$1.isFunction(E))
                    return E.call(this, T, M);
                if (utils$1$1.isRegExp(E))
                    return E.exec(T);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(S, E) {
        if (S = normalizeHeader(S),
        S) {
            const M = utils$1$1.findKey(this, S);
            return !!(M && this[M] !== void 0 && (!E || matchHeaderValue(this, this[M], M, E)))
        }
        return !1
    }
    delete(S, E) {
        const M = this;
        let T = !1;
        function $(B) {
            if (B = normalizeHeader(B),
            B) {
                const O = utils$1$1.findKey(M, B);
                O && (!E || matchHeaderValue(M, M[O], O, E)) && (delete M[O],
                T = !0)
            }
        }
        return utils$1$1.isArray(S) ? S.forEach($) : $(S),
        T
    }
    clear(S) {
        const E = Object.keys(this);
        let M = E.length
          , T = !1;
        for (; M--; ) {
            const $ = E[M];
            (!S || matchHeaderValue(this, this[$], $, S, !0)) && (delete this[$],
            T = !0)
        }
        return T
    }
    normalize(S) {
        const E = this
          , M = {};
        return utils$1$1.forEach(this, (T,$)=>{
            const B = utils$1$1.findKey(M, $);
            if (B) {
                E[B] = normalizeValue(T),
                delete E[$];
                return
            }
            const O = S ? formatHeader($) : String($).trim();
            O !== $ && delete E[$],
            E[O] = normalizeValue(T),
            M[O] = !0
        }
        ),
        this
    }
    concat(...S) {
        return this.constructor.concat(this, ...S)
    }
    toJSON(S) {
        const E = Object.create(null);
        return utils$1$1.forEach(this, (M,T)=>{
            M != null && M !== !1 && (E[T] = S && utils$1$1.isArray(M) ? M.join(", ") : M)
        }
        ),
        E
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([S,E])=>S + ": " + E).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(S) {
        return S instanceof this ? S : new this(S)
    }
    static concat(S, ...E) {
        const M = new this(S);
        return E.forEach(T=>M.set(T)),
        M
    }
    static accessor(S) {
        const M = (this[$internals] = this[$internals] = {
            accessors: {}
        }).accessors
          , T = this.prototype;
        function $(B) {
            const O = normalizeHeader(B);
            M[O] || (buildAccessors(T, B),
            M[O] = !0)
        }
        return utils$1$1.isArray(S) ? S.forEach($) : $(S),
        this
    }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1$1.reduceDescriptors(AxiosHeaders.prototype, ({value: C},S)=>{
    let E = S[0].toUpperCase() + S.slice(1);
    return {
        get: ()=>C,
        set(M) {
            this[E] = M
        }
    }
}
);
utils$1$1.freezeMethods(AxiosHeaders);
var AxiosHeaders$1 = AxiosHeaders;
function transformData(C, S) {
    const E = this || defaults$1
      , M = S || E
      , T = AxiosHeaders$1.from(M.headers);
    let $ = M.data;
    return utils$1$1.forEach(C, function(O) {
        $ = O.call(E, $, T.normalize(), S ? S.status : void 0)
    }),
    T.normalize(),
    $
}
function isCancel(C) {
    return !!(C && C.__CANCEL__)
}
function CanceledError(C, S, E) {
    AxiosError.call(this, C ?? "canceled", AxiosError.ERR_CANCELED, S, E),
    this.name = "CanceledError"
}
utils$1$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: !0
});
function settle(C, S, E) {
    const M = E.config.validateStatus;
    !E.status || !M || M(E.status) ? C(E) : S(new AxiosError("Request failed with status code " + E.status,[AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(E.status / 100) - 4],E.config,E.request,E))
}
var cookies = platform.hasStandardBrowserEnv ? {
    write(C, S, E, M, T, $) {
        const B = [C + "=" + encodeURIComponent(S)];
        utils$1$1.isNumber(E) && B.push("expires=" + new Date(E).toGMTString()),
        utils$1$1.isString(M) && B.push("path=" + M),
        utils$1$1.isString(T) && B.push("domain=" + T),
        $ === !0 && B.push("secure"),
        document.cookie = B.join("; ")
    },
    read(C) {
        const S = document.cookie.match(new RegExp("(^|;\\s*)(" + C + ")=([^;]*)"));
        return S ? decodeURIComponent(S[3]) : null
    },
    remove(C) {
        this.write(C, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function isAbsoluteURL(C) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(C)
}
function combineURLs(C, S) {
    return S ? C.replace(/\/?\/$/, "") + "/" + S.replace(/^\/+/, "") : C
}
function buildFullPath(C, S) {
    return C && !isAbsoluteURL(S) ? combineURLs(C, S) : S
}
var isURLSameOrigin = platform.hasStandardBrowserEnv ? function C() {
    const S = /(msie|trident)/i.test(navigator.userAgent)
      , E = document.createElement("a");
    let M;
    function T($) {
        let B = $;
        return S && (E.setAttribute("href", B),
        B = E.href),
        E.setAttribute("href", B),
        {
            href: E.href,
            protocol: E.protocol ? E.protocol.replace(/:$/, "") : "",
            host: E.host,
            search: E.search ? E.search.replace(/^\?/, "") : "",
            hash: E.hash ? E.hash.replace(/^#/, "") : "",
            hostname: E.hostname,
            port: E.port,
            pathname: E.pathname.charAt(0) === "/" ? E.pathname : "/" + E.pathname
        }
    }
    return M = T(window.location.href),
    function(B) {
        const O = utils$1$1.isString(B) ? T(B) : B;
        return O.protocol === M.protocol && O.host === M.host
    }
}() : function C() {
    return function() {
        return !0
    }
}();
function parseProtocol(C) {
    const S = /^([-+\w]{1,25})(:?\/\/|:)/.exec(C);
    return S && S[1] || ""
}
function speedometer(C, S) {
    C = C || 10;
    const E = new Array(C)
      , M = new Array(C);
    let T = 0, $ = 0, B;
    return S = S !== void 0 ? S : 1e3,
    function(F) {
        const N = Date.now()
          , U = M[$];
        B || (B = N),
        E[T] = F,
        M[T] = N;
        let H = $
          , Z = 0;
        for (; H !== T; )
            Z += E[H++],
            H = H % C;
        if (T = (T + 1) % C,
        T === $ && ($ = ($ + 1) % C),
        N - B < S)
            return;
        const J = U && N - U;
        return J ? Math.round(Z * 1e3 / J) : void 0
    }
}
function progressEventReducer(C, S) {
    let E = 0;
    const M = speedometer(50, 250);
    return T=>{
        const $ = T.loaded
          , B = T.lengthComputable ? T.total : void 0
          , O = $ - E
          , F = M(O)
          , N = $ <= B;
        E = $;
        const U = {
            loaded: $,
            total: B,
            progress: B ? $ / B : void 0,
            bytes: O,
            rate: F || void 0,
            estimated: F && B && N ? (B - $) / F : void 0,
            event: T
        };
        U[S ? "download" : "upload"] = !0,
        C(U)
    }
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u";
var xhrAdapter = isXHRAdapterSupported && function(C) {
    return new Promise(function(E, M) {
        let T = C.data;
        const $ = AxiosHeaders$1.from(C.headers).normalize();
        let {responseType: B, withXSRFToken: O} = C, F;
        function N() {
            C.cancelToken && C.cancelToken.unsubscribe(F),
            C.signal && C.signal.removeEventListener("abort", F)
        }
        let U;
        if (utils$1$1.isFormData(T)) {
            if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
                $.setContentType(!1);
            else if ((U = $.getContentType()) !== !1) {
                const [oe,...ae] = U ? U.split(";").map(se=>se.trim()).filter(Boolean) : [];
                $.setContentType([oe || "multipart/form-data", ...ae].join("; "))
            }
        }
        let H = new XMLHttpRequest;
        if (C.auth) {
            const oe = C.auth.username || ""
              , ae = C.auth.password ? unescape(encodeURIComponent(C.auth.password)) : "";
            $.set("Authorization", "Basic " + btoa(oe + ":" + ae))
        }
        const Z = buildFullPath(C.baseURL, C.url);
        H.open(C.method.toUpperCase(), buildURL(Z, C.params, C.paramsSerializer), !0),
        H.timeout = C.timeout;
        function J() {
            if (!H)
                return;
            const oe = AxiosHeaders$1.from("getAllResponseHeaders"in H && H.getAllResponseHeaders())
              , se = {
                data: !B || B === "text" || B === "json" ? H.responseText : H.response,
                status: H.status,
                statusText: H.statusText,
                headers: oe,
                config: C,
                request: H
            };
            settle(function(de) {
                E(de),
                N()
            }, function(de) {
                M(de),
                N()
            }, se),
            H = null
        }
        if ("onloadend"in H ? H.onloadend = J : H.onreadystatechange = function() {
            !H || H.readyState !== 4 || H.status === 0 && !(H.responseURL && H.responseURL.indexOf("file:") === 0) || setTimeout(J)
        }
        ,
        H.onabort = function() {
            H && (M(new AxiosError("Request aborted",AxiosError.ECONNABORTED,C,H)),
            H = null)
        }
        ,
        H.onerror = function() {
            M(new AxiosError("Network Error",AxiosError.ERR_NETWORK,C,H)),
            H = null
        }
        ,
        H.ontimeout = function() {
            let ae = C.timeout ? "timeout of " + C.timeout + "ms exceeded" : "timeout exceeded";
            const se = C.transitional || transitionalDefaults;
            C.timeoutErrorMessage && (ae = C.timeoutErrorMessage),
            M(new AxiosError(ae,se.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,C,H)),
            H = null
        }
        ,
        platform.hasStandardBrowserEnv && (O && utils$1$1.isFunction(O) && (O = O(C)),
        O || O !== !1 && isURLSameOrigin(Z))) {
            const oe = C.xsrfHeaderName && C.xsrfCookieName && cookies.read(C.xsrfCookieName);
            oe && $.set(C.xsrfHeaderName, oe)
        }
        T === void 0 && $.setContentType(null),
        "setRequestHeader"in H && utils$1$1.forEach($.toJSON(), function(ae, se) {
            H.setRequestHeader(se, ae)
        }),
        utils$1$1.isUndefined(C.withCredentials) || (H.withCredentials = !!C.withCredentials),
        B && B !== "json" && (H.responseType = C.responseType),
        typeof C.onDownloadProgress == "function" && H.addEventListener("progress", progressEventReducer(C.onDownloadProgress, !0)),
        typeof C.onUploadProgress == "function" && H.upload && H.upload.addEventListener("progress", progressEventReducer(C.onUploadProgress)),
        (C.cancelToken || C.signal) && (F = oe=>{
            H && (M(!oe || oe.type ? new CanceledError(null,C,H) : oe),
            H.abort(),
            H = null)
        }
        ,
        C.cancelToken && C.cancelToken.subscribe(F),
        C.signal && (C.signal.aborted ? F() : C.signal.addEventListener("abort", F)));
        const ie = parseProtocol(Z);
        if (ie && platform.protocols.indexOf(ie) === -1) {
            M(new AxiosError("Unsupported protocol " + ie + ":",AxiosError.ERR_BAD_REQUEST,C));
            return
        }
        H.send(T || null)
    }
    )
}
;
const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
};
utils$1$1.forEach(knownAdapters, (C,S)=>{
    if (C) {
        try {
            Object.defineProperty(C, "name", {
                value: S
            })
        } catch {}
        Object.defineProperty(C, "adapterName", {
            value: S
        })
    }
}
);
const renderReason = C=>`- ${C}`
  , isResolvedHandle = C=>utils$1$1.isFunction(C) || C === null || C === !1;
var adapters = {
    getAdapter: C=>{
        C = utils$1$1.isArray(C) ? C : [C];
        const {length: S} = C;
        let E, M;
        const T = {};
        for (let $ = 0; $ < S; $++) {
            E = C[$];
            let B;
            if (M = E,
            !isResolvedHandle(E) && (M = knownAdapters[(B = String(E)).toLowerCase()],
            M === void 0))
                throw new AxiosError(`Unknown adapter '${B}'`);
            if (M)
                break;
            T[B || "#" + $] = M
        }
        if (!M) {
            const $ = Object.entries(T).map(([O,F])=>`adapter ${O} ` + (F === !1 ? "is not supported by the environment" : "is not available in the build"));
            let B = S ? $.length > 1 ? `since :
` + $.map(renderReason).join(`
`) : " " + renderReason($[0]) : "as no adapter specified";
            throw new AxiosError("There is no suitable adapter to dispatch the request " + B,"ERR_NOT_SUPPORT")
        }
        return M
    }
    ,
    adapters: knownAdapters
};
function throwIfCancellationRequested(C) {
    if (C.cancelToken && C.cancelToken.throwIfRequested(),
    C.signal && C.signal.aborted)
        throw new CanceledError(null,C)
}
function dispatchRequest(C) {
    return throwIfCancellationRequested(C),
    C.headers = AxiosHeaders$1.from(C.headers),
    C.data = transformData.call(C, C.transformRequest),
    ["post", "put", "patch"].indexOf(C.method) !== -1 && C.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters.getAdapter(C.adapter || defaults$1.adapter)(C).then(function(M) {
        return throwIfCancellationRequested(C),
        M.data = transformData.call(C, C.transformResponse, M),
        M.headers = AxiosHeaders$1.from(M.headers),
        M
    }, function(M) {
        return isCancel(M) || (throwIfCancellationRequested(C),
        M && M.response && (M.response.data = transformData.call(C, C.transformResponse, M.response),
        M.response.headers = AxiosHeaders$1.from(M.response.headers))),
        Promise.reject(M)
    })
}
const headersToObject = C=>C instanceof AxiosHeaders$1 ? {
    ...C
} : C;
function mergeConfig$1(C, S) {
    S = S || {};
    const E = {};
    function M(N, U, H) {
        return utils$1$1.isPlainObject(N) && utils$1$1.isPlainObject(U) ? utils$1$1.merge.call({
            caseless: H
        }, N, U) : utils$1$1.isPlainObject(U) ? utils$1$1.merge({}, U) : utils$1$1.isArray(U) ? U.slice() : U
    }
    function T(N, U, H) {
        if (utils$1$1.isUndefined(U)) {
            if (!utils$1$1.isUndefined(N))
                return M(void 0, N, H)
        } else
            return M(N, U, H)
    }
    function $(N, U) {
        if (!utils$1$1.isUndefined(U))
            return M(void 0, U)
    }
    function B(N, U) {
        if (utils$1$1.isUndefined(U)) {
            if (!utils$1$1.isUndefined(N))
                return M(void 0, N)
        } else
            return M(void 0, U)
    }
    function O(N, U, H) {
        if (H in S)
            return M(N, U);
        if (H in C)
            return M(void 0, N)
    }
    const F = {
        url: $,
        method: $,
        data: $,
        baseURL: B,
        transformRequest: B,
        transformResponse: B,
        paramsSerializer: B,
        timeout: B,
        timeoutMessage: B,
        withCredentials: B,
        withXSRFToken: B,
        adapter: B,
        responseType: B,
        xsrfCookieName: B,
        xsrfHeaderName: B,
        onUploadProgress: B,
        onDownloadProgress: B,
        decompress: B,
        maxContentLength: B,
        maxBodyLength: B,
        beforeRedirect: B,
        transport: B,
        httpAgent: B,
        httpsAgent: B,
        cancelToken: B,
        socketPath: B,
        responseEncoding: B,
        validateStatus: O,
        headers: (N,U)=>T(headersToObject(N), headersToObject(U), !0)
    };
    return utils$1$1.forEach(Object.keys(Object.assign({}, C, S)), function(U) {
        const H = F[U] || T
          , Z = H(C[U], S[U], U);
        utils$1$1.isUndefined(Z) && H !== O || (E[U] = Z)
    }),
    E
}
const VERSION = "1.6.8"
  , validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((C,S)=>{
    validators$1[C] = function(M) {
        return typeof M === C || "a" + (S < 1 ? "n " : " ") + C
    }
}
);
const deprecatedWarnings = {};
validators$1.transitional = function C(S, E, M) {
    function T($, B) {
        return "[Axios v" + VERSION + "] Transitional option '" + $ + "'" + B + (M ? ". " + M : "")
    }
    return ($,B,O)=>{
        if (S === !1)
            throw new AxiosError(T(B, " has been removed" + (E ? " in " + E : "")),AxiosError.ERR_DEPRECATED);
        return E && !deprecatedWarnings[B] && (deprecatedWarnings[B] = !0,
        console.warn(T(B, " has been deprecated since v" + E + " and will be removed in the near future"))),
        S ? S($, B, O) : !0
    }
}
;
function assertOptions(C, S, E) {
    if (typeof C != "object")
        throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE);
    const M = Object.keys(C);
    let T = M.length;
    for (; T-- > 0; ) {
        const $ = M[T]
          , B = S[$];
        if (B) {
            const O = C[$]
              , F = O === void 0 || B(O, $, C);
            if (F !== !0)
                throw new AxiosError("option " + $ + " must be " + F,AxiosError.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (E !== !0)
            throw new AxiosError("Unknown option " + $,AxiosError.ERR_BAD_OPTION)
    }
}
var validator = {
    assertOptions,
    validators: validators$1
};
const validators = validator.validators;
class Axios {
    constructor(S) {
        this.defaults = S,
        this.interceptors = {
            request: new InterceptorManager$1,
            response: new InterceptorManager$1
        }
    }
    async request(S, E) {
        try {
            return await this._request(S, E)
        } catch (M) {
            if (M instanceof Error) {
                let T;
                Error.captureStackTrace ? Error.captureStackTrace(T = {}) : T = new Error;
                const $ = T.stack ? T.stack.replace(/^.+\n/, "") : "";
                M.stack ? $ && !String(M.stack).endsWith($.replace(/^.+\n.+\n/, "")) && (M.stack += `
` + $) : M.stack = $
            }
            throw M
        }
    }
    _request(S, E) {
        typeof S == "string" ? (E = E || {},
        E.url = S) : E = S || {},
        E = mergeConfig$1(this.defaults, E);
        const {transitional: M, paramsSerializer: T, headers: $} = E;
        M !== void 0 && validator.assertOptions(M, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, !1),
        T != null && (utils$1$1.isFunction(T) ? E.paramsSerializer = {
            serialize: T
        } : validator.assertOptions(T, {
            encode: validators.function,
            serialize: validators.function
        }, !0)),
        E.method = (E.method || this.defaults.method || "get").toLowerCase();
        let B = $ && utils$1$1.merge($.common, $[E.method]);
        $ && utils$1$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ie=>{
            delete $[ie]
        }
        ),
        E.headers = AxiosHeaders$1.concat(B, $);
        const O = [];
        let F = !0;
        this.interceptors.request.forEach(function(oe) {
            typeof oe.runWhen == "function" && oe.runWhen(E) === !1 || (F = F && oe.synchronous,
            O.unshift(oe.fulfilled, oe.rejected))
        });
        const N = [];
        this.interceptors.response.forEach(function(oe) {
            N.push(oe.fulfilled, oe.rejected)
        });
        let U, H = 0, Z;
        if (!F) {
            const ie = [dispatchRequest.bind(this), void 0];
            for (ie.unshift.apply(ie, O),
            ie.push.apply(ie, N),
            Z = ie.length,
            U = Promise.resolve(E); H < Z; )
                U = U.then(ie[H++], ie[H++]);
            return U
        }
        Z = O.length;
        let J = E;
        for (H = 0; H < Z; ) {
            const ie = O[H++]
              , oe = O[H++];
            try {
                J = ie(J)
            } catch (ae) {
                oe.call(this, ae);
                break
            }
        }
        try {
            U = dispatchRequest.call(this, J)
        } catch (ie) {
            return Promise.reject(ie)
        }
        for (H = 0,
        Z = N.length; H < Z; )
            U = U.then(N[H++], N[H++]);
        return U
    }
    getUri(S) {
        S = mergeConfig$1(this.defaults, S);
        const E = buildFullPath(S.baseURL, S.url);
        return buildURL(E, S.params, S.paramsSerializer)
    }
}
utils$1$1.forEach(["delete", "get", "head", "options"], function C(S) {
    Axios.prototype[S] = function(E, M) {
        return this.request(mergeConfig$1(M || {}, {
            method: S,
            url: E,
            data: (M || {}).data
        }))
    }
});
utils$1$1.forEach(["post", "put", "patch"], function C(S) {
    function E(M) {
        return function($, B, O) {
            return this.request(mergeConfig$1(O || {}, {
                method: S,
                headers: M ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: $,
                data: B
            }))
        }
    }
    Axios.prototype[S] = E(),
    Axios.prototype[S + "Form"] = E(!0)
});
var Axios$1 = Axios;
class CancelToken {
    constructor(S) {
        if (typeof S != "function")
            throw new TypeError("executor must be a function.");
        let E;
        this.promise = new Promise(function($) {
            E = $
        }
        );
        const M = this;
        this.promise.then(T=>{
            if (!M._listeners)
                return;
            let $ = M._listeners.length;
            for (; $-- > 0; )
                M._listeners[$](T);
            M._listeners = null
        }
        ),
        this.promise.then = T=>{
            let $;
            const B = new Promise(O=>{
                M.subscribe(O),
                $ = O
            }
            ).then(T);
            return B.cancel = function() {
                M.unsubscribe($)
            }
            ,
            B
        }
        ,
        S(function($, B, O) {
            M.reason || (M.reason = new CanceledError($,B,O),
            E(M.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(S) {
        if (this.reason) {
            S(this.reason);
            return
        }
        this._listeners ? this._listeners.push(S) : this._listeners = [S]
    }
    unsubscribe(S) {
        if (!this._listeners)
            return;
        const E = this._listeners.indexOf(S);
        E !== -1 && this._listeners.splice(E, 1)
    }
    static source() {
        let S;
        return {
            token: new CancelToken(function(T) {
                S = T
            }
            ),
            cancel: S
        }
    }
}
var CancelToken$1 = CancelToken;
function spread(C) {
    return function(E) {
        return C.apply(null, E)
    }
}
function isAxiosError(C) {
    return utils$1$1.isObject(C) && C.isAxiosError === !0
}
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([C,S])=>{
    HttpStatusCode[S] = C
}
);
var HttpStatusCode$1 = HttpStatusCode;
function createInstance(C) {
    const S = new Axios$1(C)
      , E = bind(Axios$1.prototype.request, S);
    return utils$1$1.extend(E, Axios$1.prototype, S, {
        allOwnKeys: !0
    }),
    utils$1$1.extend(E, S, null, {
        allOwnKeys: !0
    }),
    E.create = function(T) {
        return createInstance(mergeConfig$1(C, T))
    }
    ,
    E
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function C(S) {
    return Promise.all(S)
}
;
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = C=>formDataToJSON(utils$1$1.isHTMLForm(C) ? new FormData(C) : C);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var axios_1$2 = axios
  , lib$1 = {}
  , external = {}
  , errors = {}
  , en = {}
  , util = {};
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.getParsedType = C.ZodParsedType = C.objectUtil = C.util = void 0;
    var S;
    (function(M) {
        M.assertEqual = O=>O;
        function T(O) {}
        M.assertIs = T;
        function $(O) {
            throw new Error
        }
        M.assertNever = $,
        M.arrayToEnum = O=>{
            const F = {};
            for (const N of O)
                F[N] = N;
            return F
        }
        ,
        M.getValidEnumValues = O=>{
            const F = M.objectKeys(O).filter(U=>typeof O[O[U]] != "number")
              , N = {};
            for (const U of F)
                N[U] = O[U];
            return M.objectValues(N)
        }
        ,
        M.objectValues = O=>M.objectKeys(O).map(function(F) {
            return O[F]
        }),
        M.objectKeys = typeof Object.keys == "function" ? O=>Object.keys(O) : O=>{
            const F = [];
            for (const N in O)
                Object.prototype.hasOwnProperty.call(O, N) && F.push(N);
            return F
        }
        ,
        M.find = (O,F)=>{
            for (const N of O)
                if (F(N))
                    return N
        }
        ,
        M.isInteger = typeof Number.isInteger == "function" ? O=>Number.isInteger(O) : O=>typeof O == "number" && isFinite(O) && Math.floor(O) === O;
        function B(O, F=" | ") {
            return O.map(N=>typeof N == "string" ? `'${N}'` : N).join(F)
        }
        M.joinValues = B,
        M.jsonStringifyReplacer = (O,F)=>typeof F == "bigint" ? F.toString() : F
    }
    )(S = C.util || (C.util = {})),
    function(M) {
        M.mergeShapes = (T,$)=>({
            ...T,
            ...$
        })
    }(C.objectUtil || (C.objectUtil = {})),
    C.ZodParsedType = S.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
    const E = M=>{
        switch (typeof M) {
        case "undefined":
            return C.ZodParsedType.undefined;
        case "string":
            return C.ZodParsedType.string;
        case "number":
            return isNaN(M) ? C.ZodParsedType.nan : C.ZodParsedType.number;
        case "boolean":
            return C.ZodParsedType.boolean;
        case "function":
            return C.ZodParsedType.function;
        case "bigint":
            return C.ZodParsedType.bigint;
        case "symbol":
            return C.ZodParsedType.symbol;
        case "object":
            return Array.isArray(M) ? C.ZodParsedType.array : M === null ? C.ZodParsedType.null : M.then && typeof M.then == "function" && M.catch && typeof M.catch == "function" ? C.ZodParsedType.promise : typeof Map < "u" && M instanceof Map ? C.ZodParsedType.map : typeof Set < "u" && M instanceof Set ? C.ZodParsedType.set : typeof Date < "u" && M instanceof Date ? C.ZodParsedType.date : C.ZodParsedType.object;
        default:
            return C.ZodParsedType.unknown
        }
    }
    ;
    C.getParsedType = E
}
)(util);
var ZodError$1 = {};
Object.defineProperty(ZodError$1, "__esModule", {
    value: !0
});
ZodError$1.ZodError = ZodError$1.quotelessJson = ZodError$1.ZodIssueCode = void 0;
const util_1$1 = util;
ZodError$1.ZodIssueCode = util_1$1.util.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
const quotelessJson = C=>JSON.stringify(C, null, 2).replace(/"([^"]+)":/g, "$1:");
ZodError$1.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(S) {
        super(),
        this.issues = [],
        this.addIssue = M=>{
            this.issues = [...this.issues, M]
        }
        ,
        this.addIssues = (M=[])=>{
            this.issues = [...this.issues, ...M]
        }
        ;
        const E = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, E) : this.__proto__ = E,
        this.name = "ZodError",
        this.issues = S
    }
    get errors() {
        return this.issues
    }
    format(S) {
        const E = S || function($) {
            return $.message
        }
          , M = {
            _errors: []
        }
          , T = $=>{
            for (const B of $.issues)
                if (B.code === "invalid_union")
                    B.unionErrors.map(T);
                else if (B.code === "invalid_return_type")
                    T(B.returnTypeError);
                else if (B.code === "invalid_arguments")
                    T(B.argumentsError);
                else if (B.path.length === 0)
                    M._errors.push(E(B));
                else {
                    let O = M
                      , F = 0;
                    for (; F < B.path.length; ) {
                        const N = B.path[F];
                        F === B.path.length - 1 ? (O[N] = O[N] || {
                            _errors: []
                        },
                        O[N]._errors.push(E(B))) : O[N] = O[N] || {
                            _errors: []
                        },
                        O = O[N],
                        F++
                    }
                }
        }
        ;
        return T(this),
        M
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, util_1$1.util.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(S=E=>E.message) {
        const E = {}
          , M = [];
        for (const T of this.issues)
            T.path.length > 0 ? (E[T.path[0]] = E[T.path[0]] || [],
            E[T.path[0]].push(S(T))) : M.push(S(T));
        return {
            formErrors: M,
            fieldErrors: E
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
ZodError$1.ZodError = ZodError;
ZodError.create = C=>new ZodError(C);
Object.defineProperty(en, "__esModule", {
    value: !0
});
const util_1 = util
  , ZodError_1 = ZodError$1
  , errorMap = (C,S)=>{
    let E;
    switch (C.code) {
    case ZodError_1.ZodIssueCode.invalid_type:
        C.received === util_1.ZodParsedType.undefined ? E = "Required" : E = `Expected ${C.expected}, received ${C.received}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_literal:
        E = `Invalid literal value, expected ${JSON.stringify(C.expected, util_1.util.jsonStringifyReplacer)}`;
        break;
    case ZodError_1.ZodIssueCode.unrecognized_keys:
        E = `Unrecognized key(s) in object: ${util_1.util.joinValues(C.keys, ", ")}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_union:
        E = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.invalid_union_discriminator:
        E = `Invalid discriminator value. Expected ${util_1.util.joinValues(C.options)}`;
        break;
    case ZodError_1.ZodIssueCode.invalid_enum_value:
        E = `Invalid enum value. Expected ${util_1.util.joinValues(C.options)}, received '${C.received}'`;
        break;
    case ZodError_1.ZodIssueCode.invalid_arguments:
        E = "Invalid function arguments";
        break;
    case ZodError_1.ZodIssueCode.invalid_return_type:
        E = "Invalid function return type";
        break;
    case ZodError_1.ZodIssueCode.invalid_date:
        E = "Invalid date";
        break;
    case ZodError_1.ZodIssueCode.invalid_string:
        typeof C.validation == "object" ? "includes"in C.validation ? (E = `Invalid input: must include "${C.validation.includes}"`,
        typeof C.validation.position == "number" && (E = `${E} at one or more positions greater than or equal to ${C.validation.position}`)) : "startsWith"in C.validation ? E = `Invalid input: must start with "${C.validation.startsWith}"` : "endsWith"in C.validation ? E = `Invalid input: must end with "${C.validation.endsWith}"` : util_1.util.assertNever(C.validation) : C.validation !== "regex" ? E = `Invalid ${C.validation}` : E = "Invalid";
        break;
    case ZodError_1.ZodIssueCode.too_small:
        C.type === "array" ? E = `Array must contain ${C.exact ? "exactly" : C.inclusive ? "at least" : "more than"} ${C.minimum} element(s)` : C.type === "string" ? E = `String must contain ${C.exact ? "exactly" : C.inclusive ? "at least" : "over"} ${C.minimum} character(s)` : C.type === "number" ? E = `Number must be ${C.exact ? "exactly equal to " : C.inclusive ? "greater than or equal to " : "greater than "}${C.minimum}` : C.type === "date" ? E = `Date must be ${C.exact ? "exactly equal to " : C.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(C.minimum))}` : E = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.too_big:
        C.type === "array" ? E = `Array must contain ${C.exact ? "exactly" : C.inclusive ? "at most" : "less than"} ${C.maximum} element(s)` : C.type === "string" ? E = `String must contain ${C.exact ? "exactly" : C.inclusive ? "at most" : "under"} ${C.maximum} character(s)` : C.type === "number" ? E = `Number must be ${C.exact ? "exactly" : C.inclusive ? "less than or equal to" : "less than"} ${C.maximum}` : C.type === "bigint" ? E = `BigInt must be ${C.exact ? "exactly" : C.inclusive ? "less than or equal to" : "less than"} ${C.maximum}` : C.type === "date" ? E = `Date must be ${C.exact ? "exactly" : C.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(C.maximum))}` : E = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.custom:
        E = "Invalid input";
        break;
    case ZodError_1.ZodIssueCode.invalid_intersection_types:
        E = "Intersection results could not be merged";
        break;
    case ZodError_1.ZodIssueCode.not_multiple_of:
        E = `Number must be a multiple of ${C.multipleOf}`;
        break;
    case ZodError_1.ZodIssueCode.not_finite:
        E = "Number must be finite";
        break;
    default:
        E = S.defaultError,
        util_1.util.assertNever(C)
    }
    return {
        message: E
    }
}
;
en.default = errorMap;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(errors, "__esModule", {
    value: !0
});
errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
const en_1 = __importDefault$2(en);
errors.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(C) {
    overrideErrorMap = C
}
errors.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap
}
errors.getErrorMap = getErrorMap;
var parseUtil = {};
(function(C) {
    var S = commonjsGlobal && commonjsGlobal.__importDefault || function(J) {
        return J && J.__esModule ? J : {
            default: J
        }
    }
    ;
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.isAsync = C.isValid = C.isDirty = C.isAborted = C.OK = C.DIRTY = C.INVALID = C.ParseStatus = C.addIssueToContext = C.EMPTY_PATH = C.makeIssue = void 0;
    const E = errors
      , M = S(en)
      , T = J=>{
        const {data: ie, path: oe, errorMaps: ae, issueData: se} = J
          , le = [...oe, ...se.path || []]
          , de = {
            ...se,
            path: le
        };
        let fe = "";
        const pe = ae.filter(ge=>!!ge).slice().reverse();
        for (const ge of pe)
            fe = ge(de, {
                data: ie,
                defaultError: fe
            }).message;
        return {
            ...se,
            path: le,
            message: se.message || fe
        }
    }
    ;
    C.makeIssue = T,
    C.EMPTY_PATH = [];
    function $(J, ie) {
        const oe = (0,
        C.makeIssue)({
            issueData: ie,
            data: J.data,
            path: J.path,
            errorMaps: [J.common.contextualErrorMap, J.schemaErrorMap, (0,
            E.getErrorMap)(), M.default].filter(ae=>!!ae)
        });
        J.common.issues.push(oe)
    }
    C.addIssueToContext = $;
    class B {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(ie, oe) {
            const ae = [];
            for (const se of oe) {
                if (se.status === "aborted")
                    return C.INVALID;
                se.status === "dirty" && ie.dirty(),
                ae.push(se.value)
            }
            return {
                status: ie.value,
                value: ae
            }
        }
        static async mergeObjectAsync(ie, oe) {
            const ae = [];
            for (const se of oe)
                ae.push({
                    key: await se.key,
                    value: await se.value
                });
            return B.mergeObjectSync(ie, ae)
        }
        static mergeObjectSync(ie, oe) {
            const ae = {};
            for (const se of oe) {
                const {key: le, value: de} = se;
                if (le.status === "aborted" || de.status === "aborted")
                    return C.INVALID;
                le.status === "dirty" && ie.dirty(),
                de.status === "dirty" && ie.dirty(),
                le.value !== "__proto__" && (typeof de.value < "u" || se.alwaysSet) && (ae[le.value] = de.value)
            }
            return {
                status: ie.value,
                value: ae
            }
        }
    }
    C.ParseStatus = B,
    C.INVALID = Object.freeze({
        status: "aborted"
    });
    const O = J=>({
        status: "dirty",
        value: J
    });
    C.DIRTY = O;
    const F = J=>({
        status: "valid",
        value: J
    });
    C.OK = F;
    const N = J=>J.status === "aborted";
    C.isAborted = N;
    const U = J=>J.status === "dirty";
    C.isDirty = U;
    const H = J=>J.status === "valid";
    C.isValid = H;
    const Z = J=>typeof Promise < "u" && J instanceof Promise;
    C.isAsync = Z
}
)(parseUtil);
var typeAliases = {};
Object.defineProperty(typeAliases, "__esModule", {
    value: !0
});
var types = {}
  , errorUtil = {};
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.errorUtil = void 0,
    function(S) {
        S.errToObj = E=>typeof E == "string" ? {
            message: E
        } : E || {},
        S.toString = E=>typeof E == "string" ? E : E == null ? void 0 : E.message
    }(C.errorUtil || (C.errorUtil = {}))
}
)(errorUtil);
(function(C) {
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.date = C.boolean = C.bigint = C.array = C.any = C.coerce = C.ZodFirstPartyTypeKind = C.late = C.ZodSchema = C.Schema = C.custom = C.ZodReadonly = C.ZodPipeline = C.ZodBranded = C.BRAND = C.ZodNaN = C.ZodCatch = C.ZodDefault = C.ZodNullable = C.ZodOptional = C.ZodTransformer = C.ZodEffects = C.ZodPromise = C.ZodNativeEnum = C.ZodEnum = C.ZodLiteral = C.ZodLazy = C.ZodFunction = C.ZodSet = C.ZodMap = C.ZodRecord = C.ZodTuple = C.ZodIntersection = C.ZodDiscriminatedUnion = C.ZodUnion = C.ZodObject = C.ZodArray = C.ZodVoid = C.ZodNever = C.ZodUnknown = C.ZodAny = C.ZodNull = C.ZodUndefined = C.ZodSymbol = C.ZodDate = C.ZodBoolean = C.ZodBigInt = C.ZodNumber = C.ZodString = C.ZodType = void 0,
    C.NEVER = C.void = C.unknown = C.union = C.undefined = C.tuple = C.transformer = C.symbol = C.string = C.strictObject = C.set = C.record = C.promise = C.preprocess = C.pipeline = C.ostring = C.optional = C.onumber = C.oboolean = C.object = C.number = C.nullable = C.null = C.never = C.nativeEnum = C.nan = C.map = C.literal = C.lazy = C.intersection = C.instanceof = C.function = C.enum = C.effect = C.discriminatedUnion = void 0;
    const S = errors
      , E = errorUtil
      , M = parseUtil
      , T = util
      , $ = ZodError$1;
    class B {
        constructor(me, ke, Le, Qe) {
            this._cachedPath = [],
            this.parent = me,
            this.data = ke,
            this._path = Le,
            this._key = Qe
        }
        get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    const O = (Ve,me)=>{
        if ((0,
        M.isValid)(me))
            return {
                success: !0,
                data: me.value
            };
        if (!Ve.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const ke = new $.ZodError(Ve.common.issues);
                return this._error = ke,
                this._error
            }
        }
    }
    ;
    function F(Ve) {
        if (!Ve)
            return {};
        const {errorMap: me, invalid_type_error: ke, required_error: Le, description: Qe} = Ve;
        if (me && (ke || Le))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return me ? {
            errorMap: me,
            description: Qe
        } : {
            errorMap: (vt,dt)=>vt.code !== "invalid_type" ? {
                message: dt.defaultError
            } : typeof dt.data > "u" ? {
                message: Le ?? dt.defaultError
            } : {
                message: ke ?? dt.defaultError
            },
            description: Qe
        }
    }
    class N {
        constructor(me) {
            this.spa = this.safeParseAsync,
            this._def = me,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this)
        }
        get description() {
            return this._def.description
        }
        _getType(me) {
            return (0,
            T.getParsedType)(me.data)
        }
        _getOrReturnCtx(me, ke) {
            return ke || {
                common: me.parent.common,
                data: me.data,
                parsedType: (0,
                T.getParsedType)(me.data),
                schemaErrorMap: this._def.errorMap,
                path: me.path,
                parent: me.parent
            }
        }
        _processInputParams(me) {
            return {
                status: new M.ParseStatus,
                ctx: {
                    common: me.parent.common,
                    data: me.data,
                    parsedType: (0,
                    T.getParsedType)(me.data),
                    schemaErrorMap: this._def.errorMap,
                    path: me.path,
                    parent: me.parent
                }
            }
        }
        _parseSync(me) {
            const ke = this._parse(me);
            if ((0,
            M.isAsync)(ke))
                throw new Error("Synchronous parse encountered promise.");
            return ke
        }
        _parseAsync(me) {
            const ke = this._parse(me);
            return Promise.resolve(ke)
        }
        parse(me, ke) {
            const Le = this.safeParse(me, ke);
            if (Le.success)
                return Le.data;
            throw Le.error
        }
        safeParse(me, ke) {
            var Le;
            const Qe = {
                common: {
                    issues: [],
                    async: (Le = ke == null ? void 0 : ke.async) !== null && Le !== void 0 ? Le : !1,
                    contextualErrorMap: ke == null ? void 0 : ke.errorMap
                },
                path: (ke == null ? void 0 : ke.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: me,
                parsedType: (0,
                T.getParsedType)(me)
            }
              , Ke = this._parseSync({
                data: me,
                path: Qe.path,
                parent: Qe
            });
            return O(Qe, Ke)
        }
        async parseAsync(me, ke) {
            const Le = await this.safeParseAsync(me, ke);
            if (Le.success)
                return Le.data;
            throw Le.error
        }
        async safeParseAsync(me, ke) {
            const Le = {
                common: {
                    issues: [],
                    contextualErrorMap: ke == null ? void 0 : ke.errorMap,
                    async: !0
                },
                path: (ke == null ? void 0 : ke.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: me,
                parsedType: (0,
                T.getParsedType)(me)
            }
              , Qe = this._parse({
                data: me,
                path: Le.path,
                parent: Le
            })
              , Ke = await ((0,
            M.isAsync)(Qe) ? Qe : Promise.resolve(Qe));
            return O(Le, Ke)
        }
        refine(me, ke) {
            const Le = Qe=>typeof ke == "string" || typeof ke > "u" ? {
                message: ke
            } : typeof ke == "function" ? ke(Qe) : ke;
            return this._refinement((Qe,Ke)=>{
                const vt = me(Qe)
                  , dt = ()=>Ke.addIssue({
                    code: $.ZodIssueCode.custom,
                    ...Le(Qe)
                });
                return typeof Promise < "u" && vt instanceof Promise ? vt.then(It=>It ? !0 : (dt(),
                !1)) : vt ? !0 : (dt(),
                !1)
            }
            )
        }
        refinement(me, ke) {
            return this._refinement((Le,Qe)=>me(Le) ? !0 : (Qe.addIssue(typeof ke == "function" ? ke(Le, Qe) : ke),
            !1))
        }
        _refinement(me) {
            return new ct({
                schema: this,
                typeName: Ie.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: me
                }
            })
        }
        superRefine(me) {
            return this._refinement(me)
        }
        optional() {
            return De.create(this, this._def)
        }
        nullable() {
            return Ue.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return Y.create(this, this._def)
        }
        promise() {
            return bt.create(this, this._def)
        }
        or(me) {
            return ne.create([this, me], this._def)
        }
        and(me) {
            return Re.create(this, me, this._def)
        }
        transform(me) {
            return new ct({
                ...F(this._def),
                schema: this,
                typeName: Ie.ZodEffects,
                effect: {
                    type: "transform",
                    transform: me
                }
            })
        }
        default(me) {
            const ke = typeof me == "function" ? me : ()=>me;
            return new We({
                ...F(this._def),
                innerType: this,
                defaultValue: ke,
                typeName: Ie.ZodDefault
            })
        }
        brand() {
            return new Je({
                typeName: Ie.ZodBranded,
                type: this,
                ...F(this._def)
            })
        }
        catch(me) {
            const ke = typeof me == "function" ? me : ()=>me;
            return new Xe({
                ...F(this._def),
                innerType: this,
                catchValue: ke,
                typeName: Ie.ZodCatch
            })
        }
        describe(me) {
            const ke = this.constructor;
            return new ke({
                ...this._def,
                description: me
            })
        }
        pipe(me) {
            return ot.create(this, me)
        }
        readonly() {
            return je.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    C.ZodType = N,
    C.Schema = N,
    C.ZodSchema = N;
    const U = /^c[^\s-]{8,}$/i
      , H = /^[a-z][a-z0-9]*$/
      , Z = /^[0-9A-HJKMNP-TV-Z]{26}$/
      , J = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , ie = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , oe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let ae;
    const se = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/
      , le = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
      , de = Ve=>Ve.precision ? Ve.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Ve.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${Ve.precision}}Z$`) : Ve.precision === 0 ? Ve.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : Ve.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
    function fe(Ve, me) {
        return !!((me === "v4" || !me) && se.test(Ve) || (me === "v6" || !me) && le.test(Ve))
    }
    class pe extends N {
        _parse(me) {
            if (this._def.coerce && (me.data = String(me.data)),
            this._getType(me) !== T.ZodParsedType.string) {
                const Ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.string,
                    received: Ke.parsedType
                }),
                M.INVALID
            }
            const Le = new M.ParseStatus;
            let Qe;
            for (const Ke of this._def.checks)
                if (Ke.kind === "min")
                    me.data.length < Ke.value && (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.too_small,
                        minimum: Ke.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "max")
                    me.data.length > Ke.value && (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.too_big,
                        maximum: Ke.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "length") {
                    const vt = me.data.length > Ke.value
                      , dt = me.data.length < Ke.value;
                    (vt || dt) && (Qe = this._getOrReturnCtx(me, Qe),
                    vt ? (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.too_big,
                        maximum: Ke.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: Ke.message
                    }) : dt && (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.too_small,
                        minimum: Ke.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: Ke.message
                    }),
                    Le.dirty())
                } else if (Ke.kind === "email")
                    ie.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "email",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "emoji")
                    ae || (ae = new RegExp(oe,"u")),
                    ae.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "emoji",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "uuid")
                    J.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "uuid",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "cuid")
                    U.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "cuid",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "cuid2")
                    H.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "cuid2",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "ulid")
                    Z.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "ulid",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty());
                else if (Ke.kind === "url")
                    try {
                        new URL(me.data)
                    } catch {
                        Qe = this._getOrReturnCtx(me, Qe),
                        (0,
                        M.addIssueToContext)(Qe, {
                            validation: "url",
                            code: $.ZodIssueCode.invalid_string,
                            message: Ke.message
                        }),
                        Le.dirty()
                    }
                else
                    Ke.kind === "regex" ? (Ke.regex.lastIndex = 0,
                    Ke.regex.test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "regex",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty())) : Ke.kind === "trim" ? me.data = me.data.trim() : Ke.kind === "includes" ? me.data.includes(Ke.value, Ke.position) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.invalid_string,
                        validation: {
                            includes: Ke.value,
                            position: Ke.position
                        },
                        message: Ke.message
                    }),
                    Le.dirty()) : Ke.kind === "toLowerCase" ? me.data = me.data.toLowerCase() : Ke.kind === "toUpperCase" ? me.data = me.data.toUpperCase() : Ke.kind === "startsWith" ? me.data.startsWith(Ke.value) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: Ke.value
                        },
                        message: Ke.message
                    }),
                    Le.dirty()) : Ke.kind === "endsWith" ? me.data.endsWith(Ke.value) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: Ke.value
                        },
                        message: Ke.message
                    }),
                    Le.dirty()) : Ke.kind === "datetime" ? de(Ke).test(me.data) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: Ke.message
                    }),
                    Le.dirty()) : Ke.kind === "ip" ? fe(me.data, Ke.version) || (Qe = this._getOrReturnCtx(me, Qe),
                    (0,
                    M.addIssueToContext)(Qe, {
                        validation: "ip",
                        code: $.ZodIssueCode.invalid_string,
                        message: Ke.message
                    }),
                    Le.dirty()) : T.util.assertNever(Ke);
            return {
                status: Le.value,
                value: me.data
            }
        }
        _regex(me, ke, Le) {
            return this.refinement(Qe=>me.test(Qe), {
                validation: ke,
                code: $.ZodIssueCode.invalid_string,
                ...E.errorUtil.errToObj(Le)
            })
        }
        _addCheck(me) {
            return new pe({
                ...this._def,
                checks: [...this._def.checks, me]
            })
        }
        email(me) {
            return this._addCheck({
                kind: "email",
                ...E.errorUtil.errToObj(me)
            })
        }
        url(me) {
            return this._addCheck({
                kind: "url",
                ...E.errorUtil.errToObj(me)
            })
        }
        emoji(me) {
            return this._addCheck({
                kind: "emoji",
                ...E.errorUtil.errToObj(me)
            })
        }
        uuid(me) {
            return this._addCheck({
                kind: "uuid",
                ...E.errorUtil.errToObj(me)
            })
        }
        cuid(me) {
            return this._addCheck({
                kind: "cuid",
                ...E.errorUtil.errToObj(me)
            })
        }
        cuid2(me) {
            return this._addCheck({
                kind: "cuid2",
                ...E.errorUtil.errToObj(me)
            })
        }
        ulid(me) {
            return this._addCheck({
                kind: "ulid",
                ...E.errorUtil.errToObj(me)
            })
        }
        ip(me) {
            return this._addCheck({
                kind: "ip",
                ...E.errorUtil.errToObj(me)
            })
        }
        datetime(me) {
            var ke;
            return typeof me == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                message: me
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof (me == null ? void 0 : me.precision) > "u" ? null : me == null ? void 0 : me.precision,
                offset: (ke = me == null ? void 0 : me.offset) !== null && ke !== void 0 ? ke : !1,
                ...E.errorUtil.errToObj(me == null ? void 0 : me.message)
            })
        }
        regex(me, ke) {
            return this._addCheck({
                kind: "regex",
                regex: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        includes(me, ke) {
            return this._addCheck({
                kind: "includes",
                value: me,
                position: ke == null ? void 0 : ke.position,
                ...E.errorUtil.errToObj(ke == null ? void 0 : ke.message)
            })
        }
        startsWith(me, ke) {
            return this._addCheck({
                kind: "startsWith",
                value: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        endsWith(me, ke) {
            return this._addCheck({
                kind: "endsWith",
                value: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        min(me, ke) {
            return this._addCheck({
                kind: "min",
                value: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        max(me, ke) {
            return this._addCheck({
                kind: "max",
                value: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        length(me, ke) {
            return this._addCheck({
                kind: "length",
                value: me,
                ...E.errorUtil.errToObj(ke)
            })
        }
        nonempty(me) {
            return this.min(1, E.errorUtil.errToObj(me))
        }
        trim() {
            return new pe({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new pe({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new pe({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(me=>me.kind === "datetime")
        }
        get isEmail() {
            return !!this._def.checks.find(me=>me.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(me=>me.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(me=>me.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(me=>me.kind === "uuid")
        }
        get isCUID() {
            return !!this._def.checks.find(me=>me.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(me=>me.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(me=>me.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(me=>me.kind === "ip")
        }
        get minLength() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "min" && (me === null || ke.value > me) && (me = ke.value);
            return me
        }
        get maxLength() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "max" && (me === null || ke.value < me) && (me = ke.value);
            return me
        }
    }
    C.ZodString = pe,
    pe.create = Ve=>{
        var me;
        return new pe({
            checks: [],
            typeName: Ie.ZodString,
            coerce: (me = Ve == null ? void 0 : Ve.coerce) !== null && me !== void 0 ? me : !1,
            ...F(Ve)
        })
    }
    ;
    function ge(Ve, me) {
        const ke = (Ve.toString().split(".")[1] || "").length
          , Le = (me.toString().split(".")[1] || "").length
          , Qe = ke > Le ? ke : Le
          , Ke = parseInt(Ve.toFixed(Qe).replace(".", ""))
          , vt = parseInt(me.toFixed(Qe).replace(".", ""));
        return Ke % vt / Math.pow(10, Qe)
    }
    class we extends N {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(me) {
            if (this._def.coerce && (me.data = Number(me.data)),
            this._getType(me) !== T.ZodParsedType.number) {
                const Ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.number,
                    received: Ke.parsedType
                }),
                M.INVALID
            }
            let Le;
            const Qe = new M.ParseStatus;
            for (const Ke of this._def.checks)
                Ke.kind === "int" ? T.util.isInteger(me.data) || (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "min" ? (Ke.inclusive ? me.data < Ke.value : me.data <= Ke.value) && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.too_small,
                    minimum: Ke.value,
                    type: "number",
                    inclusive: Ke.inclusive,
                    exact: !1,
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "max" ? (Ke.inclusive ? me.data > Ke.value : me.data >= Ke.value) && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.too_big,
                    maximum: Ke.value,
                    type: "number",
                    inclusive: Ke.inclusive,
                    exact: !1,
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "multipleOf" ? ge(me.data, Ke.value) !== 0 && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.not_multiple_of,
                    multipleOf: Ke.value,
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "finite" ? Number.isFinite(me.data) || (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.not_finite,
                    message: Ke.message
                }),
                Qe.dirty()) : T.util.assertNever(Ke);
            return {
                status: Qe.value,
                value: me.data
            }
        }
        gte(me, ke) {
            return this.setLimit("min", me, !0, E.errorUtil.toString(ke))
        }
        gt(me, ke) {
            return this.setLimit("min", me, !1, E.errorUtil.toString(ke))
        }
        lte(me, ke) {
            return this.setLimit("max", me, !0, E.errorUtil.toString(ke))
        }
        lt(me, ke) {
            return this.setLimit("max", me, !1, E.errorUtil.toString(ke))
        }
        setLimit(me, ke, Le, Qe) {
            return new we({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: me,
                    value: ke,
                    inclusive: Le,
                    message: E.errorUtil.toString(Qe)
                }]
            })
        }
        _addCheck(me) {
            return new we({
                ...this._def,
                checks: [...this._def.checks, me]
            })
        }
        int(me) {
            return this._addCheck({
                kind: "int",
                message: E.errorUtil.toString(me)
            })
        }
        positive(me) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: E.errorUtil.toString(me)
            })
        }
        negative(me) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: E.errorUtil.toString(me)
            })
        }
        nonpositive(me) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: E.errorUtil.toString(me)
            })
        }
        nonnegative(me) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: E.errorUtil.toString(me)
            })
        }
        multipleOf(me, ke) {
            return this._addCheck({
                kind: "multipleOf",
                value: me,
                message: E.errorUtil.toString(ke)
            })
        }
        finite(me) {
            return this._addCheck({
                kind: "finite",
                message: E.errorUtil.toString(me)
            })
        }
        safe(me) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: E.errorUtil.toString(me)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: E.errorUtil.toString(me)
            })
        }
        get minValue() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "min" && (me === null || ke.value > me) && (me = ke.value);
            return me
        }
        get maxValue() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "max" && (me === null || ke.value < me) && (me = ke.value);
            return me
        }
        get isInt() {
            return !!this._def.checks.find(me=>me.kind === "int" || me.kind === "multipleOf" && T.util.isInteger(me.value))
        }
        get isFinite() {
            let me = null
              , ke = null;
            for (const Le of this._def.checks) {
                if (Le.kind === "finite" || Le.kind === "int" || Le.kind === "multipleOf")
                    return !0;
                Le.kind === "min" ? (ke === null || Le.value > ke) && (ke = Le.value) : Le.kind === "max" && (me === null || Le.value < me) && (me = Le.value)
            }
            return Number.isFinite(ke) && Number.isFinite(me)
        }
    }
    C.ZodNumber = we,
    we.create = Ve=>new we({
        checks: [],
        typeName: Ie.ZodNumber,
        coerce: (Ve == null ? void 0 : Ve.coerce) || !1,
        ...F(Ve)
    });
    class Ae extends N {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(me) {
            if (this._def.coerce && (me.data = BigInt(me.data)),
            this._getType(me) !== T.ZodParsedType.bigint) {
                const Ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.bigint,
                    received: Ke.parsedType
                }),
                M.INVALID
            }
            let Le;
            const Qe = new M.ParseStatus;
            for (const Ke of this._def.checks)
                Ke.kind === "min" ? (Ke.inclusive ? me.data < Ke.value : me.data <= Ke.value) && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.too_small,
                    type: "bigint",
                    minimum: Ke.value,
                    inclusive: Ke.inclusive,
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "max" ? (Ke.inclusive ? me.data > Ke.value : me.data >= Ke.value) && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.too_big,
                    type: "bigint",
                    maximum: Ke.value,
                    inclusive: Ke.inclusive,
                    message: Ke.message
                }),
                Qe.dirty()) : Ke.kind === "multipleOf" ? me.data % Ke.value !== BigInt(0) && (Le = this._getOrReturnCtx(me, Le),
                (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.not_multiple_of,
                    multipleOf: Ke.value,
                    message: Ke.message
                }),
                Qe.dirty()) : T.util.assertNever(Ke);
            return {
                status: Qe.value,
                value: me.data
            }
        }
        gte(me, ke) {
            return this.setLimit("min", me, !0, E.errorUtil.toString(ke))
        }
        gt(me, ke) {
            return this.setLimit("min", me, !1, E.errorUtil.toString(ke))
        }
        lte(me, ke) {
            return this.setLimit("max", me, !0, E.errorUtil.toString(ke))
        }
        lt(me, ke) {
            return this.setLimit("max", me, !1, E.errorUtil.toString(ke))
        }
        setLimit(me, ke, Le, Qe) {
            return new Ae({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: me,
                    value: ke,
                    inclusive: Le,
                    message: E.errorUtil.toString(Qe)
                }]
            })
        }
        _addCheck(me) {
            return new Ae({
                ...this._def,
                checks: [...this._def.checks, me]
            })
        }
        positive(me) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: E.errorUtil.toString(me)
            })
        }
        negative(me) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: E.errorUtil.toString(me)
            })
        }
        nonpositive(me) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: E.errorUtil.toString(me)
            })
        }
        nonnegative(me) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: E.errorUtil.toString(me)
            })
        }
        multipleOf(me, ke) {
            return this._addCheck({
                kind: "multipleOf",
                value: me,
                message: E.errorUtil.toString(ke)
            })
        }
        get minValue() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "min" && (me === null || ke.value > me) && (me = ke.value);
            return me
        }
        get maxValue() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "max" && (me === null || ke.value < me) && (me = ke.value);
            return me
        }
    }
    C.ZodBigInt = Ae,
    Ae.create = Ve=>{
        var me;
        return new Ae({
            checks: [],
            typeName: Ie.ZodBigInt,
            coerce: (me = Ve == null ? void 0 : Ve.coerce) !== null && me !== void 0 ? me : !1,
            ...F(Ve)
        })
    }
    ;
    class Se extends N {
        _parse(me) {
            if (this._def.coerce && (me.data = !!me.data),
            this._getType(me) !== T.ZodParsedType.boolean) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.boolean,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodBoolean = Se,
    Se.create = Ve=>new Se({
        typeName: Ie.ZodBoolean,
        coerce: (Ve == null ? void 0 : Ve.coerce) || !1,
        ...F(Ve)
    });
    class ue extends N {
        _parse(me) {
            if (this._def.coerce && (me.data = new Date(me.data)),
            this._getType(me) !== T.ZodParsedType.date) {
                const Ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.date,
                    received: Ke.parsedType
                }),
                M.INVALID
            }
            if (isNaN(me.data.getTime())) {
                const Ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Ke, {
                    code: $.ZodIssueCode.invalid_date
                }),
                M.INVALID
            }
            const Le = new M.ParseStatus;
            let Qe;
            for (const Ke of this._def.checks)
                Ke.kind === "min" ? me.data.getTime() < Ke.value && (Qe = this._getOrReturnCtx(me, Qe),
                (0,
                M.addIssueToContext)(Qe, {
                    code: $.ZodIssueCode.too_small,
                    message: Ke.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: Ke.value,
                    type: "date"
                }),
                Le.dirty()) : Ke.kind === "max" ? me.data.getTime() > Ke.value && (Qe = this._getOrReturnCtx(me, Qe),
                (0,
                M.addIssueToContext)(Qe, {
                    code: $.ZodIssueCode.too_big,
                    message: Ke.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: Ke.value,
                    type: "date"
                }),
                Le.dirty()) : T.util.assertNever(Ke);
            return {
                status: Le.value,
                value: new Date(me.data.getTime())
            }
        }
        _addCheck(me) {
            return new ue({
                ...this._def,
                checks: [...this._def.checks, me]
            })
        }
        min(me, ke) {
            return this._addCheck({
                kind: "min",
                value: me.getTime(),
                message: E.errorUtil.toString(ke)
            })
        }
        max(me, ke) {
            return this._addCheck({
                kind: "max",
                value: me.getTime(),
                message: E.errorUtil.toString(ke)
            })
        }
        get minDate() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "min" && (me === null || ke.value > me) && (me = ke.value);
            return me != null ? new Date(me) : null
        }
        get maxDate() {
            let me = null;
            for (const ke of this._def.checks)
                ke.kind === "max" && (me === null || ke.value < me) && (me = ke.value);
            return me != null ? new Date(me) : null
        }
    }
    C.ZodDate = ue,
    ue.create = Ve=>new ue({
        checks: [],
        coerce: (Ve == null ? void 0 : Ve.coerce) || !1,
        typeName: Ie.ZodDate,
        ...F(Ve)
    });
    class V extends N {
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.symbol) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.symbol,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodSymbol = V,
    V.create = Ve=>new V({
        typeName: Ie.ZodSymbol,
        ...F(Ve)
    });
    class W extends N {
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.undefined) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.undefined,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodUndefined = W,
    W.create = Ve=>new W({
        typeName: Ie.ZodUndefined,
        ...F(Ve)
    });
    class D extends N {
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.null) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.null,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodNull = D,
    D.create = Ve=>new D({
        typeName: Ie.ZodNull,
        ...F(Ve)
    });
    class I extends N {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(me) {
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodAny = I,
    I.create = Ve=>new I({
        typeName: Ie.ZodAny,
        ...F(Ve)
    });
    class L extends N {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(me) {
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodUnknown = L,
    L.create = Ve=>new L({
        typeName: Ie.ZodUnknown,
        ...F(Ve)
    });
    class K extends N {
        _parse(me) {
            const ke = this._getOrReturnCtx(me);
            return (0,
            M.addIssueToContext)(ke, {
                code: $.ZodIssueCode.invalid_type,
                expected: T.ZodParsedType.never,
                received: ke.parsedType
            }),
            M.INVALID
        }
    }
    C.ZodNever = K,
    K.create = Ve=>new K({
        typeName: Ie.ZodNever,
        ...F(Ve)
    });
    class X extends N {
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.undefined) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.void,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
    }
    C.ZodVoid = X,
    X.create = Ve=>new X({
        typeName: Ie.ZodVoid,
        ...F(Ve)
    });
    class Y extends N {
        _parse(me) {
            const {ctx: ke, status: Le} = this._processInputParams(me)
              , Qe = this._def;
            if (ke.parsedType !== T.ZodParsedType.array)
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.array,
                    received: ke.parsedType
                }),
                M.INVALID;
            if (Qe.exactLength !== null) {
                const vt = ke.data.length > Qe.exactLength.value
                  , dt = ke.data.length < Qe.exactLength.value;
                (vt || dt) && ((0,
                M.addIssueToContext)(ke, {
                    code: vt ? $.ZodIssueCode.too_big : $.ZodIssueCode.too_small,
                    minimum: dt ? Qe.exactLength.value : void 0,
                    maximum: vt ? Qe.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: Qe.exactLength.message
                }),
                Le.dirty())
            }
            if (Qe.minLength !== null && ke.data.length < Qe.minLength.value && ((0,
            M.addIssueToContext)(ke, {
                code: $.ZodIssueCode.too_small,
                minimum: Qe.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: Qe.minLength.message
            }),
            Le.dirty()),
            Qe.maxLength !== null && ke.data.length > Qe.maxLength.value && ((0,
            M.addIssueToContext)(ke, {
                code: $.ZodIssueCode.too_big,
                maximum: Qe.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: Qe.maxLength.message
            }),
            Le.dirty()),
            ke.common.async)
                return Promise.all([...ke.data].map((vt,dt)=>Qe.type._parseAsync(new B(ke,vt,ke.path,dt)))).then(vt=>M.ParseStatus.mergeArray(Le, vt));
            const Ke = [...ke.data].map((vt,dt)=>Qe.type._parseSync(new B(ke,vt,ke.path,dt)));
            return M.ParseStatus.mergeArray(Le, Ke)
        }
        get element() {
            return this._def.type
        }
        min(me, ke) {
            return new Y({
                ...this._def,
                minLength: {
                    value: me,
                    message: E.errorUtil.toString(ke)
                }
            })
        }
        max(me, ke) {
            return new Y({
                ...this._def,
                maxLength: {
                    value: me,
                    message: E.errorUtil.toString(ke)
                }
            })
        }
        length(me, ke) {
            return new Y({
                ...this._def,
                exactLength: {
                    value: me,
                    message: E.errorUtil.toString(ke)
                }
            })
        }
        nonempty(me) {
            return this.min(1, me)
        }
    }
    C.ZodArray = Y,
    Y.create = (Ve,me)=>new Y({
        type: Ve,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: Ie.ZodArray,
        ...F(me)
    });
    function j(Ve) {
        if (Ve instanceof G) {
            const me = {};
            for (const ke in Ve.shape) {
                const Le = Ve.shape[ke];
                me[ke] = De.create(j(Le))
            }
            return new G({
                ...Ve._def,
                shape: ()=>me
            })
        } else
            return Ve instanceof Y ? new Y({
                ...Ve._def,
                type: j(Ve.element)
            }) : Ve instanceof De ? De.create(j(Ve.unwrap())) : Ve instanceof Ue ? Ue.create(j(Ve.unwrap())) : Ve instanceof Te ? Te.create(Ve.items.map(me=>j(me))) : Ve
    }
    class G extends N {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const me = this._def.shape()
              , ke = T.util.objectKeys(me);
            return this._cached = {
                shape: me,
                keys: ke
            }
        }
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.object) {
                const xt = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(xt, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.object,
                    received: xt.parsedType
                }),
                M.INVALID
            }
            const {status: Le, ctx: Qe} = this._processInputParams(me)
              , {shape: Ke, keys: vt} = this._getCached()
              , dt = [];
            if (!(this._def.catchall instanceof K && this._def.unknownKeys === "strip"))
                for (const xt in Qe.data)
                    vt.includes(xt) || dt.push(xt);
            const It = [];
            for (const xt of vt) {
                const Dt = Ke[xt]
                  , qt = Qe.data[xt];
                It.push({
                    key: {
                        status: "valid",
                        value: xt
                    },
                    value: Dt._parse(new B(Qe,qt,Qe.path,xt)),
                    alwaysSet: xt in Qe.data
                })
            }
            if (this._def.catchall instanceof K) {
                const xt = this._def.unknownKeys;
                if (xt === "passthrough")
                    for (const Dt of dt)
                        It.push({
                            key: {
                                status: "valid",
                                value: Dt
                            },
                            value: {
                                status: "valid",
                                value: Qe.data[Dt]
                            }
                        });
                else if (xt === "strict")
                    dt.length > 0 && ((0,
                    M.addIssueToContext)(Qe, {
                        code: $.ZodIssueCode.unrecognized_keys,
                        keys: dt
                    }),
                    Le.dirty());
                else if (xt !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const xt = this._def.catchall;
                for (const Dt of dt) {
                    const qt = Qe.data[Dt];
                    It.push({
                        key: {
                            status: "valid",
                            value: Dt
                        },
                        value: xt._parse(new B(Qe,qt,Qe.path,Dt)),
                        alwaysSet: Dt in Qe.data
                    })
                }
            }
            return Qe.common.async ? Promise.resolve().then(async()=>{
                const xt = [];
                for (const Dt of It) {
                    const qt = await Dt.key;
                    xt.push({
                        key: qt,
                        value: await Dt.value,
                        alwaysSet: Dt.alwaysSet
                    })
                }
                return xt
            }
            ).then(xt=>M.ParseStatus.mergeObjectSync(Le, xt)) : M.ParseStatus.mergeObjectSync(Le, It)
        }
        get shape() {
            return this._def.shape()
        }
        strict(me) {
            return E.errorUtil.errToObj,
            new G({
                ...this._def,
                unknownKeys: "strict",
                ...me !== void 0 ? {
                    errorMap: (ke,Le)=>{
                        var Qe, Ke, vt, dt;
                        const It = (vt = (Ke = (Qe = this._def).errorMap) === null || Ke === void 0 ? void 0 : Ke.call(Qe, ke, Le).message) !== null && vt !== void 0 ? vt : Le.defaultError;
                        return ke.code === "unrecognized_keys" ? {
                            message: (dt = E.errorUtil.errToObj(me).message) !== null && dt !== void 0 ? dt : It
                        } : {
                            message: It
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new G({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new G({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(me) {
            return new G({
                ...this._def,
                shape: ()=>({
                    ...this._def.shape(),
                    ...me
                })
            })
        }
        merge(me) {
            return new G({
                unknownKeys: me._def.unknownKeys,
                catchall: me._def.catchall,
                shape: ()=>({
                    ...this._def.shape(),
                    ...me._def.shape()
                }),
                typeName: Ie.ZodObject
            })
        }
        setKey(me, ke) {
            return this.augment({
                [me]: ke
            })
        }
        catchall(me) {
            return new G({
                ...this._def,
                catchall: me
            })
        }
        pick(me) {
            const ke = {};
            return T.util.objectKeys(me).forEach(Le=>{
                me[Le] && this.shape[Le] && (ke[Le] = this.shape[Le])
            }
            ),
            new G({
                ...this._def,
                shape: ()=>ke
            })
        }
        omit(me) {
            const ke = {};
            return T.util.objectKeys(this.shape).forEach(Le=>{
                me[Le] || (ke[Le] = this.shape[Le])
            }
            ),
            new G({
                ...this._def,
                shape: ()=>ke
            })
        }
        deepPartial() {
            return j(this)
        }
        partial(me) {
            const ke = {};
            return T.util.objectKeys(this.shape).forEach(Le=>{
                const Qe = this.shape[Le];
                me && !me[Le] ? ke[Le] = Qe : ke[Le] = Qe.optional()
            }
            ),
            new G({
                ...this._def,
                shape: ()=>ke
            })
        }
        required(me) {
            const ke = {};
            return T.util.objectKeys(this.shape).forEach(Le=>{
                if (me && !me[Le])
                    ke[Le] = this.shape[Le];
                else {
                    let Ke = this.shape[Le];
                    for (; Ke instanceof De; )
                        Ke = Ke._def.innerType;
                    ke[Le] = Ke
                }
            }
            ),
            new G({
                ...this._def,
                shape: ()=>ke
            })
        }
        keyof() {
            return ze(T.util.objectKeys(this.shape))
        }
    }
    C.ZodObject = G,
    G.create = (Ve,me)=>new G({
        shape: ()=>Ve,
        unknownKeys: "strip",
        catchall: K.create(),
        typeName: Ie.ZodObject,
        ...F(me)
    }),
    G.strictCreate = (Ve,me)=>new G({
        shape: ()=>Ve,
        unknownKeys: "strict",
        catchall: K.create(),
        typeName: Ie.ZodObject,
        ...F(me)
    }),
    G.lazycreate = (Ve,me)=>new G({
        shape: Ve,
        unknownKeys: "strip",
        catchall: K.create(),
        typeName: Ie.ZodObject,
        ...F(me)
    });
    class ne extends N {
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me)
              , Le = this._def.options;
            function Qe(Ke) {
                for (const dt of Ke)
                    if (dt.result.status === "valid")
                        return dt.result;
                for (const dt of Ke)
                    if (dt.result.status === "dirty")
                        return ke.common.issues.push(...dt.ctx.common.issues),
                        dt.result;
                const vt = Ke.map(dt=>new $.ZodError(dt.ctx.common.issues));
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_union,
                    unionErrors: vt
                }),
                M.INVALID
            }
            if (ke.common.async)
                return Promise.all(Le.map(async Ke=>{
                    const vt = {
                        ...ke,
                        common: {
                            ...ke.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await Ke._parseAsync({
                            data: ke.data,
                            path: ke.path,
                            parent: vt
                        }),
                        ctx: vt
                    }
                }
                )).then(Qe);
            {
                let Ke;
                const vt = [];
                for (const It of Le) {
                    const xt = {
                        ...ke,
                        common: {
                            ...ke.common,
                            issues: []
                        },
                        parent: null
                    }
                      , Dt = It._parseSync({
                        data: ke.data,
                        path: ke.path,
                        parent: xt
                    });
                    if (Dt.status === "valid")
                        return Dt;
                    Dt.status === "dirty" && !Ke && (Ke = {
                        result: Dt,
                        ctx: xt
                    }),
                    xt.common.issues.length && vt.push(xt.common.issues)
                }
                if (Ke)
                    return ke.common.issues.push(...Ke.ctx.common.issues),
                    Ke.result;
                const dt = vt.map(It=>new $.ZodError(It));
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_union,
                    unionErrors: dt
                }),
                M.INVALID
            }
        }
        get options() {
            return this._def.options
        }
    }
    C.ZodUnion = ne,
    ne.create = (Ve,me)=>new ne({
        options: Ve,
        typeName: Ie.ZodUnion,
        ...F(me)
    });
    const te = Ve=>Ve instanceof be ? te(Ve.schema) : Ve instanceof ct ? te(Ve.innerType()) : Ve instanceof Ce ? [Ve.value] : Ve instanceof Ge ? Ve.options : Ve instanceof nt ? Object.keys(Ve.enum) : Ve instanceof We ? te(Ve._def.innerType) : Ve instanceof W ? [void 0] : Ve instanceof D ? [null] : null;
    class ce extends N {
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me);
            if (ke.parsedType !== T.ZodParsedType.object)
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.object,
                    received: ke.parsedType
                }),
                M.INVALID;
            const Le = this.discriminator
              , Qe = ke.data[Le]
              , Ke = this.optionsMap.get(Qe);
            return Ke ? ke.common.async ? Ke._parseAsync({
                data: ke.data,
                path: ke.path,
                parent: ke
            }) : Ke._parseSync({
                data: ke.data,
                path: ke.path,
                parent: ke
            }) : ((0,
            M.addIssueToContext)(ke, {
                code: $.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [Le]
            }),
            M.INVALID)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(me, ke, Le) {
            const Qe = new Map;
            for (const Ke of ke) {
                const vt = te(Ke.shape[me]);
                if (!vt)
                    throw new Error(`A discriminator value for key \`${me}\` could not be extracted from all schema options`);
                for (const dt of vt) {
                    if (Qe.has(dt))
                        throw new Error(`Discriminator property ${String(me)} has duplicate value ${String(dt)}`);
                    Qe.set(dt, Ke)
                }
            }
            return new ce({
                typeName: Ie.ZodDiscriminatedUnion,
                discriminator: me,
                options: ke,
                optionsMap: Qe,
                ...F(Le)
            })
        }
    }
    C.ZodDiscriminatedUnion = ce;
    function Ee(Ve, me) {
        const ke = (0,
        T.getParsedType)(Ve)
          , Le = (0,
        T.getParsedType)(me);
        if (Ve === me)
            return {
                valid: !0,
                data: Ve
            };
        if (ke === T.ZodParsedType.object && Le === T.ZodParsedType.object) {
            const Qe = T.util.objectKeys(me)
              , Ke = T.util.objectKeys(Ve).filter(dt=>Qe.indexOf(dt) !== -1)
              , vt = {
                ...Ve,
                ...me
            };
            for (const dt of Ke) {
                const It = Ee(Ve[dt], me[dt]);
                if (!It.valid)
                    return {
                        valid: !1
                    };
                vt[dt] = It.data
            }
            return {
                valid: !0,
                data: vt
            }
        } else if (ke === T.ZodParsedType.array && Le === T.ZodParsedType.array) {
            if (Ve.length !== me.length)
                return {
                    valid: !1
                };
            const Qe = [];
            for (let Ke = 0; Ke < Ve.length; Ke++) {
                const vt = Ve[Ke]
                  , dt = me[Ke]
                  , It = Ee(vt, dt);
                if (!It.valid)
                    return {
                        valid: !1
                    };
                Qe.push(It.data)
            }
            return {
                valid: !0,
                data: Qe
            }
        } else
            return ke === T.ZodParsedType.date && Le === T.ZodParsedType.date && +Ve == +me ? {
                valid: !0,
                data: Ve
            } : {
                valid: !1
            }
    }
    class Re extends N {
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me)
              , Qe = (Ke,vt)=>{
                if ((0,
                M.isAborted)(Ke) || (0,
                M.isAborted)(vt))
                    return M.INVALID;
                const dt = Ee(Ke.value, vt.value);
                return dt.valid ? (((0,
                M.isDirty)(Ke) || (0,
                M.isDirty)(vt)) && ke.dirty(),
                {
                    status: ke.value,
                    value: dt.data
                }) : ((0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_intersection_types
                }),
                M.INVALID)
            }
            ;
            return Le.common.async ? Promise.all([this._def.left._parseAsync({
                data: Le.data,
                path: Le.path,
                parent: Le
            }), this._def.right._parseAsync({
                data: Le.data,
                path: Le.path,
                parent: Le
            })]).then(([Ke,vt])=>Qe(Ke, vt)) : Qe(this._def.left._parseSync({
                data: Le.data,
                path: Le.path,
                parent: Le
            }), this._def.right._parseSync({
                data: Le.data,
                path: Le.path,
                parent: Le
            }))
        }
    }
    C.ZodIntersection = Re,
    Re.create = (Ve,me,ke)=>new Re({
        left: Ve,
        right: me,
        typeName: Ie.ZodIntersection,
        ...F(ke)
    });
    class Te extends N {
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me);
            if (Le.parsedType !== T.ZodParsedType.array)
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.array,
                    received: Le.parsedType
                }),
                M.INVALID;
            if (Le.data.length < this._def.items.length)
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                M.INVALID;
            !this._def.rest && Le.data.length > this._def.items.length && ((0,
            M.addIssueToContext)(Le, {
                code: $.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            ke.dirty());
            const Ke = [...Le.data].map((vt,dt)=>{
                const It = this._def.items[dt] || this._def.rest;
                return It ? It._parse(new B(Le,vt,Le.path,dt)) : null
            }
            ).filter(vt=>!!vt);
            return Le.common.async ? Promise.all(Ke).then(vt=>M.ParseStatus.mergeArray(ke, vt)) : M.ParseStatus.mergeArray(ke, Ke)
        }
        get items() {
            return this._def.items
        }
        rest(me) {
            return new Te({
                ...this._def,
                rest: me
            })
        }
    }
    C.ZodTuple = Te,
    Te.create = (Ve,me)=>{
        if (!Array.isArray(Ve))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new Te({
            items: Ve,
            typeName: Ie.ZodTuple,
            rest: null,
            ...F(me)
        })
    }
    ;
    class xe extends N {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me);
            if (Le.parsedType !== T.ZodParsedType.object)
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.object,
                    received: Le.parsedType
                }),
                M.INVALID;
            const Qe = []
              , Ke = this._def.keyType
              , vt = this._def.valueType;
            for (const dt in Le.data)
                Qe.push({
                    key: Ke._parse(new B(Le,dt,Le.path,dt)),
                    value: vt._parse(new B(Le,Le.data[dt],Le.path,dt))
                });
            return Le.common.async ? M.ParseStatus.mergeObjectAsync(ke, Qe) : M.ParseStatus.mergeObjectSync(ke, Qe)
        }
        get element() {
            return this._def.valueType
        }
        static create(me, ke, Le) {
            return ke instanceof N ? new xe({
                keyType: me,
                valueType: ke,
                typeName: Ie.ZodRecord,
                ...F(Le)
            }) : new xe({
                keyType: pe.create(),
                valueType: me,
                typeName: Ie.ZodRecord,
                ...F(ke)
            })
        }
    }
    C.ZodRecord = xe;
    class ve extends N {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me);
            if (Le.parsedType !== T.ZodParsedType.map)
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.map,
                    received: Le.parsedType
                }),
                M.INVALID;
            const Qe = this._def.keyType
              , Ke = this._def.valueType
              , vt = [...Le.data.entries()].map(([dt,It],xt)=>({
                key: Qe._parse(new B(Le,dt,Le.path,[xt, "key"])),
                value: Ke._parse(new B(Le,It,Le.path,[xt, "value"]))
            }));
            if (Le.common.async) {
                const dt = new Map;
                return Promise.resolve().then(async()=>{
                    for (const It of vt) {
                        const xt = await It.key
                          , Dt = await It.value;
                        if (xt.status === "aborted" || Dt.status === "aborted")
                            return M.INVALID;
                        (xt.status === "dirty" || Dt.status === "dirty") && ke.dirty(),
                        dt.set(xt.value, Dt.value)
                    }
                    return {
                        status: ke.value,
                        value: dt
                    }
                }
                )
            } else {
                const dt = new Map;
                for (const It of vt) {
                    const xt = It.key
                      , Dt = It.value;
                    if (xt.status === "aborted" || Dt.status === "aborted")
                        return M.INVALID;
                    (xt.status === "dirty" || Dt.status === "dirty") && ke.dirty(),
                    dt.set(xt.value, Dt.value)
                }
                return {
                    status: ke.value,
                    value: dt
                }
            }
        }
    }
    C.ZodMap = ve,
    ve.create = (Ve,me,ke)=>new ve({
        valueType: me,
        keyType: Ve,
        typeName: Ie.ZodMap,
        ...F(ke)
    });
    class Me extends N {
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me);
            if (Le.parsedType !== T.ZodParsedType.set)
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.set,
                    received: Le.parsedType
                }),
                M.INVALID;
            const Qe = this._def;
            Qe.minSize !== null && Le.data.size < Qe.minSize.value && ((0,
            M.addIssueToContext)(Le, {
                code: $.ZodIssueCode.too_small,
                minimum: Qe.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: Qe.minSize.message
            }),
            ke.dirty()),
            Qe.maxSize !== null && Le.data.size > Qe.maxSize.value && ((0,
            M.addIssueToContext)(Le, {
                code: $.ZodIssueCode.too_big,
                maximum: Qe.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: Qe.maxSize.message
            }),
            ke.dirty());
            const Ke = this._def.valueType;
            function vt(It) {
                const xt = new Set;
                for (const Dt of It) {
                    if (Dt.status === "aborted")
                        return M.INVALID;
                    Dt.status === "dirty" && ke.dirty(),
                    xt.add(Dt.value)
                }
                return {
                    status: ke.value,
                    value: xt
                }
            }
            const dt = [...Le.data.values()].map((It,xt)=>Ke._parse(new B(Le,It,Le.path,xt)));
            return Le.common.async ? Promise.all(dt).then(It=>vt(It)) : vt(dt)
        }
        min(me, ke) {
            return new Me({
                ...this._def,
                minSize: {
                    value: me,
                    message: E.errorUtil.toString(ke)
                }
            })
        }
        max(me, ke) {
            return new Me({
                ...this._def,
                maxSize: {
                    value: me,
                    message: E.errorUtil.toString(ke)
                }
            })
        }
        size(me, ke) {
            return this.min(me, ke).max(me, ke)
        }
        nonempty(me) {
            return this.min(1, me)
        }
    }
    C.ZodSet = Me,
    Me.create = (Ve,me)=>new Me({
        valueType: Ve,
        minSize: null,
        maxSize: null,
        typeName: Ie.ZodSet,
        ...F(me)
    });
    class Fe extends N {
        constructor() {
            super(...arguments),
            this.validate = this.implement
        }
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me);
            if (ke.parsedType !== T.ZodParsedType.function)
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.function,
                    received: ke.parsedType
                }),
                M.INVALID;
            function Le(dt, It) {
                return (0,
                M.makeIssue)({
                    data: dt,
                    path: ke.path,
                    errorMaps: [ke.common.contextualErrorMap, ke.schemaErrorMap, (0,
                    S.getErrorMap)(), S.defaultErrorMap].filter(xt=>!!xt),
                    issueData: {
                        code: $.ZodIssueCode.invalid_arguments,
                        argumentsError: It
                    }
                })
            }
            function Qe(dt, It) {
                return (0,
                M.makeIssue)({
                    data: dt,
                    path: ke.path,
                    errorMaps: [ke.common.contextualErrorMap, ke.schemaErrorMap, (0,
                    S.getErrorMap)(), S.defaultErrorMap].filter(xt=>!!xt),
                    issueData: {
                        code: $.ZodIssueCode.invalid_return_type,
                        returnTypeError: It
                    }
                })
            }
            const Ke = {
                errorMap: ke.common.contextualErrorMap
            }
              , vt = ke.data;
            if (this._def.returns instanceof bt) {
                const dt = this;
                return (0,
                M.OK)(async function(...It) {
                    const xt = new $.ZodError([])
                      , Dt = await dt._def.args.parseAsync(It, Ke).catch(mt=>{
                        throw xt.addIssue(Le(It, mt)),
                        xt
                    }
                    )
                      , qt = await Reflect.apply(vt, this, Dt);
                    return await dt._def.returns._def.type.parseAsync(qt, Ke).catch(mt=>{
                        throw xt.addIssue(Qe(qt, mt)),
                        xt
                    }
                    )
                })
            } else {
                const dt = this;
                return (0,
                M.OK)(function(...It) {
                    const xt = dt._def.args.safeParse(It, Ke);
                    if (!xt.success)
                        throw new $.ZodError([Le(It, xt.error)]);
                    const Dt = Reflect.apply(vt, this, xt.data)
                      , qt = dt._def.returns.safeParse(Dt, Ke);
                    if (!qt.success)
                        throw new $.ZodError([Qe(Dt, qt.error)]);
                    return qt.data
                })
            }
        }
        parameters() {
            return this._def.args
        }
        returnType() {
            return this._def.returns
        }
        args(...me) {
            return new Fe({
                ...this._def,
                args: Te.create(me).rest(L.create())
            })
        }
        returns(me) {
            return new Fe({
                ...this._def,
                returns: me
            })
        }
        implement(me) {
            return this.parse(me)
        }
        strictImplement(me) {
            return this.parse(me)
        }
        static create(me, ke, Le) {
            return new Fe({
                args: me || Te.create([]).rest(L.create()),
                returns: ke || L.create(),
                typeName: Ie.ZodFunction,
                ...F(Le)
            })
        }
    }
    C.ZodFunction = Fe;
    class be extends N {
        get schema() {
            return this._def.getter()
        }
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me);
            return this._def.getter()._parse({
                data: ke.data,
                path: ke.path,
                parent: ke
            })
        }
    }
    C.ZodLazy = be,
    be.create = (Ve,me)=>new be({
        getter: Ve,
        typeName: Ie.ZodLazy,
        ...F(me)
    });
    class Ce extends N {
        _parse(me) {
            if (me.data !== this._def.value) {
                const ke = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(ke, {
                    received: ke.data,
                    code: $.ZodIssueCode.invalid_literal,
                    expected: this._def.value
                }),
                M.INVALID
            }
            return {
                status: "valid",
                value: me.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    C.ZodLiteral = Ce,
    Ce.create = (Ve,me)=>new Ce({
        value: Ve,
        typeName: Ie.ZodLiteral,
        ...F(me)
    });
    function ze(Ve, me) {
        return new Ge({
            values: Ve,
            typeName: Ie.ZodEnum,
            ...F(me)
        })
    }
    class Ge extends N {
        _parse(me) {
            if (typeof me.data != "string") {
                const ke = this._getOrReturnCtx(me)
                  , Le = this._def.values;
                return (0,
                M.addIssueToContext)(ke, {
                    expected: T.util.joinValues(Le),
                    received: ke.parsedType,
                    code: $.ZodIssueCode.invalid_type
                }),
                M.INVALID
            }
            if (this._def.values.indexOf(me.data) === -1) {
                const ke = this._getOrReturnCtx(me)
                  , Le = this._def.values;
                return (0,
                M.addIssueToContext)(ke, {
                    received: ke.data,
                    code: $.ZodIssueCode.invalid_enum_value,
                    options: Le
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const me = {};
            for (const ke of this._def.values)
                me[ke] = ke;
            return me
        }
        get Values() {
            const me = {};
            for (const ke of this._def.values)
                me[ke] = ke;
            return me
        }
        get Enum() {
            const me = {};
            for (const ke of this._def.values)
                me[ke] = ke;
            return me
        }
        extract(me) {
            return Ge.create(me)
        }
        exclude(me) {
            return Ge.create(this.options.filter(ke=>!me.includes(ke)))
        }
    }
    C.ZodEnum = Ge,
    Ge.create = ze;
    class nt extends N {
        _parse(me) {
            const ke = T.util.getValidEnumValues(this._def.values)
              , Le = this._getOrReturnCtx(me);
            if (Le.parsedType !== T.ZodParsedType.string && Le.parsedType !== T.ZodParsedType.number) {
                const Qe = T.util.objectValues(ke);
                return (0,
                M.addIssueToContext)(Le, {
                    expected: T.util.joinValues(Qe),
                    received: Le.parsedType,
                    code: $.ZodIssueCode.invalid_type
                }),
                M.INVALID
            }
            if (ke.indexOf(me.data) === -1) {
                const Qe = T.util.objectValues(ke);
                return (0,
                M.addIssueToContext)(Le, {
                    received: Le.data,
                    code: $.ZodIssueCode.invalid_enum_value,
                    options: Qe
                }),
                M.INVALID
            }
            return (0,
            M.OK)(me.data)
        }
        get enum() {
            return this._def.values
        }
    }
    C.ZodNativeEnum = nt,
    nt.create = (Ve,me)=>new nt({
        values: Ve,
        typeName: Ie.ZodNativeEnum,
        ...F(me)
    });
    class bt extends N {
        unwrap() {
            return this._def.type
        }
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me);
            if (ke.parsedType !== T.ZodParsedType.promise && ke.common.async === !1)
                return (0,
                M.addIssueToContext)(ke, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.promise,
                    received: ke.parsedType
                }),
                M.INVALID;
            const Le = ke.parsedType === T.ZodParsedType.promise ? ke.data : Promise.resolve(ke.data);
            return (0,
            M.OK)(Le.then(Qe=>this._def.type.parseAsync(Qe, {
                path: ke.path,
                errorMap: ke.common.contextualErrorMap
            })))
        }
    }
    C.ZodPromise = bt,
    bt.create = (Ve,me)=>new bt({
        type: Ve,
        typeName: Ie.ZodPromise,
        ...F(me)
    });
    class ct extends N {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === Ie.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me)
              , Qe = this._def.effect || null
              , Ke = {
                addIssue: vt=>{
                    (0,
                    M.addIssueToContext)(Le, vt),
                    vt.fatal ? ke.abort() : ke.dirty()
                }
                ,
                get path() {
                    return Le.path
                }
            };
            if (Ke.addIssue = Ke.addIssue.bind(Ke),
            Qe.type === "preprocess") {
                const vt = Qe.transform(Le.data, Ke);
                return Le.common.issues.length ? {
                    status: "dirty",
                    value: Le.data
                } : Le.common.async ? Promise.resolve(vt).then(dt=>this._def.schema._parseAsync({
                    data: dt,
                    path: Le.path,
                    parent: Le
                })) : this._def.schema._parseSync({
                    data: vt,
                    path: Le.path,
                    parent: Le
                })
            }
            if (Qe.type === "refinement") {
                const vt = dt=>{
                    const It = Qe.refinement(dt, Ke);
                    if (Le.common.async)
                        return Promise.resolve(It);
                    if (It instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return dt
                }
                ;
                if (Le.common.async === !1) {
                    const dt = this._def.schema._parseSync({
                        data: Le.data,
                        path: Le.path,
                        parent: Le
                    });
                    return dt.status === "aborted" ? M.INVALID : (dt.status === "dirty" && ke.dirty(),
                    vt(dt.value),
                    {
                        status: ke.value,
                        value: dt.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: Le.data,
                        path: Le.path,
                        parent: Le
                    }).then(dt=>dt.status === "aborted" ? M.INVALID : (dt.status === "dirty" && ke.dirty(),
                    vt(dt.value).then(()=>({
                        status: ke.value,
                        value: dt.value
                    }))))
            }
            if (Qe.type === "transform")
                if (Le.common.async === !1) {
                    const vt = this._def.schema._parseSync({
                        data: Le.data,
                        path: Le.path,
                        parent: Le
                    });
                    if (!(0,
                    M.isValid)(vt))
                        return vt;
                    const dt = Qe.transform(vt.value, Ke);
                    if (dt instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: ke.value,
                        value: dt
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: Le.data,
                        path: Le.path,
                        parent: Le
                    }).then(vt=>(0,
                    M.isValid)(vt) ? Promise.resolve(Qe.transform(vt.value, Ke)).then(dt=>({
                        status: ke.value,
                        value: dt
                    })) : vt);
            T.util.assertNever(Qe)
        }
    }
    C.ZodEffects = ct,
    C.ZodTransformer = ct,
    ct.create = (Ve,me,ke)=>new ct({
        schema: Ve,
        typeName: Ie.ZodEffects,
        effect: me,
        ...F(ke)
    }),
    ct.createWithPreprocess = (Ve,me,ke)=>new ct({
        schema: me,
        effect: {
            type: "preprocess",
            transform: Ve
        },
        typeName: Ie.ZodEffects,
        ...F(ke)
    });
    class De extends N {
        _parse(me) {
            return this._getType(me) === T.ZodParsedType.undefined ? (0,
            M.OK)(void 0) : this._def.innerType._parse(me)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    C.ZodOptional = De,
    De.create = (Ve,me)=>new De({
        innerType: Ve,
        typeName: Ie.ZodOptional,
        ...F(me)
    });
    class Ue extends N {
        _parse(me) {
            return this._getType(me) === T.ZodParsedType.null ? (0,
            M.OK)(null) : this._def.innerType._parse(me)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    C.ZodNullable = Ue,
    Ue.create = (Ve,me)=>new Ue({
        innerType: Ve,
        typeName: Ie.ZodNullable,
        ...F(me)
    });
    class We extends N {
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me);
            let Le = ke.data;
            return ke.parsedType === T.ZodParsedType.undefined && (Le = this._def.defaultValue()),
            this._def.innerType._parse({
                data: Le,
                path: ke.path,
                parent: ke
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    C.ZodDefault = We,
    We.create = (Ve,me)=>new We({
        innerType: Ve,
        typeName: Ie.ZodDefault,
        defaultValue: typeof me.default == "function" ? me.default : ()=>me.default,
        ...F(me)
    });
    class Xe extends N {
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me)
              , Le = {
                ...ke,
                common: {
                    ...ke.common,
                    issues: []
                }
            }
              , Qe = this._def.innerType._parse({
                data: Le.data,
                path: Le.path,
                parent: {
                    ...Le
                }
            });
            return (0,
            M.isAsync)(Qe) ? Qe.then(Ke=>({
                status: "valid",
                value: Ke.status === "valid" ? Ke.value : this._def.catchValue({
                    get error() {
                        return new $.ZodError(Le.common.issues)
                    },
                    input: Le.data
                })
            })) : {
                status: "valid",
                value: Qe.status === "valid" ? Qe.value : this._def.catchValue({
                    get error() {
                        return new $.ZodError(Le.common.issues)
                    },
                    input: Le.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    C.ZodCatch = Xe,
    Xe.create = (Ve,me)=>new Xe({
        innerType: Ve,
        typeName: Ie.ZodCatch,
        catchValue: typeof me.catch == "function" ? me.catch : ()=>me.catch,
        ...F(me)
    });
    class ht extends N {
        _parse(me) {
            if (this._getType(me) !== T.ZodParsedType.nan) {
                const Le = this._getOrReturnCtx(me);
                return (0,
                M.addIssueToContext)(Le, {
                    code: $.ZodIssueCode.invalid_type,
                    expected: T.ZodParsedType.nan,
                    received: Le.parsedType
                }),
                M.INVALID
            }
            return {
                status: "valid",
                value: me.data
            }
        }
    }
    C.ZodNaN = ht,
    ht.create = Ve=>new ht({
        typeName: Ie.ZodNaN,
        ...F(Ve)
    }),
    C.BRAND = Symbol("zod_brand");
    class Je extends N {
        _parse(me) {
            const {ctx: ke} = this._processInputParams(me)
              , Le = ke.data;
            return this._def.type._parse({
                data: Le,
                path: ke.path,
                parent: ke
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    C.ZodBranded = Je;
    class ot extends N {
        _parse(me) {
            const {status: ke, ctx: Le} = this._processInputParams(me);
            if (Le.common.async)
                return (async()=>{
                    const Ke = await this._def.in._parseAsync({
                        data: Le.data,
                        path: Le.path,
                        parent: Le
                    });
                    return Ke.status === "aborted" ? M.INVALID : Ke.status === "dirty" ? (ke.dirty(),
                    (0,
                    M.DIRTY)(Ke.value)) : this._def.out._parseAsync({
                        data: Ke.value,
                        path: Le.path,
                        parent: Le
                    })
                }
                )();
            {
                const Qe = this._def.in._parseSync({
                    data: Le.data,
                    path: Le.path,
                    parent: Le
                });
                return Qe.status === "aborted" ? M.INVALID : Qe.status === "dirty" ? (ke.dirty(),
                {
                    status: "dirty",
                    value: Qe.value
                }) : this._def.out._parseSync({
                    data: Qe.value,
                    path: Le.path,
                    parent: Le
                })
            }
        }
        static create(me, ke) {
            return new ot({
                in: me,
                out: ke,
                typeName: Ie.ZodPipeline
            })
        }
    }
    C.ZodPipeline = ot;
    class je extends N {
        _parse(me) {
            const ke = this._def.innerType._parse(me);
            return (0,
            M.isValid)(ke) && (ke.value = Object.freeze(ke.value)),
            ke
        }
    }
    C.ZodReadonly = je,
    je.create = (Ve,me)=>new je({
        innerType: Ve,
        typeName: Ie.ZodReadonly,
        ...F(me)
    });
    const $e = (Ve,me={},ke)=>Ve ? I.create().superRefine((Le,Qe)=>{
        var Ke, vt;
        if (!Ve(Le)) {
            const dt = typeof me == "function" ? me(Le) : typeof me == "string" ? {
                message: me
            } : me
              , It = (vt = (Ke = dt.fatal) !== null && Ke !== void 0 ? Ke : ke) !== null && vt !== void 0 ? vt : !0
              , xt = typeof dt == "string" ? {
                message: dt
            } : dt;
            Qe.addIssue({
                code: "custom",
                ...xt,
                fatal: It
            })
        }
    }
    ) : I.create();
    C.custom = $e,
    C.late = {
        object: G.lazycreate
    };
    var Ie;
    (function(Ve) {
        Ve.ZodString = "ZodString",
        Ve.ZodNumber = "ZodNumber",
        Ve.ZodNaN = "ZodNaN",
        Ve.ZodBigInt = "ZodBigInt",
        Ve.ZodBoolean = "ZodBoolean",
        Ve.ZodDate = "ZodDate",
        Ve.ZodSymbol = "ZodSymbol",
        Ve.ZodUndefined = "ZodUndefined",
        Ve.ZodNull = "ZodNull",
        Ve.ZodAny = "ZodAny",
        Ve.ZodUnknown = "ZodUnknown",
        Ve.ZodNever = "ZodNever",
        Ve.ZodVoid = "ZodVoid",
        Ve.ZodArray = "ZodArray",
        Ve.ZodObject = "ZodObject",
        Ve.ZodUnion = "ZodUnion",
        Ve.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        Ve.ZodIntersection = "ZodIntersection",
        Ve.ZodTuple = "ZodTuple",
        Ve.ZodRecord = "ZodRecord",
        Ve.ZodMap = "ZodMap",
        Ve.ZodSet = "ZodSet",
        Ve.ZodFunction = "ZodFunction",
        Ve.ZodLazy = "ZodLazy",
        Ve.ZodLiteral = "ZodLiteral",
        Ve.ZodEnum = "ZodEnum",
        Ve.ZodEffects = "ZodEffects",
        Ve.ZodNativeEnum = "ZodNativeEnum",
        Ve.ZodOptional = "ZodOptional",
        Ve.ZodNullable = "ZodNullable",
        Ve.ZodDefault = "ZodDefault",
        Ve.ZodCatch = "ZodCatch",
        Ve.ZodPromise = "ZodPromise",
        Ve.ZodBranded = "ZodBranded",
        Ve.ZodPipeline = "ZodPipeline",
        Ve.ZodReadonly = "ZodReadonly"
    }
    )(Ie = C.ZodFirstPartyTypeKind || (C.ZodFirstPartyTypeKind = {}));
    const He = (Ve,me={
        message: `Input not instance of ${Ve.name}`
    })=>(0,
    C.custom)(ke=>ke instanceof Ve, me);
    C.instanceof = He;
    const qe = pe.create;
    C.string = qe;
    const Ne = we.create;
    C.number = Ne;
    const at = ht.create;
    C.nan = at;
    const Ye = Ae.create;
    C.bigint = Ye;
    const it = Se.create;
    C.boolean = it;
    const At = ue.create;
    C.date = At;
    const pt = V.create;
    C.symbol = pt;
    const ut = W.create;
    C.undefined = ut;
    const Rt = D.create;
    C.null = Rt;
    const yt = I.create;
    C.any = yt;
    const st = L.create;
    C.unknown = st;
    const Wt = K.create;
    C.never = Wt;
    const Ct = X.create;
    C.void = Ct;
    const Mt = Y.create;
    C.array = Mt;
    const Kt = G.create;
    C.object = Kt;
    const Pt = G.strictCreate;
    C.strictObject = Pt;
    const St = ne.create;
    C.union = St;
    const Zt = ce.create;
    C.discriminatedUnion = Zt;
    const Nt = Re.create;
    C.intersection = Nt;
    const $t = Te.create;
    C.tuple = $t;
    const Gt = xe.create;
    C.record = Gt;
    const Ot = ve.create;
    C.map = Ot;
    const Bt = Me.create;
    C.set = Bt;
    const Yt = Fe.create;
    C.function = Yt;
    const ye = be.create;
    C.lazy = ye;
    const Be = Ce.create;
    C.literal = Be;
    const Oe = Ge.create;
    C.enum = Oe;
    const he = nt.create;
    C.nativeEnum = he;
    const Pe = bt.create;
    C.promise = Pe;
    const rt = ct.create;
    C.effect = rt,
    C.transformer = rt;
    const Ze = De.create;
    C.optional = Ze;
    const tt = Ue.create;
    C.nullable = tt;
    const Et = ct.createWithPreprocess;
    C.preprocess = Et;
    const Tt = ot.create;
    C.pipeline = Tt;
    const kt = ()=>qe().optional();
    C.ostring = kt;
    const Qt = ()=>Ne().optional();
    C.onumber = Qt;
    const Vt = ()=>it().optional();
    C.oboolean = Vt,
    C.coerce = {
        string: Ve=>pe.create({
            ...Ve,
            coerce: !0
        }),
        number: Ve=>we.create({
            ...Ve,
            coerce: !0
        }),
        boolean: Ve=>Se.create({
            ...Ve,
            coerce: !0
        }),
        bigint: Ve=>Ae.create({
            ...Ve,
            coerce: !0
        }),
        date: Ve=>ue.create({
            ...Ve,
            coerce: !0
        })
    },
    C.NEVER = M.INVALID
}
)(types);
(function(C) {
    var S = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(M, T, $, B) {
        B === void 0 && (B = $),
        Object.defineProperty(M, B, {
            enumerable: !0,
            get: function() {
                return T[$]
            }
        })
    }
    : function(M, T, $, B) {
        B === void 0 && (B = $),
        M[B] = T[$]
    }
    )
      , E = commonjsGlobal && commonjsGlobal.__exportStar || function(M, T) {
        for (var $ in M)
            $ !== "default" && !Object.prototype.hasOwnProperty.call(T, $) && S(T, M, $)
    }
    ;
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    E(errors, C),
    E(parseUtil, C),
    E(typeAliases, C),
    E(util, C),
    E(types, C),
    E(ZodError$1, C)
}
)(external);
(function(C) {
    var S = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(B, O, F, N) {
        N === void 0 && (N = F),
        Object.defineProperty(B, N, {
            enumerable: !0,
            get: function() {
                return O[F]
            }
        })
    }
    : function(B, O, F, N) {
        N === void 0 && (N = F),
        B[N] = O[F]
    }
    )
      , E = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(B, O) {
        Object.defineProperty(B, "default", {
            enumerable: !0,
            value: O
        })
    }
    : function(B, O) {
        B.default = O
    }
    )
      , M = commonjsGlobal && commonjsGlobal.__importStar || function(B) {
        if (B && B.__esModule)
            return B;
        var O = {};
        if (B != null)
            for (var F in B)
                F !== "default" && Object.prototype.hasOwnProperty.call(B, F) && S(O, B, F);
        return E(O, B),
        O
    }
      , T = commonjsGlobal && commonjsGlobal.__exportStar || function(B, O) {
        for (var F in B)
            F !== "default" && !Object.prototype.hasOwnProperty.call(O, F) && S(O, B, F)
    }
    ;
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.z = void 0;
    const $ = M(external);
    C.z = $,
    T(external, C),
    C.default = $
}
)(lib$1);
const name = "@ton/ton"
  , version$4 = "13.11.1"
  , repository = "https://github.com/ton-org/ton.git"
  , author = "Whales Corp. <developers@whalescorp.com>"
  , license = "MIT"
  , main = "dist/index.js"
  , files = ["dist"]
  , scripts = {
    docs: "rm -fr docs && typedoc src/index.ts",
    build: "rm -fr dist && tsc --declaration",
    test: "jest --verbose --runInBand",
    release: "yarn build && yarn release-it --npm.yarn1"
}
  , devDependencies = {
    "@release-it/keep-a-changelog": "^5.0.0",
    "@ton/core": "^0.56.0",
    "@ton/crypto": "3.2.0",
    "@ton/emulator": "^2.1.1",
    "@types/jest": "^27.0.1",
    "@types/node": "^16.7.10",
    buffer: "^6.0.3",
    expect: "^27.1.0",
    jest: "^27.1.0",
    "jest-mock": "^27.1.0",
    karma: "^6.3.4",
    "karma-chrome-launcher": "^3.1.0",
    "karma-jasmine": "^4.0.1",
    "karma-typescript": "^5.5.2",
    "karma-webpack": "^5.0.0",
    prando: "^6.0.1",
    "release-it": "^17.1.1",
    "ts-jest": "^27.0.5",
    "ts-loader": "^9.2.5",
    "ts-node": "^10.7.0",
    typedoc: "^0.23.24",
    typescript: "^4.4.2",
    webpack: "^5.51.2"
}
  , dependencies = {
    axios: "^1.6.7",
    dataloader: "^2.0.0",
    "symbol.inspect": "1.0.1",
    teslabot: "^1.3.0",
    zod: "^3.21.4"
}
  , peerDependencies = {
    "@ton/core": ">=0.56.0",
    "@ton/crypto": ">=3.2.0"
}
  , publishConfig = {
    access: "public",
    registry: "https://registry.npmjs.org/"
}
  , packageManager = "yarn@3.4.1"
  , require$$4$1 = {
    name,
    version: version$4,
    repository,
    author,
    license,
    main,
    files,
    scripts,
    devDependencies,
    dependencies,
    peerDependencies,
    publishConfig,
    "release-it": {
        github: {
            release: !0
        },
        plugins: {
            "@release-it/keep-a-changelog": {
                filename: "CHANGELOG.md"
            }
        }
    },
    packageManager
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
;
Object.defineProperty(HttpApi$1, "__esModule", {
    value: !0
});
HttpApi$1.HttpApi = void 0;
const TonCache_1 = TonCache
  , dataloader_1 = __importDefault$1(dataloader)
  , axios_1$1 = __importDefault$1(axios_1$2)
  , zod_1$1 = lib$1
  , version$3 = require$$4$1.version
  , blockIdExt = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("ton.blockIdExt"),
    workchain: zod_1$1.z.number(),
    shard: zod_1$1.z.string(),
    seqno: zod_1$1.z.number(),
    root_hash: zod_1$1.z.string(),
    file_hash: zod_1$1.z.string()
})
  , addressInformation = zod_1$1.z.object({
    balance: zod_1$1.z.union([zod_1$1.z.number(), zod_1$1.z.string()]),
    state: zod_1$1.z.union([zod_1$1.z.literal("active"), zod_1$1.z.literal("uninitialized"), zod_1$1.z.literal("frozen")]),
    data: zod_1$1.z.string(),
    code: zod_1$1.z.string(),
    last_transaction_id: zod_1$1.z.object({
        "@type": zod_1$1.z.literal("internal.transactionId"),
        lt: zod_1$1.z.string(),
        hash: zod_1$1.z.string()
    }),
    block_id: blockIdExt,
    sync_utime: zod_1$1.z.number()
})
  , bocResponse = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("ok")
})
  , feeResponse = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("query.fees"),
    source_fees: zod_1$1.z.object({
        "@type": zod_1$1.z.literal("fees"),
        in_fwd_fee: zod_1$1.z.number(),
        storage_fee: zod_1$1.z.number(),
        gas_fee: zod_1$1.z.number(),
        fwd_fee: zod_1$1.z.number()
    })
})
  , callGetMethod = zod_1$1.z.object({
    gas_used: zod_1$1.z.number(),
    exit_code: zod_1$1.z.number(),
    stack: zod_1$1.z.array(zod_1$1.z.unknown())
})
  , messageData = zod_1$1.z.union([zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataRaw"),
    body: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataText"),
    text: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataDecryptedText"),
    text: zod_1$1.z.string()
}), zod_1$1.z.object({
    "@type": zod_1$1.z.literal("msg.dataEncryptedText"),
    text: zod_1$1.z.string()
})])
  , message = zod_1$1.z.object({
    source: zod_1$1.z.string(),
    destination: zod_1$1.z.string(),
    value: zod_1$1.z.string(),
    fwd_fee: zod_1$1.z.string(),
    ihr_fee: zod_1$1.z.string(),
    created_lt: zod_1$1.z.string(),
    body_hash: zod_1$1.z.string(),
    msg_data: messageData,
    message: zod_1$1.z.string()
})
  , transaction = zod_1$1.z.object({
    data: zod_1$1.z.string(),
    utime: zod_1$1.z.number(),
    transaction_id: zod_1$1.z.object({
        lt: zod_1$1.z.string(),
        hash: zod_1$1.z.string()
    }),
    fee: zod_1$1.z.string(),
    storage_fee: zod_1$1.z.string(),
    other_fee: zod_1$1.z.string(),
    in_msg: zod_1$1.z.union([zod_1$1.z.undefined(), message]),
    out_msgs: zod_1$1.z.array(message)
})
  , getTransactions = zod_1$1.z.array(transaction)
  , getMasterchain = zod_1$1.z.object({
    state_root_hash: zod_1$1.z.string(),
    last: blockIdExt,
    init: blockIdExt
})
  , getShards = zod_1$1.z.object({
    shards: zod_1$1.z.array(blockIdExt)
})
  , blockShortTxt = zod_1$1.z.object({
    "@type": zod_1$1.z.literal("blocks.shortTxId"),
    mode: zod_1$1.z.number(),
    account: zod_1$1.z.string(),
    lt: zod_1$1.z.string(),
    hash: zod_1$1.z.string()
})
  , getBlockTransactions = zod_1$1.z.object({
    id: blockIdExt,
    req_count: zod_1$1.z.number(),
    incomplete: zod_1$1.z.boolean(),
    transactions: zod_1$1.z.array(blockShortTxt)
});
class TypedCache {
    constructor(S, E, M, T) {
        this.namespace = S,
        this.cache = E,
        this.codec = M,
        this.keyEncoder = T
    }
    async get(S) {
        let E = await this.cache.get(this.namespace, this.keyEncoder(S));
        if (E) {
            let M = this.codec.safeParse(JSON.parse(E));
            if (M.success)
                return M.data
        }
        return null
    }
    async set(S, E) {
        E !== null ? await this.cache.set(this.namespace, this.keyEncoder(S), JSON.stringify(E)) : await this.cache.set(this.namespace, this.keyEncoder(S), null)
    }
}
class HttpApi {
    constructor(S, E) {
        this.endpoint = S,
        this.cache = new TonCache_1.InMemoryCache,
        this.parameters = {
            timeout: (E == null ? void 0 : E.timeout) || 3e4,
            apiKey: E == null ? void 0 : E.apiKey,
            adapter: E == null ? void 0 : E.adapter
        },
        this.shardCache = new TypedCache("ton-shard",this.cache,zod_1$1.z.array(blockIdExt),M=>M + ""),
        this.shardLoader = new dataloader_1.default(async M=>await Promise.all(M.map(async T=>{
            const $ = await this.shardCache.get(T);
            if ($)
                return $;
            let B = (await this.doCall("shards", {
                seqno: T
            }, getShards)).shards;
            return await this.shardCache.set(T, B),
            B
        }
        ))),
        this.shardTransactionsCache = new TypedCache("ton-shard-tx",this.cache,getBlockTransactions,M=>M.workchain + ":" + M.shard + ":" + M.seqno),
        this.shardTransactionsLoader = new dataloader_1.default(async M=>await Promise.all(M.map(async T=>{
            const $ = await this.shardTransactionsCache.get(T);
            if ($)
                return $;
            let B = await this.doCall("getBlockTransactions", {
                workchain: T.workchain,
                seqno: T.seqno,
                shard: T.shard
            }, getBlockTransactions);
            return await this.shardTransactionsCache.set(T, B),
            B
        }
        )),{
            cacheKeyFn: M=>M.workchain + ":" + M.shard + ":" + M.seqno
        })
    }
    getAddressInformation(S) {
        return this.doCall("getAddressInformation", {
            address: S.toString()
        }, addressInformation)
    }
    async getTransactions(S, E) {
        const M = E.inclusive;
        delete E.inclusive;
        let T;
        E.hash && (T = Buffer.from(E.hash, "base64").toString("hex"));
        let $ = E.limit;
        E.hash && E.lt && M !== !0 && $++;
        let B = await this.doCall("getTransactions", {
            address: S.toString(),
            ...E,
            limit: $,
            hash: T
        }, getTransactions);
        return B.length > $ && (B = B.slice(0, $)),
        E.hash && E.lt && M !== !0 && B.shift(),
        B
    }
    async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain)
    }
    async getShards(S) {
        return await this.shardLoader.load(S)
    }
    async getBlockTransactions(S, E, M) {
        return await this.shardTransactionsLoader.load({
            workchain: S,
            seqno: E,
            shard: M
        })
    }
    async getTransaction(S, E, M) {
        let T = Buffer.from(M, "base64").toString("hex")
          , B = (await this.doCall("getTransactions", {
            address: S.toString(),
            lt: E,
            hash: T,
            limit: 1
        }, getTransactions)).find(O=>O.transaction_id.lt === E && O.transaction_id.hash === M);
        return B || null
    }
    async callGetMethod(S, E, M) {
        return await this.doCall("runGetMethod", {
            address: S.toString(),
            method: E,
            stack: serializeStack(M)
        }, callGetMethod)
    }
    async sendBoc(S) {
        await this.doCall("sendBoc", {
            boc: S.toString("base64")
        }, bocResponse)
    }
    async estimateFee(S, E) {
        return await this.doCall("estimateFee", {
            address: S.toString(),
            body: E.body.toBoc().toString("base64"),
            init_data: E.initData ? E.initData.toBoc().toString("base64") : "",
            init_code: E.initCode ? E.initCode.toBoc().toString("base64") : "",
            ignore_chksig: E.ignoreSignature
        }, feeResponse)
    }
    async tryLocateResultTx(S, E, M) {
        return await this.doCall("tryLocateResultTx", {
            source: S.toString(),
            destination: E.toString(),
            created_lt: M
        }, transaction)
    }
    async tryLocateSourceTx(S, E, M) {
        return await this.doCall("tryLocateSourceTx", {
            source: S.toString(),
            destination: E.toString(),
            created_lt: M
        }, transaction)
    }
    async doCall(S, E, M) {
        let T = {
            "Content-Type": "application/json",
            "X-Ton-Client-Version": version$3
        };
        this.parameters.apiKey && (T["X-API-Key"] = this.parameters.apiKey);
        let $ = await axios_1$1.default.post(this.endpoint, JSON.stringify({
            id: "1",
            jsonrpc: "2.0",
            method: S,
            params: E
        }), {
            headers: T,
            timeout: this.parameters.timeout,
            adapter: this.parameters.adapter
        });
        if ($.status !== 200 || !$.data.ok)
            throw Error("Received error: " + JSON.stringify($.data));
        let B = M.safeParse($.data.result);
        if (B.success)
            return B.data;
        throw Error("Malformed response: " + B.error.format()._errors.join(", "))
    }
}
HttpApi$1.HttpApi = HttpApi;
function serializeStack(C) {
    let S = [];
    for (let E of C)
        if (E.type === "int")
            S.push(["num", E.value.toString()]);
        else if (E.type === "cell")
            S.push(["tvm.Cell", E.cell.toBoc().toString("base64")]);
        else if (E.type === "slice")
            S.push(["tvm.Slice", E.cell.toBoc().toString("base64")]);
        else if (E.type === "builder")
            S.push(["tvm.Builder", E.cell.toBoc().toString("base64")]);
        else
            throw Error("Unsupported stack item type: " + E.type);
    return S
}
var TonClient$1 = {};
Object.defineProperty(TonClient$1, "__esModule", {
    value: !0
});
TonClient$1.TonClient = void 0;
const HttpApi_1 = HttpApi$1
  , core_1$h = dist$4;
class TonClient {
    constructor(S) {
        this.parameters = {
            endpoint: S.endpoint
        },
        this.api = new HttpApi_1.HttpApi(this.parameters.endpoint,{
            timeout: S.timeout,
            apiKey: S.apiKey,
            adapter: S.httpAdapter
        })
    }
    async getBalance(S) {
        return (await this.getContractState(S)).balance
    }
    async runMethod(S, E, M=[]) {
        let T = await this.api.callGetMethod(S, E, M);
        if (T.exit_code !== 0)
            throw Error("Unable to execute get method. Got exit_code: " + T.exit_code);
        return {
            gas_used: T.gas_used,
            stack: parseStack(T.stack)
        }
    }
    async callGetMethod(S, E, M=[]) {
        return this.runMethod(S, E, M)
    }
    async runMethodWithError(S, E, M=[]) {
        let T = await this.api.callGetMethod(S, E, M);
        return {
            gas_used: T.gas_used,
            stack: parseStack(T.stack),
            exit_code: T.exit_code
        }
    }
    async callGetMethodWithError(S, E, M=[]) {
        return this.runMethodWithError(S, E, M)
    }
    async getTransactions(S, E) {
        let M = await this.api.getTransactions(S, E)
          , T = [];
        for (let $ of M)
            T.push((0,
            core_1$h.loadTransaction)(core_1$h.Cell.fromBoc(Buffer.from($.data, "base64"))[0].beginParse()));
        return T
    }
    async getTransaction(S, E, M) {
        let T = await this.api.getTransaction(S, E, M);
        return T ? (0,
        core_1$h.loadTransaction)(core_1$h.Cell.fromBoc(Buffer.from(T.data, "base64"))[0].beginParse()) : null
    }
    async tryLocateResultTx(S, E, M) {
        let T = await this.api.tryLocateResultTx(S, E, M);
        return (0,
        core_1$h.loadTransaction)(core_1$h.Cell.fromBase64(T.data).beginParse())
    }
    async tryLocateSourceTx(S, E, M) {
        let T = await this.api.tryLocateSourceTx(S, E, M);
        return (0,
        core_1$h.loadTransaction)(core_1$h.Cell.fromBase64(T.data).beginParse())
    }
    async getMasterchainInfo() {
        let S = await this.api.getMasterchainInfo();
        return {
            workchain: S.init.workchain,
            shard: S.last.shard,
            initSeqno: S.init.seqno,
            latestSeqno: S.last.seqno
        }
    }
    async getWorkchainShards(S) {
        return (await this.api.getShards(S)).map(M=>({
            workchain: M.workchain,
            shard: M.shard,
            seqno: M.seqno
        }))
    }
    async getShardTransactions(S, E, M) {
        let T = await this.api.getBlockTransactions(S, E, M);
        if (T.incomplete)
            throw Error("Unsupported");
        return T.transactions.map($=>({
            account: core_1$h.Address.parseRaw($.account),
            lt: $.lt,
            hash: $.hash
        }))
    }
    async sendMessage(S) {
        const E = (0,
        core_1$h.beginCell)().store((0,
        core_1$h.storeMessage)(S)).endCell().toBoc();
        await this.api.sendBoc(E)
    }
    async sendFile(S) {
        await this.api.sendBoc(S)
    }
    async estimateExternalMessageFee(S, E) {
        return await this.api.estimateFee(S, {
            body: E.body,
            initCode: E.initCode,
            initData: E.initData,
            ignoreSignature: E.ignoreSignature
        })
    }
    async sendExternalMessage(S, E) {
        if (await this.isContractDeployed(S.address) || !S.init) {
            const M = (0,
            core_1$h.external)({
                to: S.address,
                body: E
            });
            await this.sendMessage(M)
        } else {
            const M = (0,
            core_1$h.external)({
                to: S.address,
                init: S.init,
                body: E
            });
            await this.sendMessage(M)
        }
    }
    async isContractDeployed(S) {
        return (await this.getContractState(S)).state === "active"
    }
    async getContractState(S) {
        let E = await this.api.getAddressInformation(S)
          , M = BigInt(E.balance)
          , T = E.state;
        return {
            balance: M,
            state: T,
            code: E.code !== "" ? Buffer.from(E.code, "base64") : null,
            data: E.data !== "" ? Buffer.from(E.data, "base64") : null,
            lastTransaction: E.last_transaction_id.lt !== "0" ? {
                lt: E.last_transaction_id.lt,
                hash: E.last_transaction_id.hash
            } : null,
            blockId: {
                workchain: E.block_id.workchain,
                shard: E.block_id.shard,
                seqno: E.block_id.seqno
            },
            timestampt: E.sync_utime
        }
    }
    open(S) {
        return (0,
        core_1$h.openContract)(S, E=>createProvider$1(this, E.address, E.init))
    }
    provider(S, E) {
        return createProvider$1(this, S, E ?? null)
    }
}
TonClient$1.TonClient = TonClient;
function parseStackEntry(C) {
    switch (C["@type"]) {
    case "tvm.stackEntryNumber":
        return {
            type: "int",
            value: BigInt(C.number.number)
        };
    case "tvm.stackEntryCell":
        return {
            type: "cell",
            cell: core_1$h.Cell.fromBase64(C.cell)
        };
    case "tvm.stackEntryTuple":
        return {
            type: "tuple",
            items: C.tuple.elements.map(parseStackEntry)
        };
    default:
        throw Error("Unsupported item type: " + C["@type"])
    }
}
function parseStackItem(C) {
    if (C[0] === "num") {
        let S = C[1];
        return S.startsWith("-") ? {
            type: "int",
            value: -BigInt(S.slice(1))
        } : {
            type: "int",
            value: BigInt(S)
        }
    } else {
        if (C[0] === "null")
            return {
                type: "null"
            };
        if (C[0] === "cell")
            return {
                type: "cell",
                cell: core_1$h.Cell.fromBoc(Buffer.from(C[1].bytes, "base64"))[0]
            };
        if (C[0] === "slice")
            return {
                type: "slice",
                cell: core_1$h.Cell.fromBoc(Buffer.from(C[1].bytes, "base64"))[0]
            };
        if (C[0] === "builder")
            return {
                type: "builder",
                cell: core_1$h.Cell.fromBoc(Buffer.from(C[1].bytes, "base64"))[0]
            };
        if (C[0] === "tuple" || C[0] === "list")
            return C[1].elements.length === 0 ? {
                type: "null"
            } : {
                type: C[0],
                items: C[1].elements.map(parseStackEntry)
            };
        throw Error("Unsupported stack item type: " + C[0])
    }
}
function parseStack(C) {
    let S = [];
    for (let E of C)
        S.push(parseStackItem(E));
    return new core_1$h.TupleReader(S)
}
function createProvider$1(C, S, E) {
    return {
        async getState() {
            let M = await C.getContractState(S), T = M.balance, $ = M.lastTransaction ? {
                lt: BigInt(M.lastTransaction.lt),
                hash: Buffer.from(M.lastTransaction.hash, "base64")
            } : null, B;
            if (M.state === "active")
                B = {
                    type: "active",
                    code: M.code ? M.code : null,
                    data: M.data ? M.data : null
                };
            else if (M.state === "uninitialized")
                B = {
                    type: "uninit"
                };
            else if (M.state === "frozen")
                B = {
                    type: "frozen",
                    stateHash: Buffer.alloc(0)
                };
            else
                throw Error("Unsupported state");
            return {
                balance: T,
                last: $,
                state: B
            }
        },
        async get(M, T) {
            return {
                stack: (await C.callGetMethod(S, M, T)).stack
            }
        },
        async external(M) {
            let T = null;
            E && !await C.isContractDeployed(S) && (T = E);
            const $ = (0,
            core_1$h.external)({
                to: S,
                init: T,
                body: M
            });
            let B = (0,
            core_1$h.beginCell)().store((0,
            core_1$h.storeMessage)($)).endCell().toBoc();
            await C.sendFile(B)
        },
        async internal(M, T) {
            let $ = null;
            E && !await C.isContractDeployed(S) && ($ = E);
            let B = !0;
            T.bounce !== null && T.bounce !== void 0 && (B = T.bounce);
            let O;
            typeof T.value == "string" ? O = (0,
            core_1$h.toNano)(T.value) : O = T.value;
            let F = null;
            typeof T.body == "string" ? F = (0,
            core_1$h.comment)(T.body) : T.body && (F = T.body),
            await M.send({
                to: S,
                value: O,
                bounce: B,
                sendMode: T.sendMode,
                init: $,
                body: F
            })
        },
        open(M) {
            return (0,
            core_1$h.openContract)(M, T=>createProvider$1(C, T.address, T.init ?? null))
        },
        getTransactions(M, T, $, B) {
            return C.getTransactions(M, {
                limit: B ?? 100,
                lt: T.toString(),
                hash: $.toString("base64"),
                inclusive: !0
            })
        }
    }
}
var TonClient4$1 = {}
  , toUrlSafe$1 = {};
Object.defineProperty(toUrlSafe$1, "__esModule", {
    value: !0
});
toUrlSafe$1.toUrlSafe = void 0;
function toUrlSafe(C) {
    for (; C.indexOf("/") >= 0; )
        C = C.replace("/", "_");
    for (; C.indexOf("+") >= 0; )
        C = C.replace("+", "-");
    for (; C.indexOf("=") >= 0; )
        C = C.replace("=", "");
    return C
}
toUrlSafe$1.toUrlSafe = toUrlSafe;
var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(C, S, E, M, T) {
    if (M === "m")
        throw new TypeError("Private method is not writable");
    if (M === "a" && !T)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof S == "function" ? C !== S || !T : !S.has(C))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return M === "a" ? T.call(C, E) : T ? T.value = E : S.set(C, E),
    E
}
, __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(C, S, E, M) {
    if (E === "a" && !M)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof S == "function" ? C !== S || !M : !S.has(C))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return E === "m" ? M : E === "a" ? M.call(C) : M ? M.value : S.get(C)
}
, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(C) {
    return C && C.__esModule ? C : {
        default: C
    }
}
, _TonClient4_endpoint, _TonClient4_timeout, _TonClient4_adapter;
Object.defineProperty(TonClient4$1, "__esModule", {
    value: !0
});
TonClient4$1.TonClient4 = void 0;
const axios_1 = __importDefault(axios_1$2)
  , core_1$g = dist$4
  , toUrlSafe_1 = toUrlSafe$1
  , zod_1 = lib$1;
class TonClient4 {
    constructor(S) {
        _TonClient4_endpoint.set(this, void 0),
        _TonClient4_timeout.set(this, void 0),
        _TonClient4_adapter.set(this, void 0),
        __classPrivateFieldSet(this, _TonClient4_endpoint, S.endpoint, "f"),
        __classPrivateFieldSet(this, _TonClient4_timeout, S.timeout || 5e3, "f"),
        __classPrivateFieldSet(this, _TonClient4_adapter, S.httpAdapter, "f")
    }
    async getLastBlock() {
        let S = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , E = lastBlockCodec.safeParse(S.data);
        if (!E.success)
            throw Error("Mailformed response: " + E.error.format()._errors.join(", "));
        return E.data
    }
    async getBlock(S) {
        let E = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , M = blockCodec.safeParse(E.data);
        if (!M.success)
            throw Error("Mailformed response");
        if (!M.data.exist)
            throw Error("Block is out of scope");
        return M.data.block
    }
    async getBlockByUtime(S) {
        let E = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + S, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , M = blockCodec.safeParse(E.data);
        if (!M.success)
            throw Error("Mailformed response");
        if (!M.data.exist)
            throw Error("Block is out of scope");
        return M.data.block
    }
    async getAccount(S, E) {
        let M = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S + "/" + E.toString({
            urlSafe: !0
        }), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , T = accountCodec.safeParse(M.data);
        if (!T.success)
            throw Error("Mailformed response");
        return T.data
    }
    async getAccountLite(S, E) {
        let M = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S + "/" + E.toString({
            urlSafe: !0
        }) + "/lite", {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , T = accountLiteCodec.safeParse(M.data);
        if (!T.success)
            throw Error("Mailformed response");
        return T.data
    }
    async isContractDeployed(S, E) {
        return (await this.getAccountLite(S, E)).account.state.type === "active"
    }
    async isAccountChanged(S, E, M) {
        let T = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S + "/" + E.toString({
            urlSafe: !0
        }) + "/changed/" + M.toString(10), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , $ = changedCodec.safeParse(T.data);
        if (!$.success)
            throw Error("Mailformed response");
        return $.data
    }
    async getAccountTransactions(S, E, M) {
        let T = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + S.toString({
            urlSafe: !0
        }) + "/tx/" + E.toString(10) + "/" + (0,
        toUrlSafe_1.toUrlSafe)(M.toString("base64")), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , $ = transactionsCodec.safeParse(T.data);
        if (!$.success)
            throw Error("Mailformed response");
        let B = $.data
          , O = []
          , F = core_1$g.Cell.fromBoc(Buffer.from(B.boc, "base64"));
        for (let N = 0; N < B.blocks.length; N++)
            O.push({
                block: B.blocks[N],
                tx: (0,
                core_1$g.loadTransaction)(F[N].beginParse())
            });
        return O
    }
    async getAccountTransactionsParsed(S, E, M, T=20) {
        let $ = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + S.toString({
            urlSafe: !0
        }) + "/tx/parsed/" + E.toString(10) + "/" + (0,
        toUrlSafe_1.toUrlSafe)(M.toString("base64")), {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
            params: {
                count: T
            }
        })
          , B = parsedTransactionsCodec.safeParse($.data);
        if (!B.success)
            throw Error("Mailformed response");
        return B.data
    }
    async getConfig(S, E) {
        let M = "";
        E && E.length > 0 && (M = "/" + [...E].sort().join(","));
        let T = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S + "/config" + M, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , $ = configCodec.safeParse(T.data);
        if (!$.success)
            throw Error("Mailformed response");
        return $.data
    }
    async runMethod(S, E, M, T) {
        let $ = T && T.length > 0 ? "/" + (0,
        toUrlSafe_1.toUrlSafe)((0,
        core_1$g.serializeTuple)(T).toBoc({
            idx: !1,
            crc32: !1
        }).toString("base64")) : ""
          , B = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + S + "/" + E.toString({
            urlSafe: !0
        }) + "/run/" + encodeURIComponent(M) + $
          , O = await axios_1.default.get(B, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        })
          , F = runMethodCodec.safeParse(O.data);
        if (!F.success)
            throw Error("Mailformed response");
        let N = F.data.resultRaw ? (0,
        core_1$g.parseTuple)(core_1$g.Cell.fromBoc(Buffer.from(F.data.resultRaw, "base64"))[0]) : [];
        return {
            exitCode: F.data.exitCode,
            result: N,
            resultRaw: F.data.resultRaw,
            block: F.data.block,
            shardBlock: F.data.shardBlock,
            reader: new core_1$g.TupleReader(N)
        }
    }
    async sendMessage(S) {
        let E = await axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", {
            boc: S.toString("base64")
        }, {
            adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
            timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f")
        });
        if (!sendCodec.safeParse(E.data).success)
            throw Error("Mailformed response");
        return {
            status: E.data.status
        }
    }
    open(S) {
        return (0,
        core_1$g.openContract)(S, E=>createProvider(this, null, E.address, E.init))
    }
    openAt(S, E) {
        return (0,
        core_1$g.openContract)(E, M=>createProvider(this, S, M.address, M.init))
    }
    provider(S, E) {
        return createProvider(this, null, S, E ?? null)
    }
    providerAt(S, E, M) {
        return createProvider(this, S, E, M ?? null)
    }
}
TonClient4$1.TonClient4 = TonClient4;
_TonClient4_endpoint = new WeakMap,
_TonClient4_timeout = new WeakMap,
_TonClient4_adapter = new WeakMap;
function createProvider(C, S, E, M) {
    return {
        async getState() {
            let T = S;
            T === null && (T = (await C.getLastBlock()).last.seqno);
            let $ = await C.getAccount(T, E), B = $.account.last ? {
                lt: BigInt($.account.last.lt),
                hash: Buffer.from($.account.last.hash, "base64")
            } : null, O;
            if ($.account.state.type === "active")
                O = {
                    type: "active",
                    code: $.account.state.code ? Buffer.from($.account.state.code, "base64") : null,
                    data: $.account.state.data ? Buffer.from($.account.state.data, "base64") : null
                };
            else if ($.account.state.type === "uninit")
                O = {
                    type: "uninit"
                };
            else if ($.account.state.type === "frozen")
                O = {
                    type: "frozen",
                    stateHash: Buffer.from($.account.state.stateHash, "base64")
                };
            else
                throw Error("Unsupported state");
            return {
                balance: BigInt($.account.balance.coins),
                last: B,
                state: O
            }
        },
        async get(T, $) {
            let B = S;
            B === null && (B = (await C.getLastBlock()).last.seqno);
            let O = await C.runMethod(B, E, T, $);
            if (O.exitCode !== 0 && O.exitCode !== 1)
                throw Error("Exit code: " + O.exitCode);
            return {
                stack: new core_1$g.TupleReader(O.result)
            }
        },
        async external(T) {
            let $ = await C.getLastBlock()
              , B = null;
            M && (await C.getAccountLite($.last.seqno, E)).account.state.type !== "active" && (B = M);
            const O = (0,
            core_1$g.external)({
                to: E,
                init: B,
                body: T
            });
            let F = (0,
            core_1$g.beginCell)().store((0,
            core_1$g.storeMessage)(O)).endCell().toBoc();
            await C.sendMessage(F)
        },
        async internal(T, $) {
            let B = await C.getLastBlock()
              , O = null;
            M && (await C.getAccountLite(B.last.seqno, E)).account.state.type !== "active" && (O = M);
            let F = !0;
            $.bounce !== null && $.bounce !== void 0 && (F = $.bounce);
            let N;
            typeof $.value == "string" ? N = (0,
            core_1$g.toNano)($.value) : N = $.value;
            let U = null;
            typeof $.body == "string" ? U = (0,
            core_1$g.comment)($.body) : $.body && (U = $.body),
            await T.send({
                to: E,
                value: N,
                bounce: F,
                sendMode: $.sendMode,
                init: O,
                body: U
            })
        },
        open(T) {
            return (0,
            core_1$g.openContract)(T, $=>createProvider(C, S, $.address, $.init ?? null))
        },
        async getTransactions(T, $, B, O) {
            const F = typeof O == "number";
            if (F && O <= 0)
                return [];
            let N = [];
            do {
                const U = await C.getAccountTransactions(T, $, B)
                  , H = U[0].tx
                  , [Z,J] = [H.lt, H.hash()];
                if (N.length > 0 && Z === $ && J.equals(B) && U.shift(),
                U.length === 0)
                    break;
                const oe = U[U.length - 1].tx
                  , [ae,se] = [oe.lt, oe.hash()];
                if (ae === $ && se.equals(B))
                    break;
                N.push(...U.map(le=>le.tx)),
                $ = ae,
                B = se
            } while (F && N.length < O);
            return F && (N = N.slice(0, O)),
            N
        }
    }
}
const lastBlockCodec = zod_1.z.object({
    last: zod_1.z.object({
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        workchain: zod_1.z.number(),
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
    }),
    init: zod_1.z.object({
        fileHash: zod_1.z.string(),
        rootHash: zod_1.z.string()
    }),
    stateRootHash: zod_1.z.string(),
    now: zod_1.z.number()
})
  , blockCodec = zod_1.z.union([zod_1.z.object({
    exist: zod_1.z.literal(!1)
}), zod_1.z.object({
    exist: zod_1.z.literal(!0),
    block: zod_1.z.object({
        shards: zod_1.z.array(zod_1.z.object({
            workchain: zod_1.z.number(),
            seqno: zod_1.z.number(),
            shard: zod_1.z.string(),
            rootHash: zod_1.z.string(),
            fileHash: zod_1.z.string(),
            transactions: zod_1.z.array(zod_1.z.object({
                account: zod_1.z.string(),
                hash: zod_1.z.string(),
                lt: zod_1.z.string()
            }))
        }))
    })
})])
  , storageStatCodec = zod_1.z.object({
    lastPaid: zod_1.z.number(),
    duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
    used: zod_1.z.object({
        bits: zod_1.z.number(),
        cells: zod_1.z.number(),
        publicCells: zod_1.z.number()
    })
})
  , accountCodec = zod_1.z.object({
    account: zod_1.z.object({
        state: zod_1.z.union([zod_1.z.object({
            type: zod_1.z.literal("uninit")
        }), zod_1.z.object({
            type: zod_1.z.literal("active"),
            code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
            data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()])
        }), zod_1.z.object({
            type: zod_1.z.literal("frozen"),
            stateHash: zod_1.z.string()
        })]),
        balance: zod_1.z.object({
            coins: zod_1.z.string()
        }),
        last: zod_1.z.union([zod_1.z.null(), zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
        })]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    }),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , accountLiteCodec = zod_1.z.object({
    account: zod_1.z.object({
        state: zod_1.z.union([zod_1.z.object({
            type: zod_1.z.literal("uninit")
        }), zod_1.z.object({
            type: zod_1.z.literal("active"),
            codeHash: zod_1.z.string(),
            dataHash: zod_1.z.string()
        }), zod_1.z.object({
            type: zod_1.z.literal("frozen"),
            stateHash: zod_1.z.string()
        })]),
        balance: zod_1.z.object({
            coins: zod_1.z.string()
        }),
        last: zod_1.z.union([zod_1.z.null(), zod_1.z.object({
            lt: zod_1.z.string(),
            hash: zod_1.z.string()
        })]),
        storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    })
})
  , changedCodec = zod_1.z.object({
    changed: zod_1.z.boolean(),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , runMethodCodec = zod_1.z.object({
    exitCode: zod_1.z.number(),
    resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    block: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    }),
    shardBlock: zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string()
    })
})
  , configCodec = zod_1.z.object({
    config: zod_1.z.object({
        cell: zod_1.z.string(),
        address: zod_1.z.string(),
        globalBalance: zod_1.z.object({
            coins: zod_1.z.string()
        })
    })
})
  , sendCodec = zod_1.z.object({
    status: zod_1.z.number()
})
  , blocksCodec = zod_1.z.array(zod_1.z.object({
    workchain: zod_1.z.number(),
    seqno: zod_1.z.number(),
    shard: zod_1.z.string(),
    rootHash: zod_1.z.string(),
    fileHash: zod_1.z.string()
}))
  , transactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    boc: zod_1.z.string()
})
  , parsedAddressExternalCodec = zod_1.z.object({
    bits: zod_1.z.number(),
    data: zod_1.z.string()
})
  , parsedMessageInfoCodec = zod_1.z.union([zod_1.z.object({
    type: zod_1.z.literal("internal"),
    value: zod_1.z.string(),
    dest: zod_1.z.string(),
    src: zod_1.z.string(),
    bounced: zod_1.z.boolean(),
    bounce: zod_1.z.boolean(),
    ihrDisabled: zod_1.z.boolean(),
    createdAt: zod_1.z.number(),
    createdLt: zod_1.z.string(),
    fwdFee: zod_1.z.string(),
    ihrFee: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("external-in"),
    dest: zod_1.z.string(),
    src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
    importFee: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("external-out"),
    dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
})])
  , parsedStateInitCodec = zod_1.z.object({
    splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    special: zod_1.z.union([zod_1.z.object({
        tick: zod_1.z.boolean(),
        tock: zod_1.z.boolean()
    }), zod_1.z.null()])
})
  , parsedMessageCodec = zod_1.z.object({
    body: zod_1.z.string(),
    info: parsedMessageInfoCodec,
    init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
})
  , accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")])
  , txBodyCodec = zod_1.z.union([zod_1.z.object({
    type: zod_1.z.literal("comment"),
    comment: zod_1.z.string()
}), zod_1.z.object({
    type: zod_1.z.literal("payload"),
    cell: zod_1.z.string()
})])
  , parsedOperationItemCodec = zod_1.z.union([zod_1.z.object({
    kind: zod_1.z.literal("ton"),
    amount: zod_1.z.string()
}), zod_1.z.object({
    kind: zod_1.z.literal("token"),
    amount: zod_1.z.string()
})])
  , supportedMessageTypeCodec = zod_1.z.union([zod_1.z.literal("jetton::excesses"), zod_1.z.literal("jetton::transfer"), zod_1.z.literal("jetton::transfer_notification"), zod_1.z.literal("deposit"), zod_1.z.literal("deposit::ok"), zod_1.z.literal("withdraw"), zod_1.z.literal("withdraw::all"), zod_1.z.literal("withdraw::delayed"), zod_1.z.literal("withdraw::ok"), zod_1.z.literal("airdrop")])
  , opCodec = zod_1.z.object({
    type: supportedMessageTypeCodec,
    options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
})
  , parsedOperationCodec = zod_1.z.object({
    address: zod_1.z.string(),
    comment: zod_1.z.optional(zod_1.z.string()),
    items: zod_1.z.array(parsedOperationItemCodec),
    op: zod_1.z.optional(opCodec)
})
  , parsedTransactionCodec = zod_1.z.object({
    address: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string(),
    prevTransaction: zod_1.z.object({
        lt: zod_1.z.string(),
        hash: zod_1.z.string()
    }),
    time: zod_1.z.number(),
    outMessagesCount: zod_1.z.number(),
    oldStatus: accountStatusCodec,
    newStatus: accountStatusCodec,
    fees: zod_1.z.string(),
    update: zod_1.z.object({
        oldHash: zod_1.z.string(),
        newHash: zod_1.z.string()
    }),
    inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
    outMessages: zod_1.z.array(parsedMessageCodec),
    parsed: zod_1.z.object({
        seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
        body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
        status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
        dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
        kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
        amount: zod_1.z.string(),
        resolvedAddress: zod_1.z.string(),
        bounced: zod_1.z.boolean(),
        mentioned: zod_1.z.array(zod_1.z.string())
    }),
    operation: parsedOperationCodec
})
  , parsedTransactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    transactions: zod_1.z.array(parsedTransactionCodec)
});
var WalletContractV1R1$1 = {}
  , createWalletTransfer = {};
Object.defineProperty(createWalletTransfer, "__esModule", {
    value: !0
});
createWalletTransfer.createWalletTransferV4 = createWalletTransfer.createWalletTransferV3 = createWalletTransfer.createWalletTransferV2 = createWalletTransfer.createWalletTransferV1 = void 0;
const core_1$f = dist$4
  , crypto_1$2 = requireDist();
function createWalletTransferV1(C) {
    let S = (0,
    core_1$f.beginCell)().storeUint(C.seqno, 32);
    C.message && (S.storeUint(C.sendMode, 8),
    S.storeRef((0,
    core_1$f.beginCell)().store((0,
    core_1$f.storeMessageRelaxed)(C.message))));
    let E = (0,
    crypto_1$2.sign)(S.endCell().hash(), C.secretKey);
    return (0,
    core_1$f.beginCell)().storeBuffer(E).storeBuilder(S).endCell()
}
createWalletTransfer.createWalletTransferV1 = createWalletTransferV1;
function createWalletTransferV2(C) {
    if (C.messages.length > 4)
        throw Error("Maximum number of messages in a single transfer is 4");
    let S = (0,
    core_1$f.beginCell)().storeUint(C.seqno, 32);
    if (C.seqno === 0)
        for (let T = 0; T < 32; T++)
            S.storeBit(1);
    else
        S.storeUint(C.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    for (let T of C.messages)
        S.storeUint(C.sendMode, 8),
        S.storeRef((0,
        core_1$f.beginCell)().store((0,
        core_1$f.storeMessageRelaxed)(T)));
    let E = (0,
    crypto_1$2.sign)(S.endCell().hash(), C.secretKey);
    return (0,
    core_1$f.beginCell)().storeBuffer(E).storeBuilder(S).endCell()
}
createWalletTransfer.createWalletTransferV2 = createWalletTransferV2;
function createWalletTransferV3(C) {
    if (C.messages.length > 4)
        throw Error("Maximum number of messages in a single transfer is 4");
    let S = (0,
    core_1$f.beginCell)().storeUint(C.walletId, 32);
    if (C.seqno === 0)
        for (let T = 0; T < 32; T++)
            S.storeBit(1);
    else
        S.storeUint(C.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    S.storeUint(C.seqno, 32);
    for (let T of C.messages)
        S.storeUint(C.sendMode, 8),
        S.storeRef((0,
        core_1$f.beginCell)().store((0,
        core_1$f.storeMessageRelaxed)(T)));
    let E = (0,
    crypto_1$2.sign)(S.endCell().hash(), C.secretKey);
    return (0,
    core_1$f.beginCell)().storeBuffer(E).storeBuilder(S).endCell()
}
createWalletTransfer.createWalletTransferV3 = createWalletTransferV3;
function createWalletTransferV4(C) {
    if (C.messages.length > 4)
        throw Error("Maximum number of messages in a single transfer is 4");
    let S = (0,
    core_1$f.beginCell)().storeUint(C.walletId, 32);
    if (C.seqno === 0)
        for (let T = 0; T < 32; T++)
            S.storeBit(1);
    else
        S.storeUint(C.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    S.storeUint(C.seqno, 32),
    S.storeUint(0, 8);
    for (let T of C.messages)
        S.storeUint(C.sendMode, 8),
        S.storeRef((0,
        core_1$f.beginCell)().store((0,
        core_1$f.storeMessageRelaxed)(T)));
    let E = (0,
    crypto_1$2.sign)(S.endCell().hash(), C.secretKey);
    return (0,
    core_1$f.beginCell)().storeBuffer(E).storeBuilder(S).endCell()
}
createWalletTransfer.createWalletTransferV4 = createWalletTransferV4;
Object.defineProperty(WalletContractV1R1$1, "__esModule", {
    value: !0
});
WalletContractV1R1$1.WalletContractV1R1 = void 0;
const core_1$e = dist$4
  , createWalletTransfer_1$7 = createWalletTransfer;
class WalletContractV1R1 {
    static create(S) {
        return new WalletContractV1R1(S.workchain,S.publicKey)
    }
    constructor(S, E) {
        this.workchain = S,
        this.publicKey = E;
        let M = core_1$e.Cell.fromBoc(Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0]
          , T = (0,
        core_1$e.beginCell)().storeUint(0, 32).storeBuffer(E).endCell();
        this.init = {
            code: M,
            data: T
        },
        this.address = (0,
        core_1$e.contractAddress)(S, {
            code: M,
            data: T
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        let E = await S.getState();
        return E.state.type === "active" ? core_1$e.Cell.fromBoc(E.state.data)[0].beginParse().loadUint(32) : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$e.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$7.createWalletTransferV1)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            message: S.message
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    message: (0,
                    core_1$e.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV1R1$1.WalletContractV1R1 = WalletContractV1R1;
var WalletContractV1R2$1 = {};
Object.defineProperty(WalletContractV1R2$1, "__esModule", {
    value: !0
});
WalletContractV1R2$1.WalletContractV1R2 = void 0;
const core_1$d = dist$4
  , createWalletTransfer_1$6 = createWalletTransfer;
class WalletContractV1R2 {
    static create(S) {
        return new WalletContractV1R2(S.workchain,S.publicKey)
    }
    constructor(S, E) {
        this.workchain = S,
        this.publicKey = E;
        let M = core_1$d.Cell.fromBoc(Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0]
          , T = (0,
        core_1$d.beginCell)().storeUint(0, 32).storeBuffer(E).endCell();
        this.init = {
            code: M,
            data: T
        },
        this.address = (0,
        core_1$d.contractAddress)(S, {
            code: M,
            data: T
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$d.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$6.createWalletTransferV1)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            message: S.message
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    message: (0,
                    core_1$d.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV1R2$1.WalletContractV1R2 = WalletContractV1R2;
var WalletContractV1R3$1 = {};
Object.defineProperty(WalletContractV1R3$1, "__esModule", {
    value: !0
});
WalletContractV1R3$1.WalletContractV1R3 = void 0;
const core_1$c = dist$4
  , createWalletTransfer_1$5 = createWalletTransfer;
class WalletContractV1R3 {
    static create(S) {
        return new WalletContractV1R3(S.workchain,S.publicKey)
    }
    constructor(S, E) {
        this.workchain = S,
        this.publicKey = E;
        let M = core_1$c.Cell.fromBoc(Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0]
          , T = (0,
        core_1$c.beginCell)().storeUint(0, 32).storeBuffer(E).endCell();
        this.init = {
            code: M,
            data: T
        },
        this.address = (0,
        core_1$c.contractAddress)(S, {
            code: M,
            data: T
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$c.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$5.createWalletTransferV1)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            message: S.message
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    message: (0,
                    core_1$c.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV1R3$1.WalletContractV1R3 = WalletContractV1R3;
var WalletContractV2R1$1 = {};
Object.defineProperty(WalletContractV2R1$1, "__esModule", {
    value: !0
});
WalletContractV2R1$1.WalletContractV2R1 = void 0;
const core_1$b = dist$4
  , createWalletTransfer_1$4 = createWalletTransfer;
class WalletContractV2R1 {
    static create(S) {
        return new WalletContractV2R1(S.workchain,S.publicKey)
    }
    constructor(S, E) {
        this.workchain = S,
        this.publicKey = E;
        let M = core_1$b.Cell.fromBoc(Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0]
          , T = (0,
        core_1$b.beginCell)().storeUint(0, 32).storeBuffer(E).endCell();
        this.init = {
            code: M,
            data: T
        },
        this.address = (0,
        core_1$b.contractAddress)(S, {
            code: M,
            data: T
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$b.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$4.createWalletTransferV2)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            messages: S.messages,
            timeout: S.timeout
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    messages: [(0,
                    core_1$b.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })]
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV2R1$1.WalletContractV2R1 = WalletContractV2R1;
var WalletContractV2R2$1 = {};
Object.defineProperty(WalletContractV2R2$1, "__esModule", {
    value: !0
});
WalletContractV2R2$1.WalletContractV2R2 = void 0;
const core_1$a = dist$4
  , createWalletTransfer_1$3 = createWalletTransfer;
class WalletContractV2R2 {
    static create(S) {
        return new WalletContractV2R2(S.workchain,S.publicKey)
    }
    constructor(S, E) {
        this.workchain = S,
        this.publicKey = E;
        let M = core_1$a.Cell.fromBoc(Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0]
          , T = (0,
        core_1$a.beginCell)().storeUint(0, 32).storeBuffer(E).endCell();
        this.init = {
            code: M,
            data: T
        },
        this.address = (0,
        core_1$a.contractAddress)(S, {
            code: M,
            data: T
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$a.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$3.createWalletTransferV2)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            messages: S.messages,
            timeout: S.timeout
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    messages: [(0,
                    core_1$a.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })]
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV2R2$1.WalletContractV2R2 = WalletContractV2R2;
var WalletContractV3R1$1 = {};
Object.defineProperty(WalletContractV3R1$1, "__esModule", {
    value: !0
});
WalletContractV3R1$1.WalletContractV3R1 = void 0;
const core_1$9 = dist$4
  , createWalletTransfer_1$2 = createWalletTransfer;
class WalletContractV3R1 {
    static create(S) {
        return new WalletContractV3R1(S.workchain,S.publicKey,S.walletId)
    }
    constructor(S, E, M) {
        this.workchain = S,
        this.publicKey = E,
        M != null ? this.walletId = M : this.walletId = 698983191 + S;
        let T = core_1$9.Cell.fromBoc(Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0]
          , $ = (0,
        core_1$9.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(E).endCell();
        this.init = {
            code: T,
            data: $
        },
        this.address = (0,
        core_1$9.contractAddress)(S, {
            code: T,
            data: $
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$9.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$2.createWalletTransferV3)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            messages: S.messages,
            timeout: S.timeout,
            walletId: this.walletId
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    messages: [(0,
                    core_1$9.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })]
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV3R1$1.WalletContractV3R1 = WalletContractV3R1;
var WalletContractV3R2$1 = {};
Object.defineProperty(WalletContractV3R2$1, "__esModule", {
    value: !0
});
WalletContractV3R2$1.WalletContractV3R2 = void 0;
const core_1$8 = dist$4
  , createWalletTransfer_1$1 = createWalletTransfer;
class WalletContractV3R2 {
    static create(S) {
        return new WalletContractV3R2(S.workchain,S.publicKey,S.walletId)
    }
    constructor(S, E, M) {
        this.workchain = S,
        this.publicKey = E,
        M != null ? this.walletId = M : this.walletId = 698983191 + S;
        let T = core_1$8.Cell.fromBoc(Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0]
          , $ = (0,
        core_1$8.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(E).endCell();
        this.init = {
            code: T,
            data: $
        },
        this.address = (0,
        core_1$8.contractAddress)(S, {
            code: T,
            data: $
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$8.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1$1.createWalletTransferV3)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            messages: S.messages,
            timeout: S.timeout,
            walletId: this.walletId
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    messages: [(0,
                    core_1$8.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })]
                });
                await this.send(S, $)
            }
        }
    }
}
WalletContractV3R2$1.WalletContractV3R2 = WalletContractV3R2;
var WalletContractV4$2 = {};
Object.defineProperty(WalletContractV4$2, "__esModule", {
    value: !0
});
WalletContractV4$2.WalletContractV4 = void 0;
const core_1$7 = dist$4
  , createWalletTransfer_1 = createWalletTransfer;
let WalletContractV4$1 = class Rr {
    static create(S) {
        return new Rr(S.workchain,S.publicKey,S.walletId)
    }
    constructor(S, E, M) {
        this.workchain = S,
        this.publicKey = E,
        M != null ? this.walletId = M : this.walletId = 698983191 + S;
        let T = core_1$7.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0]
          , $ = (0,
        core_1$7.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
        this.init = {
            code: T,
            data: $
        },
        this.address = (0,
        core_1$7.contractAddress)(S, {
            code: T,
            data: $
        })
    }
    async getBalance(S) {
        return (await S.getState()).balance
    }
    async getSeqno(S) {
        return (await S.getState()).state.type === "active" ? (await S.get("seqno", [])).stack.readNumber() : 0
    }
    async send(S, E) {
        await S.external(E)
    }
    async sendTransfer(S, E) {
        let M = this.createTransfer(E);
        await this.send(S, M)
    }
    createTransfer(S) {
        let E = core_1$7.SendMode.PAY_GAS_SEPARATELY;
        return S.sendMode !== null && S.sendMode !== void 0 && (E = S.sendMode),
        (0,
        createWalletTransfer_1.createWalletTransferV4)({
            seqno: S.seqno,
            sendMode: E,
            secretKey: S.secretKey,
            messages: S.messages,
            timeout: S.timeout,
            walletId: this.walletId
        })
    }
    sender(S, E) {
        return {
            send: async M=>{
                let T = await this.getSeqno(S)
                  , $ = this.createTransfer({
                    seqno: T,
                    secretKey: E,
                    sendMode: M.sendMode,
                    messages: [(0,
                    core_1$7.internal)({
                        to: M.to,
                        value: M.value,
                        init: M.init,
                        body: M.body,
                        bounce: M.bounce
                    })]
                });
                await this.send(S, $)
            }
        }
    }
}
;
WalletContractV4$2.WalletContractV4 = WalletContractV4$1;
var JettonMaster$1 = {};
Object.defineProperty(JettonMaster$1, "__esModule", {
    value: !0
});
JettonMaster$1.JettonMaster = void 0;
const core_1$6 = dist$4;
class JettonMaster {
    static create(S) {
        return new JettonMaster(S)
    }
    constructor(S) {
        this.address = S
    }
    async getWalletAddress(S, E) {
        return (await S.get("get_wallet_address", [{
            type: "slice",
            cell: (0,
            core_1$6.beginCell)().storeAddress(E).endCell()
        }])).stack.readAddress()
    }
    async getJettonData(S) {
        let E = await S.get("get_jetton_data", [])
          , M = E.stack.readBigNumber()
          , T = E.stack.readBoolean()
          , $ = E.stack.readAddress()
          , B = E.stack.readCell()
          , O = E.stack.readCell();
        return {
            totalSupply: M,
            mintable: T,
            adminAddress: $,
            content: B,
            walletCode: O
        }
    }
}
JettonMaster$1.JettonMaster = JettonMaster;
var JettonWallet$3 = {};
Object.defineProperty(JettonWallet$3, "__esModule", {
    value: !0
});
JettonWallet$3.JettonWallet = void 0;
let JettonWallet$2 = class Ir {
    static create(S) {
        return new Ir(S)
    }
    constructor(S) {
        this.address = S
    }
    async getBalance(S) {
        return (await S.getState()).state.type !== "active" ? 0n : (await S.get("get_wallet_data", [])).stack.readBigNumber()
    }
}
;
JettonWallet$3.JettonWallet = JettonWallet$2;
var MultisigOrder$1 = {};
Object.defineProperty(MultisigOrder$1, "__esModule", {
    value: !0
});
MultisigOrder$1.MultisigOrder = void 0;
const crypto_1$1 = requireDist()
  , core_1$5 = dist$4;
class MultisigOrder {
    constructor(S) {
        this.signatures = {},
        this.payload = S
    }
    static fromCell(S) {
        var B;
        let E = S.beginParse()
          , M = (B = E.loadMaybeRef()) == null ? void 0 : B.beginParse();
        const T = E.asCell();
        let $ = new MultisigOrder(T);
        if (M) {
            for (; M.remainingBits > 0; ) {
                const O = M.loadBuffer(64)
                  , F = M.loadUint(8);
                $.signatures[F] = O,
                M.remainingRefs > 0 ? M = M.loadRef().asSlice() : M.skip(1)
            }
            M.endParse()
        }
        return $
    }
    static fromPayload(S) {
        return new MultisigOrder(S)
    }
    addSignature(S, E, M) {
        const T = this.payload.hash();
        if (!(0,
        crypto_1$1.signVerify)(T, E, M.owners.get(S).slice(0, -1)))
            throw Error("invalid signature");
        this.signatures[S] = E
    }
    sign(S, E) {
        const M = this.payload.hash();
        return this.signatures[S] = (0,
        crypto_1$1.sign)(M, E),
        M
    }
    unionSignatures(S) {
        this.signatures = Object.assign({}, this.signatures, S.signatures)
    }
    clearSignatures() {
        this.signatures = {}
    }
    toCell(S) {
        let E = (0,
        core_1$5.beginCell)().storeBit(0);
        for (const M in this.signatures) {
            const T = this.signatures[M];
            E = (0,
            core_1$5.beginCell)().storeBit(1).storeRef((0,
            core_1$5.beginCell)().storeBuffer(T).storeUint(parseInt(M), 8).storeBuilder(E).endCell())
        }
        return (0,
        core_1$5.beginCell)().storeUint(S, 8).storeBuilder(E).storeBuilder(this.payload.asBuilder()).endCell()
    }
}
MultisigOrder$1.MultisigOrder = MultisigOrder;
var MultisigOrderBuilder$1 = {};
Object.defineProperty(MultisigOrderBuilder$1, "__esModule", {
    value: !0
});
MultisigOrderBuilder$1.MultisigOrderBuilder = void 0;
const core_1$4 = dist$4
  , MultisigOrder_1 = MultisigOrder$1;
class MultisigOrderBuilder {
    constructor(S, E) {
        this.messages = (0,
        core_1$4.beginCell)(),
        this.queryId = 0n,
        this.walletId = S,
        this.queryOffset = E || 7200
    }
    addMessage(S, E) {
        if (this.messages.refs >= 4)
            throw Error("only 4 refs are allowed");
        this.updateQueryId(),
        this.messages.storeUint(E, 8),
        this.messages.storeRef((0,
        core_1$4.beginCell)().store((0,
        core_1$4.storeMessageRelaxed)(S)).endCell())
    }
    clearMessages() {
        this.messages = (0,
        core_1$4.beginCell)()
    }
    build() {
        return MultisigOrder_1.MultisigOrder.fromPayload((0,
        core_1$4.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell())
    }
    updateQueryId() {
        const S = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
        this.queryId = S << 32n
    }
}
MultisigOrderBuilder$1.MultisigOrderBuilder = MultisigOrderBuilder;
var MultisigWallet$1 = {};
Object.defineProperty(MultisigWallet$1, "__esModule", {
    value: !0
});
MultisigWallet$1.MultisigWallet = void 0;
const crypto_1 = requireDist()
  , core_1$3 = dist$4
  , MULTISIG_CODE = core_1$3.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
class MultisigWallet {
    constructor(S, E, M, T, $) {
        this.provider = null,
        this.owners = core_1$3.Dictionary.empty(),
        this.workchain = E,
        this.walletId = M,
        this.k = T;
        for (let B = 0; B < S.length; B += 1)
            this.owners.set(B, Buffer.concat([S[B], Buffer.alloc(1)]));
        this.init = {
            code: MULTISIG_CODE,
            data: (0,
            core_1$3.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, core_1$3.Dictionary.Keys.Uint(8), core_1$3.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
        },
        this.address = ($ == null ? void 0 : $.address) || (0,
        core_1$3.contractAddress)(E, this.init),
        $ != null && $.provider ? this.provider = $.provider : $ != null && $.client && (this.provider = $.client.provider(this.address, {
            code: this.init.code,
            data: this.init.data
        }))
    }
    static async fromAddress(S, E) {
        let M;
        if (E.provider)
            M = E.provider;
        else {
            if (!E.client)
                throw Error("Either provider or client must be specified");
            M = E.client.provider(S, {
                code: null,
                data: null
            })
        }
        const T = (await M.getState()).state;
        if (T.type !== "active")
            throw Error("Contract must be active");
        const $ = core_1$3.Cell.fromBoc(T.data)[0].beginParse()
          , B = $.loadUint(32);
        $.skip(8);
        const O = $.loadUint(8);
        $.skip(64);
        const F = $.loadDict(core_1$3.Dictionary.Keys.Uint(8), core_1$3.Dictionary.Values.Buffer(33));
        let N = [];
        for (const [U,H] of F) {
            const Z = H.subarray(0, 32);
            N.push(Z)
        }
        return new MultisigWallet(N,S.workChain,B,O,{
            address: S,
            provider: M,
            client: E.client
        })
    }
    async deployExternal(S) {
        if (!S && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        S || (S = this.provider),
        await S.external(core_1$3.Cell.EMPTY)
    }
    async deployInternal(S, E=1000000000n) {
        await S.send({
            sendMode: 3,
            to: this.address,
            value: E,
            init: this.init,
            body: core_1$3.Cell.EMPTY,
            bounce: !0
        })
    }
    async sendOrder(S, E, M) {
        if (!M && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        M || (M = this.provider);
        let T = (0,
        crypto_1.keyPairFromSecretKey)(E).publicKey
          , $ = this.getOwnerIdByPubkey(T)
          , B = S.toCell($)
          , O = (0,
        crypto_1.sign)(B.hash(), E);
        B = (0,
        core_1$3.beginCell)().storeBuffer(O).storeSlice(B.asSlice()).endCell(),
        await M.external(B)
    }
    async sendOrderWithoutSecretKey(S, E, M, T) {
        if (!T && !this.provider)
            throw Error("you must specify provider if there is no such property in MultisigWallet instance");
        T || (T = this.provider);
        let $ = S.toCell(M);
        $ = (0,
        core_1$3.beginCell)().storeBuffer(E).storeSlice($.asSlice()).endCell(),
        await T.external($)
    }
    getOwnerIdByPubkey(S) {
        for (const [E,M] of this.owners)
            if (M.subarray(0, 32).equals(S))
                return E;
        throw Error("public key is not an owner")
    }
}
MultisigWallet$1.MultisigWallet = MultisigWallet;
var ElectorContract$1 = {};
Object.defineProperty(ElectorContract$1, "__esModule", {
    value: !0
});
ElectorContract$1.ElectorContract = void 0;
const core_1$2 = dist$4
  , FrozenDictValue = {
    serialize(C, S) {
        throw Error("not implemented")
    },
    parse(C) {
        const S = new core_1$2.Address(-1,C.loadBuffer(32))
          , E = C.loadUintBig(64)
          , M = C.loadCoins();
        return {
            address: S,
            weight: E,
            stake: M
        }
    }
}
  , EntitiesDictValue = {
    serialize(C, S) {
        throw Error("not implemented")
    },
    parse(C) {
        const S = C.loadCoins();
        C.skip(64);
        const E = new core_1$2.Address(-1,C.loadBuffer(32))
          , M = C.loadBuffer(32);
        return {
            stake: S,
            address: E,
            adnl: M
        }
    }
};
class ElectorContract {
    static create() {
        return new ElectorContract
    }
    constructor() {
        this.address = core_1$2.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333")
    }
    async getReturnedStake(S, E) {
        if (E.workChain !== -1)
            throw Error("Only masterchain addresses could have stake");
        return (await S.get("compute_returned_stake", [{
            type: "int",
            value: BigInt("0x" + E.hash.toString("hex"))
        }])).stack.readBigNumber()
    }
    async getPastElectionsList(S) {
        const E = await S.get("past_elections_list", [])
          , M = new core_1$2.TupleReader(E.stack.readLispList())
          , T = [];
        for (; M.remaining > 0; ) {
            const $ = M.readTuple()
              , B = $.readNumber()
              , O = $.readNumber();
            $.pop();
            const F = $.readNumber();
            T.push({
                id: B,
                unfreezeAt: O,
                stakeHeld: F
            })
        }
        return T
    }
    async getPastElections(S) {
        const E = await S.get("past_elections", [])
          , M = new core_1$2.TupleReader(E.stack.readLispList())
          , T = [];
        for (; M.remaining > 0; ) {
            const $ = M.readTuple()
              , B = $.readNumber()
              , O = $.readNumber()
              , F = $.readNumber();
            $.pop();
            const N = $.readCell()
              , U = $.readBigNumber()
              , H = $.readBigNumber();
            let Z = new Map;
            const J = N.beginParse().loadDictDirect(core_1$2.Dictionary.Keys.Buffer(32), FrozenDictValue);
            for (const [ie,oe] of J)
                Z.set(BigInt("0x" + ie.toString("hex")).toString(10), {
                    address: oe.address,
                    weight: oe.weight,
                    stake: oe.stake
                });
            T.push({
                id: B,
                unfreezeAt: O,
                stakeHeld: F,
                totalStake: U,
                bonuses: H,
                frozen: Z
            })
        }
        return T
    }
    async getElectionEntities(S) {
        const E = await S.getState();
        if (E.state.type !== "active")
            throw Error("Unexpected error");
        const T = core_1$2.Cell.fromBoc(E.state.data)[0].beginParse();
        if (!T.loadBit())
            return null;
        const $ = T.loadRef().beginParse()
          , B = $.loadUint(32)
          , O = $.loadUint(32)
          , F = $.loadCoins()
          , N = $.loadCoins()
          , U = $.loadDict(core_1$2.Dictionary.Keys.Buffer(32), EntitiesDictValue);
        let H = [];
        if (U)
            for (const [Z,J] of U)
                H.push({
                    pubkey: Z,
                    stake: J.stake,
                    address: J.address,
                    adnl: J.adnl
                });
        return {
            minStake: F,
            allStakes: N,
            endElectionsTime: O,
            startWorkTime: B,
            entities: H
        }
    }
    async getActiveElectionId(S) {
        const M = (await S.get("active_election_id", [])).stack.readNumber();
        return M > 0 ? M : null
    }
    async getComplaints(S, E) {
        const M = new core_1$2.TupleBuilder;
        M.writeNumber(E);
        const T = await S.get("list_complaints", M.build());
        if (T.stack.peek().type === "null")
            return [];
        const $ = new core_1$2.TupleReader(T.stack.readLispList())
          , B = [];
        for (; $.remaining > 0; ) {
            const O = $.readTuple()
              , F = O.readBigNumber()
              , N = O.readTuple()
              , U = N.readTuple()
              , H = Buffer.from(U.readBigNumber().toString(16), "hex");
            U.readCell();
            const Z = U.readNumber()
              , J = U.readNumber()
              , ie = new core_1$2.Address(-1,Buffer.from(U.readBigNumber().toString(16), "hex"))
              , oe = U.readBigNumber()
              , ae = U.readBigNumber()
              , se = U.readBigNumber()
              , le = []
              , de = new core_1$2.TupleReader(N.readLispList());
            for (; de.remaining > 0; )
                le.push(de.readNumber());
            const fe = N.readBigNumber()
              , pe = N.readBigNumber();
            B.push({
                id: F,
                publicKey: H,
                createdAt: Z,
                severity: J,
                paid: oe,
                suggestedFine: ae,
                suggestedFinePart: se,
                rewardAddress: ie,
                votes: le,
                remainingWeight: pe,
                vsetId: fe
            })
        }
        return B
    }
}
ElectorContract$1.ElectorContract = ElectorContract;
var ConfigParser = {};
Object.defineProperty(ConfigParser, "__esModule", {
    value: !0
});
ConfigParser.parseFullConfig = ConfigParser.loadConfigParamsAsSlice = ConfigParser.loadConfigParamById = ConfigParser.parseVotingSetup = ConfigParser.parseProposalSetup = ConfigParser.configParse29 = ConfigParser.configParse28 = ConfigParser.configParseMsgPrices = ConfigParser.configParseGasLimitsPrices = ConfigParser.configParseBridge = ConfigParser.configParseValidatorSet = ConfigParser.configParse12 = ConfigParser.configParseWorkchainDescriptor = ConfigParser.configParse40 = ConfigParser.configParse8 = ConfigParser.configParse18 = ConfigParser.configParse17 = ConfigParser.configParse16 = ConfigParser.configParse15 = ConfigParser.configParse13 = ConfigParser.configParse5 = ConfigParser.configParseMasterAddressRequired = ConfigParser.parseBridge = ConfigParser.parseValidatorSet = ConfigParser.configParseMasterAddress = void 0;
const core_1$1 = dist$4;
function configParseMasterAddress(C) {
    return C ? new core_1$1.Address(-1,C.loadBuffer(32)) : null
}
ConfigParser.configParseMasterAddress = configParseMasterAddress;
function readPublicKey(C) {
    if (C.loadUint(32) !== 2390828938)
        throw Error("Invalid config");
    return C.loadBuffer(32)
}
const ValidatorDescriptionDictValue = {
    serialize(C, S) {
        throw Error("not implemented")
    },
    parse(C) {
        const S = C.loadUint(8);
        if (S === 83)
            return {
                publicKey: readPublicKey(C),
                weight: C.loadUintBig(64),
                adnlAddress: null
            };
        if (S === 115)
            return {
                publicKey: readPublicKey(C),
                weight: C.loadUintBig(64),
                adnlAddress: C.loadBuffer(32)
            };
        throw Error("Invalid config")
    }
};
function parseValidatorSet(C) {
    const S = C.loadUint(8);
    if (S === 17) {
        const E = C.loadUint(32)
          , M = C.loadUint(32)
          , T = C.loadUint(16)
          , $ = C.loadUint(16)
          , B = C.loadDictDirect(core_1$1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
            timeSince: E,
            timeUntil: M,
            total: T,
            main: $,
            totalWeight: null,
            list: B
        }
    } else if (S === 18) {
        const E = C.loadUint(32)
          , M = C.loadUint(32)
          , T = C.loadUint(16)
          , $ = C.loadUint(16)
          , B = C.loadUintBig(64)
          , O = C.loadDict(core_1$1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
        return {
            timeSince: E,
            timeUntil: M,
            total: T,
            main: $,
            totalWeight: B,
            list: O
        }
    }
}
ConfigParser.parseValidatorSet = parseValidatorSet;
function parseBridge(C) {
    const S = new core_1$1.Address(-1,C.loadBuffer(32))
      , E = new core_1$1.Address(-1,C.loadBuffer(32))
      , M = C.loadDict(core_1$1.Dictionary.Keys.Buffer(32), core_1$1.Dictionary.Values.Buffer(32))
      , T = new Map;
    for (const [B,O] of M)
        T.set(new core_1$1.Address(-1,B).toString(), O);
    const $ = C.loadBuffer(32);
    return {
        bridgeAddress: S,
        oracleMultisigAddress: E,
        oracles: T,
        externalChainAddress: $
    }
}
ConfigParser.parseBridge = parseBridge;
function configParseMasterAddressRequired(C) {
    if (!C)
        throw Error("Invalid config");
    return configParseMasterAddress(C)
}
ConfigParser.configParseMasterAddressRequired = configParseMasterAddressRequired;
function configParse5(C) {
    if (!C)
        throw Error("Invalid config");
    if (C.loadUint(8) === 1) {
        const E = C.loadBit() ? new core_1$1.Address(-1,C.loadBuffer(32)) : null
          , M = C.loadUint(32)
          , T = C.loadUint(32);
        return {
            blackholeAddr: E,
            feeBurnNominator: M,
            feeBurnDenominator: T
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse5 = configParse5;
function configParse13(C) {
    if (!C)
        throw Error("Invalid config");
    if (C.loadUint(8) === 26) {
        const E = C.loadCoins()
          , M = C.loadCoins()
          , T = C.loadCoins();
        return {
            deposit: E,
            bitPrice: M,
            cellPrice: T
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse13 = configParse13;
function configParse15(C) {
    if (!C)
        throw Error("Invalid config");
    const S = C.loadUint(32)
      , E = C.loadUint(32)
      , M = C.loadUint(32)
      , T = C.loadUint(32);
    return {
        validatorsElectedFor: S,
        electorsStartBefore: E,
        electorsEndBefore: M,
        stakeHeldFor: T
    }
}
ConfigParser.configParse15 = configParse15;
function configParse16(C) {
    if (!C)
        throw Error("Invalid config");
    const S = C.loadUint(16)
      , E = C.loadUint(16)
      , M = C.loadUint(16);
    return {
        maxValidators: S,
        maxMainValidators: E,
        minValidators: M
    }
}
ConfigParser.configParse16 = configParse16;
function configParse17(C) {
    if (!C)
        throw Error("Invalid config");
    const S = C.loadCoins()
      , E = C.loadCoins()
      , M = C.loadCoins()
      , T = C.loadUint(32);
    return {
        minStake: S,
        maxStake: E,
        minTotalStake: M,
        maxStakeFactor: T
    }
}
ConfigParser.configParse17 = configParse17;
const StoragePricesDictValue = {
    serialize(C, S) {
        throw Error("not implemented")
    },
    parse(C) {
        if (C.loadUint(8) !== 204)
            throw Error("Invalid config");
        const E = C.loadUint(32)
          , M = C.loadUintBig(64)
          , T = C.loadUintBig(64)
          , $ = C.loadUintBig(64)
          , B = C.loadUintBig(64);
        return {
            utime_since: E,
            bit_price_ps: M,
            cell_price_ps: T,
            mc_bit_price_ps: $,
            mc_cell_price_ps: B
        }
    }
};
function configParse18(C) {
    if (!C)
        throw Error("Invalid config");
    return C.loadDictDirect(core_1$1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values()
}
ConfigParser.configParse18 = configParse18;
function configParse8(C) {
    if (!C)
        return {
            version: 0,
            capabilities: 0n
        };
    const S = C.loadUint(32)
      , E = C.loadUintBig(64);
    return {
        version: S,
        capabilities: E
    }
}
ConfigParser.configParse8 = configParse8;
function configParse40(C) {
    if (!C)
        return null;
    if (C.loadUint(8) !== 1)
        throw Error("Invalid config");
    const E = C.loadCoins()
      , M = C.loadCoins()
      , T = C.loadUint(16)
      , $ = C.loadUint(16)
      , B = C.loadUint(16)
      , O = C.loadUint(16)
      , F = C.loadUint(16)
      , N = C.loadUint(16)
      , U = C.loadUint(16)
      , H = C.loadUint(16)
      , Z = C.loadUint(16);
    return {
        defaultFlatFine: E,
        defaultProportionaFine: M,
        severityFlatMult: T,
        severityProportionalMult: $,
        unfunishableInterval: B,
        longInterval: O,
        longFlatMult: F,
        longProportionalMult: N,
        mediumInterval: U,
        mediumFlatMult: H,
        mediumProportionalMult: Z
    }
}
ConfigParser.configParse40 = configParse40;
function configParseWorkchainDescriptor(C) {
    if (C.loadUint(8) !== 166)
        throw Error("Invalid config");
    const S = C.loadUint(32)
      , E = C.loadUint(8)
      , M = C.loadUint(8)
      , T = C.loadUint(8)
      , $ = C.loadBit()
      , B = C.loadBit()
      , O = C.loadBit()
      , F = C.loadUint(13)
      , N = C.loadBuffer(32)
      , U = C.loadBuffer(32)
      , H = C.loadUint(32);
    if (C.loadBit())
        throw Error("Invalid config");
    const Z = C.loadUint(32)
      , J = C.loadUintBig(64);
    return {
        enabledSince: S,
        actialMinSplit: E,
        min_split: M,
        max_split: T,
        basic: $,
        active: B,
        accept_msgs: O,
        flags: F,
        zerostateRootHash: N,
        zerostateFileHash: U,
        version: H,
        format: {
            vmVersion: Z,
            vmMode: J
        }
    }
}
ConfigParser.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
const WorkchainDescriptorDictValue = {
    serialize(C, S) {
        throw Error("not implemented")
    },
    parse(C) {
        if (C.loadUint(8) !== 166)
            throw Error("Invalid config");
        const S = C.loadUint(32)
          , E = C.loadUint(8)
          , M = C.loadUint(8)
          , T = C.loadUint(8)
          , $ = C.loadBit()
          , B = C.loadBit()
          , O = C.loadBit()
          , F = C.loadUint(13)
          , N = C.loadBuffer(32)
          , U = C.loadBuffer(32)
          , H = C.loadUint(32);
        if (C.loadBit())
            throw Error("Invalid config");
        const Z = C.loadUint(32)
          , J = C.loadUintBig(64);
        return {
            enabledSince: S,
            actialMinSplit: E,
            min_split: M,
            max_split: T,
            basic: $,
            active: B,
            accept_msgs: O,
            flags: F,
            zerostateRootHash: N,
            zerostateFileHash: U,
            version: H,
            format: {
                vmVersion: Z,
                vmMode: J
            }
        }
    }
};
function configParse12(C) {
    if (!C)
        throw Error("Invalid config");
    const S = C.loadDict(core_1$1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
    if (S)
        return S;
    throw Error("No workchains exist")
}
ConfigParser.configParse12 = configParse12;
function configParseValidatorSet(C) {
    return C ? parseValidatorSet(C) : null
}
ConfigParser.configParseValidatorSet = configParseValidatorSet;
function configParseBridge(C) {
    return C ? parseBridge(C) : null
}
ConfigParser.configParseBridge = configParseBridge;
function parseGasLimitsInternal(C) {
    const S = C.loadUint(8);
    if (S === 222) {
        const E = C.loadUintBig(64)
          , M = C.loadUintBig(64)
          , T = C.loadUintBig(64)
          , $ = C.loadUintBig(64)
          , B = C.loadUintBig(64)
          , O = C.loadUintBig(64)
          , F = C.loadUintBig(64);
        return {
            gasPrice: E,
            gasLimit: M,
            specialGasLimit: T,
            gasCredit: $,
            blockGasLimit: B,
            freezeDueLimit: O,
            deleteDueLimit: F
        }
    } else if (S === 221) {
        const E = C.loadUintBig(64)
          , M = C.loadUintBig(64)
          , T = C.loadUintBig(64)
          , $ = C.loadUintBig(64)
          , B = C.loadUintBig(64)
          , O = C.loadUintBig(64);
        return {
            gasPrice: E,
            gasLimit: M,
            gasCredit: T,
            blockGasLimit: $,
            freezeDueLimit: B,
            deleteDueLimit: O
        }
    } else
        throw Error("Invalid config")
}
function configParseGasLimitsPrices(C) {
    if (!C)
        throw Error("Invalid config");
    if (C.loadUint(8) === 209) {
        const E = C.loadUintBig(64)
          , M = C.loadUintBig(64)
          , T = parseGasLimitsInternal(C);
        return {
            flatLimit: E,
            flatGasPrice: M,
            other: T
        }
    } else
        throw Error("Invalid config")
}
ConfigParser.configParseGasLimitsPrices = configParseGasLimitsPrices;
function configParseMsgPrices(C) {
    if (!C)
        throw new Error("Invalid config");
    if (C.loadUint(8) !== 234)
        throw new Error("Invalid msg prices param");
    return {
        lumpPrice: C.loadUintBig(64),
        bitPrice: C.loadUintBig(64),
        cellPrice: C.loadUintBig(64),
        ihrPriceFactor: C.loadUint(32),
        firstFrac: C.loadUint(16),
        nextFrac: C.loadUint(16)
    }
}
ConfigParser.configParseMsgPrices = configParseMsgPrices;
function configParse28(C) {
    if (!C)
        throw new Error("Invalid config");
    const S = C.loadUint(8);
    if (S === 193) {
        const E = C.loadUint(32)
          , M = C.loadUint(32)
          , T = C.loadUint(32)
          , $ = C.loadUint(32);
        return {
            masterCatchainLifetime: E,
            shardCatchainLifetime: M,
            shardValidatorsLifetime: T,
            shardValidatorsCount: $
        }
    }
    if (S === 194) {
        const E = C.loadUint(7)
          , M = C.loadBit()
          , T = C.loadUint(32)
          , $ = C.loadUint(32)
          , B = C.loadUint(32)
          , O = C.loadUint(32);
        return {
            flags: E,
            suffleMasterValidators: M,
            masterCatchainLifetime: T,
            shardCatchainLifetime: $,
            shardValidatorsLifetime: B,
            shardValidatorsCount: O
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse28 = configParse28;
function configParse29(C) {
    if (!C)
        throw new Error("Invalid config");
    const S = C.loadUint(8);
    if (S === 214) {
        const E = C.loadUint(32)
          , M = C.loadUint(32)
          , T = C.loadUint(32)
          , $ = C.loadUint(32)
          , B = C.loadUint(32)
          , O = C.loadUint(32)
          , F = C.loadUint(32)
          , N = C.loadUint(32);
        return {
            roundCandidates: E,
            nextCandidateDelay: M,
            consensusTimeout: T,
            fastAttempts: $,
            attemptDuration: B,
            catchainMaxDeps: O,
            maxBlockBytes: F,
            maxColaltedBytes: N
        }
    } else if (S === 215) {
        const E = C.loadUint(7)
          , M = C.loadBit()
          , T = C.loadUint(8)
          , $ = C.loadUint(32)
          , B = C.loadUint(32)
          , O = C.loadUint(32)
          , F = C.loadUint(32)
          , N = C.loadUint(32)
          , U = C.loadUint(32)
          , H = C.loadUint(32);
        return {
            flags: E,
            newCatchainIds: M,
            roundCandidates: T,
            nextCandidateDelay: $,
            consensusTimeout: B,
            fastAttempts: O,
            attemptDuration: F,
            catchainMaxDeps: N,
            maxBlockBytes: U,
            maxColaltedBytes: H
        }
    } else if (S === 216) {
        const E = C.loadUint(7)
          , M = C.loadBit()
          , T = C.loadUint(8)
          , $ = C.loadUint(32)
          , B = C.loadUint(32)
          , O = C.loadUint(32)
          , F = C.loadUint(32)
          , N = C.loadUint(32)
          , U = C.loadUint(32)
          , H = C.loadUint(32)
          , Z = C.loadUint(16);
        return {
            flags: E,
            newCatchainIds: M,
            roundCandidates: T,
            nextCandidateDelay: $,
            consensusTimeout: B,
            fastAttempts: O,
            attemptDuration: F,
            catchainMaxDeps: N,
            maxBlockBytes: U,
            maxColaltedBytes: H,
            protoVersion: Z
        }
    } else if (S === 217) {
        const E = C.loadUint(7)
          , M = C.loadBit()
          , T = C.loadUint(8)
          , $ = C.loadUint(32)
          , B = C.loadUint(32)
          , O = C.loadUint(32)
          , F = C.loadUint(32)
          , N = C.loadUint(32)
          , U = C.loadUint(32)
          , H = C.loadUint(32)
          , Z = C.loadUint(16)
          , J = C.loadUint(32);
        return {
            flags: E,
            newCatchainIds: M,
            roundCandidates: T,
            nextCandidateDelay: $,
            consensusTimeout: B,
            fastAttempts: O,
            attemptDuration: F,
            catchainMaxDeps: N,
            maxBlockBytes: U,
            maxColaltedBytes: H,
            protoVersion: Z,
            catchainMaxBlocksCoeff: J
        }
    }
    throw new Error("Invalid config")
}
ConfigParser.configParse29 = configParse29;
function parseProposalSetup(C) {
    if (C.loadUint(8) !== 54)
        throw new Error("Invalid config");
    const E = C.loadUint(8)
      , M = C.loadUint(8)
      , T = C.loadUint(8)
      , $ = C.loadUint(8)
      , B = C.loadUint(32)
      , O = C.loadUint(32)
      , F = C.loadUint(32)
      , N = C.loadUint(32);
    return {
        minTotalRounds: E,
        maxTotalRounds: M,
        minWins: T,
        maxLoses: $,
        minStoreSec: B,
        maxStoreSec: O,
        bitPrice: F,
        cellPrice: N
    }
}
ConfigParser.parseProposalSetup = parseProposalSetup;
function parseVotingSetup(C) {
    if (!C)
        throw new Error("Invalid config");
    if (C.loadUint(8) !== 145)
        throw new Error("Invalid config");
    const E = parseProposalSetup(C.loadRef().beginParse())
      , M = parseProposalSetup(C.loadRef().beginParse());
    return {
        normalParams: E,
        criticalParams: M
    }
}
ConfigParser.parseVotingSetup = parseVotingSetup;
function loadConfigParams(C) {
    return core_1$1.Cell.fromBase64(C).beginParse().loadDictDirect(core_1$1.Dictionary.Keys.Int(32), core_1$1.Dictionary.Values.Cell())
}
function loadConfigParamById(C, S) {
    return loadConfigParams(C).get(S)
}
ConfigParser.loadConfigParamById = loadConfigParamById;
function loadConfigParamsAsSlice(C) {
    const S = loadConfigParams(C)
      , E = new Map;
    for (const [M,T] of S)
        E.set(M, T.beginParse());
    return E
}
ConfigParser.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
function parseFullConfig(C) {
    return {
        configAddress: configParseMasterAddressRequired(C.get(0)),
        electorAddress: configParseMasterAddressRequired(C.get(1)),
        minterAddress: configParseMasterAddress(C.get(2)),
        feeCollectorAddress: configParseMasterAddress(C.get(3)),
        dnsRootAddress: configParseMasterAddress(C.get(4)),
        burningConfig: configParse5(C.get(5)),
        globalVersion: configParse8(C.get(8)),
        workchains: configParse12(C.get(12)),
        voting: parseVotingSetup(C.get(11)),
        validators: {
            ...configParse15(C.get(15)),
            ...configParse16(C.get(16)),
            ...configParse17(C.get(17))
        },
        storagePrices: configParse18(C.get(18)),
        gasPrices: {
            masterchain: configParseGasLimitsPrices(C.get(20)),
            workchain: configParseGasLimitsPrices(C.get(21))
        },
        msgPrices: {
            masterchain: configParseMsgPrices(C.get(24)),
            workchain: configParseMsgPrices(C.get(25))
        },
        validatorSets: {
            prevValidators: configParseValidatorSet(C.get(32)),
            prevTempValidators: configParseValidatorSet(C.get(33)),
            currentValidators: configParseValidatorSet(C.get(34)),
            currentTempValidators: configParseValidatorSet(C.get(35)),
            nextValidators: configParseValidatorSet(C.get(36)),
            nextTempValidators: configParseValidatorSet(C.get(37))
        },
        validatorsPunish: configParse40(C.get(40)),
        bridges: {
            ethereum: configParseBridge(C.get(71)),
            binance: configParseBridge(C.get(72)),
            polygon: configParseBridge(C.get(73))
        },
        catchain: configParse28(C.get(28)),
        consensus: configParse29(C.get(29))
    }
}
ConfigParser.parseFullConfig = parseFullConfig;
var fees = {};
Object.defineProperty(fees, "__esModule", {
    value: !0
});
fees.computeMessageForwardFees = fees.computeExternalMessageFees = fees.computeGasPrices = fees.computeFwdFees = fees.computeStorageFees = void 0;
const core_1 = dist$4;
function computeStorageFees(C) {
    const {lastPaid: S, now: E, storagePrices: M, storageStat: T, special: $, masterchain: B} = C;
    if (E <= S || M.length === 0 || E < M[0].utime_since || $)
        return BigInt(0);
    let O = Math.max(S, M[0].utime_since)
      , F = BigInt(0);
    for (let N = 0; N < M.length && O < E; N++) {
        let U = N < M.length - 1 ? Math.min(E, M[N + 1].utime_since) : E
          , H = BigInt(0);
        if (O < U) {
            let Z = U - O;
            H += BigInt(T.cells) * (B ? M[N].mc_cell_price_ps : M[N].cell_price_ps),
            H += BigInt(T.bits) * (B ? M[N].mc_bit_price_ps : M[N].bit_price_ps),
            H = H * BigInt(Z)
        }
        O = U,
        F += H
    }
    return shr16ceil(F)
}
fees.computeStorageFees = computeStorageFees;
function computeFwdFees(C, S, E) {
    return C.lumpPrice + shr16ceil(C.bitPrice * E + C.cellPrice * S)
}
fees.computeFwdFees = computeFwdFees;
function computeGasPrices(C, S) {
    return C <= S.flatLimit ? S.flatPrice : S.flatPrice + (S.price * (C - S.flatLimit) >> 16n)
}
fees.computeGasPrices = computeGasPrices;
function computeExternalMessageFees(C, S) {
    let E = collectCellStats(S);
    return E.bits -= S.bits.length,
    E.cells -= 1,
    computeFwdFees(C, BigInt(E.cells), BigInt(E.bits))
}
fees.computeExternalMessageFees = computeExternalMessageFees;
function computeMessageForwardFees(C, S) {
    let E = (0,
    core_1.loadMessageRelaxed)(S.beginParse())
      , M = {
        bits: 0,
        cells: 0
    };
    if (E.init) {
        const F = new core_1.Cell().asBuilder();
        (0,
        core_1.storeStateInit)(E.init)(F);
        const N = F.endCell();
        let U = collectCellStats(N);
        U.bits -= N.bits.length,
        U.cells -= 1,
        M.bits += U.bits,
        M.cells += U.cells
    }
    let T = collectCellStats(E.body);
    T.bits -= E.body.bits.length,
    T.cells -= 1,
    M.bits += T.bits,
    M.cells += T.cells;
    let $ = computeFwdFees(C, BigInt(M.cells), BigInt(M.bits))
      , B = $ * BigInt(C.firstFrac) >> 16n
      , O = $ - B;
    return {
        fees: B,
        remaining: O
    }
}
fees.computeMessageForwardFees = computeMessageForwardFees;
function collectCellStats(C) {
    let S = C.bits.length
      , E = 1;
    for (let M of C.refs) {
        let T = collectCellStats(M);
        E += T.cells,
        S += T.bits
    }
    return {
        bits: S,
        cells: E
    }
}
function shr16ceil(C) {
    let S = C % 65536n
      , E = C >> 16n;
    return S !== 0n && (E += 1n),
    E
}
(function(C) {
    var S = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ge, we, Ae, Se) {
        Se === void 0 && (Se = Ae);
        var ue = Object.getOwnPropertyDescriptor(we, Ae);
        (!ue || ("get"in ue ? !we.__esModule : ue.writable || ue.configurable)) && (ue = {
            enumerable: !0,
            get: function() {
                return we[Ae]
            }
        }),
        Object.defineProperty(ge, Se, ue)
    }
    : function(ge, we, Ae, Se) {
        Se === void 0 && (Se = Ae),
        ge[Se] = we[Ae]
    }
    )
      , E = commonjsGlobal && commonjsGlobal.__exportStar || function(ge, we) {
        for (var Ae in ge)
            Ae !== "default" && !Object.prototype.hasOwnProperty.call(we, Ae) && S(we, ge, Ae)
    }
    ;
    Object.defineProperty(C, "__esModule", {
        value: !0
    }),
    C.computeStorageFees = C.computeMessageForwardFees = C.computeGasPrices = C.computeFwdFees = C.computeExternalMessageFees = C.loadConfigParamsAsSlice = C.loadConfigParamById = C.parseFullConfig = C.parseVotingSetup = C.parseValidatorSet = C.parseProposalSetup = C.parseBridge = C.configParseWorkchainDescriptor = C.configParseValidatorSet = C.configParseMsgPrices = C.configParseMasterAddressRequired = C.configParseMasterAddress = C.configParseGasLimitsPrices = C.configParseBridge = C.configParse40 = C.configParse29 = C.configParse28 = C.configParse18 = C.configParse17 = C.configParse16 = C.configParse15 = C.configParse13 = C.configParse12 = C.configParse8 = C.configParse5 = C.ElectorContract = C.MultisigWallet = C.MultisigOrderBuilder = C.MultisigOrder = C.JettonWallet = C.JettonMaster = C.WalletContractV4 = C.WalletContractV3R2 = C.WalletContractV3R1 = C.WalletContractV2R2 = C.WalletContractV2R1 = C.WalletContractV1R3 = C.WalletContractV1R2 = C.WalletContractV1R1 = C.TonClient4 = C.TonClient = C.HttpApi = void 0,
    E(dist$4, C);
    var M = HttpApi$1;
    Object.defineProperty(C, "HttpApi", {
        enumerable: !0,
        get: function() {
            return M.HttpApi
        }
    });
    var T = TonClient$1;
    Object.defineProperty(C, "TonClient", {
        enumerable: !0,
        get: function() {
            return T.TonClient
        }
    });
    var $ = TonClient4$1;
    Object.defineProperty(C, "TonClient4", {
        enumerable: !0,
        get: function() {
            return $.TonClient4
        }
    });
    var B = WalletContractV1R1$1;
    Object.defineProperty(C, "WalletContractV1R1", {
        enumerable: !0,
        get: function() {
            return B.WalletContractV1R1
        }
    });
    var O = WalletContractV1R2$1;
    Object.defineProperty(C, "WalletContractV1R2", {
        enumerable: !0,
        get: function() {
            return O.WalletContractV1R2
        }
    });
    var F = WalletContractV1R3$1;
    Object.defineProperty(C, "WalletContractV1R3", {
        enumerable: !0,
        get: function() {
            return F.WalletContractV1R3
        }
    });
    var N = WalletContractV2R1$1;
    Object.defineProperty(C, "WalletContractV2R1", {
        enumerable: !0,
        get: function() {
            return N.WalletContractV2R1
        }
    });
    var U = WalletContractV2R2$1;
    Object.defineProperty(C, "WalletContractV2R2", {
        enumerable: !0,
        get: function() {
            return U.WalletContractV2R2
        }
    });
    var H = WalletContractV3R1$1;
    Object.defineProperty(C, "WalletContractV3R1", {
        enumerable: !0,
        get: function() {
            return H.WalletContractV3R1
        }
    });
    var Z = WalletContractV3R2$1;
    Object.defineProperty(C, "WalletContractV3R2", {
        enumerable: !0,
        get: function() {
            return Z.WalletContractV3R2
        }
    });
    var J = WalletContractV4$2;
    Object.defineProperty(C, "WalletContractV4", {
        enumerable: !0,
        get: function() {
            return J.WalletContractV4
        }
    });
    var ie = JettonMaster$1;
    Object.defineProperty(C, "JettonMaster", {
        enumerable: !0,
        get: function() {
            return ie.JettonMaster
        }
    });
    var oe = JettonWallet$3;
    Object.defineProperty(C, "JettonWallet", {
        enumerable: !0,
        get: function() {
            return oe.JettonWallet
        }
    });
    var ae = MultisigOrder$1;
    Object.defineProperty(C, "MultisigOrder", {
        enumerable: !0,
        get: function() {
            return ae.MultisigOrder
        }
    });
    var se = MultisigOrderBuilder$1;
    Object.defineProperty(C, "MultisigOrderBuilder", {
        enumerable: !0,
        get: function() {
            return se.MultisigOrderBuilder
        }
    });
    var le = MultisigWallet$1;
    Object.defineProperty(C, "MultisigWallet", {
        enumerable: !0,
        get: function() {
            return le.MultisigWallet
        }
    });
    var de = ElectorContract$1;
    Object.defineProperty(C, "ElectorContract", {
        enumerable: !0,
        get: function() {
            return de.ElectorContract
        }
    });
    var fe = ConfigParser;
    Object.defineProperty(C, "configParse5", {
        enumerable: !0,
        get: function() {
            return fe.configParse5
        }
    }),
    Object.defineProperty(C, "configParse8", {
        enumerable: !0,
        get: function() {
            return fe.configParse8
        }
    }),
    Object.defineProperty(C, "configParse12", {
        enumerable: !0,
        get: function() {
            return fe.configParse12
        }
    }),
    Object.defineProperty(C, "configParse13", {
        enumerable: !0,
        get: function() {
            return fe.configParse13
        }
    }),
    Object.defineProperty(C, "configParse15", {
        enumerable: !0,
        get: function() {
            return fe.configParse15
        }
    }),
    Object.defineProperty(C, "configParse16", {
        enumerable: !0,
        get: function() {
            return fe.configParse16
        }
    }),
    Object.defineProperty(C, "configParse17", {
        enumerable: !0,
        get: function() {
            return fe.configParse17
        }
    }),
    Object.defineProperty(C, "configParse18", {
        enumerable: !0,
        get: function() {
            return fe.configParse18
        }
    }),
    Object.defineProperty(C, "configParse28", {
        enumerable: !0,
        get: function() {
            return fe.configParse28
        }
    }),
    Object.defineProperty(C, "configParse29", {
        enumerable: !0,
        get: function() {
            return fe.configParse29
        }
    }),
    Object.defineProperty(C, "configParse40", {
        enumerable: !0,
        get: function() {
            return fe.configParse40
        }
    }),
    Object.defineProperty(C, "configParseBridge", {
        enumerable: !0,
        get: function() {
            return fe.configParseBridge
        }
    }),
    Object.defineProperty(C, "configParseGasLimitsPrices", {
        enumerable: !0,
        get: function() {
            return fe.configParseGasLimitsPrices
        }
    }),
    Object.defineProperty(C, "configParseMasterAddress", {
        enumerable: !0,
        get: function() {
            return fe.configParseMasterAddress
        }
    }),
    Object.defineProperty(C, "configParseMasterAddressRequired", {
        enumerable: !0,
        get: function() {
            return fe.configParseMasterAddressRequired
        }
    }),
    Object.defineProperty(C, "configParseMsgPrices", {
        enumerable: !0,
        get: function() {
            return fe.configParseMsgPrices
        }
    }),
    Object.defineProperty(C, "configParseValidatorSet", {
        enumerable: !0,
        get: function() {
            return fe.configParseValidatorSet
        }
    }),
    Object.defineProperty(C, "configParseWorkchainDescriptor", {
        enumerable: !0,
        get: function() {
            return fe.configParseWorkchainDescriptor
        }
    }),
    Object.defineProperty(C, "parseBridge", {
        enumerable: !0,
        get: function() {
            return fe.parseBridge
        }
    }),
    Object.defineProperty(C, "parseProposalSetup", {
        enumerable: !0,
        get: function() {
            return fe.parseProposalSetup
        }
    }),
    Object.defineProperty(C, "parseValidatorSet", {
        enumerable: !0,
        get: function() {
            return fe.parseValidatorSet
        }
    }),
    Object.defineProperty(C, "parseVotingSetup", {
        enumerable: !0,
        get: function() {
            return fe.parseVotingSetup
        }
    }),
    Object.defineProperty(C, "parseFullConfig", {
        enumerable: !0,
        get: function() {
            return fe.parseFullConfig
        }
    }),
    Object.defineProperty(C, "loadConfigParamById", {
        enumerable: !0,
        get: function() {
            return fe.loadConfigParamById
        }
    }),
    Object.defineProperty(C, "loadConfigParamsAsSlice", {
        enumerable: !0,
        get: function() {
            return fe.loadConfigParamsAsSlice
        }
    });
    var pe = fees;
    Object.defineProperty(C, "computeExternalMessageFees", {
        enumerable: !0,
        get: function() {
            return pe.computeExternalMessageFees
        }
    }),
    Object.defineProperty(C, "computeFwdFees", {
        enumerable: !0,
        get: function() {
            return pe.computeFwdFees
        }
    }),
    Object.defineProperty(C, "computeGasPrices", {
        enumerable: !0,
        get: function() {
            return pe.computeGasPrices
        }
    }),
    Object.defineProperty(C, "computeMessageForwardFees", {
        enumerable: !0,
        get: function() {
            return pe.computeMessageForwardFees
        }
    }),
    Object.defineProperty(C, "computeStorageFees", {
        enumerable: !0,
        get: function() {
            return pe.computeStorageFees
        }
    })
}
)(dist$2);
async function _getClient() {
    return new dist$2.TonClient({
        endpoint: await getHttpEndpoint_1({
            network: "mainnet",
            accessVersion: 4
        })
    })
}
const clientP = _getClient();
async function getClient() {
    return clientP
}
async function sleep(C) {
    return new Promise(S=>{
        setTimeout(S, C)
    }
    )
}
async function waitTx(C) {
    const S = await getClient();
    let E = 25, M;
    for (; E > 0; ) {
        E--;
        const T = await S.getTransactions(C, {
            limit: 10
        });
        if (M && M.lt !== T[0].lt) {
            await sleep(5e3);
            return
        }
        await sleep(3e3),
        M = T[0]
    }
    throw new Error("Timeout")
}
const BackgroundImage$5 = "/assets/LoaderBackground-BV7zbOer.png"
  , LoadingTitle = "/assets/LoadingTitle-BLoHtEgU.png"
  , CloseImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABQCAMAAACNtsODAAAAAXNSR0IArs4c6QAAAKVQTFRFAAAA////cCAicCAl////cCAk////cCAk////////cCAj////cCAk////cCEl/Pf4////++jr9eTm9dbb98PL28fI9aq20rq775Wi8YCSvJaY53SE9GaBrX+B32Zz8lp28VBu8Edm7UFf1Utf5EBa6ztY5zZSl1xf4DdRzTxO4jBJ1zJJ3ylA3CM51CY8yyU42B4yhD9D1hkszRwu0xQmeS8ycCElG6aqcwAAABB0Uk5TABUVMEFLa3d/kJC9v97l+rwg4CUAAAWdSURBVHjaldUNW6paEAVgLNM0PxCJA5oeUzIEJb/a//+n3VkzbEc5V6gF5/bcnp63NQPunIo0mq3OS7/vUvr9l06r6fw6UFovQ7ecl1bj10rZUOsXzPPQrUj/ufFbZuQHYRi9UaIoDMYjpZz6NPuuxAtAaMAFY0s16+p0XM7QL5S/nAVuTuQXvTqNSqd/wwhyFWhvgVD9Cqkp22EGBJD3xTsS072IBZv68uvujteSDYfCsMJZvi+XJPFFIH1/KqXuvAnPlzo3ChLjHy76Qhq1Clzk+X6fQBiKMJKP5Qcn/iAMeV8E9zo1bx1lYHDWH2u+yUGv0EWaZafBe44sA8U6dFnIhktNeeONktOXPqU2OpVFknWK/zIV/s9b0Ck7gtB9XSdJk3SdUqBZqfPPgnx1CIk51oGSwMHNof+J46C8Jgw2UqdgErpgoQ+cjJParJP4fXQZTt+giBw7FpRpOE0oa5mKGfrWDZUkU/s26ab92z6rMUqumIrFWXn4sQ1J2zTd0gUp0CeHQhjsuk8Ch6UMUlI4yHiTk0QO/tGehlxJNxTYPuqopI5I+dZSaRJqpRYX0ucljkoccVSySblSi6EXjH49GDkab6WOShcqS1HphVftUt6uFySOSpsNOxr/C86OLlRyKY1isnExF0NTV6JS4WjmqARpt9umPs8mk4W2EKDQLUuFowmtg1ZRMRtPpg4a1QWNwCD5Npbn1sSjoUJgWEqSUZ3jfREkEkrh55u8Ih8OM/IW1UgjPLVC2VOnAEviAyRQh47TpEbyNlpoDwlL6vCuI3WWH1Qpg1Tt5AVD2c15233sWg9EnBkJSV6lA0alFc4Shv6ikfSR2SBVOaqgUcKQSyn92UGljUolB4NxlHIpCl2f80kG6a6TXyvHK0gdMDEaZV/3IEhwCoZSguCIVDPaPqcyuKSPhTws+3ouPVfvLompi3PM8H2G3sp9qh//KYchEBLj/HD+4IUkSJRKR6ULwxJeyFdnglOBHP1DWO1AOoESCcFHZOLM8KHFZFoITo10IkSY8/GMD+3MOeDjfDsYnGrpRBIUls74+U/ne0hfFgJRkjT7ycF2OtlC53PmUoxjXrEkroM7TbKfHLVUiRncvGvjDLCksRSSRvOys9mopI2kEMXHigbO4NulLIlBUoIy/59XsCT5KMSOnezQc3oy29pKBG3GJackjb/IOeF5IQFP1nO6BrMNl7aRSuqIpI7dELL3MJnpOm3Dzy1khi5AOSTr5IhI6pzBsBThp4xpO4/GTKSSSJStSOrsVYKDQnYwfukmxjw5DwOpFEgfJNvm+cYXxx6r+UkkHw7KsCMb8g7GOI7TQyXKm3W2VIkqzMM5DjGW6OOeEzAPVycEhSS5K4V6BLWN+cbvGsXMiATKKnwcEiUG9gNHN+0ZmoygB/r6CTjgRiLl2y0zgFhCoOiekdClfBLw4MhsMlwoyiW7rVUAQToiJzCcSAbjyWQ2DEeJ4OAGk293dEv0WD1yIcmcH+w3T0bBczPmMHQpCyBaSBWVdK6VSxkejDEDMFIJa0Km5KTKIPoHo4j2kQXhbXS0kpm5SAik5BQMJLSRyKk1Myj04GglXjgSJOIoo2NpnWPo2kVzIa2knbxYHVA6lu5n5Wkf2pDmyXA+h1IqLo+FSwfbS50h9iOPTNM1nIP8plGU6hskkDr7aCjND4bTVUWHM98Tl+MFiW2kjjKUCd4f3XRJwngohfjTpLznbOq7Eg9jlR1dk2QCiuP54TzOgGTxfBpcvj9CHV1QKW1jcyCqIkNl8OTvS8js9R7zOgOjTrWEWmppF1ZqHOSJN675nE1exzym5/2ZzA5QNIMn524eIdVFn1dFHro/dbrqVIxXF4xVn/aglmmjTn0elKpn6gbs3WN6Jaa+llra5ZeK9mp3e70BE4Net/1YpfwHabhUcc4KBv8AAAAASUVORK5CYII="
  , Loader = "/assets/TransactionLoader-81Z5diLZ.png"
  , Container$8 = re$4("div", {
    width: "354px",
    background: `url(${BackgroundImage$5})`,
    position: "relative",
    height: "206px",
    backgroundSize: "contain",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
})
  , ModalTitle$4 = re$4("img", {
    position: "absolute",
    width: "210px",
    height: "70px",
    left: "-17px",
    top: "-21px"
})
  , CloseButton$7 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , rotate = ee({
    "0%": {
        transform: "rotate(360deg)"
    },
    "100%": {
        transform: "rotate(0deg)"
    }
})
  , LoaderImg = re$4("img", {
    width: "128px",
    height: "128px",
    animation: `${rotate} 2s linear infinite`,
    marginBottom: "40px"
})
  , LoaderText = re$4("p", {
    color: "rgba(255, 255, 255, 0.70)",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "120%",
    position: "absolute",
    bottom: "48px",
    textAlign: "center",
    width: "100%"
});
function TransactionLoaderContainer({onClose: C}) {
    return jsxRuntimeExports.jsxs(Container$8, {
        children: [jsxRuntimeExports.jsx(ModalTitle$4, {
            src: LoadingTitle
        }), jsxRuntimeExports.jsx(CloseButton$7, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(LoaderImg, {
            src: Loader
        }), jsxRuntimeExports.jsx(LoaderText, {
            children: "Confirm transaction on your wallet"
        })]
    })
}
const page = "_page_1sifh_13"
  , classes$8 = {
    page,
    "tutorial-popup": "_tutorial-popup_1sifh_20"
};
function r$1(C) {
    var S, E, M = "";
    if (typeof C == "string" || typeof C == "number")
        M += C;
    else if (typeof C == "object")
        if (Array.isArray(C)) {
            var T = C.length;
            for (S = 0; S < T; S++)
                C[S] && (E = r$1(C[S])) && (M && (M += " "),
                M += E)
        } else
            for (E in C)
                C[E] && (M && (M += " "),
                M += E);
    return M
}
function clsx() {
    for (var C, S, E = 0, M = "", T = arguments.length; E < T; E++)
        (C = arguments[E]) && (S = r$1(C)) && (M && (M += " "),
        M += S);
    return M
}
const button = "_button_wjemm_1"
  , classes$7 = {
    button
};
function _objectWithoutPropertiesLoose(C, S) {
    if (C == null)
        return {};
    var E = {}, M = Object.keys(C), T, $;
    for ($ = 0; $ < M.length; $++)
        T = M[$],
        !(S.indexOf(T) >= 0) && (E[T] = C[T]);
    return E
}
function composeClasses(C, S, E=void 0) {
    const M = {};
    return Object.keys(C).forEach(T=>{
        M[T] = C[T].reduce(($,B)=>{
            if (B) {
                const O = S(B);
                O !== "" && $.push(O),
                E && E[B] && $.push(E[B])
            }
            return $
        }
        , []).join(" ")
    }
    ),
    M
}
function formatMuiErrorMessage$1(C) {
    let S = "https://mui.com/production-error/?code=" + C;
    for (let E = 1; E < arguments.length; E += 1)
        S += "&args[]=" + encodeURIComponent(arguments[E]);
    return "Minified MUI error #" + C + "; visit " + S + " for the full message."
}
const formatMuiErrorMessage = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: formatMuiErrorMessage$1
}, Symbol.toStringTag, {
    value: "Module"
}));
function memoize$1(C) {
    var S = Object.create(null);
    return function(E) {
        return S[E] === void 0 && (S[E] = C(E)),
        S[E]
    }
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , isPropValid = memoize$1(function(C) {
    return reactPropsRegex.test(C) || C.charCodeAt(0) === 111 && C.charCodeAt(1) === 110 && C.charCodeAt(2) < 91
});
function sheetForTag(C) {
    if (C.sheet)
        return C.sheet;
    for (var S = 0; S < document.styleSheets.length; S++)
        if (document.styleSheets[S].ownerNode === C)
            return document.styleSheets[S]
}
function createStyleElement(C) {
    var S = document.createElement("style");
    return S.setAttribute("data-emotion", C.key),
    C.nonce !== void 0 && S.setAttribute("nonce", C.nonce),
    S.appendChild(document.createTextNode("")),
    S.setAttribute("data-s", ""),
    S
}
var StyleSheet = function() {
    function C(E) {
        var M = this;
        this._insertTag = function(T) {
            var $;
            M.tags.length === 0 ? M.insertionPoint ? $ = M.insertionPoint.nextSibling : M.prepend ? $ = M.container.firstChild : $ = M.before : $ = M.tags[M.tags.length - 1].nextSibling,
            M.container.insertBefore(T, $),
            M.tags.push(T)
        }
        ,
        this.isSpeedy = E.speedy === void 0 ? !0 : E.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = E.nonce,
        this.key = E.key,
        this.container = E.container,
        this.prepend = E.prepend,
        this.insertionPoint = E.insertionPoint,
        this.before = null
    }
    var S = C.prototype;
    return S.hydrate = function(M) {
        M.forEach(this._insertTag)
    }
    ,
    S.insert = function(M) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
        var T = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var $ = sheetForTag(T);
            try {
                $.insertRule(M, $.cssRules.length)
            } catch {}
        } else
            T.appendChild(document.createTextNode(M));
        this.ctr++
    }
    ,
    S.flush = function() {
        this.tags.forEach(function(M) {
            return M.parentNode && M.parentNode.removeChild(M)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    C
}()
  , MS = "-ms-"
  , MOZ = "-moz-"
  , WEBKIT = "-webkit-"
  , COMMENT$1 = "comm"
  , RULESET$1 = "rule"
  , DECLARATION$1 = "decl"
  , IMPORT$1 = "@import"
  , KEYFRAMES$1 = "@keyframes"
  , LAYER$1 = "@layer"
  , abs$1 = Math.abs
  , from$2 = String.fromCharCode
  , assign = Object.assign;
function hash(C, S) {
    return charat$1(C, 0) ^ 45 ? (((S << 2 ^ charat$1(C, 0)) << 2 ^ charat$1(C, 1)) << 2 ^ charat$1(C, 2)) << 2 ^ charat$1(C, 3) : 0
}
function trim$2(C) {
    return C.trim()
}
function match$2(C, S) {
    return (C = S.exec(C)) ? C[0] : C
}
function replace$1(C, S, E) {
    return C.replace(S, E)
}
function indexof$1(C, S) {
    return C.indexOf(S)
}
function charat$1(C, S) {
    return C.charCodeAt(S) | 0
}
function substr$1(C, S, E) {
    return C.slice(S, E)
}
function strlen$1(C) {
    return C.length
}
function sizeof$1(C) {
    return C.length
}
function append$1(C, S) {
    return S.push(C),
    C
}
function combine(C, S) {
    return C.map(S).join("")
}
var line$1 = 1
  , column$1 = 1
  , length$1 = 0
  , position$1 = 0
  , character$1 = 0
  , characters$1 = "";
function node$1(C, S, E, M, T, $, B) {
    return {
        value: C,
        root: S,
        parent: E,
        type: M,
        props: T,
        children: $,
        line: line$1,
        column: column$1,
        length: B,
        return: ""
    }
}
function copy(C, S) {
    return assign(node$1("", null, null, "", null, null, 0), C, {
        length: -C.length
    }, S)
}
function char$1() {
    return character$1
}
function prev$1() {
    return character$1 = position$1 > 0 ? charat$1(characters$1, --position$1) : 0,
    column$1--,
    character$1 === 10 && (column$1 = 1,
    line$1--),
    character$1
}
function next$1() {
    return character$1 = position$1 < length$1 ? charat$1(characters$1, position$1++) : 0,
    column$1++,
    character$1 === 10 && (column$1 = 1,
    line$1++),
    character$1
}
function peek$1() {
    return charat$1(characters$1, position$1)
}
function caret$1() {
    return position$1
}
function slice$1(C, S) {
    return substr$1(characters$1, C, S)
}
function token$1(C) {
    switch (C) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function alloc$1(C) {
    return line$1 = column$1 = 1,
    length$1 = strlen$1(characters$1 = C),
    position$1 = 0,
    []
}
function dealloc$1(C) {
    return characters$1 = "",
    C
}
function delimit$1(C) {
    return trim$2(slice$1(position$1 - 1, delimiter$1(C === 91 ? C + 2 : C === 40 ? C + 1 : C)))
}
function whitespace$1(C) {
    for (; (character$1 = peek$1()) && character$1 < 33; )
        next$1();
    return token$1(C) > 2 || token$1(character$1) > 3 ? "" : " "
}
function escaping$1(C, S) {
    for (; --S && next$1() && !(character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97); )
        ;
    return slice$1(C, caret$1() + (S < 6 && peek$1() == 32 && next$1() == 32))
}
function delimiter$1(C) {
    for (; next$1(); )
        switch (character$1) {
        case C:
            return position$1;
        case 34:
        case 39:
            C !== 34 && C !== 39 && delimiter$1(character$1);
            break;
        case 40:
            C === 41 && delimiter$1(C);
            break;
        case 92:
            next$1();
            break
        }
    return position$1
}
function commenter$1(C, S) {
    for (; next$1() && C + character$1 !== 57; )
        if (C + character$1 === 84 && peek$1() === 47)
            break;
    return "/*" + slice$1(S, position$1 - 1) + "*" + from$2(C === 47 ? C : next$1())
}
function identifier$1(C) {
    for (; !token$1(peek$1()); )
        next$1();
    return slice$1(C, position$1)
}
function compile$1(C) {
    return dealloc$1(parse$9("", null, null, null, [""], C = alloc$1(C), 0, [0], C))
}
function parse$9(C, S, E, M, T, $, B, O, F) {
    for (var N = 0, U = 0, H = B, Z = 0, J = 0, ie = 0, oe = 1, ae = 1, se = 1, le = 0, de = "", fe = T, pe = $, ge = M, we = de; ae; )
        switch (ie = le,
        le = next$1()) {
        case 40:
            if (ie != 108 && charat$1(we, H - 1) == 58) {
                indexof$1(we += replace$1(delimit$1(le), "&", "&\f"), "&\f") != -1 && (se = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            we += delimit$1(le);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            we += whitespace$1(ie);
            break;
        case 92:
            we += escaping$1(caret$1() - 1, 7);
            continue;
        case 47:
            switch (peek$1()) {
            case 42:
            case 47:
                append$1(comment$1(commenter$1(next$1(), caret$1()), S, E), F);
                break;
            default:
                we += "/"
            }
            break;
        case 123 * oe:
            O[N++] = strlen$1(we) * se;
        case 125 * oe:
        case 59:
        case 0:
            switch (le) {
            case 0:
            case 125:
                ae = 0;
            case 59 + U:
                se == -1 && (we = replace$1(we, /\f/g, "")),
                J > 0 && strlen$1(we) - H && append$1(J > 32 ? declaration$1(we + ";", M, E, H - 1) : declaration$1(replace$1(we, " ", "") + ";", M, E, H - 2), F);
                break;
            case 59:
                we += ";";
            default:
                if (append$1(ge = ruleset$1(we, S, E, N, U, T, O, de, fe = [], pe = [], H), $),
                le === 123)
                    if (U === 0)
                        parse$9(we, S, ge, ge, fe, $, H, O, pe);
                    else
                        switch (Z === 99 && charat$1(we, 3) === 110 ? 100 : Z) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            parse$9(C, ge, ge, M && append$1(ruleset$1(C, ge, ge, 0, 0, T, O, de, T, fe = [], H), pe), T, pe, H, O, M ? fe : pe);
                            break;
                        default:
                            parse$9(we, ge, ge, ge, [""], pe, 0, O, pe)
                        }
            }
            N = U = J = 0,
            oe = se = 1,
            de = we = "",
            H = B;
            break;
        case 58:
            H = 1 + strlen$1(we),
            J = ie;
        default:
            if (oe < 1) {
                if (le == 123)
                    --oe;
                else if (le == 125 && oe++ == 0 && prev$1() == 125)
                    continue
            }
            switch (we += from$2(le),
            le * oe) {
            case 38:
                se = U > 0 ? 1 : (we += "\f",
                -1);
                break;
            case 44:
                O[N++] = (strlen$1(we) - 1) * se,
                se = 1;
                break;
            case 64:
                peek$1() === 45 && (we += delimit$1(next$1())),
                Z = peek$1(),
                U = H = strlen$1(de = we += identifier$1(caret$1())),
                le++;
                break;
            case 45:
                ie === 45 && strlen$1(we) == 2 && (oe = 0)
            }
        }
    return $
}
function ruleset$1(C, S, E, M, T, $, B, O, F, N, U) {
    for (var H = T - 1, Z = T === 0 ? $ : [""], J = sizeof$1(Z), ie = 0, oe = 0, ae = 0; ie < M; ++ie)
        for (var se = 0, le = substr$1(C, H + 1, H = abs$1(oe = B[ie])), de = C; se < J; ++se)
            (de = trim$2(oe > 0 ? Z[se] + " " + le : replace$1(le, /&\f/g, Z[se]))) && (F[ae++] = de);
    return node$1(C, S, E, T === 0 ? RULESET$1 : O, F, N, U)
}
function comment$1(C, S, E) {
    return node$1(C, S, E, COMMENT$1, from$2(char$1()), substr$1(C, 2, -2), 0)
}
function declaration$1(C, S, E, M) {
    return node$1(C, S, E, DECLARATION$1, substr$1(C, 0, M), substr$1(C, M + 1, -1), M)
}
function serialize$1(C, S) {
    for (var E = "", M = sizeof$1(C), T = 0; T < M; T++)
        E += S(C[T], T, C, S) || "";
    return E
}
function stringify$1(C, S, E, M) {
    switch (C.type) {
    case LAYER$1:
        if (C.children.length)
            break;
    case IMPORT$1:
    case DECLARATION$1:
        return C.return = C.return || C.value;
    case COMMENT$1:
        return "";
    case KEYFRAMES$1:
        return C.return = C.value + "{" + serialize$1(C.children, M) + "}";
    case RULESET$1:
        C.value = C.props.join(",")
    }
    return strlen$1(E = serialize$1(C.children, M)) ? C.return = C.value + "{" + E + "}" : ""
}
function middleware(C) {
    var S = sizeof$1(C);
    return function(E, M, T, $) {
        for (var B = "", O = 0; O < S; O++)
            B += C[O](E, M, T, $) || "";
        return B
    }
}
function rulesheet(C) {
    return function(S) {
        S.root || (S = S.return) && C(S)
    }
}
var identifierWithPointTracking = function C(S, E, M) {
    for (var T = 0, $ = 0; T = $,
    $ = peek$1(),
    T === 38 && $ === 12 && (E[M] = 1),
    !token$1($); )
        next$1();
    return slice$1(S, position$1)
}
  , toRules = function C(S, E) {
    var M = -1
      , T = 44;
    do
        switch (token$1(T)) {
        case 0:
            T === 38 && peek$1() === 12 && (E[M] = 1),
            S[M] += identifierWithPointTracking(position$1 - 1, E, M);
            break;
        case 2:
            S[M] += delimit$1(T);
            break;
        case 4:
            if (T === 44) {
                S[++M] = peek$1() === 58 ? "&\f" : "",
                E[M] = S[M].length;
                break
            }
        default:
            S[M] += from$2(T)
        }
    while (T = next$1());
    return S
}
  , getRules = function C(S, E) {
    return dealloc$1(toRules(alloc$1(S), E))
}
  , fixedElements = new WeakMap
  , compat = function C(S) {
    if (!(S.type !== "rule" || !S.parent || S.length < 1)) {
        for (var E = S.value, M = S.parent, T = S.column === M.column && S.line === M.line; M.type !== "rule"; )
            if (M = M.parent,
            !M)
                return;
        if (!(S.props.length === 1 && E.charCodeAt(0) !== 58 && !fixedElements.get(M)) && !T) {
            fixedElements.set(S, !0);
            for (var $ = [], B = getRules(E, $), O = M.props, F = 0, N = 0; F < B.length; F++)
                for (var U = 0; U < O.length; U++,
                N++)
                    S.props[N] = $[F] ? B[F].replace(/&\f/g, O[U]) : O[U] + " " + B[F]
        }
    }
}
  , removeLabel = function C(S) {
    if (S.type === "decl") {
        var E = S.value;
        E.charCodeAt(0) === 108 && E.charCodeAt(2) === 98 && (S.return = "",
        S.value = "")
    }
};
function prefix(C, S) {
    switch (hash(C, S)) {
    case 5103:
        return WEBKIT + "print-" + C + C;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return WEBKIT + C + C;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return WEBKIT + C + MOZ + C + MS + C + C;
    case 6828:
    case 4268:
        return WEBKIT + C + MS + C + C;
    case 6165:
        return WEBKIT + C + MS + "flex-" + C + C;
    case 5187:
        return WEBKIT + C + replace$1(C, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + C;
    case 5443:
        return WEBKIT + C + MS + "flex-item-" + replace$1(C, /flex-|-self/, "") + C;
    case 4675:
        return WEBKIT + C + MS + "flex-line-pack" + replace$1(C, /align-content|flex-|-self/, "") + C;
    case 5548:
        return WEBKIT + C + MS + replace$1(C, "shrink", "negative") + C;
    case 5292:
        return WEBKIT + C + MS + replace$1(C, "basis", "preferred-size") + C;
    case 6060:
        return WEBKIT + "box-" + replace$1(C, "-grow", "") + WEBKIT + C + MS + replace$1(C, "grow", "positive") + C;
    case 4554:
        return WEBKIT + replace$1(C, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + C;
    case 6187:
        return replace$1(replace$1(replace$1(C, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), C, "") + C;
    case 5495:
    case 3959:
        return replace$1(C, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
        return replace$1(replace$1(C, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + C + C;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return replace$1(C, /(.+)-inline(.+)/, WEBKIT + "$1$2") + C;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (strlen$1(C) - 1 - S > 6)
            switch (charat$1(C, S + 1)) {
            case 109:
                if (charat$1(C, S + 4) !== 45)
                    break;
            case 102:
                return replace$1(C, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat$1(C, S + 3) == 108 ? "$3" : "$2-$3")) + C;
            case 115:
                return ~indexof$1(C, "stretch") ? prefix(replace$1(C, "stretch", "fill-available"), S) + C : C
            }
        break;
    case 4949:
        if (charat$1(C, S + 1) !== 115)
            break;
    case 6444:
        switch (charat$1(C, strlen$1(C) - 3 - (~indexof$1(C, "!important") && 10))) {
        case 107:
            return replace$1(C, ":", ":" + WEBKIT) + C;
        case 101:
            return replace$1(C, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat$1(C, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + C
        }
        break;
    case 5936:
        switch (charat$1(C, S + 11)) {
        case 114:
            return WEBKIT + C + MS + replace$1(C, /[svh]\w+-[tblr]{2}/, "tb") + C;
        case 108:
            return WEBKIT + C + MS + replace$1(C, /[svh]\w+-[tblr]{2}/, "tb-rl") + C;
        case 45:
            return WEBKIT + C + MS + replace$1(C, /[svh]\w+-[tblr]{2}/, "lr") + C
        }
        return WEBKIT + C + MS + C + C
    }
    return C
}
var prefixer = function C(S, E, M, T) {
    if (S.length > -1 && !S.return)
        switch (S.type) {
        case DECLARATION$1:
            S.return = prefix(S.value, S.length);
            break;
        case KEYFRAMES$1:
            return serialize$1([copy(S, {
                value: replace$1(S.value, "@", "@" + WEBKIT)
            })], T);
        case RULESET$1:
            if (S.length)
                return combine(S.props, function($) {
                    switch (match$2($, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return serialize$1([copy(S, {
                            props: [replace$1($, /:(read-\w+)/, ":" + MOZ + "$1")]
                        })], T);
                    case "::placeholder":
                        return serialize$1([copy(S, {
                            props: [replace$1($, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                        }), copy(S, {
                            props: [replace$1($, /:(plac\w+)/, ":" + MOZ + "$1")]
                        }), copy(S, {
                            props: [replace$1($, /:(plac\w+)/, MS + "input-$1")]
                        })], T)
                    }
                    return ""
                })
        }
}
  , defaultStylisPlugins = [prefixer]
  , createCache$1 = function C(S) {
    var E = S.key;
    if (E === "css") {
        var M = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(M, function(oe) {
            var ae = oe.getAttribute("data-emotion");
            ae.indexOf(" ") !== -1 && (document.head.appendChild(oe),
            oe.setAttribute("data-s", ""))
        })
    }
    var T = S.stylisPlugins || defaultStylisPlugins, $ = {}, B, O = [];
    B = S.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + E + ' "]'), function(oe) {
        for (var ae = oe.getAttribute("data-emotion").split(" "), se = 1; se < ae.length; se++)
            $[ae[se]] = !0;
        O.push(oe)
    });
    var F, N = [compat, removeLabel];
    {
        var U, H = [stringify$1, rulesheet(function(oe) {
            U.insert(oe)
        })], Z = middleware(N.concat(T, H)), J = function(ae) {
            return serialize$1(compile$1(ae), Z)
        };
        F = function(ae, se, le, de) {
            U = le,
            J(ae ? ae + "{" + se.styles + "}" : se.styles),
            de && (ie.inserted[se.name] = !0)
        }
    }
    var ie = {
        key: E,
        sheet: new StyleSheet({
            key: E,
            container: B,
            nonce: S.nonce,
            speedy: S.speedy,
            prepend: S.prepend,
            insertionPoint: S.insertionPoint
        }),
        nonce: S.nonce,
        inserted: $,
        registered: {},
        insert: F
    };
    return ie.sheet.hydrate(O),
    ie
}
  , reactIs$2 = {
    exports: {}
}
  , reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol == "function" && Symbol.for
  , c$1 = b$1 ? Symbol.for("react.element") : 60103
  , d$1 = b$1 ? Symbol.for("react.portal") : 60106
  , e$1 = b$1 ? Symbol.for("react.fragment") : 60107
  , f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108
  , g$1 = b$1 ? Symbol.for("react.profiler") : 60114
  , h$1 = b$1 ? Symbol.for("react.provider") : 60109
  , k$1 = b$1 ? Symbol.for("react.context") : 60110
  , l$2 = b$1 ? Symbol.for("react.async_mode") : 60111
  , m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111
  , n$2 = b$1 ? Symbol.for("react.forward_ref") : 60112
  , p$1 = b$1 ? Symbol.for("react.suspense") : 60113
  , q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120
  , r = b$1 ? Symbol.for("react.memo") : 60115
  , t$3 = b$1 ? Symbol.for("react.lazy") : 60116
  , v$1 = b$1 ? Symbol.for("react.block") : 60121
  , w = b$1 ? Symbol.for("react.fundamental") : 60117
  , x = b$1 ? Symbol.for("react.responder") : 60118
  , y = b$1 ? Symbol.for("react.scope") : 60119;
function z(C) {
    if (typeof C == "object" && C !== null) {
        var S = C.$$typeof;
        switch (S) {
        case c$1:
            switch (C = C.type,
            C) {
            case l$2:
            case m$1:
            case e$1:
            case g$1:
            case f$1:
            case p$1:
                return C;
            default:
                switch (C = C && C.$$typeof,
                C) {
                case k$1:
                case n$2:
                case t$3:
                case r:
                case h$1:
                    return C;
                default:
                    return S
                }
            }
        case d$1:
            return S
        }
    }
}
function A(C) {
    return z(C) === m$1
}
reactIs_production_min$1.AsyncMode = l$2;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$2;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$3;
reactIs_production_min$1.Memo = r;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(C) {
    return A(C) || z(C) === l$2
}
;
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(C) {
    return z(C) === k$1
}
;
reactIs_production_min$1.isContextProvider = function(C) {
    return z(C) === h$1
}
;
reactIs_production_min$1.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === c$1
}
;
reactIs_production_min$1.isForwardRef = function(C) {
    return z(C) === n$2
}
;
reactIs_production_min$1.isFragment = function(C) {
    return z(C) === e$1
}
;
reactIs_production_min$1.isLazy = function(C) {
    return z(C) === t$3
}
;
reactIs_production_min$1.isMemo = function(C) {
    return z(C) === r
}
;
reactIs_production_min$1.isPortal = function(C) {
    return z(C) === d$1
}
;
reactIs_production_min$1.isProfiler = function(C) {
    return z(C) === g$1
}
;
reactIs_production_min$1.isStrictMode = function(C) {
    return z(C) === f$1
}
;
reactIs_production_min$1.isSuspense = function(C) {
    return z(C) === p$1
}
;
reactIs_production_min$1.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === e$1 || C === m$1 || C === g$1 || C === f$1 || C === p$1 || C === q$1 || typeof C == "object" && C !== null && (C.$$typeof === t$3 || C.$$typeof === r || C.$$typeof === h$1 || C.$$typeof === k$1 || C.$$typeof === n$2 || C.$$typeof === w || C.$$typeof === x || C.$$typeof === y || C.$$typeof === v$1)
}
;
reactIs_production_min$1.typeOf = z;
reactIs$2.exports = reactIs_production_min$1;
var reactIsExports$1 = reactIs$2.exports
  , reactIs$1 = reactIsExports$1
  , FORWARD_REF_STATICS = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
}
  , MEMO_STATICS = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
}
  , TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser = !0;
function getRegisteredStyles(C, S, E) {
    var M = "";
    return E.split(" ").forEach(function(T) {
        C[T] !== void 0 ? S.push(C[T] + ";") : M += T + " "
    }),
    M
}
var registerStyles = function C(S, E, M) {
    var T = S.key + "-" + E.name;
    (M === !1 || isBrowser === !1) && S.registered[T] === void 0 && (S.registered[T] = E.styles)
}
  , insertStyles = function C(S, E, M) {
    registerStyles(S, E, M);
    var T = S.key + "-" + E.name;
    if (S.inserted[E.name] === void 0) {
        var $ = E;
        do
            S.insert(E === $ ? "." + T : "", $, S.sheet, !0),
            $ = $.next;
        while ($ !== void 0)
    }
};
function murmur2$1(C) {
    for (var S = 0, E, M = 0, T = C.length; T >= 4; ++M,
    T -= 4)
        E = C.charCodeAt(M) & 255 | (C.charCodeAt(++M) & 255) << 8 | (C.charCodeAt(++M) & 255) << 16 | (C.charCodeAt(++M) & 255) << 24,
        E = (E & 65535) * 1540483477 + ((E >>> 16) * 59797 << 16),
        E ^= E >>> 24,
        S = (E & 65535) * 1540483477 + ((E >>> 16) * 59797 << 16) ^ (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16);
    switch (T) {
    case 3:
        S ^= (C.charCodeAt(M + 2) & 255) << 16;
    case 2:
        S ^= (C.charCodeAt(M + 1) & 255) << 8;
    case 1:
        S ^= C.charCodeAt(M) & 255,
        S = (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16)
    }
    return S ^= S >>> 13,
    S = (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16),
    ((S ^ S >>> 15) >>> 0).toString(36)
}
var unitlessKeys$1 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , hyphenateRegex = /[A-Z]|^ms/g
  , animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , isCustomProperty = function C(S) {
    return S.charCodeAt(1) === 45
}
  , isProcessableValue = function C(S) {
    return S != null && typeof S != "boolean"
}
  , processStyleName = memoize$1(function(C) {
    return isCustomProperty(C) ? C : C.replace(hyphenateRegex, "-$&").toLowerCase()
})
  , processStyleValue = function C(S, E) {
    switch (S) {
    case "animation":
    case "animationName":
        if (typeof E == "string")
            return E.replace(animationRegex, function(M, T, $) {
                return cursor = {
                    name: T,
                    styles: $,
                    next: cursor
                },
                T
            })
    }
    return unitlessKeys$1[S] !== 1 && !isCustomProperty(S) && typeof E == "number" && E !== 0 ? E + "px" : E
}
  , noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(C, S, E) {
    if (E == null)
        return "";
    if (E.__emotion_styles !== void 0)
        return E;
    switch (typeof E) {
    case "boolean":
        return "";
    case "object":
        {
            if (E.anim === 1)
                return cursor = {
                    name: E.name,
                    styles: E.styles,
                    next: cursor
                },
                E.name;
            if (E.styles !== void 0) {
                var M = E.next;
                if (M !== void 0)
                    for (; M !== void 0; )
                        cursor = {
                            name: M.name,
                            styles: M.styles,
                            next: cursor
                        },
                        M = M.next;
                var T = E.styles + ";";
                return T
            }
            return createStringFromObject(C, S, E)
        }
    case "function":
        {
            if (C !== void 0) {
                var $ = cursor
                  , B = E(C);
                return cursor = $,
                handleInterpolation(C, S, B)
            }
            break
        }
    }
    if (S == null)
        return E;
    var O = S[E];
    return O !== void 0 ? O : E
}
function createStringFromObject(C, S, E) {
    var M = "";
    if (Array.isArray(E))
        for (var T = 0; T < E.length; T++)
            M += handleInterpolation(C, S, E[T]) + ";";
    else
        for (var $ in E) {
            var B = E[$];
            if (typeof B != "object")
                S != null && S[B] !== void 0 ? M += $ + "{" + S[B] + "}" : isProcessableValue(B) && (M += processStyleName($) + ":" + processStyleValue($, B) + ";");
            else if (Array.isArray(B) && typeof B[0] == "string" && (S == null || S[B[0]] === void 0))
                for (var O = 0; O < B.length; O++)
                    isProcessableValue(B[O]) && (M += processStyleName($) + ":" + processStyleValue($, B[O]) + ";");
            else {
                var F = handleInterpolation(C, S, B);
                switch ($) {
                case "animation":
                case "animationName":
                    {
                        M += processStyleName($) + ":" + F + ";";
                        break
                    }
                default:
                    M += $ + "{" + F + "}"
                }
            }
        }
    return M
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor, serializeStyles = function C(S, E, M) {
    if (S.length === 1 && typeof S[0] == "object" && S[0] !== null && S[0].styles !== void 0)
        return S[0];
    var T = !0
      , $ = "";
    cursor = void 0;
    var B = S[0];
    B == null || B.raw === void 0 ? (T = !1,
    $ += handleInterpolation(M, E, B)) : $ += B[0];
    for (var O = 1; O < S.length; O++)
        $ += handleInterpolation(M, E, S[O]),
        T && ($ += B[O]);
    labelPattern.lastIndex = 0;
    for (var F = "", N; (N = labelPattern.exec($)) !== null; )
        F += "-" + N[1];
    var U = murmur2$1($) + F;
    return {
        name: U,
        styles: $,
        next: cursor
    }
}, syncFallback = function C(S) {
    return S()
}, useInsertionEffect$2 = React.useInsertionEffect ? React.useInsertionEffect : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect$2 || syncFallback, useInsertionEffectWithLayoutFallback = useInsertionEffect$2 || reactExports.useLayoutEffect, EmotionCacheContext = reactExports.createContext(typeof HTMLElement < "u" ? createCache$1({
    key: "css"
}) : null), CacheProvider = EmotionCacheContext.Provider, withEmotionCache = function C(S) {
    return reactExports.forwardRef(function(E, M) {
        var T = reactExports.useContext(EmotionCacheContext);
        return S(E, T, M)
    })
}, ThemeContext = reactExports.createContext({}), Global = withEmotionCache(function(C, S) {
    var E = C.styles
      , M = serializeStyles([E], void 0, reactExports.useContext(ThemeContext))
      , T = reactExports.useRef();
    return useInsertionEffectWithLayoutFallback(function() {
        var $ = S.key + "-global"
          , B = new S.sheet.constructor({
            key: $,
            nonce: S.sheet.nonce,
            container: S.sheet.container,
            speedy: S.sheet.isSpeedy
        })
          , O = !1
          , F = document.querySelector('style[data-emotion="' + $ + " " + M.name + '"]');
        return S.sheet.tags.length && (B.before = S.sheet.tags[0]),
        F !== null && (O = !0,
        F.setAttribute("data-emotion", $),
        B.hydrate([F])),
        T.current = [B, O],
        function() {
            B.flush()
        }
    }, [S]),
    useInsertionEffectWithLayoutFallback(function() {
        var $ = T.current
          , B = $[0]
          , O = $[1];
        if (O) {
            $[1] = !1;
            return
        }
        if (M.next !== void 0 && insertStyles(S, M.next, !0),
        B.tags.length) {
            var F = B.tags[B.tags.length - 1].nextElementSibling;
            B.before = F,
            B.flush()
        }
        S.insert("", M, B, !1)
    }, [S, M.name]),
    null
});
function css() {
    for (var C = arguments.length, S = new Array(C), E = 0; E < C; E++)
        S[E] = arguments[E];
    return serializeStyles(S)
}
var keyframes = function C() {
    var S = css.apply(void 0, arguments)
      , E = "animation-" + S.name;
    return {
        name: E,
        styles: "@keyframes " + E + "{" + S.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}
  , testOmitPropsOnStringTag = isPropValid
  , testOmitPropsOnComponent = function C(S) {
    return S !== "theme"
}
  , getDefaultShouldForwardProp = function C(S) {
    return typeof S == "string" && S.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent
}
  , composeShouldForwardProps = function C(S, E, M) {
    var T;
    if (E) {
        var $ = E.shouldForwardProp;
        T = S.__emotion_forwardProp && $ ? function(B) {
            return S.__emotion_forwardProp(B) && $(B)
        }
        : $
    }
    return typeof T != "function" && M && (T = S.__emotion_forwardProp),
    T
}
  , Insertion = function C(S) {
    var E = S.cache
      , M = S.serialized
      , T = S.isStringTag;
    return registerStyles(E, M, T),
    useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(E, M, T)
    }),
    null
}
  , createStyled$2 = function C(S, E) {
    var M = S.__emotion_real === S, T = M && S.__emotion_base || S, $, B;
    E !== void 0 && ($ = E.label,
    B = E.target);
    var O = composeShouldForwardProps(S, E, M)
      , F = O || getDefaultShouldForwardProp(T)
      , N = !F("as");
    return function() {
        var U = arguments
          , H = M && S.__emotion_styles !== void 0 ? S.__emotion_styles.slice(0) : [];
        if ($ !== void 0 && H.push("label:" + $ + ";"),
        U[0] == null || U[0].raw === void 0)
            H.push.apply(H, U);
        else {
            H.push(U[0][0]);
            for (var Z = U.length, J = 1; J < Z; J++)
                H.push(U[J], U[0][J])
        }
        var ie = withEmotionCache(function(oe, ae, se) {
            var le = N && oe.as || T
              , de = ""
              , fe = []
              , pe = oe;
            if (oe.theme == null) {
                pe = {};
                for (var ge in oe)
                    pe[ge] = oe[ge];
                pe.theme = reactExports.useContext(ThemeContext)
            }
            typeof oe.className == "string" ? de = getRegisteredStyles(ae.registered, fe, oe.className) : oe.className != null && (de = oe.className + " ");
            var we = serializeStyles(H.concat(fe), ae.registered, pe);
            de += ae.key + "-" + we.name,
            B !== void 0 && (de += " " + B);
            var Ae = N && O === void 0 ? getDefaultShouldForwardProp(le) : F
              , Se = {};
            for (var ue in oe)
                N && ue === "as" || Ae(ue) && (Se[ue] = oe[ue]);
            return Se.className = de,
            Se.ref = se,
            reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, {
                cache: ae,
                serialized: we,
                isStringTag: typeof le == "string"
            }), reactExports.createElement(le, Se))
        });
        return ie.displayName = $ !== void 0 ? $ : "Styled(" + (typeof T == "string" ? T : T.displayName || T.name || "Component") + ")",
        ie.defaultProps = S.defaultProps,
        ie.__emotion_real = ie,
        ie.__emotion_base = T,
        ie.__emotion_styles = H,
        ie.__emotion_forwardProp = O,
        Object.defineProperty(ie, "toString", {
            value: function() {
                return "." + B
            }
        }),
        ie.withComponent = function(oe, ae) {
            return C(oe, _extends$3({}, E, ae, {
                shouldForwardProp: composeShouldForwardProps(ie, ae, !0)
            })).apply(void 0, H)
        }
        ,
        ie
    }
}
  , tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , newStyled = createStyled$2.bind();
tags.forEach(function(C) {
    newStyled[C] = newStyled(C)
});
let cache;
typeof document == "object" && (cache = createCache$1({
    key: "css",
    prepend: !0
}));
function StyledEngineProvider(C) {
    const {injectFirst: S, children: E} = C;
    return S && cache ? jsxRuntimeExports.jsx(CacheProvider, {
        value: cache,
        children: E
    }) : E
}
function isEmpty$1(C) {
    return C == null || Object.keys(C).length === 0
}
function GlobalStyles(C) {
    const {styles: S, defaultTheme: E={}} = C
      , M = typeof S == "function" ? T=>S(isEmpty$1(T) ? E : T) : S;
    return jsxRuntimeExports.jsx(Global, {
        styles: M
    })
}
function styled$1(C, S) {
    return newStyled(C, S)
}
const internal_processStyles = (C,S)=>{
    Array.isArray(C.__emotion_styles) && (C.__emotion_styles = S(C.__emotion_styles))
}
  , styledEngine = Object.freeze(Object.defineProperty({
    __proto__: null,
    GlobalStyles,
    StyledEngineProvider,
    ThemeContext,
    css,
    default: styled$1,
    internal_processStyles,
    keyframes
}, Symbol.toStringTag, {
    value: "Module"
}));
function isPlainObject$1(C) {
    if (typeof C != "object" || C === null)
        return !1;
    const S = Object.getPrototypeOf(C);
    return (S === null || S === Object.prototype || Object.getPrototypeOf(S) === null) && !(Symbol.toStringTag in C) && !(Symbol.iterator in C)
}
function deepClone(C) {
    if (!isPlainObject$1(C))
        return C;
    const S = {};
    return Object.keys(C).forEach(E=>{
        S[E] = deepClone(C[E])
    }
    ),
    S
}
function deepmerge$1(C, S, E={
    clone: !0
}) {
    const M = E.clone ? _extends$3({}, C) : C;
    return isPlainObject$1(C) && isPlainObject$1(S) && Object.keys(S).forEach(T=>{
        T !== "__proto__" && (isPlainObject$1(S[T]) && T in C && isPlainObject$1(C[T]) ? M[T] = deepmerge$1(C[T], S[T], E) : E.clone ? M[T] = isPlainObject$1(S[T]) ? deepClone(S[T]) : S[T] : M[T] = S[T])
    }
    ),
    M
}
const deepmerge = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: deepmerge$1,
    isPlainObject: isPlainObject$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , _excluded$u = ["values", "unit", "step"]
  , sortBreakpointsValues = C=>{
    const S = Object.keys(C).map(E=>({
        key: E,
        val: C[E]
    })) || [];
    return S.sort((E,M)=>E.val - M.val),
    S.reduce((E,M)=>_extends$3({}, E, {
        [M.key]: M.val
    }), {})
}
;
function createBreakpoints(C) {
    const {values: S={
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    }, unit: E="px", step: M=5} = C
      , T = _objectWithoutPropertiesLoose(C, _excluded$u)
      , $ = sortBreakpointsValues(S)
      , B = Object.keys($);
    function O(Z) {
        return `@media (min-width:${typeof S[Z] == "number" ? S[Z] : Z}${E})`
    }
    function F(Z) {
        return `@media (max-width:${(typeof S[Z] == "number" ? S[Z] : Z) - M / 100}${E})`
    }
    function N(Z, J) {
        const ie = B.indexOf(J);
        return `@media (min-width:${typeof S[Z] == "number" ? S[Z] : Z}${E}) and (max-width:${(ie !== -1 && typeof S[B[ie]] == "number" ? S[B[ie]] : J) - M / 100}${E})`
    }
    function U(Z) {
        return B.indexOf(Z) + 1 < B.length ? N(Z, B[B.indexOf(Z) + 1]) : O(Z)
    }
    function H(Z) {
        const J = B.indexOf(Z);
        return J === 0 ? O(B[1]) : J === B.length - 1 ? F(B[J]) : N(Z, B[B.indexOf(Z) + 1]).replace("@media", "@media not all and")
    }
    return _extends$3({
        keys: B,
        values: $,
        up: O,
        down: F,
        between: N,
        only: U,
        not: H,
        unit: E
    }, T)
}
const shape = {
    borderRadius: 4
}
  , shape$1 = shape;
function merge$3(C, S) {
    return S ? deepmerge$1(C, S, {
        clone: !1
    }) : C
}
const values$1 = {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
}
  , defaultBreakpoints = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: C=>`@media (min-width:${values$1[C]}px)`
};
function handleBreakpoints(C, S, E) {
    const M = C.theme || {};
    if (Array.isArray(S)) {
        const $ = M.breakpoints || defaultBreakpoints;
        return S.reduce((B,O,F)=>(B[$.up($.keys[F])] = E(S[F]),
        B), {})
    }
    if (typeof S == "object") {
        const $ = M.breakpoints || defaultBreakpoints;
        return Object.keys(S).reduce((B,O)=>{
            if (Object.keys($.values || values$1).indexOf(O) !== -1) {
                const F = $.up(O);
                B[F] = E(S[O], O)
            } else {
                const F = O;
                B[F] = S[F]
            }
            return B
        }
        , {})
    }
    return E(S)
}
function createEmptyBreakpointObject(C={}) {
    var S;
    return ((S = C.keys) == null ? void 0 : S.reduce((M,T)=>{
        const $ = C.up(T);
        return M[$] = {},
        M
    }
    , {})) || {}
}
function removeUnusedBreakpoints(C, S) {
    return C.reduce((E,M)=>{
        const T = E[M];
        return (!T || Object.keys(T).length === 0) && delete E[M],
        E
    }
    , S)
}
function capitalize$1(C) {
    if (typeof C != "string")
        throw new Error(formatMuiErrorMessage$1(7));
    return C.charAt(0).toUpperCase() + C.slice(1)
}
const capitalize = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: capitalize$1
}, Symbol.toStringTag, {
    value: "Module"
}));
function getPath(C, S, E=!0) {
    if (!S || typeof S != "string")
        return null;
    if (C && C.vars && E) {
        const M = `vars.${S}`.split(".").reduce((T,$)=>T && T[$] ? T[$] : null, C);
        if (M != null)
            return M
    }
    return S.split(".").reduce((M,T)=>M && M[T] != null ? M[T] : null, C)
}
function getStyleValue(C, S, E, M=E) {
    let T;
    return typeof C == "function" ? T = C(E) : Array.isArray(C) ? T = C[E] || M : T = getPath(C, E) || M,
    S && (T = S(T, M, C)),
    T
}
function style$2(C) {
    const {prop: S, cssProperty: E=C.prop, themeKey: M, transform: T} = C
      , $ = B=>{
        if (B[S] == null)
            return null;
        const O = B[S]
          , F = B.theme
          , N = getPath(F, M) || {};
        return handleBreakpoints(B, O, H=>{
            let Z = getStyleValue(N, T, H);
            return H === Z && typeof H == "string" && (Z = getStyleValue(N, T, `${S}${H === "default" ? "" : capitalize$1(H)}`, H)),
            E === !1 ? Z : {
                [E]: Z
            }
        }
        )
    }
    ;
    return $.propTypes = {},
    $.filterProps = [S],
    $
}
function memoize(C) {
    const S = {};
    return E=>(S[E] === void 0 && (S[E] = C(E)),
    S[E])
}
const properties = {
    m: "margin",
    p: "padding"
}
  , directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
}
  , aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
}
  , getCssProperties = memoize(C=>{
    if (C.length > 2)
        if (aliases[C])
            C = aliases[C];
        else
            return [C];
    const [S,E] = C.split("")
      , M = properties[S]
      , T = directions[E] || "";
    return Array.isArray(T) ? T.map($=>M + $) : [M + T]
}
)
  , marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
  , paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(C, S, E, M) {
    var T;
    const $ = (T = getPath(C, S, !1)) != null ? T : E;
    return typeof $ == "number" ? B=>typeof B == "string" ? B : $ * B : Array.isArray($) ? B=>typeof B == "string" ? B : $[B] : typeof $ == "function" ? $ : ()=>{}
}
function createUnarySpacing(C) {
    return createUnaryUnit(C, "spacing", 8)
}
function getValue$1(C, S) {
    if (typeof S == "string" || S == null)
        return S;
    const E = Math.abs(S)
      , M = C(E);
    return S >= 0 ? M : typeof M == "number" ? -M : `-${M}`
}
function getStyleFromPropValue(C, S) {
    return E=>C.reduce((M,T)=>(M[T] = getValue$1(S, E),
    M), {})
}
function resolveCssProperty(C, S, E, M) {
    if (S.indexOf(E) === -1)
        return null;
    const T = getCssProperties(E)
      , $ = getStyleFromPropValue(T, M)
      , B = C[E];
    return handleBreakpoints(C, B, $)
}
function style$1(C, S) {
    const E = createUnarySpacing(C.theme);
    return Object.keys(C).map(M=>resolveCssProperty(C, S, M, E)).reduce(merge$3, {})
}
function margin(C) {
    return style$1(C, marginKeys)
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(C) {
    return style$1(C, paddingKeys)
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(C=8) {
    if (C.mui)
        return C;
    const S = createUnarySpacing({
        spacing: C
    })
      , E = (...M)=>(M.length === 0 ? [1] : M).map($=>{
        const B = S($);
        return typeof B == "number" ? `${B}px` : B
    }
    ).join(" ");
    return E.mui = !0,
    E
}
function compose(...C) {
    const S = C.reduce((M,T)=>(T.filterProps.forEach($=>{
        M[$] = T
    }
    ),
    M), {})
      , E = M=>Object.keys(M).reduce((T,$)=>S[$] ? merge$3(T, S[$](M)) : T, {});
    return E.propTypes = {},
    E.filterProps = C.reduce((M,T)=>M.concat(T.filterProps), []),
    E
}
function borderTransform(C) {
    return typeof C != "number" ? C : `${C}px solid`
}
function createBorderStyle(C, S) {
    return style$2({
        prop: C,
        themeKey: "borders",
        transform: S
    })
}
const border = createBorderStyle("border", borderTransform)
  , borderTop = createBorderStyle("borderTop", borderTransform)
  , borderRight = createBorderStyle("borderRight", borderTransform)
  , borderBottom = createBorderStyle("borderBottom", borderTransform)
  , borderLeft = createBorderStyle("borderLeft", borderTransform)
  , borderColor = createBorderStyle("borderColor")
  , borderTopColor = createBorderStyle("borderTopColor")
  , borderRightColor = createBorderStyle("borderRightColor")
  , borderBottomColor = createBorderStyle("borderBottomColor")
  , borderLeftColor = createBorderStyle("borderLeftColor")
  , outline = createBorderStyle("outline", borderTransform)
  , outlineColor = createBorderStyle("outlineColor")
  , borderRadius = C=>{
    if (C.borderRadius !== void 0 && C.borderRadius !== null) {
        const S = createUnaryUnit(C.theme, "shape.borderRadius", 4)
          , E = M=>({
            borderRadius: getValue$1(S, M)
        });
        return handleBreakpoints(C, C.borderRadius, E)
    }
    return null
}
;
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = C=>{
    if (C.gap !== void 0 && C.gap !== null) {
        const S = createUnaryUnit(C.theme, "spacing", 8)
          , E = M=>({
            gap: getValue$1(S, M)
        });
        return handleBreakpoints(C, C.gap, E)
    }
    return null
}
;
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = C=>{
    if (C.columnGap !== void 0 && C.columnGap !== null) {
        const S = createUnaryUnit(C.theme, "spacing", 8)
          , E = M=>({
            columnGap: getValue$1(S, M)
        });
        return handleBreakpoints(C, C.columnGap, E)
    }
    return null
}
;
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = C=>{
    if (C.rowGap !== void 0 && C.rowGap !== null) {
        const S = createUnaryUnit(C.theme, "spacing", 8)
          , E = M=>({
            rowGap: getValue$1(S, M)
        });
        return handleBreakpoints(C, C.rowGap, E)
    }
    return null
}
;
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
    prop: "gridColumn"
})
  , gridRow = style$2({
    prop: "gridRow"
})
  , gridAutoFlow = style$2({
    prop: "gridAutoFlow"
})
  , gridAutoColumns = style$2({
    prop: "gridAutoColumns"
})
  , gridAutoRows = style$2({
    prop: "gridAutoRows"
})
  , gridTemplateColumns = style$2({
    prop: "gridTemplateColumns"
})
  , gridTemplateRows = style$2({
    prop: "gridTemplateRows"
})
  , gridTemplateAreas = style$2({
    prop: "gridTemplateAreas"
})
  , gridArea = style$2({
    prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(C, S) {
    return S === "grey" ? S : C
}
const color = style$2({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
})
  , bgcolor = style$2({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
})
  , backgroundColor = style$2({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(C) {
    return C <= 1 && C !== 0 ? `${C * 100}%` : C
}
const width = style$2({
    prop: "width",
    transform: sizingTransform
})
  , maxWidth = C=>{
    if (C.maxWidth !== void 0 && C.maxWidth !== null) {
        const S = E=>{
            var M, T;
            const $ = ((M = C.theme) == null || (M = M.breakpoints) == null || (M = M.values) == null ? void 0 : M[E]) || values$1[E];
            return $ ? ((T = C.theme) == null || (T = T.breakpoints) == null ? void 0 : T.unit) !== "px" ? {
                maxWidth: `${$}${C.theme.breakpoints.unit}`
            } : {
                maxWidth: $
            } : {
                maxWidth: sizingTransform(E)
            }
        }
        ;
        return handleBreakpoints(C, C.maxWidth, S)
    }
    return null
}
;
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
    prop: "minWidth",
    transform: sizingTransform
})
  , height = style$2({
    prop: "height",
    transform: sizingTransform
})
  , maxHeight = style$2({
    prop: "maxHeight",
    transform: sizingTransform
})
  , minHeight = style$2({
    prop: "minHeight",
    transform: sizingTransform
});
style$2({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
});
style$2({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
});
const boxSizing = style$2({
    prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    border: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderTop: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderRight: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderBottom: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderLeft: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderColor: {
        themeKey: "palette"
    },
    borderTopColor: {
        themeKey: "palette"
    },
    borderRightColor: {
        themeKey: "palette"
    },
    borderBottomColor: {
        themeKey: "palette"
    },
    borderLeftColor: {
        themeKey: "palette"
    },
    outline: {
        themeKey: "borders",
        transform: borderTransform
    },
    outlineColor: {
        themeKey: "palette"
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
    },
    color: {
        themeKey: "palette",
        transform: paletteTransform
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
    },
    backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
    },
    p: {
        style: padding
    },
    pt: {
        style: padding
    },
    pr: {
        style: padding
    },
    pb: {
        style: padding
    },
    pl: {
        style: padding
    },
    px: {
        style: padding
    },
    py: {
        style: padding
    },
    padding: {
        style: padding
    },
    paddingTop: {
        style: padding
    },
    paddingRight: {
        style: padding
    },
    paddingBottom: {
        style: padding
    },
    paddingLeft: {
        style: padding
    },
    paddingX: {
        style: padding
    },
    paddingY: {
        style: padding
    },
    paddingInline: {
        style: padding
    },
    paddingInlineStart: {
        style: padding
    },
    paddingInlineEnd: {
        style: padding
    },
    paddingBlock: {
        style: padding
    },
    paddingBlockStart: {
        style: padding
    },
    paddingBlockEnd: {
        style: padding
    },
    m: {
        style: margin
    },
    mt: {
        style: margin
    },
    mr: {
        style: margin
    },
    mb: {
        style: margin
    },
    ml: {
        style: margin
    },
    mx: {
        style: margin
    },
    my: {
        style: margin
    },
    margin: {
        style: margin
    },
    marginTop: {
        style: margin
    },
    marginRight: {
        style: margin
    },
    marginBottom: {
        style: margin
    },
    marginLeft: {
        style: margin
    },
    marginX: {
        style: margin
    },
    marginY: {
        style: margin
    },
    marginInline: {
        style: margin
    },
    marginInlineStart: {
        style: margin
    },
    marginInlineEnd: {
        style: margin
    },
    marginBlock: {
        style: margin
    },
    marginBlockStart: {
        style: margin
    },
    marginBlockEnd: {
        style: margin
    },
    displayPrint: {
        cssProperty: !1,
        transform: C=>({
            "@media print": {
                display: C
            }
        })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
        style: gap
    },
    rowGap: {
        style: rowGap
    },
    columnGap: {
        style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
        themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
        themeKey: "shadows"
    },
    width: {
        transform: sizingTransform
    },
    maxWidth: {
        style: maxWidth
    },
    minWidth: {
        transform: sizingTransform
    },
    height: {
        transform: sizingTransform
    },
    maxHeight: {
        transform: sizingTransform
    },
    minHeight: {
        transform: sizingTransform
    },
    boxSizing: {},
    fontFamily: {
        themeKey: "typography"
    },
    fontSize: {
        themeKey: "typography"
    },
    fontStyle: {
        themeKey: "typography"
    },
    fontWeight: {
        themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: !1,
        themeKey: "typography"
    }
}
  , defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...C) {
    const S = C.reduce((M,T)=>M.concat(Object.keys(T)), [])
      , E = new Set(S);
    return C.every(M=>E.size === Object.keys(M).length)
}
function callIfFn(C, S) {
    return typeof C == "function" ? C(S) : C
}
function unstable_createStyleFunctionSx() {
    function C(E, M, T, $) {
        const B = {
            [E]: M,
            theme: T
        }
          , O = $[E];
        if (!O)
            return {
                [E]: M
            };
        const {cssProperty: F=E, themeKey: N, transform: U, style: H} = O;
        if (M == null)
            return null;
        if (N === "typography" && M === "inherit")
            return {
                [E]: M
            };
        const Z = getPath(T, N) || {};
        return H ? H(B) : handleBreakpoints(B, M, ie=>{
            let oe = getStyleValue(Z, U, ie);
            return ie === oe && typeof ie == "string" && (oe = getStyleValue(Z, U, `${E}${ie === "default" ? "" : capitalize$1(ie)}`, ie)),
            F === !1 ? oe : {
                [F]: oe
            }
        }
        )
    }
    function S(E) {
        var M;
        const {sx: T, theme: $={}} = E || {};
        if (!T)
            return null;
        const B = (M = $.unstable_sxConfig) != null ? M : defaultSxConfig$1;
        function O(F) {
            let N = F;
            if (typeof F == "function")
                N = F($);
            else if (typeof F != "object")
                return F;
            if (!N)
                return null;
            const U = createEmptyBreakpointObject($.breakpoints)
              , H = Object.keys(U);
            let Z = U;
            return Object.keys(N).forEach(J=>{
                const ie = callIfFn(N[J], $);
                if (ie != null)
                    if (typeof ie == "object")
                        if (B[J])
                            Z = merge$3(Z, C(J, ie, $, B));
                        else {
                            const oe = handleBreakpoints({
                                theme: $
                            }, ie, ae=>({
                                [J]: ae
                            }));
                            objectsHaveSameKeys(oe, ie) ? Z[J] = S({
                                sx: ie,
                                theme: $
                            }) : Z = merge$3(Z, oe)
                        }
                    else
                        Z = merge$3(Z, C(J, ie, $, B))
            }
            ),
            removeUnusedBreakpoints(H, Z)
        }
        return Array.isArray(T) ? T.map(O) : O(T)
    }
    return S
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
function applyStyles(C, S) {
    const E = this;
    return E.vars && typeof E.getColorSchemeSelector == "function" ? {
        [E.getColorSchemeSelector(C).replace(/(\[[^\]]+\])/, "*:where($1)")]: S
    } : E.palette.mode === C ? S : {}
}
const _excluded$t = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$3(C={}, ...S) {
    const {breakpoints: E={}, palette: M={}, spacing: T, shape: $={}} = C
      , B = _objectWithoutPropertiesLoose(C, _excluded$t)
      , O = createBreakpoints(E)
      , F = createSpacing(T);
    let N = deepmerge$1({
        breakpoints: O,
        direction: "ltr",
        components: {},
        palette: _extends$3({
            mode: "light"
        }, M),
        spacing: F,
        shape: _extends$3({}, shape$1, $)
    }, B);
    return N.applyStyles = applyStyles,
    N = S.reduce((U,H)=>deepmerge$1(U, H), N),
    N.unstable_sxConfig = _extends$3({}, defaultSxConfig$1, B == null ? void 0 : B.unstable_sxConfig),
    N.unstable_sx = function(H) {
        return styleFunctionSx$1({
            sx: H,
            theme: this
        })
    }
    ,
    N
}
const createTheme$2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: createTheme$3,
    private_createBreakpoints: createBreakpoints,
    unstable_applyStyles: applyStyles
}, Symbol.toStringTag, {
    value: "Module"
}));
function isObjectEmpty(C) {
    return Object.keys(C).length === 0
}
function useTheme$3(C=null) {
    const S = reactExports.useContext(ThemeContext);
    return !S || isObjectEmpty(S) ? C : S
}
const systemDefaultTheme$1 = createTheme$3();
function useTheme$2(C=systemDefaultTheme$1) {
    return useTheme$3(C)
}
const _excluded$s = ["sx"]
  , splitProps = C=>{
    var S, E;
    const M = {
        systemProps: {},
        otherProps: {}
    }
      , T = (S = C == null || (E = C.theme) == null ? void 0 : E.unstable_sxConfig) != null ? S : defaultSxConfig$1;
    return Object.keys(C).forEach($=>{
        T[$] ? M.systemProps[$] = C[$] : M.otherProps[$] = C[$]
    }
    ),
    M
}
;
function extendSxProp(C) {
    const {sx: S} = C
      , E = _objectWithoutPropertiesLoose(C, _excluded$s)
      , {systemProps: M, otherProps: T} = splitProps(E);
    let $;
    return Array.isArray(S) ? $ = [M, ...S] : typeof S == "function" ? $ = (...B)=>{
        const O = S(...B);
        return isPlainObject$1(O) ? _extends$3({}, M, O) : M
    }
    : $ = _extends$3({}, M, S),
    _extends$3({}, T, {
        sx: $
    })
}
const styleFunctionSx = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: styleFunctionSx$1,
    extendSxProp,
    unstable_createStyleFunctionSx,
    unstable_defaultSxConfig: defaultSxConfig$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , defaultGenerator = C=>C
  , createClassNameGenerator = ()=>{
    let C = defaultGenerator;
    return {
        configure(S) {
            C = S
        },
        generate(S) {
            return C(S)
        },
        reset() {
            C = defaultGenerator
        }
    }
}
  , ClassNameGenerator = createClassNameGenerator()
  , globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};
function generateUtilityClass(C, S, E="Mui") {
    const M = globalStateClasses[S];
    return M ? `${E}-${M}` : `${ClassNameGenerator.generate(C)}-${S}`
}
function generateUtilityClasses(C, S, E="Mui") {
    const M = {};
    return S.forEach(T=>{
        M[T] = generateUtilityClass(C, T, E)
    }
    ),
    M
}
var reactIs = {
    exports: {}
}
  , reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t$2 = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(C) {
    if (typeof C == "object" && C !== null) {
        var S = C.$$typeof;
        switch (S) {
        case b:
            switch (C = C.type,
            C) {
            case d:
            case f:
            case e:
            case m:
            case n$1:
                return C;
            default:
                switch (C = C && C.$$typeof,
                C) {
                case k:
                case h:
                case l$1:
                case q:
                case p:
                case g:
                    return C;
                default:
                    return S
                }
            }
        case c:
            return S
        }
    }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l$1;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n$1;
reactIs_production_min.isAsyncMode = function() {
    return !1
}
;
reactIs_production_min.isConcurrentMode = function() {
    return !1
}
;
reactIs_production_min.isContextConsumer = function(C) {
    return v(C) === h
}
;
reactIs_production_min.isContextProvider = function(C) {
    return v(C) === g
}
;
reactIs_production_min.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === b
}
;
reactIs_production_min.isForwardRef = function(C) {
    return v(C) === l$1
}
;
reactIs_production_min.isFragment = function(C) {
    return v(C) === d
}
;
reactIs_production_min.isLazy = function(C) {
    return v(C) === q
}
;
reactIs_production_min.isMemo = function(C) {
    return v(C) === p
}
;
reactIs_production_min.isPortal = function(C) {
    return v(C) === c
}
;
reactIs_production_min.isProfiler = function(C) {
    return v(C) === f
}
;
reactIs_production_min.isStrictMode = function(C) {
    return v(C) === e
}
;
reactIs_production_min.isSuspense = function(C) {
    return v(C) === m
}
;
reactIs_production_min.isSuspenseList = function(C) {
    return v(C) === n$1
}
;
reactIs_production_min.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === d || C === f || C === e || C === m || C === n$1 || C === t$2 || typeof C == "object" && C !== null && (C.$$typeof === q || C.$$typeof === p || C.$$typeof === g || C.$$typeof === h || C.$$typeof === l$1 || C.$$typeof === u || C.getModuleId !== void 0)
}
;
reactIs_production_min.typeOf = v;
reactIs.exports = reactIs_production_min;
var reactIsExports = reactIs.exports;
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(C) {
    const S = `${C}`.match(fnNameMatchRegex);
    return S && S[1] || ""
}
function getFunctionComponentName(C, S="") {
    return C.displayName || C.name || getFunctionName(C) || S
}
function getWrappedName(C, S, E) {
    const M = getFunctionComponentName(S);
    return C.displayName || (M !== "" ? `${E}(${M})` : E)
}
function getDisplayName$1(C) {
    if (C != null) {
        if (typeof C == "string")
            return C;
        if (typeof C == "function")
            return getFunctionComponentName(C, "Component");
        if (typeof C == "object")
            switch (C.$$typeof) {
            case reactIsExports.ForwardRef:
                return getWrappedName(C, C.render, "ForwardRef");
            case reactIsExports.Memo:
                return getWrappedName(C, C.type, "memo");
            default:
                return
            }
    }
}
const getDisplayName = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: getDisplayName$1,
    getFunctionName
}, Symbol.toStringTag, {
    value: "Module"
}));
function resolveProps(C, S) {
    const E = _extends$3({}, S);
    return Object.keys(C).forEach(M=>{
        if (M.toString().match(/^(components|slots)$/))
            E[M] = _extends$3({}, C[M], E[M]);
        else if (M.toString().match(/^(componentsProps|slotProps)$/)) {
            const T = C[M] || {}
              , $ = S[M];
            E[M] = {},
            !$ || !Object.keys($) ? E[M] = T : !T || !Object.keys(T) ? E[M] = $ : (E[M] = _extends$3({}, $),
            Object.keys(T).forEach(B=>{
                E[M][B] = resolveProps(T[B], $[B])
            }
            ))
        } else
            E[M] === void 0 && (E[M] = C[M])
    }
    ),
    E
}
function getThemeProps(C) {
    const {theme: S, name: E, props: M} = C;
    return !S || !S.components || !S.components[E] || !S.components[E].defaultProps ? M : resolveProps(S.components[E].defaultProps, M)
}
function useThemeProps$3({props: C, name: S, defaultTheme: E, themeId: M}) {
    let T = useTheme$2(E);
    return M && (T = T[M] || T),
    getThemeProps({
        theme: T,
        name: S,
        props: C
    })
}
const useEnhancedEffect = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function clamp$1(C, S=Number.MIN_SAFE_INTEGER, E=Number.MAX_SAFE_INTEGER) {
    return Math.max(S, Math.min(C, E))
}
const clamp = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: clamp$1
}, Symbol.toStringTag, {
    value: "Module"
}));
function createChainedFunction(...C) {
    return C.reduce((S,E)=>E == null ? S : function(...T) {
        S.apply(this, T),
        E.apply(this, T)
    }
    , ()=>{}
    )
}
function ownerDocument(C) {
    return C && C.ownerDocument || document
}
function ownerWindow(C) {
    return ownerDocument(C).defaultView || window
}
function setRef(C, S) {
    typeof C == "function" ? C(S) : C && (C.current = S)
}
function useEventCallback(C) {
    const S = reactExports.useRef(C);
    return useEnhancedEffect(()=>{
        S.current = C
    }
    ),
    reactExports.useRef((...E)=>(0,
    S.current)(...E)).current
}
function useForkRef(...C) {
    return reactExports.useMemo(()=>C.every(S=>S == null) ? null : S=>{
        C.forEach(E=>{
            setRef(E, S)
        }
        )
    }
    , C)
}
const UNINITIALIZED = {};
function useLazyRef(C, S) {
    const E = reactExports.useRef(UNINITIALIZED);
    return E.current === UNINITIALIZED && (E.current = C(S)),
    E
}
const EMPTY$1 = [];
function useOnMount(C) {
    reactExports.useEffect(C, EMPTY$1)
}
class Timeout {
    constructor() {
        this.currentId = null,
        this.clear = ()=>{
            this.currentId !== null && (clearTimeout(this.currentId),
            this.currentId = null)
        }
        ,
        this.disposeEffect = ()=>this.clear
    }
    static create() {
        return new Timeout
    }
    start(S, E) {
        this.clear(),
        this.currentId = setTimeout(()=>{
            this.currentId = null,
            E()
        }
        , S)
    }
}
function useTimeout() {
    const C = useLazyRef(Timeout.create).current;
    return useOnMount(C.disposeEffect),
    C
}
let hadKeyboardEvent = !0
  , hadFocusVisibleRecently = !1;
const hadFocusVisibleRecentlyTimeout = new Timeout
  , inputTypesWhitelist = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0
};
function focusTriggersKeyboardModality(C) {
    const {type: S, tagName: E} = C;
    return !!(E === "INPUT" && inputTypesWhitelist[S] && !C.readOnly || E === "TEXTAREA" && !C.readOnly || C.isContentEditable)
}
function handleKeyDown(C) {
    C.metaKey || C.altKey || C.ctrlKey || (hadKeyboardEvent = !0)
}
function handlePointerDown() {
    hadKeyboardEvent = !1
}
function handleVisibilityChange() {
    this.visibilityState === "hidden" && hadFocusVisibleRecently && (hadKeyboardEvent = !0)
}
function prepare$1(C) {
    C.addEventListener("keydown", handleKeyDown, !0),
    C.addEventListener("mousedown", handlePointerDown, !0),
    C.addEventListener("pointerdown", handlePointerDown, !0),
    C.addEventListener("touchstart", handlePointerDown, !0),
    C.addEventListener("visibilitychange", handleVisibilityChange, !0)
}
function isFocusVisible(C) {
    const {target: S} = C;
    try {
        return S.matches(":focus-visible")
    } catch {}
    return hadKeyboardEvent || focusTriggersKeyboardModality(S)
}
function useIsFocusVisible() {
    const C = reactExports.useCallback(T=>{
        T != null && prepare$1(T.ownerDocument)
    }
    , [])
      , S = reactExports.useRef(!1);
    function E() {
        return S.current ? (hadFocusVisibleRecently = !0,
        hadFocusVisibleRecentlyTimeout.start(100, ()=>{
            hadFocusVisibleRecently = !1
        }
        ),
        S.current = !1,
        !0) : !1
    }
    function M(T) {
        return isFocusVisible(T) ? (S.current = !0,
        !0) : !1
    }
    return {
        isFocusVisibleRef: S,
        onFocus: M,
        onBlur: E,
        ref: C
    }
}
function getScrollbarSize(C) {
    const S = C.documentElement.clientWidth;
    return Math.abs(window.innerWidth - S)
}
function _typeof(C) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
        return typeof S
    }
    : function(S) {
        return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S
    }
    ,
    _typeof(C)
}
function toPrimitive(C, S) {
    if (_typeof(C) != "object" || !C)
        return C;
    var E = C[Symbol.toPrimitive];
    if (E !== void 0) {
        var M = E.call(C, S || "default");
        if (_typeof(M) != "object")
            return M;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (S === "string" ? String : Number)(C)
}
function toPropertyKey(C) {
    var S = toPrimitive(C, "string");
    return _typeof(S) == "symbol" ? S : S + ""
}
function createMixins(C, S) {
    return _extends$3({
        toolbar: {
            minHeight: 56,
            [C.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [C.up("sm")]: {
                minHeight: 64
            }
        }
    }, S)
}
var colorManipulator = {}
  , interopRequireDefault = {
    exports: {}
};
(function(C) {
    function S(E) {
        return E && E.__esModule ? E : {
            default: E
        }
    }
    C.exports = S,
    C.exports.__esModule = !0,
    C.exports.default = C.exports
}
)(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
const require$$1$3 = getAugmentedNamespace(formatMuiErrorMessage)
  , require$$2$1 = getAugmentedNamespace(clamp);
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
    value: !0
});
var alpha_1 = colorManipulator.alpha = alpha;
colorManipulator.blend = blend;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
var emphasize_1 = colorManipulator.emphasize = emphasize
  , getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb$1;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex$1;
var _formatMuiErrorMessage2 = _interopRequireDefault$1(require$$1$3)
  , _clamp = _interopRequireDefault$1(require$$2$1);
function clampWrapper(C, S=0, E=1) {
    return (0,
    _clamp.default)(C, S, E)
}
function hexToRgb(C) {
    C = C.slice(1);
    const S = new RegExp(`.{1,${C.length >= 6 ? 2 : 1}}`,"g");
    let E = C.match(S);
    return E && E[0].length === 1 && (E = E.map(M=>M + M)),
    E ? `rgb${E.length === 4 ? "a" : ""}(${E.map((M,T)=>T < 3 ? parseInt(M, 16) : Math.round(parseInt(M, 16) / 255 * 1e3) / 1e3).join(", ")})` : ""
}
function intToHex(C) {
    const S = C.toString(16);
    return S.length === 1 ? `0${S}` : S
}
function decomposeColor(C) {
    if (C.type)
        return C;
    if (C.charAt(0) === "#")
        return decomposeColor(hexToRgb(C));
    const S = C.indexOf("(")
      , E = C.substring(0, S);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(E) === -1)
        throw new Error((0,
        _formatMuiErrorMessage2.default)(9, C));
    let M = C.substring(S + 1, C.length - 1), T;
    if (E === "color") {
        if (M = M.split(" "),
        T = M.shift(),
        M.length === 4 && M[3].charAt(0) === "/" && (M[3] = M[3].slice(1)),
        ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(T) === -1)
            throw new Error((0,
            _formatMuiErrorMessage2.default)(10, T))
    } else
        M = M.split(",");
    return M = M.map($=>parseFloat($)),
    {
        type: E,
        values: M,
        colorSpace: T
    }
}
const colorChannel = C=>{
    const S = decomposeColor(C);
    return S.values.slice(0, 3).map((E,M)=>S.type.indexOf("hsl") !== -1 && M !== 0 ? `${E}%` : E).join(" ")
}
;
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = (C,S)=>{
    try {
        return colorChannel(C)
    } catch {
        return C
    }
}
;
colorManipulator.private_safeColorChannel = private_safeColorChannel;
function recomposeColor(C) {
    const {type: S, colorSpace: E} = C;
    let {values: M} = C;
    return S.indexOf("rgb") !== -1 ? M = M.map((T,$)=>$ < 3 ? parseInt(T, 10) : T) : S.indexOf("hsl") !== -1 && (M[1] = `${M[1]}%`,
    M[2] = `${M[2]}%`),
    S.indexOf("color") !== -1 ? M = `${E} ${M.join(" ")}` : M = `${M.join(", ")}`,
    `${S}(${M})`
}
function rgbToHex$1(C) {
    if (C.indexOf("#") === 0)
        return C;
    const {values: S} = decomposeColor(C);
    return `#${S.map((E,M)=>intToHex(M === 3 ? Math.round(255 * E) : E)).join("")}`
}
function hslToRgb$1(C) {
    C = decomposeColor(C);
    const {values: S} = C
      , E = S[0]
      , M = S[1] / 100
      , T = S[2] / 100
      , $ = M * Math.min(T, 1 - T)
      , B = (N,U=(N + E / 30) % 12)=>T - $ * Math.max(Math.min(U - 3, 9 - U, 1), -1);
    let O = "rgb";
    const F = [Math.round(B(0) * 255), Math.round(B(8) * 255), Math.round(B(4) * 255)];
    return C.type === "hsla" && (O += "a",
    F.push(S[3])),
    recomposeColor({
        type: O,
        values: F
    })
}
function getLuminance(C) {
    C = decomposeColor(C);
    let S = C.type === "hsl" || C.type === "hsla" ? decomposeColor(hslToRgb$1(C)).values : C.values;
    return S = S.map(E=>(C.type !== "color" && (E /= 255),
    E <= .03928 ? E / 12.92 : ((E + .055) / 1.055) ** 2.4)),
    Number((.2126 * S[0] + .7152 * S[1] + .0722 * S[2]).toFixed(3))
}
function getContrastRatio(C, S) {
    const E = getLuminance(C)
      , M = getLuminance(S);
    return (Math.max(E, M) + .05) / (Math.min(E, M) + .05)
}
function alpha(C, S) {
    return C = decomposeColor(C),
    S = clampWrapper(S),
    (C.type === "rgb" || C.type === "hsl") && (C.type += "a"),
    C.type === "color" ? C.values[3] = `/${S}` : C.values[3] = S,
    recomposeColor(C)
}
function private_safeAlpha(C, S, E) {
    try {
        return alpha(C, S)
    } catch {
        return C
    }
}
function darken(C, S) {
    if (C = decomposeColor(C),
    S = clampWrapper(S),
    C.type.indexOf("hsl") !== -1)
        C.values[2] *= 1 - S;
    else if (C.type.indexOf("rgb") !== -1 || C.type.indexOf("color") !== -1)
        for (let E = 0; E < 3; E += 1)
            C.values[E] *= 1 - S;
    return recomposeColor(C)
}
function private_safeDarken(C, S, E) {
    try {
        return darken(C, S)
    } catch {
        return C
    }
}
function lighten(C, S) {
    if (C = decomposeColor(C),
    S = clampWrapper(S),
    C.type.indexOf("hsl") !== -1)
        C.values[2] += (100 - C.values[2]) * S;
    else if (C.type.indexOf("rgb") !== -1)
        for (let E = 0; E < 3; E += 1)
            C.values[E] += (255 - C.values[E]) * S;
    else if (C.type.indexOf("color") !== -1)
        for (let E = 0; E < 3; E += 1)
            C.values[E] += (1 - C.values[E]) * S;
    return recomposeColor(C)
}
function private_safeLighten(C, S, E) {
    try {
        return lighten(C, S)
    } catch {
        return C
    }
}
function emphasize(C, S=.15) {
    return getLuminance(C) > .5 ? darken(C, S) : lighten(C, S)
}
function private_safeEmphasize(C, S, E) {
    try {
        return emphasize(C, S)
    } catch {
        return C
    }
}
function blend(C, S, E, M=1) {
    const T = (F,N)=>Math.round((F ** (1 / M) * (1 - E) + N ** (1 / M) * E) ** M)
      , $ = decomposeColor(C)
      , B = decomposeColor(S)
      , O = [T($.values[0], B.values[0]), T($.values[1], B.values[1]), T($.values[2], B.values[2])];
    return recomposeColor({
        type: "rgb",
        values: O
    })
}
const common = {
    black: "#000",
    white: "#fff"
}
  , common$1 = common
  , grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
}
  , grey$1 = grey
  , purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
}
  , purple$1 = purple
  , red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
}
  , red$1 = red
  , orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
}
  , orange$1 = orange
  , blue$1 = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
}
  , blue$2 = blue$1
  , lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
}
  , lightBlue$1 = lightBlue
  , green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
}
  , green$1 = green
  , _excluded$r = ["mode", "contrastThreshold", "tonalOffset"]
  , light = {
    text: {
        primary: "rgba(0, 0, 0, 0.87)",
        secondary: "rgba(0, 0, 0, 0.6)",
        disabled: "rgba(0, 0, 0, 0.38)"
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: {
        paper: common$1.white,
        default: common$1.white
    },
    action: {
        active: "rgba(0, 0, 0, 0.54)",
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: .04,
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: .08,
        disabled: "rgba(0, 0, 0, 0.26)",
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: .38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: .12,
        activatedOpacity: .12
    }
}
  , dark = {
    text: {
        primary: common$1.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
        paper: "#121212",
        default: "#121212"
    },
    action: {
        active: common$1.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: .08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: .16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: .38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: .12,
        activatedOpacity: .24
    }
};
function addLightOrDark(C, S, E, M) {
    const T = M.light || M
      , $ = M.dark || M * 1.5;
    C[S] || (C.hasOwnProperty(E) ? C[S] = C[E] : S === "light" ? C.light = lighten_1(C.main, T) : S === "dark" && (C.dark = darken_1(C.main, $)))
}
function getDefaultPrimary(C="light") {
    return C === "dark" ? {
        main: blue$2[200],
        light: blue$2[50],
        dark: blue$2[400]
    } : {
        main: blue$2[700],
        light: blue$2[400],
        dark: blue$2[800]
    }
}
function getDefaultSecondary(C="light") {
    return C === "dark" ? {
        main: purple$1[200],
        light: purple$1[50],
        dark: purple$1[400]
    } : {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700]
    }
}
function getDefaultError(C="light") {
    return C === "dark" ? {
        main: red$1[500],
        light: red$1[300],
        dark: red$1[700]
    } : {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800]
    }
}
function getDefaultInfo(C="light") {
    return C === "dark" ? {
        main: lightBlue$1[400],
        light: lightBlue$1[300],
        dark: lightBlue$1[700]
    } : {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900]
    }
}
function getDefaultSuccess(C="light") {
    return C === "dark" ? {
        main: green$1[400],
        light: green$1[300],
        dark: green$1[700]
    } : {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900]
    }
}
function getDefaultWarning(C="light") {
    return C === "dark" ? {
        main: orange$1[400],
        light: orange$1[300],
        dark: orange$1[700]
    } : {
        main: "#ed6c02",
        light: orange$1[500],
        dark: orange$1[900]
    }
}
function createPalette(C) {
    const {mode: S="light", contrastThreshold: E=3, tonalOffset: M=.2} = C
      , T = _objectWithoutPropertiesLoose(C, _excluded$r)
      , $ = C.primary || getDefaultPrimary(S)
      , B = C.secondary || getDefaultSecondary(S)
      , O = C.error || getDefaultError(S)
      , F = C.info || getDefaultInfo(S)
      , N = C.success || getDefaultSuccess(S)
      , U = C.warning || getDefaultWarning(S);
    function H(oe) {
        return getContrastRatio_1(oe, dark.text.primary) >= E ? dark.text.primary : light.text.primary
    }
    const Z = ({color: oe, name: ae, mainShade: se=500, lightShade: le=300, darkShade: de=700})=>{
        if (oe = _extends$3({}, oe),
        !oe.main && oe[se] && (oe.main = oe[se]),
        !oe.hasOwnProperty("main"))
            throw new Error(formatMuiErrorMessage$1(11, ae ? ` (${ae})` : "", se));
        if (typeof oe.main != "string")
            throw new Error(formatMuiErrorMessage$1(12, ae ? ` (${ae})` : "", JSON.stringify(oe.main)));
        return addLightOrDark(oe, "light", le, M),
        addLightOrDark(oe, "dark", de, M),
        oe.contrastText || (oe.contrastText = H(oe.main)),
        oe
    }
      , J = {
        dark,
        light
    };
    return deepmerge$1(_extends$3({
        common: _extends$3({}, common$1),
        mode: S,
        primary: Z({
            color: $,
            name: "primary"
        }),
        secondary: Z({
            color: B,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: Z({
            color: O,
            name: "error"
        }),
        warning: Z({
            color: U,
            name: "warning"
        }),
        info: Z({
            color: F,
            name: "info"
        }),
        success: Z({
            color: N,
            name: "success"
        }),
        grey: grey$1,
        contrastThreshold: E,
        getContrastText: H,
        augmentColor: Z,
        tonalOffset: M
    }, J[S]), T)
}
const _excluded$q = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(C) {
    return Math.round(C * 1e5) / 1e5
}
const caseAllCaps = {
    textTransform: "uppercase"
}
  , defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(C, S) {
    const E = typeof S == "function" ? S(C) : S
      , {fontFamily: M=defaultFontFamily, fontSize: T=14, fontWeightLight: $=300, fontWeightRegular: B=400, fontWeightMedium: O=500, fontWeightBold: F=700, htmlFontSize: N=16, allVariants: U, pxToRem: H} = E
      , Z = _objectWithoutPropertiesLoose(E, _excluded$q)
      , J = T / 14
      , ie = H || (se=>`${se / N * J}rem`)
      , oe = (se,le,de,fe,pe)=>_extends$3({
        fontFamily: M,
        fontWeight: se,
        fontSize: ie(le),
        lineHeight: de
    }, M === defaultFontFamily ? {
        letterSpacing: `${round(fe / le)}em`
    } : {}, pe, U)
      , ae = {
        h1: oe($, 96, 1.167, -1.5),
        h2: oe($, 60, 1.2, -.5),
        h3: oe(B, 48, 1.167, 0),
        h4: oe(B, 34, 1.235, .25),
        h5: oe(B, 24, 1.334, 0),
        h6: oe(O, 20, 1.6, .15),
        subtitle1: oe(B, 16, 1.75, .15),
        subtitle2: oe(O, 14, 1.57, .1),
        body1: oe(B, 16, 1.5, .15),
        body2: oe(B, 14, 1.43, .15),
        button: oe(O, 14, 1.75, .4, caseAllCaps),
        caption: oe(B, 12, 1.66, .4),
        overline: oe(B, 12, 2.66, 1, caseAllCaps),
        inherit: {
            fontFamily: "inherit",
            fontWeight: "inherit",
            fontSize: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit"
        }
    };
    return deepmerge$1(_extends$3({
        htmlFontSize: N,
        pxToRem: ie,
        fontFamily: M,
        fontSize: T,
        fontWeightLight: $,
        fontWeightRegular: B,
        fontWeightMedium: O,
        fontWeightBold: F
    }, ae), Z, {
        clone: !1
    })
}
const shadowKeyUmbraOpacity = .2
  , shadowKeyPenumbraOpacity = .14
  , shadowAmbientShadowOpacity = .12;
function createShadow(...C) {
    return [`${C[0]}px ${C[1]}px ${C[2]}px ${C[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${C[4]}px ${C[5]}px ${C[6]}px ${C[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${C[8]}px ${C[9]}px ${C[10]}px ${C[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",")
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
  , _excluded$p = ["duration", "easing", "delay"]
  , easing = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}
  , duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195
};
function formatMs(C) {
    return `${Math.round(C)}ms`
}
function getAutoHeightDuration(C) {
    if (!C)
        return 0;
    const S = C / 36;
    return Math.round((4 + 15 * S ** .25 + S / 5) * 10)
}
function createTransitions(C) {
    const S = _extends$3({}, easing, C.easing)
      , E = _extends$3({}, duration, C.duration);
    return _extends$3({
        getAutoHeightDuration,
        create: (T=["all"],$={})=>{
            const {duration: B=E.standard, easing: O=S.easeInOut, delay: F=0} = $;
            return _objectWithoutPropertiesLoose($, _excluded$p),
            (Array.isArray(T) ? T : [T]).map(N=>`${N} ${typeof B == "string" ? B : formatMs(B)} ${O} ${typeof F == "string" ? F : formatMs(F)}`).join(",")
        }
    }, C, {
        easing: S,
        duration: E
    })
}
const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
}
  , zIndex$1 = zIndex
  , _excluded$o = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme$1(C={}, ...S) {
    const {mixins: E={}, palette: M={}, transitions: T={}, typography: $={}} = C
      , B = _objectWithoutPropertiesLoose(C, _excluded$o);
    if (C.vars)
        throw new Error(formatMuiErrorMessage$1(18));
    const O = createPalette(M)
      , F = createTheme$3(C);
    let N = deepmerge$1(F, {
        mixins: createMixins(F.breakpoints, E),
        palette: O,
        shadows: shadows.slice(),
        typography: createTypography(O, $),
        transitions: createTransitions(T),
        zIndex: _extends$3({}, zIndex$1)
    });
    return N = deepmerge$1(N, B),
    N = S.reduce((U,H)=>deepmerge$1(U, H), N),
    N.unstable_sxConfig = _extends$3({}, defaultSxConfig$1, B == null ? void 0 : B.unstable_sxConfig),
    N.unstable_sx = function(H) {
        return styleFunctionSx$1({
            sx: H,
            theme: this
        })
    }
    ,
    N
}
const defaultTheme$1 = createTheme$1()
  , defaultTheme$2 = defaultTheme$1
  , THEME_ID = "$$material";
function useThemeProps$2({props: C, name: S}) {
    return useThemeProps$3({
        props: C,
        name: S,
        defaultTheme: defaultTheme$2,
        themeId: THEME_ID
    })
}
var createStyled$1 = {};
const require$$1$2 = getAugmentedNamespace(_extends$4);
var objectWithoutPropertiesLoose = {
    exports: {}
}, hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
    return hasRequiredObjectWithoutPropertiesLoose || (hasRequiredObjectWithoutPropertiesLoose = 1,
    function(C) {
        function S(E, M) {
            if (E == null)
                return {};
            var T = {}, $ = Object.keys(E), B, O;
            for (O = 0; O < $.length; O++)
                B = $[O],
                !(M.indexOf(B) >= 0) && (T[B] = E[B]);
            return T
        }
        C.exports = S,
        C.exports.__esModule = !0,
        C.exports.default = C.exports
    }(objectWithoutPropertiesLoose)),
    objectWithoutPropertiesLoose.exports
}
const require$$1$1 = getAugmentedNamespace(styledEngine)
  , require$$4 = getAugmentedNamespace(deepmerge)
  , require$$5 = getAugmentedNamespace(capitalize)
  , require$$6 = getAugmentedNamespace(getDisplayName)
  , require$$7 = getAugmentedNamespace(createTheme$2)
  , require$$8 = getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(createStyled$1, "__esModule", {
    value: !0
});
var _default$1 = createStyled$1.default = createStyled;
createStyled$1.shouldForwardProp = shouldForwardProp;
createStyled$1.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault(require$$1$2)
  , _objectWithoutPropertiesLoose2 = _interopRequireDefault(requireObjectWithoutPropertiesLoose())
  , _styledEngine = _interopRequireWildcard(require$$1$1)
  , _deepmerge = require$$4;
_interopRequireDefault(require$$5);
_interopRequireDefault(require$$6);
var _createTheme = _interopRequireDefault(require$$7)
  , _styleFunctionSx = _interopRequireDefault(require$$8);
const _excluded$n = ["ownerState"]
  , _excluded2$3 = ["variants"]
  , _excluded3$1 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function _getRequireWildcardCache(C) {
    if (typeof WeakMap != "function")
        return null;
    var S = new WeakMap
      , E = new WeakMap;
    return (_getRequireWildcardCache = function(M) {
        return M ? E : S
    }
    )(C)
}
function _interopRequireWildcard(C, S) {
    if (!S && C && C.__esModule)
        return C;
    if (C === null || typeof C != "object" && typeof C != "function")
        return {
            default: C
        };
    var E = _getRequireWildcardCache(S);
    if (E && E.has(C))
        return E.get(C);
    var M = {
        __proto__: null
    }
      , T = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var $ in C)
        if ($ !== "default" && Object.prototype.hasOwnProperty.call(C, $)) {
            var B = T ? Object.getOwnPropertyDescriptor(C, $) : null;
            B && (B.get || B.set) ? Object.defineProperty(M, $, B) : M[$] = C[$]
        }
    return M.default = C,
    E && E.set(C, M),
    M
}
function isEmpty(C) {
    return Object.keys(C).length === 0
}
function isStringTag(C) {
    return typeof C == "string" && C.charCodeAt(0) > 96
}
function shouldForwardProp(C) {
    return C !== "ownerState" && C !== "theme" && C !== "sx" && C !== "as"
}
const systemDefaultTheme = createStyled$1.systemDefaultTheme = (0,
_createTheme.default)()
  , lowercaseFirstLetter = C=>C && C.charAt(0).toLowerCase() + C.slice(1);
function resolveTheme({defaultTheme: C, theme: S, themeId: E}) {
    return isEmpty(S) ? C : S[E] || S
}
function defaultOverridesResolver(C) {
    return C ? (S,E)=>E[C] : null
}
function processStyleArg(C, S) {
    let {ownerState: E} = S
      , M = (0,
    _objectWithoutPropertiesLoose2.default)(S, _excluded$n);
    const T = typeof C == "function" ? C((0,
    _extends2.default)({
        ownerState: E
    }, M)) : C;
    if (Array.isArray(T))
        return T.flatMap($=>processStyleArg($, (0,
        _extends2.default)({
            ownerState: E
        }, M)));
    if (T && typeof T == "object" && Array.isArray(T.variants)) {
        const {variants: $=[]} = T;
        let O = (0,
        _objectWithoutPropertiesLoose2.default)(T, _excluded2$3);
        return $.forEach(F=>{
            let N = !0;
            typeof F.props == "function" ? N = F.props((0,
            _extends2.default)({
                ownerState: E
            }, M, E)) : Object.keys(F.props).forEach(U=>{
                (E == null ? void 0 : E[U]) !== F.props[U] && M[U] !== F.props[U] && (N = !1)
            }
            ),
            N && (Array.isArray(O) || (O = [O]),
            O.push(typeof F.style == "function" ? F.style((0,
            _extends2.default)({
                ownerState: E
            }, M, E)) : F.style))
        }
        ),
        O
    }
    return T
}
function createStyled(C={}) {
    const {themeId: S, defaultTheme: E=systemDefaultTheme, rootShouldForwardProp: M=shouldForwardProp, slotShouldForwardProp: T=shouldForwardProp} = C
      , $ = B=>(0,
    _styleFunctionSx.default)((0,
    _extends2.default)({}, B, {
        theme: resolveTheme((0,
        _extends2.default)({}, B, {
            defaultTheme: E,
            themeId: S
        }))
    }));
    return $.__mui_systemSx = !0,
    (B,O={})=>{
        (0,
        _styledEngine.internal_processStyles)(B, pe=>pe.filter(ge=>!(ge != null && ge.__mui_systemSx)));
        const {name: F, slot: N, skipVariantsResolver: U, skipSx: H, overridesResolver: Z=defaultOverridesResolver(lowercaseFirstLetter(N))} = O
          , J = (0,
        _objectWithoutPropertiesLoose2.default)(O, _excluded3$1)
          , ie = U !== void 0 ? U : N && N !== "Root" && N !== "root" || !1
          , oe = H || !1;
        let ae, se = shouldForwardProp;
        N === "Root" || N === "root" ? se = M : N ? se = T : isStringTag(B) && (se = void 0);
        const le = (0,
        _styledEngine.default)(B, (0,
        _extends2.default)({
            shouldForwardProp: se,
            label: ae
        }, J))
          , de = pe=>typeof pe == "function" && pe.__emotion_real !== pe || (0,
        _deepmerge.isPlainObject)(pe) ? ge=>processStyleArg(pe, (0,
        _extends2.default)({}, ge, {
            theme: resolveTheme({
                theme: ge.theme,
                defaultTheme: E,
                themeId: S
            })
        })) : pe
          , fe = (pe,...ge)=>{
            let we = de(pe);
            const Ae = ge ? ge.map(de) : [];
            F && Z && Ae.push(V=>{
                const W = resolveTheme((0,
                _extends2.default)({}, V, {
                    defaultTheme: E,
                    themeId: S
                }));
                if (!W.components || !W.components[F] || !W.components[F].styleOverrides)
                    return null;
                const D = W.components[F].styleOverrides
                  , I = {};
                return Object.entries(D).forEach(([L,K])=>{
                    I[L] = processStyleArg(K, (0,
                    _extends2.default)({}, V, {
                        theme: W
                    }))
                }
                ),
                Z(V, I)
            }
            ),
            F && !ie && Ae.push(V=>{
                var W;
                const D = resolveTheme((0,
                _extends2.default)({}, V, {
                    defaultTheme: E,
                    themeId: S
                }))
                  , I = D == null || (W = D.components) == null || (W = W[F]) == null ? void 0 : W.variants;
                return processStyleArg({
                    variants: I
                }, (0,
                _extends2.default)({}, V, {
                    theme: D
                }))
            }
            ),
            oe || Ae.push($);
            const Se = Ae.length - ge.length;
            if (Array.isArray(pe) && Se > 0) {
                const V = new Array(Se).fill("");
                we = [...pe, ...V],
                we.raw = [...pe.raw, ...V]
            }
            const ue = le(we, ...Ae);
            return B.muiName && (ue.muiName = B.muiName),
            ue
        }
        ;
        return le.withConfig && (fe.withConfig = le.withConfig),
        fe
    }
}
function slotShouldForwardProp(C) {
    return C !== "ownerState" && C !== "theme" && C !== "sx" && C !== "as"
}
const rootShouldForwardProp = C=>slotShouldForwardProp(C) && C !== "classes"
  , rootShouldForwardProp$1 = rootShouldForwardProp
  , styled = _default$1({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$2,
    rootShouldForwardProp: rootShouldForwardProp$1
});
function getCircularProgressUtilityClass(C) {
    return generateUtilityClass("MuiCircularProgress", C)
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const _excluded$m = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let _$1 = C=>C, _t$1, _t2$1, _t3$1, _t4$1;
const SIZE = 44
  , circularRotateKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`))
  , circularDashKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`))
  , useUtilityClasses$b = C=>{
    const {classes: S, variant: E, color: M, disableShrink: T} = C
      , $ = {
        root: ["root", E, `color${capitalize$1(M)}`],
        svg: ["svg"],
        circle: ["circle", `circle${capitalize$1(E)}`, T && "circleDisableShrink"]
    };
    return composeClasses($, getCircularProgressUtilityClass, S)
}
  , CircularProgressRoot = styled("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, S[E.variant], S[`color${capitalize$1(E.color)}`]]
    }
})(({ownerState: C, theme: S})=>_extends$3({
    display: "inline-block"
}, C.variant === "determinate" && {
    transition: S.transitions.create("transform")
}, C.color !== "inherit" && {
    color: (S.vars || S).palette[C.color].main
}), ({ownerState: C})=>C.variant === "indeterminate" && css(_t3$1 || (_t3$1 = _$1`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe))
  , CircularProgressSVG = styled("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (C,S)=>S.svg
})({
    display: "block"
})
  , CircularProgressCircle = styled("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.circle, S[`circle${capitalize$1(E.variant)}`], E.disableShrink && S.circleDisableShrink]
    }
})(({ownerState: C, theme: S})=>_extends$3({
    stroke: "currentColor"
}, C.variant === "determinate" && {
    transition: S.transitions.create("stroke-dashoffset")
}, C.variant === "indeterminate" && {
    strokeDasharray: "80px, 200px",
    strokeDashoffset: 0
}), ({ownerState: C})=>C.variant === "indeterminate" && !C.disableShrink && css(_t4$1 || (_t4$1 = _$1`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe))
  , CircularProgress = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiCircularProgress"
    })
      , {className: T, color: $="primary", disableShrink: B=!1, size: O=40, style: F, thickness: N=3.6, value: U=0, variant: H="indeterminate"} = M
      , Z = _objectWithoutPropertiesLoose(M, _excluded$m)
      , J = _extends$3({}, M, {
        color: $,
        disableShrink: B,
        size: O,
        thickness: N,
        value: U,
        variant: H
    })
      , ie = useUtilityClasses$b(J)
      , oe = {}
      , ae = {}
      , se = {};
    if (H === "determinate") {
        const le = 2 * Math.PI * ((SIZE - N) / 2);
        oe.strokeDasharray = le.toFixed(3),
        se["aria-valuenow"] = Math.round(U),
        oe.strokeDashoffset = `${((100 - U) / 100 * le).toFixed(3)}px`,
        ae.transform = "rotate(-90deg)"
    }
    return jsxRuntimeExports.jsx(CircularProgressRoot, _extends$3({
        className: clsx(ie.root, T),
        style: _extends$3({
            width: O,
            height: O
        }, ae, F),
        ownerState: J,
        ref: E,
        role: "progressbar"
    }, se, Z, {
        children: jsxRuntimeExports.jsx(CircularProgressSVG, {
            className: ie.svg,
            ownerState: J,
            viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
            children: jsxRuntimeExports.jsx(CircularProgressCircle, {
                className: ie.circle,
                style: oe,
                ownerState: J,
                cx: SIZE,
                cy: SIZE,
                r: (SIZE - N) / 2,
                fill: "none",
                strokeWidth: N
            })
        })
    }))
})
  , CircularProgress$1 = CircularProgress
  , spinnerWrapper = "_spinnerWrapper_1sjwi_1"
  , classes$6 = {
    spinnerWrapper
}
  , ButtonSpinner = observer(({isLoading: C})=>C ? jsxRuntimeExports.jsx("div", {
    className: classes$6.spinnerWrapper,
    children: jsxRuntimeExports.jsx(CircularProgress$1, {
        className: classes$6.spinner
    })
}) : null);
reactExports.forwardRef((C,S)=>{
    const {className: E, children: M, variant: T="primary", isDisabled: $, isLoading: B, size: O, ...F} = C
      , N = clsx(classes$7.button, E, {
        [classes$7._primary]: T === "primary",
        [classes$7._secondary]: T === "secondary",
        [classes$7._xsm]: O === "xsm",
        [classes$7._sm]: O === "sm",
        [classes$7._md]: O === "md",
        [classes$7._lg]: O === "lg"
    });
    if (F.as === "button")
        return jsxRuntimeExports.jsxs("button", {
            ref: S,
            className: N,
            ...F,
            disabled: $,
            children: [M, jsxRuntimeExports.jsx(ButtonSpinner, {
                isLoading: B
            })]
        });
    if (F.as === "a")
        return jsxRuntimeExports.jsxs("a", {
            className: N,
            ...F,
            children: [M, jsxRuntimeExports.jsx(ButtonSpinner, {
                isLoading: B
            })]
        });
    if (F.as === "link")
        return jsxRuntimeExports.jsxs(Link$1, {
            className: N,
            ...F,
            children: [M, B && jsxRuntimeExports.jsx(ButtonSpinner, {
                isLoading: B
            })]
        });
    throw new Error("Button as prop must be one of: button, a, link")
}
);
var isCheckBoxInput = C=>C.type === "checkbox"
  , isDateObject = C=>C instanceof Date
  , isNullOrUndefined = C=>C == null;
const isObjectType = C=>typeof C == "object";
var isObject$2 = C=>!isNullOrUndefined(C) && !Array.isArray(C) && isObjectType(C) && !isDateObject(C)
  , getEventValue = C=>isObject$2(C) && C.target ? isCheckBoxInput(C.target) ? C.target.checked : C.target.value : C
  , getNodeParentName = C=>C.substring(0, C.search(/\.\d+(\.|$)/)) || C
  , isNameInFieldArray = (C,S)=>C.has(getNodeParentName(S))
  , isPlainObject = C=>{
    const S = C.constructor && C.constructor.prototype;
    return isObject$2(S) && S.hasOwnProperty("isPrototypeOf")
}
  , isWeb = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function cloneObject(C) {
    let S;
    const E = Array.isArray(C);
    if (C instanceof Date)
        S = new Date(C);
    else if (C instanceof Set)
        S = new Set(C);
    else if (!(isWeb && (C instanceof Blob || C instanceof FileList)) && (E || isObject$2(C)))
        if (S = E ? [] : {},
        !E && !isPlainObject(C))
            S = C;
        else
            for (const M in C)
                C.hasOwnProperty(M) && (S[M] = cloneObject(C[M]));
    else
        return C;
    return S
}
var compact = C=>Array.isArray(C) ? C.filter(Boolean) : []
  , isUndefined$1 = C=>C === void 0
  , get$2 = (C,S,E)=>{
    if (!S || !isObject$2(C))
        return E;
    const M = compact(S.split(/[,[\].]+?/)).reduce((T,$)=>isNullOrUndefined(T) ? T : T[$], C);
    return isUndefined$1(M) || M === C ? isUndefined$1(C[S]) ? E : C[S] : M
}
  , isBoolean = C=>typeof C == "boolean";
const EVENTS = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , VALIDATION_MODE = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , INPUT_VALIDATION_RULES = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , HookFormContext = React$1.createContext(null)
  , useFormContext = ()=>React$1.useContext(HookFormContext);
var getProxyFormState = (C,S,E,M=!0)=>{
    const T = {
        defaultValues: S._defaultValues
    };
    for (const $ in C)
        Object.defineProperty(T, $, {
            get: ()=>{
                const B = $;
                return S._proxyFormState[B] !== VALIDATION_MODE.all && (S._proxyFormState[B] = !M || VALIDATION_MODE.all),
                E && (E[B] = !0),
                C[B]
            }
        });
    return T
}
  , isEmptyObject = C=>isObject$2(C) && !Object.keys(C).length
  , shouldRenderFormState = (C,S,E,M)=>{
    E(C);
    const {name: T, ...$} = C;
    return isEmptyObject($) || Object.keys($).length >= Object.keys(S).length || Object.keys($).find(B=>S[B] === (!M || VALIDATION_MODE.all))
}
  , convertToArrayPayload = C=>Array.isArray(C) ? C : [C]
  , shouldSubscribeByName = (C,S,E)=>!C || !S || C === S || convertToArrayPayload(C).some(M=>M && (E ? M === S : M.startsWith(S) || S.startsWith(M)));
function useSubscribe(C) {
    const S = React$1.useRef(C);
    S.current = C,
    React$1.useEffect(()=>{
        const E = !C.disabled && S.current.subject && S.current.subject.subscribe({
            next: S.current.next
        });
        return ()=>{
            E && E.unsubscribe()
        }
    }
    , [C.disabled])
}
function useFormState(C) {
    const S = useFormContext()
      , {control: E=S.control, disabled: M, name: T, exact: $} = C || {}
      , [B,O] = React$1.useState(E._formState)
      , F = React$1.useRef(!0)
      , N = React$1.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    })
      , U = React$1.useRef(T);
    return U.current = T,
    useSubscribe({
        disabled: M,
        next: H=>F.current && shouldSubscribeByName(U.current, H.name, $) && shouldRenderFormState(H, N.current, E._updateFormState) && O({
            ...E._formState,
            ...H
        }),
        subject: E._subjects.state
    }),
    React$1.useEffect(()=>(F.current = !0,
    N.current.isValid && E._updateValid(!0),
    ()=>{
        F.current = !1
    }
    ), [E]),
    getProxyFormState(B, E, N.current, !1)
}
var isString$1 = C=>typeof C == "string"
  , generateWatchOutput = (C,S,E,M,T)=>isString$1(C) ? (M && S.watch.add(C),
get$2(E, C, T)) : Array.isArray(C) ? C.map($=>(M && S.watch.add($),
get$2(E, $))) : (M && (S.watchAll = !0),
E);
function useWatch(C) {
    const S = useFormContext()
      , {control: E=S.control, name: M, defaultValue: T, disabled: $, exact: B} = C || {}
      , O = React$1.useRef(M);
    O.current = M,
    useSubscribe({
        disabled: $,
        subject: E._subjects.values,
        next: U=>{
            shouldSubscribeByName(O.current, U.name, B) && N(cloneObject(generateWatchOutput(O.current, E._names, U.values || E._formValues, !1, T)))
        }
    });
    const [F,N] = React$1.useState(E._getWatch(M, T));
    return React$1.useEffect(()=>E._removeUnmounted()),
    F
}
var isKey = C=>/^\w*$/.test(C)
  , stringToPath = C=>compact(C.replace(/["|']|\]/g, "").split(/\.|\[/))
  , set$1 = (C,S,E)=>{
    let M = -1;
    const T = isKey(S) ? [S] : stringToPath(S)
      , $ = T.length
      , B = $ - 1;
    for (; ++M < $; ) {
        const O = T[M];
        let F = E;
        if (M !== B) {
            const N = C[O];
            F = isObject$2(N) || Array.isArray(N) ? N : isNaN(+T[M + 1]) ? {} : []
        }
        C[O] = F,
        C = C[O]
    }
    return C
}
;
function useController(C) {
    const S = useFormContext()
      , {name: E, disabled: M, control: T=S.control, shouldUnregister: $} = C
      , B = isNameInFieldArray(T._names.array, E)
      , O = useWatch({
        control: T,
        name: E,
        defaultValue: get$2(T._formValues, E, get$2(T._defaultValues, E, C.defaultValue)),
        exact: !0
    })
      , F = useFormState({
        control: T,
        name: E
    })
      , N = React$1.useRef(T.register(E, {
        ...C.rules,
        value: O,
        ...isBoolean(C.disabled) ? {
            disabled: C.disabled
        } : {}
    }));
    return React$1.useEffect(()=>{
        const U = T._options.shouldUnregister || $
          , H = (Z,J)=>{
            const ie = get$2(T._fields, Z);
            ie && (ie._f.mount = J)
        }
        ;
        if (H(E, !0),
        U) {
            const Z = cloneObject(get$2(T._options.defaultValues, E));
            set$1(T._defaultValues, E, Z),
            isUndefined$1(get$2(T._formValues, E)) && set$1(T._formValues, E, Z)
        }
        return ()=>{
            (B ? U && !T._state.action : U) ? T.unregister(E) : H(E, !1)
        }
    }
    , [E, T, B, $]),
    React$1.useEffect(()=>{
        get$2(T._fields, E) && T._updateDisabledField({
            disabled: M,
            fields: T._fields,
            name: E,
            value: get$2(T._fields, E)._f.value
        })
    }
    , [M, E, T]),
    {
        field: {
            name: E,
            value: O,
            ...isBoolean(M) || F.disabled ? {
                disabled: F.disabled || M
            } : {},
            onChange: React$1.useCallback(U=>N.current.onChange({
                target: {
                    value: getEventValue(U),
                    name: E
                },
                type: EVENTS.CHANGE
            }), [E]),
            onBlur: React$1.useCallback(()=>N.current.onBlur({
                target: {
                    value: get$2(T._formValues, E),
                    name: E
                },
                type: EVENTS.BLUR
            }), [E, T]),
            ref: U=>{
                const H = get$2(T._fields, E);
                H && U && (H._f.ref = {
                    focus: ()=>U.focus(),
                    select: ()=>U.select(),
                    setCustomValidity: Z=>U.setCustomValidity(Z),
                    reportValidity: ()=>U.reportValidity()
                })
            }
        },
        formState: F,
        fieldState: Object.defineProperties({}, {
            invalid: {
                enumerable: !0,
                get: ()=>!!get$2(F.errors, E)
            },
            isDirty: {
                enumerable: !0,
                get: ()=>!!get$2(F.dirtyFields, E)
            },
            isTouched: {
                enumerable: !0,
                get: ()=>!!get$2(F.touchedFields, E)
            },
            isValidating: {
                enumerable: !0,
                get: ()=>!!get$2(F.validatingFields, E)
            },
            error: {
                enumerable: !0,
                get: ()=>get$2(F.errors, E)
            }
        })
    }
}
const Controller = C=>C.render(useController(C));
var appendErrors = (C,S,E,M,T)=>S ? {
    ...E[C],
    types: {
        ...E[C] && E[C].types ? E[C].types : {},
        [M]: T || !0
    }
} : {}
  , getValidationModes = C=>({
    isOnSubmit: !C || C === VALIDATION_MODE.onSubmit,
    isOnBlur: C === VALIDATION_MODE.onBlur,
    isOnChange: C === VALIDATION_MODE.onChange,
    isOnAll: C === VALIDATION_MODE.all,
    isOnTouch: C === VALIDATION_MODE.onTouched
})
  , isWatched = (C,S,E)=>!E && (S.watchAll || S.watch.has(C) || [...S.watch].some(M=>C.startsWith(M) && /^\.\w+/.test(C.slice(M.length))));
const iterateFieldsByAction = (C,S,E,M)=>{
    for (const T of E || Object.keys(C)) {
        const $ = get$2(C, T);
        if ($) {
            const {_f: B, ...O} = $;
            if (B) {
                if (B.refs && B.refs[0] && S(B.refs[0], T) && !M)
                    break;
                if (B.ref && S(B.ref, B.name) && !M)
                    break;
                iterateFieldsByAction(O, S)
            } else
                isObject$2(O) && iterateFieldsByAction(O, S)
        }
    }
}
;
var updateFieldArrayRootError = (C,S,E)=>{
    const M = compact(get$2(C, E));
    return set$1(M, "root", S[E]),
    set$1(C, E, M),
    C
}
  , isFileInput = C=>C.type === "file"
  , isFunction$1 = C=>typeof C == "function"
  , isHTMLElement = C=>{
    if (!isWeb)
        return !1;
    const S = C ? C.ownerDocument : 0;
    return C instanceof (S && S.defaultView ? S.defaultView.HTMLElement : HTMLElement)
}
  , isMessage = C=>isString$1(C)
  , isRadioInput = C=>C.type === "radio"
  , isRegex = C=>C instanceof RegExp;
const defaultResult = {
    value: !1,
    isValid: !1
}
  , validResult = {
    value: !0,
    isValid: !0
};
var getCheckboxValue = C=>{
    if (Array.isArray(C)) {
        if (C.length > 1) {
            const S = C.filter(E=>E && E.checked && !E.disabled).map(E=>E.value);
            return {
                value: S,
                isValid: !!S.length
            }
        }
        return C[0].checked && !C[0].disabled ? C[0].attributes && !isUndefined$1(C[0].attributes.value) ? isUndefined$1(C[0].value) || C[0].value === "" ? validResult : {
            value: C[0].value,
            isValid: !0
        } : validResult : defaultResult
    }
    return defaultResult
}
;
const defaultReturn = {
    isValid: !1,
    value: null
};
var getRadioValue = C=>Array.isArray(C) ? C.reduce((S,E)=>E && E.checked && !E.disabled ? {
    isValid: !0,
    value: E.value
} : S, defaultReturn) : defaultReturn;
function getValidateError(C, S, E="validate") {
    if (isMessage(C) || Array.isArray(C) && C.every(isMessage) || isBoolean(C) && !C)
        return {
            type: E,
            message: isMessage(C) ? C : "",
            ref: S
        }
}
var getValueAndMessage = C=>isObject$2(C) && !isRegex(C) ? C : {
    value: C,
    message: ""
}
  , validateField = async(C,S,E,M,T)=>{
    const {ref: $, refs: B, required: O, maxLength: F, minLength: N, min: U, max: H, pattern: Z, validate: J, name: ie, valueAsNumber: oe, mount: ae, disabled: se} = C._f
      , le = get$2(S, ie);
    if (!ae || se)
        return {};
    const de = B ? B[0] : $
      , fe = W=>{
        M && de.reportValidity && (de.setCustomValidity(isBoolean(W) ? "" : W || ""),
        de.reportValidity())
    }
      , pe = {}
      , ge = isRadioInput($)
      , we = isCheckBoxInput($)
      , Ae = ge || we
      , Se = (oe || isFileInput($)) && isUndefined$1($.value) && isUndefined$1(le) || isHTMLElement($) && $.value === "" || le === "" || Array.isArray(le) && !le.length
      , ue = appendErrors.bind(null, ie, E, pe)
      , V = (W,D,I,L=INPUT_VALIDATION_RULES.maxLength,K=INPUT_VALIDATION_RULES.minLength)=>{
        const X = W ? D : I;
        pe[ie] = {
            type: W ? L : K,
            message: X,
            ref: $,
            ...ue(W ? L : K, X)
        }
    }
    ;
    if (T ? !Array.isArray(le) || !le.length : O && (!Ae && (Se || isNullOrUndefined(le)) || isBoolean(le) && !le || we && !getCheckboxValue(B).isValid || ge && !getRadioValue(B).isValid)) {
        const {value: W, message: D} = isMessage(O) ? {
            value: !!O,
            message: O
        } : getValueAndMessage(O);
        if (W && (pe[ie] = {
            type: INPUT_VALIDATION_RULES.required,
            message: D,
            ref: de,
            ...ue(INPUT_VALIDATION_RULES.required, D)
        },
        !E))
            return fe(D),
            pe
    }
    if (!Se && (!isNullOrUndefined(U) || !isNullOrUndefined(H))) {
        let W, D;
        const I = getValueAndMessage(H)
          , L = getValueAndMessage(U);
        if (!isNullOrUndefined(le) && !isNaN(le)) {
            const K = $.valueAsNumber || le && +le;
            isNullOrUndefined(I.value) || (W = K > I.value),
            isNullOrUndefined(L.value) || (D = K < L.value)
        } else {
            const K = $.valueAsDate || new Date(le)
              , X = G=>new Date(new Date().toDateString() + " " + G)
              , Y = $.type == "time"
              , j = $.type == "week";
            isString$1(I.value) && le && (W = Y ? X(le) > X(I.value) : j ? le > I.value : K > new Date(I.value)),
            isString$1(L.value) && le && (D = Y ? X(le) < X(L.value) : j ? le < L.value : K < new Date(L.value))
        }
        if ((W || D) && (V(!!W, I.message, L.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min),
        !E))
            return fe(pe[ie].message),
            pe
    }
    if ((F || N) && !Se && (isString$1(le) || T && Array.isArray(le))) {
        const W = getValueAndMessage(F)
          , D = getValueAndMessage(N)
          , I = !isNullOrUndefined(W.value) && le.length > +W.value
          , L = !isNullOrUndefined(D.value) && le.length < +D.value;
        if ((I || L) && (V(I, W.message, D.message),
        !E))
            return fe(pe[ie].message),
            pe
    }
    if (Z && !Se && isString$1(le)) {
        const {value: W, message: D} = getValueAndMessage(Z);
        if (isRegex(W) && !le.match(W) && (pe[ie] = {
            type: INPUT_VALIDATION_RULES.pattern,
            message: D,
            ref: $,
            ...ue(INPUT_VALIDATION_RULES.pattern, D)
        },
        !E))
            return fe(D),
            pe
    }
    if (J) {
        if (isFunction$1(J)) {
            const W = await J(le, S)
              , D = getValidateError(W, de);
            if (D && (pe[ie] = {
                ...D,
                ...ue(INPUT_VALIDATION_RULES.validate, D.message)
            },
            !E))
                return fe(D.message),
                pe
        } else if (isObject$2(J)) {
            let W = {};
            for (const D in J) {
                if (!isEmptyObject(W) && !E)
                    break;
                const I = getValidateError(await J[D](le, S), de, D);
                I && (W = {
                    ...I,
                    ...ue(D, I.message)
                },
                fe(I.message),
                E && (pe[ie] = W))
            }
            if (!isEmptyObject(W) && (pe[ie] = {
                ref: de,
                ...W
            },
            !E))
                return pe
        }
    }
    return fe(!0),
    pe
}
;
function baseGet(C, S) {
    const E = S.slice(0, -1).length;
    let M = 0;
    for (; M < E; )
        C = isUndefined$1(C) ? M++ : C[S[M++]];
    return C
}
function isEmptyArray(C) {
    for (const S in C)
        if (C.hasOwnProperty(S) && !isUndefined$1(C[S]))
            return !1;
    return !0
}
function unset(C, S) {
    const E = Array.isArray(S) ? S : isKey(S) ? [S] : stringToPath(S)
      , M = E.length === 1 ? C : baseGet(C, E)
      , T = E.length - 1
      , $ = E[T];
    return M && delete M[$],
    T !== 0 && (isObject$2(M) && isEmptyObject(M) || Array.isArray(M) && isEmptyArray(M)) && unset(C, E.slice(0, -1)),
    C
}
var createSubject = ()=>{
    let C = [];
    return {
        get observers() {
            return C
        },
        next: T=>{
            for (const $ of C)
                $.next && $.next(T)
        }
        ,
        subscribe: T=>(C.push(T),
        {
            unsubscribe: ()=>{
                C = C.filter($=>$ !== T)
            }
        }),
        unsubscribe: ()=>{
            C = []
        }
    }
}
  , isPrimitive = C=>isNullOrUndefined(C) || !isObjectType(C);
function deepEqual(C, S) {
    if (isPrimitive(C) || isPrimitive(S))
        return C === S;
    if (isDateObject(C) && isDateObject(S))
        return C.getTime() === S.getTime();
    const E = Object.keys(C)
      , M = Object.keys(S);
    if (E.length !== M.length)
        return !1;
    for (const T of E) {
        const $ = C[T];
        if (!M.includes(T))
            return !1;
        if (T !== "ref") {
            const B = S[T];
            if (isDateObject($) && isDateObject(B) || isObject$2($) && isObject$2(B) || Array.isArray($) && Array.isArray(B) ? !deepEqual($, B) : $ !== B)
                return !1
        }
    }
    return !0
}
var isMultipleSelect = C=>C.type === "select-multiple"
  , isRadioOrCheckbox = C=>isRadioInput(C) || isCheckBoxInput(C)
  , live = C=>isHTMLElement(C) && C.isConnected
  , objectHasFunction = C=>{
    for (const S in C)
        if (isFunction$1(C[S]))
            return !0;
    return !1
}
;
function markFieldsDirty(C, S={}) {
    const E = Array.isArray(C);
    if (isObject$2(C) || E)
        for (const M in C)
            Array.isArray(C[M]) || isObject$2(C[M]) && !objectHasFunction(C[M]) ? (S[M] = Array.isArray(C[M]) ? [] : {},
            markFieldsDirty(C[M], S[M])) : isNullOrUndefined(C[M]) || (S[M] = !0);
    return S
}
function getDirtyFieldsFromDefaultValues(C, S, E) {
    const M = Array.isArray(C);
    if (isObject$2(C) || M)
        for (const T in C)
            Array.isArray(C[T]) || isObject$2(C[T]) && !objectHasFunction(C[T]) ? isUndefined$1(S) || isPrimitive(E[T]) ? E[T] = Array.isArray(C[T]) ? markFieldsDirty(C[T], []) : {
                ...markFieldsDirty(C[T])
            } : getDirtyFieldsFromDefaultValues(C[T], isNullOrUndefined(S) ? {} : S[T], E[T]) : E[T] = !deepEqual(C[T], S[T]);
    return E
}
var getDirtyFields = (C,S)=>getDirtyFieldsFromDefaultValues(C, S, markFieldsDirty(S))
  , getFieldValueAs = (C,{valueAsNumber: S, valueAsDate: E, setValueAs: M})=>isUndefined$1(C) ? C : S ? C === "" ? NaN : C && +C : E && isString$1(C) ? new Date(C) : M ? M(C) : C;
function getFieldValue(C) {
    const S = C.ref;
    if (!(C.refs ? C.refs.every(E=>E.disabled) : S.disabled))
        return isFileInput(S) ? S.files : isRadioInput(S) ? getRadioValue(C.refs).value : isMultipleSelect(S) ? [...S.selectedOptions].map(({value: E})=>E) : isCheckBoxInput(S) ? getCheckboxValue(C.refs).value : getFieldValueAs(isUndefined$1(S.value) ? C.ref.value : S.value, C)
}
var getResolverOptions = (C,S,E,M)=>{
    const T = {};
    for (const $ of C) {
        const B = get$2(S, $);
        B && set$1(T, $, B._f)
    }
    return {
        criteriaMode: E,
        names: [...C],
        fields: T,
        shouldUseNativeValidation: M
    }
}
  , getRuleValue = C=>isUndefined$1(C) ? C : isRegex(C) ? C.source : isObject$2(C) ? isRegex(C.value) ? C.value.source : C.value : C
  , hasValidation = C=>C.mount && (C.required || C.min || C.max || C.maxLength || C.minLength || C.pattern || C.validate);
function schemaErrorLookup(C, S, E) {
    const M = get$2(C, E);
    if (M || isKey(E))
        return {
            error: M,
            name: E
        };
    const T = E.split(".");
    for (; T.length; ) {
        const $ = T.join(".")
          , B = get$2(S, $)
          , O = get$2(C, $);
        if (B && !Array.isArray(B) && E !== $)
            return {
                name: E
            };
        if (O && O.type)
            return {
                name: $,
                error: O
            };
        T.pop()
    }
    return {
        name: E
    }
}
var skipValidation = (C,S,E,M,T)=>T.isOnAll ? !1 : !E && T.isOnTouch ? !(S || C) : (E ? M.isOnBlur : T.isOnBlur) ? !C : (E ? M.isOnChange : T.isOnChange) ? C : !0
  , unsetEmptyArray = (C,S)=>!compact(get$2(C, S)).length && unset(C, S);
const defaultOptions = {
    mode: VALIDATION_MODE.onSubmit,
    reValidateMode: VALIDATION_MODE.onChange,
    shouldFocusError: !0
};
function createFormControl(C={}) {
    let S = {
        ...defaultOptions,
        ...C
    }, E = {
        submitCount: 0,
        isDirty: !1,
        isLoading: isFunction$1(S.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: S.errors || {},
        disabled: S.disabled || !1
    }, M = {}, T = isObject$2(S.defaultValues) || isObject$2(S.values) ? cloneObject(S.defaultValues || S.values) || {} : {}, $ = S.shouldUnregister ? {} : cloneObject(T), B = {
        action: !1,
        mount: !1,
        watch: !1
    }, O = {
        mount: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, F, N = 0;
    const U = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    }
      , H = {
        values: createSubject(),
        array: createSubject(),
        state: createSubject()
    }
      , Z = getValidationModes(S.mode)
      , J = getValidationModes(S.reValidateMode)
      , ie = S.criteriaMode === VALIDATION_MODE.all
      , oe = De=>Ue=>{
        clearTimeout(N),
        N = setTimeout(De, Ue)
    }
      , ae = async De=>{
        if (U.isValid || De) {
            const Ue = S.resolver ? isEmptyObject((await Ae()).errors) : await ue(M, !0);
            Ue !== E.isValid && H.state.next({
                isValid: Ue
            })
        }
    }
      , se = (De,Ue)=>{
        (U.isValidating || U.validatingFields) && ((De || Array.from(O.mount)).forEach(We=>{
            We && (Ue ? set$1(E.validatingFields, We, Ue) : unset(E.validatingFields, We))
        }
        ),
        H.state.next({
            validatingFields: E.validatingFields,
            isValidating: !isEmptyObject(E.validatingFields)
        }))
    }
      , le = (De,Ue=[],We,Xe,ht=!0,Je=!0)=>{
        if (Xe && We) {
            if (B.action = !0,
            Je && Array.isArray(get$2(M, De))) {
                const ot = We(get$2(M, De), Xe.argA, Xe.argB);
                ht && set$1(M, De, ot)
            }
            if (Je && Array.isArray(get$2(E.errors, De))) {
                const ot = We(get$2(E.errors, De), Xe.argA, Xe.argB);
                ht && set$1(E.errors, De, ot),
                unsetEmptyArray(E.errors, De)
            }
            if (U.touchedFields && Je && Array.isArray(get$2(E.touchedFields, De))) {
                const ot = We(get$2(E.touchedFields, De), Xe.argA, Xe.argB);
                ht && set$1(E.touchedFields, De, ot)
            }
            U.dirtyFields && (E.dirtyFields = getDirtyFields(T, $)),
            H.state.next({
                name: De,
                isDirty: W(De, Ue),
                dirtyFields: E.dirtyFields,
                errors: E.errors,
                isValid: E.isValid
            })
        } else
            set$1($, De, Ue)
    }
      , de = (De,Ue)=>{
        set$1(E.errors, De, Ue),
        H.state.next({
            errors: E.errors
        })
    }
      , fe = De=>{
        E.errors = De,
        H.state.next({
            errors: E.errors,
            isValid: !1
        })
    }
      , pe = (De,Ue,We,Xe)=>{
        const ht = get$2(M, De);
        if (ht) {
            const Je = get$2($, De, isUndefined$1(We) ? get$2(T, De) : We);
            isUndefined$1(Je) || Xe && Xe.defaultChecked || Ue ? set$1($, De, Ue ? Je : getFieldValue(ht._f)) : L(De, Je),
            B.mount && ae()
        }
    }
      , ge = (De,Ue,We,Xe,ht)=>{
        let Je = !1
          , ot = !1;
        const je = {
            name: De
        }
          , $e = !!(get$2(M, De) && get$2(M, De)._f.disabled);
        if (!We || Xe) {
            U.isDirty && (ot = E.isDirty,
            E.isDirty = je.isDirty = W(),
            Je = ot !== je.isDirty);
            const Ie = $e || deepEqual(get$2(T, De), Ue);
            ot = !!(!$e && get$2(E.dirtyFields, De)),
            Ie || $e ? unset(E.dirtyFields, De) : set$1(E.dirtyFields, De, !0),
            je.dirtyFields = E.dirtyFields,
            Je = Je || U.dirtyFields && ot !== !Ie
        }
        if (We) {
            const Ie = get$2(E.touchedFields, De);
            Ie || (set$1(E.touchedFields, De, We),
            je.touchedFields = E.touchedFields,
            Je = Je || U.touchedFields && Ie !== We)
        }
        return Je && ht && H.state.next(je),
        Je ? je : {}
    }
      , we = (De,Ue,We,Xe)=>{
        const ht = get$2(E.errors, De)
          , Je = U.isValid && isBoolean(Ue) && E.isValid !== Ue;
        if (C.delayError && We ? (F = oe(()=>de(De, We)),
        F(C.delayError)) : (clearTimeout(N),
        F = null,
        We ? set$1(E.errors, De, We) : unset(E.errors, De)),
        (We ? !deepEqual(ht, We) : ht) || !isEmptyObject(Xe) || Je) {
            const ot = {
                ...Xe,
                ...Je && isBoolean(Ue) ? {
                    isValid: Ue
                } : {},
                errors: E.errors,
                name: De
            };
            E = {
                ...E,
                ...ot
            },
            H.state.next(ot)
        }
    }
      , Ae = async De=>{
        se(De, !0);
        const Ue = await S.resolver($, S.context, getResolverOptions(De || O.mount, M, S.criteriaMode, S.shouldUseNativeValidation));
        return se(De),
        Ue
    }
      , Se = async De=>{
        const {errors: Ue} = await Ae(De);
        if (De)
            for (const We of De) {
                const Xe = get$2(Ue, We);
                Xe ? set$1(E.errors, We, Xe) : unset(E.errors, We)
            }
        else
            E.errors = Ue;
        return Ue
    }
      , ue = async(De,Ue,We={
        valid: !0
    })=>{
        for (const Xe in De) {
            const ht = De[Xe];
            if (ht) {
                const {_f: Je, ...ot} = ht;
                if (Je) {
                    const je = O.array.has(Je.name);
                    se([Xe], !0);
                    const $e = await validateField(ht, $, ie, S.shouldUseNativeValidation && !Ue, je);
                    if (se([Xe]),
                    $e[Je.name] && (We.valid = !1,
                    Ue))
                        break;
                    !Ue && (get$2($e, Je.name) ? je ? updateFieldArrayRootError(E.errors, $e, Je.name) : set$1(E.errors, Je.name, $e[Je.name]) : unset(E.errors, Je.name))
                }
                ot && await ue(ot, Ue, We)
            }
        }
        return We.valid
    }
      , V = ()=>{
        for (const De of O.unMount) {
            const Ue = get$2(M, De);
            Ue && (Ue._f.refs ? Ue._f.refs.every(We=>!live(We)) : !live(Ue._f.ref)) && Te(De)
        }
        O.unMount = new Set
    }
      , W = (De,Ue)=>(De && Ue && set$1($, De, Ue),
    !deepEqual(ne(), T))
      , D = (De,Ue,We)=>generateWatchOutput(De, O, {
        ...B.mount ? $ : isUndefined$1(Ue) ? T : isString$1(De) ? {
            [De]: Ue
        } : Ue
    }, We, Ue)
      , I = De=>compact(get$2(B.mount ? $ : T, De, C.shouldUnregister ? get$2(T, De, []) : []))
      , L = (De,Ue,We={})=>{
        const Xe = get$2(M, De);
        let ht = Ue;
        if (Xe) {
            const Je = Xe._f;
            Je && (!Je.disabled && set$1($, De, getFieldValueAs(Ue, Je)),
            ht = isHTMLElement(Je.ref) && isNullOrUndefined(Ue) ? "" : Ue,
            isMultipleSelect(Je.ref) ? [...Je.ref.options].forEach(ot=>ot.selected = ht.includes(ot.value)) : Je.refs ? isCheckBoxInput(Je.ref) ? Je.refs.length > 1 ? Je.refs.forEach(ot=>(!ot.defaultChecked || !ot.disabled) && (ot.checked = Array.isArray(ht) ? !!ht.find(je=>je === ot.value) : ht === ot.value)) : Je.refs[0] && (Je.refs[0].checked = !!ht) : Je.refs.forEach(ot=>ot.checked = ot.value === ht) : isFileInput(Je.ref) ? Je.ref.value = "" : (Je.ref.value = ht,
            Je.ref.type || H.values.next({
                name: De,
                values: {
                    ...$
                }
            })))
        }
        (We.shouldDirty || We.shouldTouch) && ge(De, ht, We.shouldTouch, We.shouldDirty, !0),
        We.shouldValidate && G(De)
    }
      , K = (De,Ue,We)=>{
        for (const Xe in Ue) {
            const ht = Ue[Xe]
              , Je = `${De}.${Xe}`
              , ot = get$2(M, Je);
            (O.array.has(De) || !isPrimitive(ht) || ot && !ot._f) && !isDateObject(ht) ? K(Je, ht, We) : L(Je, ht, We)
        }
    }
      , X = (De,Ue,We={})=>{
        const Xe = get$2(M, De)
          , ht = O.array.has(De)
          , Je = cloneObject(Ue);
        set$1($, De, Je),
        ht ? (H.array.next({
            name: De,
            values: {
                ...$
            }
        }),
        (U.isDirty || U.dirtyFields) && We.shouldDirty && H.state.next({
            name: De,
            dirtyFields: getDirtyFields(T, $),
            isDirty: W(De, Je)
        })) : Xe && !Xe._f && !isNullOrUndefined(Je) ? K(De, Je, We) : L(De, Je, We),
        isWatched(De, O) && H.state.next({
            ...E
        }),
        H.values.next({
            name: B.mount ? De : void 0,
            values: {
                ...$
            }
        })
    }
      , Y = async De=>{
        const Ue = De.target;
        let We = Ue.name
          , Xe = !0;
        const ht = get$2(M, We)
          , Je = ()=>Ue.type ? getFieldValue(ht._f) : getEventValue(De)
          , ot = je=>{
            Xe = Number.isNaN(je) || je === get$2($, We, je)
        }
        ;
        if (ht) {
            let je, $e;
            const Ie = Je()
              , He = De.type === EVENTS.BLUR || De.type === EVENTS.FOCUS_OUT
              , qe = !hasValidation(ht._f) && !S.resolver && !get$2(E.errors, We) && !ht._f.deps || skipValidation(He, get$2(E.touchedFields, We), E.isSubmitted, J, Z)
              , Ne = isWatched(We, O, He);
            set$1($, We, Ie),
            He ? (ht._f.onBlur && ht._f.onBlur(De),
            F && F(0)) : ht._f.onChange && ht._f.onChange(De);
            const at = ge(We, Ie, He, !1)
              , Ye = !isEmptyObject(at) || Ne;
            if (!He && H.values.next({
                name: We,
                type: De.type,
                values: {
                    ...$
                }
            }),
            qe)
                return U.isValid && ae(),
                Ye && H.state.next({
                    name: We,
                    ...Ne ? {} : at
                });
            if (!He && Ne && H.state.next({
                ...E
            }),
            S.resolver) {
                const {errors: it} = await Ae([We]);
                if (ot(Ie),
                Xe) {
                    const At = schemaErrorLookup(E.errors, M, We)
                      , pt = schemaErrorLookup(it, M, At.name || We);
                    je = pt.error,
                    We = pt.name,
                    $e = isEmptyObject(it)
                }
            } else
                se([We], !0),
                je = (await validateField(ht, $, ie, S.shouldUseNativeValidation))[We],
                se([We]),
                ot(Ie),
                Xe && (je ? $e = !1 : U.isValid && ($e = await ue(M, !0)));
            Xe && (ht._f.deps && G(ht._f.deps),
            we(We, $e, je, at))
        }
    }
      , j = (De,Ue)=>{
        if (get$2(E.errors, Ue) && De.focus)
            return De.focus(),
            1
    }
      , G = async(De,Ue={})=>{
        let We, Xe;
        const ht = convertToArrayPayload(De);
        if (S.resolver) {
            const Je = await Se(isUndefined$1(De) ? De : ht);
            We = isEmptyObject(Je),
            Xe = De ? !ht.some(ot=>get$2(Je, ot)) : We
        } else
            De ? (Xe = (await Promise.all(ht.map(async Je=>{
                const ot = get$2(M, Je);
                return await ue(ot && ot._f ? {
                    [Je]: ot
                } : ot)
            }
            ))).every(Boolean),
            !(!Xe && !E.isValid) && ae()) : Xe = We = await ue(M);
        return H.state.next({
            ...!isString$1(De) || U.isValid && We !== E.isValid ? {} : {
                name: De
            },
            ...S.resolver || !De ? {
                isValid: We
            } : {},
            errors: E.errors
        }),
        Ue.shouldFocus && !Xe && iterateFieldsByAction(M, j, De ? ht : O.mount),
        Xe
    }
      , ne = De=>{
        const Ue = {
            ...T,
            ...B.mount ? $ : {}
        };
        return isUndefined$1(De) ? Ue : isString$1(De) ? get$2(Ue, De) : De.map(We=>get$2(Ue, We))
    }
      , te = (De,Ue)=>({
        invalid: !!get$2((Ue || E).errors, De),
        isDirty: !!get$2((Ue || E).dirtyFields, De),
        isTouched: !!get$2((Ue || E).touchedFields, De),
        isValidating: !!get$2((Ue || E).validatingFields, De),
        error: get$2((Ue || E).errors, De)
    })
      , ce = De=>{
        De && convertToArrayPayload(De).forEach(Ue=>unset(E.errors, Ue)),
        H.state.next({
            errors: De ? E.errors : {}
        })
    }
      , Ee = (De,Ue,We)=>{
        const Xe = (get$2(M, De, {
            _f: {}
        })._f || {}).ref;
        set$1(E.errors, De, {
            ...Ue,
            ref: Xe
        }),
        H.state.next({
            name: De,
            errors: E.errors,
            isValid: !1
        }),
        We && We.shouldFocus && Xe && Xe.focus && Xe.focus()
    }
      , Re = (De,Ue)=>isFunction$1(De) ? H.values.subscribe({
        next: We=>De(D(void 0, Ue), We)
    }) : D(De, Ue, !0)
      , Te = (De,Ue={})=>{
        for (const We of De ? convertToArrayPayload(De) : O.mount)
            O.mount.delete(We),
            O.array.delete(We),
            Ue.keepValue || (unset(M, We),
            unset($, We)),
            !Ue.keepError && unset(E.errors, We),
            !Ue.keepDirty && unset(E.dirtyFields, We),
            !Ue.keepTouched && unset(E.touchedFields, We),
            !Ue.keepIsValidating && unset(E.validatingFields, We),
            !S.shouldUnregister && !Ue.keepDefaultValue && unset(T, We);
        H.values.next({
            values: {
                ...$
            }
        }),
        H.state.next({
            ...E,
            ...Ue.keepDirty ? {
                isDirty: W()
            } : {}
        }),
        !Ue.keepIsValid && ae()
    }
      , xe = ({disabled: De, name: Ue, field: We, fields: Xe, value: ht})=>{
        if (isBoolean(De)) {
            const Je = De ? void 0 : isUndefined$1(ht) ? getFieldValue(We ? We._f : get$2(Xe, Ue)._f) : ht;
            set$1($, Ue, Je),
            ge(Ue, Je, !1, !1, !0)
        }
    }
      , ve = (De,Ue={})=>{
        let We = get$2(M, De);
        const Xe = isBoolean(Ue.disabled);
        return set$1(M, De, {
            ...We || {},
            _f: {
                ...We && We._f ? We._f : {
                    ref: {
                        name: De
                    }
                },
                name: De,
                mount: !0,
                ...Ue
            }
        }),
        O.mount.add(De),
        We ? xe({
            field: We,
            disabled: Ue.disabled,
            name: De,
            value: Ue.value
        }) : pe(De, !0, Ue.value),
        {
            ...Xe ? {
                disabled: Ue.disabled
            } : {},
            ...S.progressive ? {
                required: !!Ue.required,
                min: getRuleValue(Ue.min),
                max: getRuleValue(Ue.max),
                minLength: getRuleValue(Ue.minLength),
                maxLength: getRuleValue(Ue.maxLength),
                pattern: getRuleValue(Ue.pattern)
            } : {},
            name: De,
            onChange: Y,
            onBlur: Y,
            ref: ht=>{
                if (ht) {
                    ve(De, Ue),
                    We = get$2(M, De);
                    const Je = isUndefined$1(ht.value) && ht.querySelectorAll && ht.querySelectorAll("input,select,textarea")[0] || ht
                      , ot = isRadioOrCheckbox(Je)
                      , je = We._f.refs || [];
                    if (ot ? je.find($e=>$e === Je) : Je === We._f.ref)
                        return;
                    set$1(M, De, {
                        _f: {
                            ...We._f,
                            ...ot ? {
                                refs: [...je.filter(live), Je, ...Array.isArray(get$2(T, De)) ? [{}] : []],
                                ref: {
                                    type: Je.type,
                                    name: De
                                }
                            } : {
                                ref: Je
                            }
                        }
                    }),
                    pe(De, !1, void 0, Je)
                } else
                    We = get$2(M, De, {}),
                    We._f && (We._f.mount = !1),
                    (S.shouldUnregister || Ue.shouldUnregister) && !(isNameInFieldArray(O.array, De) && B.action) && O.unMount.add(De)
            }
        }
    }
      , Me = ()=>S.shouldFocusError && iterateFieldsByAction(M, j, O.mount)
      , Fe = De=>{
        isBoolean(De) && (H.state.next({
            disabled: De
        }),
        iterateFieldsByAction(M, (Ue,We)=>{
            let Xe = De;
            const ht = get$2(M, We);
            ht && isBoolean(ht._f.disabled) && (Xe || (Xe = ht._f.disabled)),
            Ue.disabled = Xe
        }
        , 0, !1))
    }
      , be = (De,Ue)=>async We=>{
        let Xe;
        We && (We.preventDefault && We.preventDefault(),
        We.persist && We.persist());
        let ht = cloneObject($);
        if (H.state.next({
            isSubmitting: !0
        }),
        S.resolver) {
            const {errors: Je, values: ot} = await Ae();
            E.errors = Je,
            ht = ot
        } else
            await ue(M);
        if (unset(E.errors, "root"),
        isEmptyObject(E.errors)) {
            H.state.next({
                errors: {}
            });
            try {
                await De(ht, We)
            } catch (Je) {
                Xe = Je
            }
        } else
            Ue && await Ue({
                ...E.errors
            }, We),
            Me(),
            setTimeout(Me);
        if (H.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: isEmptyObject(E.errors) && !Xe,
            submitCount: E.submitCount + 1,
            errors: E.errors
        }),
        Xe)
            throw Xe
    }
      , Ce = (De,Ue={})=>{
        get$2(M, De) && (isUndefined$1(Ue.defaultValue) ? X(De, cloneObject(get$2(T, De))) : (X(De, Ue.defaultValue),
        set$1(T, De, cloneObject(Ue.defaultValue))),
        Ue.keepTouched || unset(E.touchedFields, De),
        Ue.keepDirty || (unset(E.dirtyFields, De),
        E.isDirty = Ue.defaultValue ? W(De, cloneObject(get$2(T, De))) : W()),
        Ue.keepError || (unset(E.errors, De),
        U.isValid && ae()),
        H.state.next({
            ...E
        }))
    }
      , ze = (De,Ue={})=>{
        const We = De ? cloneObject(De) : T
          , Xe = cloneObject(We)
          , ht = isEmptyObject(De)
          , Je = ht ? T : Xe;
        if (Ue.keepDefaultValues || (T = We),
        !Ue.keepValues) {
            if (Ue.keepDirtyValues)
                for (const ot of O.mount)
                    get$2(E.dirtyFields, ot) ? set$1(Je, ot, get$2($, ot)) : X(ot, get$2(Je, ot));
            else {
                if (isWeb && isUndefined$1(De))
                    for (const ot of O.mount) {
                        const je = get$2(M, ot);
                        if (je && je._f) {
                            const $e = Array.isArray(je._f.refs) ? je._f.refs[0] : je._f.ref;
                            if (isHTMLElement($e)) {
                                const Ie = $e.closest("form");
                                if (Ie) {
                                    Ie.reset();
                                    break
                                }
                            }
                        }
                    }
                M = {}
            }
            $ = C.shouldUnregister ? Ue.keepDefaultValues ? cloneObject(T) : {} : cloneObject(Je),
            H.array.next({
                values: {
                    ...Je
                }
            }),
            H.values.next({
                values: {
                    ...Je
                }
            })
        }
        O = {
            mount: Ue.keepDirtyValues ? O.mount : new Set,
            unMount: new Set,
            array: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        B.mount = !U.isValid || !!Ue.keepIsValid || !!Ue.keepDirtyValues,
        B.watch = !!C.shouldUnregister,
        H.state.next({
            submitCount: Ue.keepSubmitCount ? E.submitCount : 0,
            isDirty: ht ? !1 : Ue.keepDirty ? E.isDirty : !!(Ue.keepDefaultValues && !deepEqual(De, T)),
            isSubmitted: Ue.keepIsSubmitted ? E.isSubmitted : !1,
            dirtyFields: ht ? [] : Ue.keepDirtyValues ? Ue.keepDefaultValues && $ ? getDirtyFields(T, $) : E.dirtyFields : Ue.keepDefaultValues && De ? getDirtyFields(T, De) : {},
            touchedFields: Ue.keepTouched ? E.touchedFields : {},
            errors: Ue.keepErrors ? E.errors : {},
            isSubmitSuccessful: Ue.keepIsSubmitSuccessful ? E.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , Ge = (De,Ue)=>ze(isFunction$1(De) ? De($) : De, Ue);
    return {
        control: {
            register: ve,
            unregister: Te,
            getFieldState: te,
            handleSubmit: be,
            setError: Ee,
            _executeSchema: Ae,
            _getWatch: D,
            _getDirty: W,
            _updateValid: ae,
            _removeUnmounted: V,
            _updateFieldArray: le,
            _updateDisabledField: xe,
            _getFieldArray: I,
            _reset: ze,
            _resetDefaultValues: ()=>isFunction$1(S.defaultValues) && S.defaultValues().then(De=>{
                Ge(De, S.resetOptions),
                H.state.next({
                    isLoading: !1
                })
            }
            ),
            _updateFormState: De=>{
                E = {
                    ...E,
                    ...De
                }
            }
            ,
            _disableForm: Fe,
            _subjects: H,
            _proxyFormState: U,
            _setErrors: fe,
            get _fields() {
                return M
            },
            get _formValues() {
                return $
            },
            get _state() {
                return B
            },
            set _state(De) {
                B = De
            },
            get _defaultValues() {
                return T
            },
            get _names() {
                return O
            },
            set _names(De) {
                O = De
            },
            get _formState() {
                return E
            },
            set _formState(De) {
                E = De
            },
            get _options() {
                return S
            },
            set _options(De) {
                S = {
                    ...S,
                    ...De
                }
            }
        },
        trigger: G,
        register: ve,
        handleSubmit: be,
        watch: Re,
        setValue: X,
        getValues: ne,
        reset: Ge,
        resetField: Ce,
        clearErrors: ce,
        unregister: Te,
        setError: Ee,
        setFocus: (De,Ue={})=>{
            const We = get$2(M, De)
              , Xe = We && We._f;
            if (Xe) {
                const ht = Xe.refs ? Xe.refs[0] : Xe.ref;
                ht.focus && (ht.focus(),
                Ue.shouldSelect && ht.select())
            }
        }
        ,
        getFieldState: te
    }
}
function useForm(C={}) {
    const S = React$1.useRef()
      , E = React$1.useRef()
      , [M,T] = React$1.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: isFunction$1(C.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: C.errors || {},
        disabled: C.disabled || !1,
        defaultValues: isFunction$1(C.defaultValues) ? void 0 : C.defaultValues
    });
    S.current || (S.current = {
        ...createFormControl(C),
        formState: M
    });
    const $ = S.current.control;
    return $._options = C,
    useSubscribe({
        subject: $._subjects.state,
        next: B=>{
            shouldRenderFormState(B, $._proxyFormState, $._updateFormState, !0) && T({
                ...$._formState
            })
        }
    }),
    React$1.useEffect(()=>$._disableForm(C.disabled), [$, C.disabled]),
    React$1.useEffect(()=>{
        if ($._proxyFormState.isDirty) {
            const B = $._getDirty();
            B !== M.isDirty && $._subjects.state.next({
                isDirty: B
            })
        }
    }
    , [$, M.isDirty]),
    React$1.useEffect(()=>{
        C.values && !deepEqual(C.values, E.current) ? ($._reset(C.values, $._options.resetOptions),
        E.current = C.values,
        T(B=>({
            ...B
        }))) : $._resetDefaultValues()
    }
    , [C.values, $]),
    React$1.useEffect(()=>{
        C.errors && $._setErrors(C.errors)
    }
    , [C.errors, $]),
    React$1.useEffect(()=>{
        $._state.mount || ($._updateValid(),
        $._state.mount = !0),
        $._state.watch && ($._state.watch = !1,
        $._subjects.state.next({
            ...$._formState
        })),
        $._removeUnmounted()
    }
    ),
    React$1.useEffect(()=>{
        C.shouldUnregister && $._subjects.values.next({
            values: $._getWatch()
        })
    }
    , [C.shouldUnregister, $]),
    S.current.formState = getProxyFormState(M, $),
    S.current
}
function replaceCommasAndKeepFirstDot(C) {
    const S = C.replace(/,/g, ".")
      , E = S.indexOf(".");
    if (E === -1)
        return S;
    const M = S.substring(0, E + 1)
      , $ = S.substring(E + 1).replace(/\./g, "");
    return M + $
}
const filterData = ({value: C, pattern: S, isUpperCase: E, isOnlyNumbers: M, notGreat: T, toFixed: $, isNotNegative: B, isOnlyEnglish: O, notGreatSymbol: F, isNatural: N, notMin: U})=>{
    let H = C;
    if (E && (H = H.toUpperCase()),
    M) {
        const Z = /^-?(\d+([.,]\d*)?|[.,]\d*|[.,]?)$/;
        if (H = H.split("").filter(J=>(Z == null ? void 0 : Z.test(J)) || J === " ").join(""),
        H = replaceCommasAndKeepFirstDot(H),
        N && (H = Math.ceil(isNaN(parseFloat(H)) ? 0 : parseFloat(H)).toString()),
        B && (H = H.replace("-", "")),
        T !== void 0 && parseFloat(C) > parseFloat(T) && (H = T),
        U !== void 0 && parseFloat(C) < parseFloat(U) && (H = U),
        $ !== void 0 && H.split(".").length > 1) {
            const J = H.split(".");
            J[1] && $ !== 0 ? H = [J[0], J[1].slice(0, $)].join(".") : H = J[0]
        }
    }
    if (O) {
        const Z = /[a-zA-Z0-9!@#$%^&*()_+{}[\]:;<>,.?~\\/-]/;
        H = H.split("").filter(J=>(Z == null ? void 0 : Z.test(J)) || J === " ").join("")
    }
    return S && (H = H.split("").filter(Z=>S == null ? void 0 : S.test(Z)).join("")),
    F && (H = H.slice(0, F)),
    H
}
  , input = "_input_1jk6x_1"
  , errorText = "_errorText_1jk6x_12"
  , _error = "__error_1jk6x_17"
  , bgNumbers = "_bgNumbers_1jk6x_21"
  , numbers = "_numbers_1jk6x_35"
  , imgResultContainer = "_imgResultContainer_1jk6x_64"
  , classes$5 = {
    input,
    errorText,
    _error,
    bgNumbers,
    numbers,
    imgResultContainer
}
  , Input = observer(({controlledInputProps: C, className: S, errorMessage: E, isError: M, ...T})=>(reactExports.useEffect(()=>{
    var B;
    const $ = (B = C.control) == null ? void 0 : B._defaultValues[C.name];
    $ !== void 0 && C.setValue(C.name, $)
}
, [C.control._defaultValues[C.name]]),
jsxRuntimeExports.jsx(Controller, {
    control: C == null ? void 0 : C.control,
    name: C == null ? void 0 : C.name,
    rules: C == null ? void 0 : C.rules,
    render: ({field: $})=>jsxRuntimeExports.jsx("input", {
        ...T,
        ...$,
        className: clsx(classes$5.input, {
            [classes$5._error]: M
        }),
        onChange: B=>{
            const O = filterData({
                value: B.target.value,
                ...C.validateParams
            });
            $.onChange({
                ...B,
                target: {
                    ...B.target,
                    value: O
                }
            })
        }
    })
})));
function useTheme$1() {
    const C = useTheme$2(defaultTheme$2);
    return C[THEME_ID] || C
}
const getOverlayAlpha = C=>{
    let S;
    return C < 1 ? S = 5.11916 * C ** 2 : S = 4.5 * Math.log(C + 1) + 2,
    (S / 100).toFixed(2)
}
;
function getSvgIconUtilityClass(C) {
    return generateUtilityClass("MuiSvgIcon", C)
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$l = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"]
  , useUtilityClasses$a = C=>{
    const {color: S, fontSize: E, classes: M} = C
      , T = {
        root: ["root", S !== "inherit" && `color${capitalize$1(S)}`, `fontSize${capitalize$1(E)}`]
    };
    return composeClasses(T, getSvgIconUtilityClass, M)
}
  , SvgIconRoot = styled("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, E.color !== "inherit" && S[`color${capitalize$1(E.color)}`], S[`fontSize${capitalize$1(E.fontSize)}`]]
    }
})(({theme: C, ownerState: S})=>{
    var E, M, T, $, B, O, F, N, U, H, Z, J, ie;
    return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        fill: S.hasSvgAsChild ? void 0 : "currentColor",
        flexShrink: 0,
        transition: (E = C.transitions) == null || (M = E.create) == null ? void 0 : M.call(E, "fill", {
            duration: (T = C.transitions) == null || (T = T.duration) == null ? void 0 : T.shorter
        }),
        fontSize: {
            inherit: "inherit",
            small: (($ = C.typography) == null || (B = $.pxToRem) == null ? void 0 : B.call($, 20)) || "1.25rem",
            medium: ((O = C.typography) == null || (F = O.pxToRem) == null ? void 0 : F.call(O, 24)) || "1.5rem",
            large: ((N = C.typography) == null || (U = N.pxToRem) == null ? void 0 : U.call(N, 35)) || "2.1875rem"
        }[S.fontSize],
        color: (H = (Z = (C.vars || C).palette) == null || (Z = Z[S.color]) == null ? void 0 : Z.main) != null ? H : {
            action: (J = (C.vars || C).palette) == null || (J = J.action) == null ? void 0 : J.active,
            disabled: (ie = (C.vars || C).palette) == null || (ie = ie.action) == null ? void 0 : ie.disabled,
            inherit: void 0
        }[S.color]
    }
}
)
  , SvgIcon = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiSvgIcon"
    })
      , {children: T, className: $, color: B="inherit", component: O="svg", fontSize: F="medium", htmlColor: N, inheritViewBox: U=!1, titleAccess: H, viewBox: Z="0 0 24 24"} = M
      , J = _objectWithoutPropertiesLoose(M, _excluded$l)
      , ie = reactExports.isValidElement(T) && T.type === "svg"
      , oe = _extends$3({}, M, {
        color: B,
        component: O,
        fontSize: F,
        instanceFontSize: S.fontSize,
        inheritViewBox: U,
        viewBox: Z,
        hasSvgAsChild: ie
    })
      , ae = {};
    U || (ae.viewBox = Z);
    const se = useUtilityClasses$a(oe);
    return jsxRuntimeExports.jsxs(SvgIconRoot, _extends$3({
        as: O,
        className: clsx(se.root, $),
        focusable: "false",
        color: N,
        "aria-hidden": H ? void 0 : !0,
        role: H ? "img" : void 0,
        ref: E
    }, ae, J, ie && T.props, {
        ownerState: oe,
        children: [ie ? T.props.children : T, H ? jsxRuntimeExports.jsx("title", {
            children: H
        }) : null]
    }))
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(C, S) {
    function E(M, T) {
        return jsxRuntimeExports.jsx(SvgIcon, _extends$3({
            "data-testid": `${S}Icon`,
            ref: T
        }, M, {
            children: C
        }))
    }
    return E.muiName = SvgIcon.muiName,
    reactExports.memo(reactExports.forwardRef(E))
}
function createUseThemeProps(C) {
    return useThemeProps$2
}
function _setPrototypeOf(C, S) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(M, T) {
        return M.__proto__ = T,
        M
    }
    ,
    _setPrototypeOf(C, S)
}
function _inheritsLoose(C, S) {
    C.prototype = Object.create(S.prototype),
    C.prototype.constructor = C,
    _setPrototypeOf(C, S)
}
const config$1 = {
    disabled: !1
}
  , TransitionGroupContext = React$1.createContext(null);
var forceReflow = function C(S) {
    return S.scrollTop
}
  , UNMOUNTED = "unmounted"
  , EXITED = "exited"
  , ENTERING = "entering"
  , ENTERED = "entered"
  , EXITING = "exiting"
  , Transition = function(C) {
    _inheritsLoose(S, C);
    function S(M, T) {
        var $;
        $ = C.call(this, M, T) || this;
        var B = T, O = B && !B.isMounting ? M.enter : M.appear, F;
        return $.appearStatus = null,
        M.in ? O ? (F = EXITED,
        $.appearStatus = ENTERING) : F = ENTERED : M.unmountOnExit || M.mountOnEnter ? F = UNMOUNTED : F = EXITED,
        $.state = {
            status: F
        },
        $.nextCallback = null,
        $
    }
    S.getDerivedStateFromProps = function(T, $) {
        var B = T.in;
        return B && $.status === UNMOUNTED ? {
            status: EXITED
        } : null
    }
    ;
    var E = S.prototype;
    return E.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    E.componentDidUpdate = function(T) {
        var $ = null;
        if (T !== this.props) {
            var B = this.state.status;
            this.props.in ? B !== ENTERING && B !== ENTERED && ($ = ENTERING) : (B === ENTERING || B === ENTERED) && ($ = EXITING)
        }
        this.updateStatus(!1, $)
    }
    ,
    E.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    E.getTimeouts = function() {
        var T = this.props.timeout, $, B, O;
        return $ = B = O = T,
        T != null && typeof T != "number" && ($ = T.exit,
        B = T.enter,
        O = T.appear !== void 0 ? T.appear : B),
        {
            exit: $,
            enter: B,
            appear: O
        }
    }
    ,
    E.updateStatus = function(T, $) {
        if (T === void 0 && (T = !1),
        $ !== null)
            if (this.cancelNextCallback(),
            $ === ENTERING) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var B = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
                    B && forceReflow(B)
                }
                this.performEnter(T)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === EXITED && this.setState({
                status: UNMOUNTED
            })
    }
    ,
    E.performEnter = function(T) {
        var $ = this
          , B = this.props.enter
          , O = this.context ? this.context.isMounting : T
          , F = this.props.nodeRef ? [O] : [ReactDOM.findDOMNode(this), O]
          , N = F[0]
          , U = F[1]
          , H = this.getTimeouts()
          , Z = O ? H.appear : H.enter;
        if (!T && !B || config$1.disabled) {
            this.safeSetState({
                status: ENTERED
            }, function() {
                $.props.onEntered(N)
            });
            return
        }
        this.props.onEnter(N, U),
        this.safeSetState({
            status: ENTERING
        }, function() {
            $.props.onEntering(N, U),
            $.onTransitionEnd(Z, function() {
                $.safeSetState({
                    status: ENTERED
                }, function() {
                    $.props.onEntered(N, U)
                })
            })
        })
    }
    ,
    E.performExit = function() {
        var T = this
          , $ = this.props.exit
          , B = this.getTimeouts()
          , O = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!$ || config$1.disabled) {
            this.safeSetState({
                status: EXITED
            }, function() {
                T.props.onExited(O)
            });
            return
        }
        this.props.onExit(O),
        this.safeSetState({
            status: EXITING
        }, function() {
            T.props.onExiting(O),
            T.onTransitionEnd(B.exit, function() {
                T.safeSetState({
                    status: EXITED
                }, function() {
                    T.props.onExited(O)
                })
            })
        })
    }
    ,
    E.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    E.safeSetState = function(T, $) {
        $ = this.setNextCallback($),
        this.setState(T, $)
    }
    ,
    E.setNextCallback = function(T) {
        var $ = this
          , B = !0;
        return this.nextCallback = function(O) {
            B && (B = !1,
            $.nextCallback = null,
            T(O))
        }
        ,
        this.nextCallback.cancel = function() {
            B = !1
        }
        ,
        this.nextCallback
    }
    ,
    E.onTransitionEnd = function(T, $) {
        this.setNextCallback($);
        var B = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this)
          , O = T == null && !this.props.addEndListener;
        if (!B || O) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var F = this.props.nodeRef ? [this.nextCallback] : [B, this.nextCallback]
              , N = F[0]
              , U = F[1];
            this.props.addEndListener(N, U)
        }
        T != null && setTimeout(this.nextCallback, T)
    }
    ,
    E.render = function() {
        var T = this.state.status;
        if (T === UNMOUNTED)
            return null;
        var $ = this.props
          , B = $.children;
        $.in,
        $.mountOnEnter,
        $.unmountOnExit,
        $.appear,
        $.enter,
        $.exit,
        $.timeout,
        $.addEndListener,
        $.onEnter,
        $.onEntering,
        $.onEntered,
        $.onExit,
        $.onExiting,
        $.onExited,
        $.nodeRef;
        var O = _objectWithoutPropertiesLoose($, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return React$1.createElement(TransitionGroupContext.Provider, {
            value: null
        }, typeof B == "function" ? B(T, O) : React$1.cloneElement(React$1.Children.only(B), O))
    }
    ,
    S
}(React$1.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$2() {}
Transition.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized(C) {
    if (C === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return C
}
function getChildMapping(C, S) {
    var E = function($) {
        return S && reactExports.isValidElement($) ? S($) : $
    }
      , M = Object.create(null);
    return C && reactExports.Children.map(C, function(T) {
        return T
    }).forEach(function(T) {
        M[T.key] = E(T)
    }),
    M
}
function mergeChildMappings(C, S) {
    C = C || {},
    S = S || {};
    function E(U) {
        return U in S ? S[U] : C[U]
    }
    var M = Object.create(null)
      , T = [];
    for (var $ in C)
        $ in S ? T.length && (M[$] = T,
        T = []) : T.push($);
    var B, O = {};
    for (var F in S) {
        if (M[F])
            for (B = 0; B < M[F].length; B++) {
                var N = M[F][B];
                O[M[F][B]] = E(N)
            }
        O[F] = E(F)
    }
    for (B = 0; B < T.length; B++)
        O[T[B]] = E(T[B]);
    return O
}
function getProp(C, S, E) {
    return E[S] != null ? E[S] : C.props[S]
}
function getInitialChildMapping(C, S) {
    return getChildMapping(C.children, function(E) {
        return reactExports.cloneElement(E, {
            onExited: S.bind(null, E),
            in: !0,
            appear: getProp(E, "appear", C),
            enter: getProp(E, "enter", C),
            exit: getProp(E, "exit", C)
        })
    })
}
function getNextChildMapping(C, S, E) {
    var M = getChildMapping(C.children)
      , T = mergeChildMappings(S, M);
    return Object.keys(T).forEach(function($) {
        var B = T[$];
        if (reactExports.isValidElement(B)) {
            var O = $ in S
              , F = $ in M
              , N = S[$]
              , U = reactExports.isValidElement(N) && !N.props.in;
            F && (!O || U) ? T[$] = reactExports.cloneElement(B, {
                onExited: E.bind(null, B),
                in: !0,
                exit: getProp(B, "exit", C),
                enter: getProp(B, "enter", C)
            }) : !F && O && !U ? T[$] = reactExports.cloneElement(B, {
                in: !1
            }) : F && O && reactExports.isValidElement(N) && (T[$] = reactExports.cloneElement(B, {
                onExited: E.bind(null, B),
                in: N.props.in,
                exit: getProp(B, "exit", C),
                enter: getProp(B, "enter", C)
            }))
        }
    }),
    T
}
var values = Object.values || function(C) {
    return Object.keys(C).map(function(S) {
        return C[S]
    })
}
  , defaultProps = {
    component: "div",
    childFactory: function C(S) {
        return S
    }
}
  , TransitionGroup = function(C) {
    _inheritsLoose(S, C);
    function S(M, T) {
        var $;
        $ = C.call(this, M, T) || this;
        var B = $.handleExited.bind(_assertThisInitialized($));
        return $.state = {
            contextValue: {
                isMounting: !0
            },
            handleExited: B,
            firstRender: !0
        },
        $
    }
    var E = S.prototype;
    return E.componentDidMount = function() {
        this.mounted = !0,
        this.setState({
            contextValue: {
                isMounting: !1
            }
        })
    }
    ,
    E.componentWillUnmount = function() {
        this.mounted = !1
    }
    ,
    S.getDerivedStateFromProps = function(T, $) {
        var B = $.children
          , O = $.handleExited
          , F = $.firstRender;
        return {
            children: F ? getInitialChildMapping(T, O) : getNextChildMapping(T, B, O),
            firstRender: !1
        }
    }
    ,
    E.handleExited = function(T, $) {
        var B = getChildMapping(this.props.children);
        T.key in B || (T.props.onExited && T.props.onExited($),
        this.mounted && this.setState(function(O) {
            var F = _extends$3({}, O.children);
            return delete F[T.key],
            {
                children: F
            }
        }))
    }
    ,
    E.render = function() {
        var T = this.props
          , $ = T.component
          , B = T.childFactory
          , O = _objectWithoutPropertiesLoose(T, ["component", "childFactory"])
          , F = this.state.contextValue
          , N = values(this.state.children).map(B);
        return delete O.appear,
        delete O.enter,
        delete O.exit,
        $ === null ? React$1.createElement(TransitionGroupContext.Provider, {
            value: F
        }, N) : React$1.createElement(TransitionGroupContext.Provider, {
            value: F
        }, React$1.createElement($, O, N))
    }
    ,
    S
}(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup
  , reflow = C=>C.scrollTop;
function getTransitionProps(C, S) {
    var E, M;
    const {timeout: T, easing: $, style: B={}} = C;
    return {
        duration: (E = B.transitionDuration) != null ? E : typeof T == "number" ? T : T[S.mode] || 0,
        easing: (M = B.transitionTimingFunction) != null ? M : typeof $ == "object" ? $[S.mode] : $,
        delay: B.transitionDelay
    }
}
function getPaperUtilityClass(C) {
    return generateUtilityClass("MuiPaper", C)
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$k = ["className", "component", "elevation", "square", "variant"]
  , useUtilityClasses$9 = C=>{
    const {square: S, elevation: E, variant: M, classes: T} = C
      , $ = {
        root: ["root", M, !S && "rounded", M === "elevation" && `elevation${E}`]
    };
    return composeClasses($, getPaperUtilityClass, T)
}
  , PaperRoot = styled("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, S[E.variant], !E.square && S.rounded, E.variant === "elevation" && S[`elevation${E.elevation}`]]
    }
})(({theme: C, ownerState: S})=>{
    var E;
    return _extends$3({
        backgroundColor: (C.vars || C).palette.background.paper,
        color: (C.vars || C).palette.text.primary,
        transition: C.transitions.create("box-shadow")
    }, !S.square && {
        borderRadius: C.shape.borderRadius
    }, S.variant === "outlined" && {
        border: `1px solid ${(C.vars || C).palette.divider}`
    }, S.variant === "elevation" && _extends$3({
        boxShadow: (C.vars || C).shadows[S.elevation]
    }, !C.vars && C.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(S.elevation))}, ${alpha_1("#fff", getOverlayAlpha(S.elevation))})`
    }, C.vars && {
        backgroundImage: (E = C.vars.overlays) == null ? void 0 : E[S.elevation]
    }))
}
)
  , Paper = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiPaper"
    })
      , {className: T, component: $="div", elevation: B=1, square: O=!1, variant: F="elevation"} = M
      , N = _objectWithoutPropertiesLoose(M, _excluded$k)
      , U = _extends$3({}, M, {
        component: $,
        elevation: B,
        square: O,
        variant: F
    })
      , H = useUtilityClasses$9(U);
    return jsxRuntimeExports.jsx(PaperRoot, _extends$3({
        as: $,
        ownerState: U,
        className: clsx(H.root, T),
        ref: E
    }, N))
})
  , Paper$1 = Paper;
function isHostComponent(C) {
    return typeof C == "string"
}
function appendOwnerState(C, S, E) {
    return C === void 0 || isHostComponent(C) ? S : _extends$3({}, S, {
        ownerState: _extends$3({}, S.ownerState, E)
    })
}
function extractEventHandlers(C, S=[]) {
    if (C === void 0)
        return {};
    const E = {};
    return Object.keys(C).filter(M=>M.match(/^on[A-Z]/) && typeof C[M] == "function" && !S.includes(M)).forEach(M=>{
        E[M] = C[M]
    }
    ),
    E
}
function resolveComponentProps(C, S, E) {
    return typeof C == "function" ? C(S, E) : C
}
function omitEventHandlers(C) {
    if (C === void 0)
        return {};
    const S = {};
    return Object.keys(C).filter(E=>!(E.match(/^on[A-Z]/) && typeof C[E] == "function")).forEach(E=>{
        S[E] = C[E]
    }
    ),
    S
}
function mergeSlotProps(C) {
    const {getSlotProps: S, additionalProps: E, externalSlotProps: M, externalForwardedProps: T, className: $} = C;
    if (!S) {
        const J = clsx(E == null ? void 0 : E.className, $, T == null ? void 0 : T.className, M == null ? void 0 : M.className)
          , ie = _extends$3({}, E == null ? void 0 : E.style, T == null ? void 0 : T.style, M == null ? void 0 : M.style)
          , oe = _extends$3({}, E, T, M);
        return J.length > 0 && (oe.className = J),
        Object.keys(ie).length > 0 && (oe.style = ie),
        {
            props: oe,
            internalRef: void 0
        }
    }
    const B = extractEventHandlers(_extends$3({}, T, M))
      , O = omitEventHandlers(M)
      , F = omitEventHandlers(T)
      , N = S(B)
      , U = clsx(N == null ? void 0 : N.className, E == null ? void 0 : E.className, $, T == null ? void 0 : T.className, M == null ? void 0 : M.className)
      , H = _extends$3({}, N == null ? void 0 : N.style, E == null ? void 0 : E.style, T == null ? void 0 : T.style, M == null ? void 0 : M.style)
      , Z = _extends$3({}, N, E, F, O);
    return U.length > 0 && (Z.className = U),
    Object.keys(H).length > 0 && (Z.style = H),
    {
        props: Z,
        internalRef: N.ref
    }
}
const _excluded$j = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(C) {
    var S;
    const {elementType: E, externalSlotProps: M, ownerState: T, skipResolvingSlotProps: $=!1} = C
      , B = _objectWithoutPropertiesLoose(C, _excluded$j)
      , O = $ ? {} : resolveComponentProps(M, T)
      , {props: F, internalRef: N} = mergeSlotProps(_extends$3({}, B, {
        externalSlotProps: O
    }))
      , U = useForkRef(N, O == null ? void 0 : O.ref, (S = C.additionalProps) == null ? void 0 : S.ref);
    return appendOwnerState(E, _extends$3({}, F, {
        ref: U
    }), T)
}
const _excluded$i = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"]
  , _excluded2$2 = ["component", "slots", "slotProps"]
  , _excluded3 = ["component"];
function useSlot(C, S) {
    const {className: E, elementType: M, ownerState: T, externalForwardedProps: $, getSlotOwnerState: B, internalForwardedProps: O} = S
      , F = _objectWithoutPropertiesLoose(S, _excluded$i)
      , {component: N, slots: U={
        [C]: void 0
    }, slotProps: H={
        [C]: void 0
    }} = $
      , Z = _objectWithoutPropertiesLoose($, _excluded2$2)
      , J = U[C] || M
      , ie = resolveComponentProps(H[C], T)
      , oe = mergeSlotProps(_extends$3({
        className: E
    }, F, {
        externalForwardedProps: C === "root" ? Z : void 0,
        externalSlotProps: ie
    }))
      , {props: {component: ae}, internalRef: se} = oe
      , le = _objectWithoutPropertiesLoose(oe.props, _excluded3)
      , de = useForkRef(se, ie == null ? void 0 : ie.ref, S.ref)
      , fe = B ? B(le) : {}
      , pe = _extends$3({}, T, fe)
      , ge = C === "root" ? ae || N : ae
      , we = appendOwnerState(J, _extends$3({}, C === "root" && !N && !U[C] && O, C !== "root" && !U[C] && O, le, ge && {
        as: ge
    }, {
        ref: de
    }), pe);
    return Object.keys(fe).forEach(Ae=>{
        delete we[Ae]
    }
    ),
    [J, we]
}
function Ripple(C) {
    const {className: S, classes: E, pulsate: M=!1, rippleX: T, rippleY: $, rippleSize: B, in: O, onExited: F, timeout: N} = C
      , [U,H] = reactExports.useState(!1)
      , Z = clsx(S, E.ripple, E.rippleVisible, M && E.ripplePulsate)
      , J = {
        width: B,
        height: B,
        top: -(B / 2) + $,
        left: -(B / 2) + T
    }
      , ie = clsx(E.child, U && E.childLeaving, M && E.childPulsate);
    return !O && !U && H(!0),
    reactExports.useEffect(()=>{
        if (!O && F != null) {
            const oe = setTimeout(F, N);
            return ()=>{
                clearTimeout(oe)
            }
        }
    }
    , [F, O, N]),
    jsxRuntimeExports.jsx("span", {
        className: Z,
        style: J,
        children: jsxRuntimeExports.jsx("span", {
            className: ie
        })
    })
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"])
  , _excluded$h = ["center", "classes", "className"];
let _ = C=>C, _t, _t2, _t3, _t4;
const DURATION = 550
  , DELAY_RIPPLE = 80
  , enterKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`))
  , exitKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`))
  , pulsateKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`))
  , TouchRippleRoot = styled("span", {
    name: "MuiTouchRipple",
    slot: "Root"
})({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
})
  , TouchRippleRipple = styled(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple"
})(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({theme: C})=>C.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({theme: C})=>C.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({theme: C})=>C.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({theme: C})=>C.transitions.easing.easeInOut)
  , TouchRipple = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiTouchRipple"
    })
      , {center: T=!1, classes: $={}, className: B} = M
      , O = _objectWithoutPropertiesLoose(M, _excluded$h)
      , [F,N] = reactExports.useState([])
      , U = reactExports.useRef(0)
      , H = reactExports.useRef(null);
    reactExports.useEffect(()=>{
        H.current && (H.current(),
        H.current = null)
    }
    , [F]);
    const Z = reactExports.useRef(!1)
      , J = useTimeout()
      , ie = reactExports.useRef(null)
      , oe = reactExports.useRef(null)
      , ae = reactExports.useCallback(fe=>{
        const {pulsate: pe, rippleX: ge, rippleY: we, rippleSize: Ae, cb: Se} = fe;
        N(ue=>[...ue, jsxRuntimeExports.jsx(TouchRippleRipple, {
            classes: {
                ripple: clsx($.ripple, touchRippleClasses.ripple),
                rippleVisible: clsx($.rippleVisible, touchRippleClasses.rippleVisible),
                ripplePulsate: clsx($.ripplePulsate, touchRippleClasses.ripplePulsate),
                child: clsx($.child, touchRippleClasses.child),
                childLeaving: clsx($.childLeaving, touchRippleClasses.childLeaving),
                childPulsate: clsx($.childPulsate, touchRippleClasses.childPulsate)
            },
            timeout: DURATION,
            pulsate: pe,
            rippleX: ge,
            rippleY: we,
            rippleSize: Ae
        }, U.current)]),
        U.current += 1,
        H.current = Se
    }
    , [$])
      , se = reactExports.useCallback((fe={},pe={},ge=()=>{}
    )=>{
        const {pulsate: we=!1, center: Ae=T || pe.pulsate, fakeElement: Se=!1} = pe;
        if ((fe == null ? void 0 : fe.type) === "mousedown" && Z.current) {
            Z.current = !1;
            return
        }
        (fe == null ? void 0 : fe.type) === "touchstart" && (Z.current = !0);
        const ue = Se ? null : oe.current
          , V = ue ? ue.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };
        let W, D, I;
        if (Ae || fe === void 0 || fe.clientX === 0 && fe.clientY === 0 || !fe.clientX && !fe.touches)
            W = Math.round(V.width / 2),
            D = Math.round(V.height / 2);
        else {
            const {clientX: L, clientY: K} = fe.touches && fe.touches.length > 0 ? fe.touches[0] : fe;
            W = Math.round(L - V.left),
            D = Math.round(K - V.top)
        }
        if (Ae)
            I = Math.sqrt((2 * V.width ** 2 + V.height ** 2) / 3),
            I % 2 === 0 && (I += 1);
        else {
            const L = Math.max(Math.abs((ue ? ue.clientWidth : 0) - W), W) * 2 + 2
              , K = Math.max(Math.abs((ue ? ue.clientHeight : 0) - D), D) * 2 + 2;
            I = Math.sqrt(L ** 2 + K ** 2)
        }
        fe != null && fe.touches ? ie.current === null && (ie.current = ()=>{
            ae({
                pulsate: we,
                rippleX: W,
                rippleY: D,
                rippleSize: I,
                cb: ge
            })
        }
        ,
        J.start(DELAY_RIPPLE, ()=>{
            ie.current && (ie.current(),
            ie.current = null)
        }
        )) : ae({
            pulsate: we,
            rippleX: W,
            rippleY: D,
            rippleSize: I,
            cb: ge
        })
    }
    , [T, ae, J])
      , le = reactExports.useCallback(()=>{
        se({}, {
            pulsate: !0
        })
    }
    , [se])
      , de = reactExports.useCallback((fe,pe)=>{
        if (J.clear(),
        (fe == null ? void 0 : fe.type) === "touchend" && ie.current) {
            ie.current(),
            ie.current = null,
            J.start(0, ()=>{
                de(fe, pe)
            }
            );
            return
        }
        ie.current = null,
        N(ge=>ge.length > 0 ? ge.slice(1) : ge),
        H.current = pe
    }
    , [J]);
    return reactExports.useImperativeHandle(E, ()=>({
        pulsate: le,
        start: se,
        stop: de
    }), [le, se, de]),
    jsxRuntimeExports.jsx(TouchRippleRoot, _extends$3({
        className: clsx(touchRippleClasses.root, $.root, B),
        ref: oe
    }, O, {
        children: jsxRuntimeExports.jsx(TransitionGroup$1, {
            component: null,
            exit: !0,
            children: F
        })
    }))
})
  , TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(C) {
    return generateUtilityClass("MuiButtonBase", C)
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"])
  , _excluded$g = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"]
  , useUtilityClasses$8 = C=>{
    const {disabled: S, focusVisible: E, focusVisibleClassName: M, classes: T} = C
      , B = composeClasses({
        root: ["root", S && "disabled", E && "focusVisible"]
    }, getButtonBaseUtilityClass, T);
    return E && M && (B.root += ` ${M}`),
    B
}
  , ButtonBaseRoot = styled("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (C,S)=>S.root
})({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": {
        borderStyle: "none"
    },
    [`&.${buttonBaseClasses.disabled}`]: {
        pointerEvents: "none",
        cursor: "default"
    },
    "@media print": {
        colorAdjust: "exact"
    }
})
  , ButtonBase = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiButtonBase"
    })
      , {action: T, centerRipple: $=!1, children: B, className: O, component: F="button", disabled: N=!1, disableRipple: U=!1, disableTouchRipple: H=!1, focusRipple: Z=!1, LinkComponent: J="a", onBlur: ie, onClick: oe, onContextMenu: ae, onDragLeave: se, onFocus: le, onFocusVisible: de, onKeyDown: fe, onKeyUp: pe, onMouseDown: ge, onMouseLeave: we, onMouseUp: Ae, onTouchEnd: Se, onTouchMove: ue, onTouchStart: V, tabIndex: W=0, TouchRippleProps: D, touchRippleRef: I, type: L} = M
      , K = _objectWithoutPropertiesLoose(M, _excluded$g)
      , X = reactExports.useRef(null)
      , Y = reactExports.useRef(null)
      , j = useForkRef(Y, I)
      , {isFocusVisibleRef: G, onFocus: ne, onBlur: te, ref: ce} = useIsFocusVisible()
      , [Ee,Re] = reactExports.useState(!1);
    N && Ee && Re(!1),
    reactExports.useImperativeHandle(T, ()=>({
        focusVisible: ()=>{
            Re(!0),
            X.current.focus()
        }
    }), []);
    const [Te,xe] = reactExports.useState(!1);
    reactExports.useEffect(()=>{
        xe(!0)
    }
    , []);
    const ve = Te && !U && !N;
    reactExports.useEffect(()=>{
        Ee && Z && !U && Te && Y.current.pulsate()
    }
    , [U, Z, Ee, Te]);
    function Me(qe, Ne, at=H) {
        return useEventCallback(Ye=>(Ne && Ne(Ye),
        !at && Y.current && Y.current[qe](Ye),
        !0))
    }
    const Fe = Me("start", ge)
      , be = Me("stop", ae)
      , Ce = Me("stop", se)
      , ze = Me("stop", Ae)
      , Ge = Me("stop", qe=>{
        Ee && qe.preventDefault(),
        we && we(qe)
    }
    )
      , nt = Me("start", V)
      , bt = Me("stop", Se)
      , ct = Me("stop", ue)
      , De = Me("stop", qe=>{
        te(qe),
        G.current === !1 && Re(!1),
        ie && ie(qe)
    }
    , !1)
      , Ue = useEventCallback(qe=>{
        X.current || (X.current = qe.currentTarget),
        ne(qe),
        G.current === !0 && (Re(!0),
        de && de(qe)),
        le && le(qe)
    }
    )
      , We = ()=>{
        const qe = X.current;
        return F && F !== "button" && !(qe.tagName === "A" && qe.href)
    }
      , Xe = reactExports.useRef(!1)
      , ht = useEventCallback(qe=>{
        Z && !Xe.current && Ee && Y.current && qe.key === " " && (Xe.current = !0,
        Y.current.stop(qe, ()=>{
            Y.current.start(qe)
        }
        )),
        qe.target === qe.currentTarget && We() && qe.key === " " && qe.preventDefault(),
        fe && fe(qe),
        qe.target === qe.currentTarget && We() && qe.key === "Enter" && !N && (qe.preventDefault(),
        oe && oe(qe))
    }
    )
      , Je = useEventCallback(qe=>{
        Z && qe.key === " " && Y.current && Ee && !qe.defaultPrevented && (Xe.current = !1,
        Y.current.stop(qe, ()=>{
            Y.current.pulsate(qe)
        }
        )),
        pe && pe(qe),
        oe && qe.target === qe.currentTarget && We() && qe.key === " " && !qe.defaultPrevented && oe(qe)
    }
    );
    let ot = F;
    ot === "button" && (K.href || K.to) && (ot = J);
    const je = {};
    ot === "button" ? (je.type = L === void 0 ? "button" : L,
    je.disabled = N) : (!K.href && !K.to && (je.role = "button"),
    N && (je["aria-disabled"] = N));
    const $e = useForkRef(E, ce, X)
      , Ie = _extends$3({}, M, {
        centerRipple: $,
        component: F,
        disabled: N,
        disableRipple: U,
        disableTouchRipple: H,
        focusRipple: Z,
        tabIndex: W,
        focusVisible: Ee
    })
      , He = useUtilityClasses$8(Ie);
    return jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$3({
        as: ot,
        className: clsx(He.root, O),
        ownerState: Ie,
        onBlur: De,
        onClick: oe,
        onContextMenu: be,
        onFocus: Ue,
        onKeyDown: ht,
        onKeyUp: Je,
        onMouseDown: Fe,
        onMouseLeave: Ge,
        onMouseUp: ze,
        onDragLeave: Ce,
        onTouchEnd: bt,
        onTouchMove: ct,
        onTouchStart: nt,
        ref: $e,
        tabIndex: N ? -1 : W,
        type: L
    }, je, K, {
        children: [B, ve ? jsxRuntimeExports.jsx(TouchRipple$1, _extends$3({
            ref: j,
            center: $
        }, D)) : null]
    }))
})
  , ButtonBase$1 = ButtonBase;
function getAlertUtilityClass(C) {
    return generateUtilityClass("MuiAlert", C)
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"])
  , alertClasses$1 = alertClasses;
function getIconButtonUtilityClass(C) {
    return generateUtilityClass("MuiIconButton", C)
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"])
  , _excluded$f = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"]
  , useUtilityClasses$7 = C=>{
    const {classes: S, disabled: E, color: M, edge: T, size: $} = C
      , B = {
        root: ["root", E && "disabled", M !== "default" && `color${capitalize$1(M)}`, T && `edge${capitalize$1(T)}`, `size${capitalize$1($)}`]
    };
    return composeClasses(B, getIconButtonUtilityClass, S)
}
  , IconButtonRoot = styled(ButtonBase$1, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, E.color !== "default" && S[`color${capitalize$1(E.color)}`], E.edge && S[`edge${capitalize$1(E.edge)}`], S[`size${capitalize$1(E.size)}`]]
    }
})(({theme: C, ownerState: S})=>_extends$3({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: C.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    overflow: "visible",
    color: (C.vars || C).palette.action.active,
    transition: C.transitions.create("background-color", {
        duration: C.transitions.duration.shortest
    })
}, !S.disableRipple && {
    "&:hover": {
        backgroundColor: C.vars ? `rgba(${C.vars.palette.action.activeChannel} / ${C.vars.palette.action.hoverOpacity})` : alpha_1(C.palette.action.active, C.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    }
}, S.edge === "start" && {
    marginLeft: S.size === "small" ? -3 : -12
}, S.edge === "end" && {
    marginRight: S.size === "small" ? -3 : -12
}), ({theme: C, ownerState: S})=>{
    var E;
    const M = (E = (C.vars || C).palette) == null ? void 0 : E[S.color];
    return _extends$3({}, S.color === "inherit" && {
        color: "inherit"
    }, S.color !== "inherit" && S.color !== "default" && _extends$3({
        color: M == null ? void 0 : M.main
    }, !S.disableRipple && {
        "&:hover": _extends$3({}, M && {
            backgroundColor: C.vars ? `rgba(${M.mainChannel} / ${C.vars.palette.action.hoverOpacity})` : alpha_1(M.main, C.palette.action.hoverOpacity)
        }, {
            "@media (hover: none)": {
                backgroundColor: "transparent"
            }
        })
    }), S.size === "small" && {
        padding: 5,
        fontSize: C.typography.pxToRem(18)
    }, S.size === "large" && {
        padding: 12,
        fontSize: C.typography.pxToRem(28)
    }, {
        [`&.${iconButtonClasses.disabled}`]: {
            backgroundColor: "transparent",
            color: (C.vars || C).palette.action.disabled
        }
    })
}
)
  , IconButton = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiIconButton"
    })
      , {edge: T=!1, children: $, className: B, color: O="default", disabled: F=!1, disableFocusRipple: N=!1, size: U="medium"} = M
      , H = _objectWithoutPropertiesLoose(M, _excluded$f)
      , Z = _extends$3({}, M, {
        edge: T,
        color: O,
        disabled: F,
        disableFocusRipple: N,
        size: U
    })
      , J = useUtilityClasses$7(Z);
    return jsxRuntimeExports.jsx(IconButtonRoot, _extends$3({
        className: clsx(J.root, B),
        centerRipple: !0,
        focusRipple: !N,
        disabled: F,
        ref: E
    }, H, {
        ownerState: Z,
        children: $
    }))
})
  , IconButton$1 = IconButton
  , SuccessOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined")
  , ReportProblemOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined")
  , ErrorOutlineIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline")
  , InfoOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined")
  , ClearIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close")
  , _excluded$e = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"]
  , useThemeProps$1 = createUseThemeProps()
  , useUtilityClasses$6 = C=>{
    const {variant: S, color: E, severity: M, classes: T} = C
      , $ = {
        root: ["root", `color${capitalize$1(E || M)}`, `${S}${capitalize$1(E || M)}`, `${S}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"]
    };
    return composeClasses($, getAlertUtilityClass, T)
}
  , AlertRoot = styled(Paper$1, {
    name: "MuiAlert",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, S[E.variant], S[`${E.variant}${capitalize$1(E.color || E.severity)}`]]
    }
})(({theme: C})=>{
    const S = C.palette.mode === "light" ? darken_1 : lighten_1
      , E = C.palette.mode === "light" ? lighten_1 : darken_1;
    return _extends$3({}, C.typography.body2, {
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px",
        variants: [...Object.entries(C.palette).filter(([,M])=>M.main && M.light).map(([M])=>({
            props: {
                colorSeverity: M,
                variant: "standard"
            },
            style: {
                color: C.vars ? C.vars.palette.Alert[`${M}Color`] : S(C.palette[M].light, .6),
                backgroundColor: C.vars ? C.vars.palette.Alert[`${M}StandardBg`] : E(C.palette[M].light, .9),
                [`& .${alertClasses$1.icon}`]: C.vars ? {
                    color: C.vars.palette.Alert[`${M}IconColor`]
                } : {
                    color: C.palette[M].main
                }
            }
        })), ...Object.entries(C.palette).filter(([,M])=>M.main && M.light).map(([M])=>({
            props: {
                colorSeverity: M,
                variant: "outlined"
            },
            style: {
                color: C.vars ? C.vars.palette.Alert[`${M}Color`] : S(C.palette[M].light, .6),
                border: `1px solid ${(C.vars || C).palette[M].light}`,
                [`& .${alertClasses$1.icon}`]: C.vars ? {
                    color: C.vars.palette.Alert[`${M}IconColor`]
                } : {
                    color: C.palette[M].main
                }
            }
        })), ...Object.entries(C.palette).filter(([,M])=>M.main && M.dark).map(([M])=>({
            props: {
                colorSeverity: M,
                variant: "filled"
            },
            style: _extends$3({
                fontWeight: C.typography.fontWeightMedium
            }, C.vars ? {
                color: C.vars.palette.Alert[`${M}FilledColor`],
                backgroundColor: C.vars.palette.Alert[`${M}FilledBg`]
            } : {
                backgroundColor: C.palette.mode === "dark" ? C.palette[M].dark : C.palette[M].main,
                color: C.palette.getContrastText(C.palette[M].main)
            })
        }))]
    })
}
)
  , AlertIcon = styled("div", {
    name: "MuiAlert",
    slot: "Icon",
    overridesResolver: (C,S)=>S.icon
})({
    marginRight: 12,
    padding: "7px 0",
    display: "flex",
    fontSize: 22,
    opacity: .9
})
  , AlertMessage = styled("div", {
    name: "MuiAlert",
    slot: "Message",
    overridesResolver: (C,S)=>S.message
})({
    padding: "8px 0",
    minWidth: 0,
    overflow: "auto"
})
  , AlertAction = styled("div", {
    name: "MuiAlert",
    slot: "Action",
    overridesResolver: (C,S)=>S.action
})({
    display: "flex",
    alignItems: "flex-start",
    padding: "4px 0 0 16px",
    marginLeft: "auto",
    marginRight: -8
})
  , defaultIconMapping = {
    success: jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
        fontSize: "inherit"
    }),
    warning: jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
        fontSize: "inherit"
    }),
    error: jsxRuntimeExports.jsx(ErrorOutlineIcon, {
        fontSize: "inherit"
    }),
    info: jsxRuntimeExports.jsx(InfoOutlinedIcon, {
        fontSize: "inherit"
    })
}
  , Alert = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$1({
        props: S,
        name: "MuiAlert"
    })
      , {action: T, children: $, className: B, closeText: O="Close", color: F, components: N={}, componentsProps: U={}, icon: H, iconMapping: Z=defaultIconMapping, onClose: J, role: ie="alert", severity: oe="success", slotProps: ae={}, slots: se={}, variant: le="standard"} = M
      , de = _objectWithoutPropertiesLoose(M, _excluded$e)
      , fe = _extends$3({}, M, {
        color: F,
        severity: oe,
        variant: le,
        colorSeverity: F || oe
    })
      , pe = useUtilityClasses$6(fe)
      , ge = {
        slots: _extends$3({
            closeButton: N.CloseButton,
            closeIcon: N.CloseIcon
        }, se),
        slotProps: _extends$3({}, U, ae)
    }
      , [we,Ae] = useSlot("closeButton", {
        elementType: IconButton$1,
        externalForwardedProps: ge,
        ownerState: fe
    })
      , [Se,ue] = useSlot("closeIcon", {
        elementType: ClearIcon,
        externalForwardedProps: ge,
        ownerState: fe
    });
    return jsxRuntimeExports.jsxs(AlertRoot, _extends$3({
        role: ie,
        elevation: 0,
        ownerState: fe,
        className: clsx(pe.root, B),
        ref: E
    }, de, {
        children: [H !== !1 ? jsxRuntimeExports.jsx(AlertIcon, {
            ownerState: fe,
            className: pe.icon,
            children: H || Z[oe] || defaultIconMapping[oe]
        }) : null, jsxRuntimeExports.jsx(AlertMessage, {
            ownerState: fe,
            className: pe.message,
            children: $
        }), T != null ? jsxRuntimeExports.jsx(AlertAction, {
            ownerState: fe,
            className: pe.action,
            children: T
        }) : null, T == null && J ? jsxRuntimeExports.jsx(AlertAction, {
            ownerState: fe,
            className: pe.action,
            children: jsxRuntimeExports.jsx(we, _extends$3({
                size: "small",
                "aria-label": O,
                title: O,
                color: "inherit",
                onClick: J
            }, Ae, {
                children: jsxRuntimeExports.jsx(Se, _extends$3({
                    fontSize: "small"
                }, ue))
            }))
        }) : null]
    }))
})
  , Alert$1 = Alert;
function getTypographyUtilityClass(C) {
    return generateUtilityClass("MuiTypography", C)
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$d = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"]
  , useUtilityClasses$5 = C=>{
    const {align: S, gutterBottom: E, noWrap: M, paragraph: T, variant: $, classes: B} = C
      , O = {
        root: ["root", $, C.align !== "inherit" && `align${capitalize$1(S)}`, E && "gutterBottom", M && "noWrap", T && "paragraph"]
    };
    return composeClasses(O, getTypographyUtilityClass, B)
}
  , TypographyRoot = styled("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, E.variant && S[E.variant], E.align !== "inherit" && S[`align${capitalize$1(E.align)}`], E.noWrap && S.noWrap, E.gutterBottom && S.gutterBottom, E.paragraph && S.paragraph]
    }
})(({theme: C, ownerState: S})=>_extends$3({
    margin: 0
}, S.variant === "inherit" && {
    font: "inherit"
}, S.variant !== "inherit" && C.typography[S.variant], S.align !== "inherit" && {
    textAlign: S.align
}, S.noWrap && {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
}, S.gutterBottom && {
    marginBottom: "0.35em"
}, S.paragraph && {
    marginBottom: 16
}))
  , defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
}
  , colorTransformations = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
}
  , transformDeprecatedColors = C=>colorTransformations[C] || C
  , Typography = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiTypography"
    })
      , T = transformDeprecatedColors(M.color)
      , $ = extendSxProp(_extends$3({}, M, {
        color: T
    }))
      , {align: B="inherit", className: O, component: F, gutterBottom: N=!1, noWrap: U=!1, paragraph: H=!1, variant: Z="body1", variantMapping: J=defaultVariantMapping} = $
      , ie = _objectWithoutPropertiesLoose($, _excluded$d)
      , oe = _extends$3({}, $, {
        align: B,
        color: T,
        className: O,
        component: F,
        gutterBottom: N,
        noWrap: U,
        paragraph: H,
        variant: Z,
        variantMapping: J
    })
      , ae = F || (H ? "p" : J[Z] || defaultVariantMapping[Z]) || "span"
      , se = useUtilityClasses$5(oe);
    return jsxRuntimeExports.jsx(TypographyRoot, _extends$3({
        as: ae,
        ref: E,
        ownerState: oe,
        className: clsx(se.root, O)
    }, ie))
})
  , Typography$1 = Typography;
function getAlertTitleUtilityClass(C) {
    return generateUtilityClass("MuiAlertTitle", C)
}
generateUtilityClasses("MuiAlertTitle", ["root"]);
const _excluded$c = ["className"]
  , useThemeProps = createUseThemeProps()
  , useUtilityClasses$4 = C=>{
    const {classes: S} = C;
    return composeClasses({
        root: ["root"]
    }, getAlertTitleUtilityClass, S)
}
  , AlertTitleRoot = styled(Typography$1, {
    name: "MuiAlertTitle",
    slot: "Root",
    overridesResolver: (C,S)=>S.root
})(({theme: C})=>({
    fontWeight: C.typography.fontWeightMedium,
    marginTop: -2
}))
  , AlertTitle = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps({
        props: S,
        name: "MuiAlertTitle"
    })
      , {className: T} = M
      , $ = _objectWithoutPropertiesLoose(M, _excluded$c)
      , B = M
      , O = useUtilityClasses$4(B);
    return jsxRuntimeExports.jsx(AlertTitleRoot, _extends$3({
        gutterBottom: !0,
        component: "div",
        ownerState: B,
        ref: E,
        className: clsx(O.root, T)
    }, $))
})
  , AlertTitle$1 = AlertTitle;
function mapEventPropToEvent(C) {
    return C.substring(2).toLowerCase()
}
function clickedRootScrollbar(C, S) {
    return S.documentElement.clientWidth < C.clientX || S.documentElement.clientHeight < C.clientY
}
function ClickAwayListener(C) {
    const {children: S, disableReactTree: E=!1, mouseEvent: M="onClick", onClickAway: T, touchEvent: $="onTouchEnd"} = C
      , B = reactExports.useRef(!1)
      , O = reactExports.useRef(null)
      , F = reactExports.useRef(!1)
      , N = reactExports.useRef(!1);
    reactExports.useEffect(()=>(setTimeout(()=>{
        F.current = !0
    }
    , 0),
    ()=>{
        F.current = !1
    }
    ), []);
    const U = useForkRef(S.ref, O)
      , H = useEventCallback(ie=>{
        const oe = N.current;
        N.current = !1;
        const ae = ownerDocument(O.current);
        if (!F.current || !O.current || "clientX"in ie && clickedRootScrollbar(ie, ae))
            return;
        if (B.current) {
            B.current = !1;
            return
        }
        let se;
        ie.composedPath ? se = ie.composedPath().indexOf(O.current) > -1 : se = !ae.documentElement.contains(ie.target) || O.current.contains(ie.target),
        !se && (E || !oe) && T(ie)
    }
    )
      , Z = ie=>oe=>{
        N.current = !0;
        const ae = S.props[ie];
        ae && ae(oe)
    }
      , J = {
        ref: U
    };
    return $ !== !1 && (J[$] = Z($)),
    reactExports.useEffect(()=>{
        if ($ !== !1) {
            const ie = mapEventPropToEvent($)
              , oe = ownerDocument(O.current)
              , ae = ()=>{
                B.current = !0
            }
            ;
            return oe.addEventListener(ie, H),
            oe.addEventListener("touchmove", ae),
            ()=>{
                oe.removeEventListener(ie, H),
                oe.removeEventListener("touchmove", ae)
            }
        }
    }
    , [H, $]),
    M !== !1 && (J[M] = Z(M)),
    reactExports.useEffect(()=>{
        if (M !== !1) {
            const ie = mapEventPropToEvent(M)
              , oe = ownerDocument(O.current);
            return oe.addEventListener(ie, H),
            ()=>{
                oe.removeEventListener(ie, H)
            }
        }
    }
    , [H, M]),
    jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: reactExports.cloneElement(S, J)
    })
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(C) {
    const S = parseInt(C.getAttribute("tabindex") || "", 10);
    return Number.isNaN(S) ? C.contentEditable === "true" || (C.nodeName === "AUDIO" || C.nodeName === "VIDEO" || C.nodeName === "DETAILS") && C.getAttribute("tabindex") === null ? 0 : C.tabIndex : S
}
function isNonTabbableRadio(C) {
    if (C.tagName !== "INPUT" || C.type !== "radio" || !C.name)
        return !1;
    const S = M=>C.ownerDocument.querySelector(`input[type="radio"]${M}`);
    let E = S(`[name="${C.name}"]:checked`);
    return E || (E = S(`[name="${C.name}"]`)),
    E !== C
}
function isNodeMatchingSelectorFocusable(C) {
    return !(C.disabled || C.tagName === "INPUT" && C.type === "hidden" || isNonTabbableRadio(C))
}
function defaultGetTabbable(C) {
    const S = []
      , E = [];
    return Array.from(C.querySelectorAll(candidatesSelector)).forEach((M,T)=>{
        const $ = getTabIndex(M);
        $ === -1 || !isNodeMatchingSelectorFocusable(M) || ($ === 0 ? S.push(M) : E.push({
            documentOrder: T,
            tabIndex: $,
            node: M
        }))
    }
    ),
    E.sort((M,T)=>M.tabIndex === T.tabIndex ? M.documentOrder - T.documentOrder : M.tabIndex - T.tabIndex).map(M=>M.node).concat(S)
}
function defaultIsEnabled() {
    return !0
}
function FocusTrap(C) {
    const {children: S, disableAutoFocus: E=!1, disableEnforceFocus: M=!1, disableRestoreFocus: T=!1, getTabbable: $=defaultGetTabbable, isEnabled: B=defaultIsEnabled, open: O} = C
      , F = reactExports.useRef(!1)
      , N = reactExports.useRef(null)
      , U = reactExports.useRef(null)
      , H = reactExports.useRef(null)
      , Z = reactExports.useRef(null)
      , J = reactExports.useRef(!1)
      , ie = reactExports.useRef(null)
      , oe = useForkRef(S.ref, ie)
      , ae = reactExports.useRef(null);
    reactExports.useEffect(()=>{
        !O || !ie.current || (J.current = !E)
    }
    , [E, O]),
    reactExports.useEffect(()=>{
        if (!O || !ie.current)
            return;
        const de = ownerDocument(ie.current);
        return ie.current.contains(de.activeElement) || (ie.current.hasAttribute("tabIndex") || ie.current.setAttribute("tabIndex", "-1"),
        J.current && ie.current.focus()),
        ()=>{
            T || (H.current && H.current.focus && (F.current = !0,
            H.current.focus()),
            H.current = null)
        }
    }
    , [O]),
    reactExports.useEffect(()=>{
        if (!O || !ie.current)
            return;
        const de = ownerDocument(ie.current)
          , fe = we=>{
            ae.current = we,
            !(M || !B() || we.key !== "Tab") && de.activeElement === ie.current && we.shiftKey && (F.current = !0,
            U.current && U.current.focus())
        }
          , pe = ()=>{
            const we = ie.current;
            if (we === null)
                return;
            if (!de.hasFocus() || !B() || F.current) {
                F.current = !1;
                return
            }
            if (we.contains(de.activeElement) || M && de.activeElement !== N.current && de.activeElement !== U.current)
                return;
            if (de.activeElement !== Z.current)
                Z.current = null;
            else if (Z.current !== null)
                return;
            if (!J.current)
                return;
            let Ae = [];
            if ((de.activeElement === N.current || de.activeElement === U.current) && (Ae = $(ie.current)),
            Ae.length > 0) {
                var Se, ue;
                const V = !!((Se = ae.current) != null && Se.shiftKey && ((ue = ae.current) == null ? void 0 : ue.key) === "Tab")
                  , W = Ae[0]
                  , D = Ae[Ae.length - 1];
                typeof W != "string" && typeof D != "string" && (V ? D.focus() : W.focus())
            } else
                we.focus()
        }
        ;
        de.addEventListener("focusin", pe),
        de.addEventListener("keydown", fe, !0);
        const ge = setInterval(()=>{
            de.activeElement && de.activeElement.tagName === "BODY" && pe()
        }
        , 50);
        return ()=>{
            clearInterval(ge),
            de.removeEventListener("focusin", pe),
            de.removeEventListener("keydown", fe, !0)
        }
    }
    , [E, M, T, B, O, $]);
    const se = de=>{
        H.current === null && (H.current = de.relatedTarget),
        J.current = !0,
        Z.current = de.target;
        const fe = S.props.onFocus;
        fe && fe(de)
    }
      , le = de=>{
        H.current === null && (H.current = de.relatedTarget),
        J.current = !0
    }
    ;
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            tabIndex: O ? 0 : -1,
            onFocus: le,
            ref: N,
            "data-testid": "sentinelStart"
        }), reactExports.cloneElement(S, {
            ref: oe,
            onFocus: se
        }), jsxRuntimeExports.jsx("div", {
            tabIndex: O ? 0 : -1,
            onFocus: le,
            ref: U,
            "data-testid": "sentinelEnd"
        })]
    })
}
function getContainer$2(C) {
    return typeof C == "function" ? C() : C
}
const Portal = reactExports.forwardRef(function C(S, E) {
    const {children: M, container: T, disablePortal: $=!1} = S
      , [B,O] = reactExports.useState(null)
      , F = useForkRef(reactExports.isValidElement(M) ? M.ref : null, E);
    if (useEnhancedEffect(()=>{
        $ || O(getContainer$2(T) || document.body)
    }
    , [T, $]),
    useEnhancedEffect(()=>{
        if (B && !$)
            return setRef(E, B),
            ()=>{
                setRef(E, null)
            }
    }
    , [E, B, $]),
    $) {
        if (reactExports.isValidElement(M)) {
            const N = {
                ref: F
            };
            return reactExports.cloneElement(M, N)
        }
        return jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: M
        })
    }
    return jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: B && reactDomExports.createPortal(M, B)
    })
});
function isOverflowing(C) {
    const S = ownerDocument(C);
    return S.body === C ? ownerWindow(C).innerWidth > S.documentElement.clientWidth : C.scrollHeight > C.clientHeight
}
function ariaHidden(C, S) {
    S ? C.setAttribute("aria-hidden", "true") : C.removeAttribute("aria-hidden")
}
function getPaddingRight(C) {
    return parseInt(ownerWindow(C).getComputedStyle(C).paddingRight, 10) || 0
}
function isAriaHiddenForbiddenOnElement(C) {
    const E = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(C.tagName) !== -1
      , M = C.tagName === "INPUT" && C.getAttribute("type") === "hidden";
    return E || M
}
function ariaHiddenSiblings(C, S, E, M, T) {
    const $ = [S, E, ...M];
    [].forEach.call(C.children, B=>{
        const O = $.indexOf(B) === -1
          , F = !isAriaHiddenForbiddenOnElement(B);
        O && F && ariaHidden(B, T)
    }
    )
}
function findIndexOf(C, S) {
    let E = -1;
    return C.some((M,T)=>S(M) ? (E = T,
    !0) : !1),
    E
}
function handleContainer(C, S) {
    const E = []
      , M = C.container;
    if (!S.disableScrollLock) {
        if (isOverflowing(M)) {
            const B = getScrollbarSize(ownerDocument(M));
            E.push({
                value: M.style.paddingRight,
                property: "padding-right",
                el: M
            }),
            M.style.paddingRight = `${getPaddingRight(M) + B}px`;
            const O = ownerDocument(M).querySelectorAll(".mui-fixed");
            [].forEach.call(O, F=>{
                E.push({
                    value: F.style.paddingRight,
                    property: "padding-right",
                    el: F
                }),
                F.style.paddingRight = `${getPaddingRight(F) + B}px`
            }
            )
        }
        let $;
        if (M.parentNode instanceof DocumentFragment)
            $ = ownerDocument(M).body;
        else {
            const B = M.parentElement
              , O = ownerWindow(M);
            $ = (B == null ? void 0 : B.nodeName) === "HTML" && O.getComputedStyle(B).overflowY === "scroll" ? B : M
        }
        E.push({
            value: $.style.overflow,
            property: "overflow",
            el: $
        }, {
            value: $.style.overflowX,
            property: "overflow-x",
            el: $
        }, {
            value: $.style.overflowY,
            property: "overflow-y",
            el: $
        }),
        $.style.overflow = "hidden"
    }
    return ()=>{
        E.forEach(({value: $, el: B, property: O})=>{
            $ ? B.style.setProperty(O, $) : B.style.removeProperty(O)
        }
        )
    }
}
function getHiddenSiblings(C) {
    const S = [];
    return [].forEach.call(C.children, E=>{
        E.getAttribute("aria-hidden") === "true" && S.push(E)
    }
    ),
    S
}
class ModalManager {
    constructor() {
        this.containers = void 0,
        this.modals = void 0,
        this.modals = [],
        this.containers = []
    }
    add(S, E) {
        let M = this.modals.indexOf(S);
        if (M !== -1)
            return M;
        M = this.modals.length,
        this.modals.push(S),
        S.modalRef && ariaHidden(S.modalRef, !1);
        const T = getHiddenSiblings(E);
        ariaHiddenSiblings(E, S.mount, S.modalRef, T, !0);
        const $ = findIndexOf(this.containers, B=>B.container === E);
        return $ !== -1 ? (this.containers[$].modals.push(S),
        M) : (this.containers.push({
            modals: [S],
            container: E,
            restore: null,
            hiddenSiblings: T
        }),
        M)
    }
    mount(S, E) {
        const M = findIndexOf(this.containers, $=>$.modals.indexOf(S) !== -1)
          , T = this.containers[M];
        T.restore || (T.restore = handleContainer(T, E))
    }
    remove(S, E=!0) {
        const M = this.modals.indexOf(S);
        if (M === -1)
            return M;
        const T = findIndexOf(this.containers, B=>B.modals.indexOf(S) !== -1)
          , $ = this.containers[T];
        if ($.modals.splice($.modals.indexOf(S), 1),
        this.modals.splice(M, 1),
        $.modals.length === 0)
            $.restore && $.restore(),
            S.modalRef && ariaHidden(S.modalRef, E),
            ariaHiddenSiblings($.container, S.mount, S.modalRef, $.hiddenSiblings, !1),
            this.containers.splice(T, 1);
        else {
            const B = $.modals[$.modals.length - 1];
            B.modalRef && ariaHidden(B.modalRef, !1)
        }
        return M
    }
    isTopModal(S) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === S
    }
}
function getContainer$1(C) {
    return typeof C == "function" ? C() : C
}
function getHasTransition(C) {
    return C ? C.props.hasOwnProperty("in") : !1
}
const defaultManager = new ModalManager;
function useModal(C) {
    const {container: S, disableEscapeKeyDown: E=!1, disableScrollLock: M=!1, manager: T=defaultManager, closeAfterTransition: $=!1, onTransitionEnter: B, onTransitionExited: O, children: F, onClose: N, open: U, rootRef: H} = C
      , Z = reactExports.useRef({})
      , J = reactExports.useRef(null)
      , ie = reactExports.useRef(null)
      , oe = useForkRef(ie, H)
      , [ae,se] = reactExports.useState(!U)
      , le = getHasTransition(F);
    let de = !0;
    (C["aria-hidden"] === "false" || C["aria-hidden"] === !1) && (de = !1);
    const fe = ()=>ownerDocument(J.current)
      , pe = ()=>(Z.current.modalRef = ie.current,
    Z.current.mount = J.current,
    Z.current)
      , ge = ()=>{
        T.mount(pe(), {
            disableScrollLock: M
        }),
        ie.current && (ie.current.scrollTop = 0)
    }
      , we = useEventCallback(()=>{
        const K = getContainer$1(S) || fe().body;
        T.add(pe(), K),
        ie.current && ge()
    }
    )
      , Ae = reactExports.useCallback(()=>T.isTopModal(pe()), [T])
      , Se = useEventCallback(K=>{
        J.current = K,
        K && (U && Ae() ? ge() : ie.current && ariaHidden(ie.current, de))
    }
    )
      , ue = reactExports.useCallback(()=>{
        T.remove(pe(), de)
    }
    , [de, T]);
    reactExports.useEffect(()=>()=>{
        ue()
    }
    , [ue]),
    reactExports.useEffect(()=>{
        U ? we() : (!le || !$) && ue()
    }
    , [U, ue, le, $, we]);
    const V = K=>X=>{
        var Y;
        (Y = K.onKeyDown) == null || Y.call(K, X),
        !(X.key !== "Escape" || X.which === 229 || !Ae()) && (E || (X.stopPropagation(),
        N && N(X, "escapeKeyDown")))
    }
      , W = K=>X=>{
        var Y;
        (Y = K.onClick) == null || Y.call(K, X),
        X.target === X.currentTarget && N && N(X, "backdropClick")
    }
    ;
    return {
        getRootProps: (K={})=>{
            const X = extractEventHandlers(C);
            delete X.onTransitionEnter,
            delete X.onTransitionExited;
            const Y = _extends$3({}, X, K);
            return _extends$3({
                role: "presentation"
            }, Y, {
                onKeyDown: V(Y),
                ref: oe
            })
        }
        ,
        getBackdropProps: (K={})=>{
            const X = K;
            return _extends$3({
                "aria-hidden": !0
            }, X, {
                onClick: W(X),
                open: U
            })
        }
        ,
        getTransitionProps: ()=>{
            const K = ()=>{
                se(!1),
                B && B()
            }
              , X = ()=>{
                se(!0),
                O && O(),
                $ && ue()
            }
            ;
            return {
                onEnter: createChainedFunction(K, F == null ? void 0 : F.props.onEnter),
                onExited: createChainedFunction(X, F == null ? void 0 : F.props.onExited)
            }
        }
        ,
        rootRef: oe,
        portalRef: Se,
        isTopModal: Ae,
        exited: ae,
        hasTransition: le
    }
}
function useSnackbar(C={}) {
    const {autoHideDuration: S=null, disableWindowBlurListener: E=!1, onClose: M, open: T, resumeHideDuration: $} = C
      , B = useTimeout();
    reactExports.useEffect(()=>{
        if (!T)
            return;
        function se(le) {
            le.defaultPrevented || (le.key === "Escape" || le.key === "Esc") && (M == null || M(le, "escapeKeyDown"))
        }
        return document.addEventListener("keydown", se),
        ()=>{
            document.removeEventListener("keydown", se)
        }
    }
    , [T, M]);
    const O = useEventCallback((se,le)=>{
        M == null || M(se, le)
    }
    )
      , F = useEventCallback(se=>{
        !M || se == null || B.start(se, ()=>{
            O(null, "timeout")
        }
        )
    }
    );
    reactExports.useEffect(()=>(T && F(S),
    B.clear), [T, S, F, B]);
    const N = se=>{
        M == null || M(se, "clickaway")
    }
      , U = B.clear
      , H = reactExports.useCallback(()=>{
        S != null && F($ ?? S * .5)
    }
    , [S, $, F])
      , Z = se=>le=>{
        const de = se.onBlur;
        de == null || de(le),
        H()
    }
      , J = se=>le=>{
        const de = se.onFocus;
        de == null || de(le),
        U()
    }
      , ie = se=>le=>{
        const de = se.onMouseEnter;
        de == null || de(le),
        U()
    }
      , oe = se=>le=>{
        const de = se.onMouseLeave;
        de == null || de(le),
        H()
    }
    ;
    return reactExports.useEffect(()=>{
        if (!E && T)
            return window.addEventListener("focus", H),
            window.addEventListener("blur", U),
            ()=>{
                window.removeEventListener("focus", H),
                window.removeEventListener("blur", U)
            }
    }
    , [E, T, H, U]),
    {
        getRootProps: (se={})=>{
            const le = _extends$3({}, extractEventHandlers(C), extractEventHandlers(se));
            return _extends$3({
                role: "presentation"
            }, se, le, {
                onBlur: Z(le),
                onFocus: J(le),
                onMouseEnter: ie(le),
                onMouseLeave: oe(le)
            })
        }
        ,
        onClickAway: N
    }
}
const _excluded$b = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]
  , styles$1 = {
    entering: {
        opacity: 1
    },
    entered: {
        opacity: 1
    }
}
  , Fade = reactExports.forwardRef(function C(S, E) {
    const M = useTheme$1()
      , T = {
        enter: M.transitions.duration.enteringScreen,
        exit: M.transitions.duration.leavingScreen
    }
      , {addEndListener: $, appear: B=!0, children: O, easing: F, in: N, onEnter: U, onEntered: H, onEntering: Z, onExit: J, onExited: ie, onExiting: oe, style: ae, timeout: se=T, TransitionComponent: le=Transition$1} = S
      , de = _objectWithoutPropertiesLoose(S, _excluded$b)
      , fe = reactExports.useRef(null)
      , pe = useForkRef(fe, O.ref, E)
      , ge = I=>L=>{
        if (I) {
            const K = fe.current;
            L === void 0 ? I(K) : I(K, L)
        }
    }
      , we = ge(Z)
      , Ae = ge((I,L)=>{
        reflow(I);
        const K = getTransitionProps({
            style: ae,
            timeout: se,
            easing: F
        }, {
            mode: "enter"
        });
        I.style.webkitTransition = M.transitions.create("opacity", K),
        I.style.transition = M.transitions.create("opacity", K),
        U && U(I, L)
    }
    )
      , Se = ge(H)
      , ue = ge(oe)
      , V = ge(I=>{
        const L = getTransitionProps({
            style: ae,
            timeout: se,
            easing: F
        }, {
            mode: "exit"
        });
        I.style.webkitTransition = M.transitions.create("opacity", L),
        I.style.transition = M.transitions.create("opacity", L),
        J && J(I)
    }
    )
      , W = ge(ie)
      , D = I=>{
        $ && $(fe.current, I)
    }
    ;
    return jsxRuntimeExports.jsx(le, _extends$3({
        appear: B,
        in: N,
        nodeRef: fe,
        onEnter: Ae,
        onEntered: Se,
        onEntering: we,
        onExit: V,
        onExited: W,
        onExiting: ue,
        addEndListener: D,
        timeout: se
    }, de, {
        children: (I,L)=>reactExports.cloneElement(O, _extends$3({
            style: _extends$3({
                opacity: 0,
                visibility: I === "exited" && !N ? "hidden" : void 0
            }, styles$1[I], ae, O.props.style),
            ref: pe
        }, L))
    }))
})
  , Fade$1 = Fade;
function getBackdropUtilityClass(C) {
    return generateUtilityClass("MuiBackdrop", C)
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$a = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"]
  , useUtilityClasses$3 = C=>{
    const {classes: S, invisible: E} = C;
    return composeClasses({
        root: ["root", E && "invisible"]
    }, getBackdropUtilityClass, S)
}
  , BackdropRoot = styled("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, E.invisible && S.invisible]
    }
})(({ownerState: C})=>_extends$3({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
}, C.invisible && {
    backgroundColor: "transparent"
}))
  , Backdrop = reactExports.forwardRef(function C(S, E) {
    var M, T, $;
    const B = useThemeProps$2({
        props: S,
        name: "MuiBackdrop"
    })
      , {children: O, className: F, component: N="div", components: U={}, componentsProps: H={}, invisible: Z=!1, open: J, slotProps: ie={}, slots: oe={}, TransitionComponent: ae=Fade$1, transitionDuration: se} = B
      , le = _objectWithoutPropertiesLoose(B, _excluded$a)
      , de = _extends$3({}, B, {
        component: N,
        invisible: Z
    })
      , fe = useUtilityClasses$3(de)
      , pe = (M = ie.root) != null ? M : H.root;
    return jsxRuntimeExports.jsx(ae, _extends$3({
        in: J,
        timeout: se
    }, le, {
        children: jsxRuntimeExports.jsx(BackdropRoot, _extends$3({
            "aria-hidden": !0
        }, pe, {
            as: (T = ($ = oe.root) != null ? $ : U.Root) != null ? T : N,
            className: clsx(fe.root, F, pe == null ? void 0 : pe.className),
            ownerState: _extends$3({}, de, pe == null ? void 0 : pe.ownerState),
            classes: fe,
            ref: E,
            children: O
        }))
    }))
})
  , Backdrop$1 = Backdrop;
function getModalUtilityClass(C) {
    return generateUtilityClass("MuiModal", C)
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$9 = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"]
  , useUtilityClasses$2 = C=>{
    const {open: S, exited: E, classes: M} = C;
    return composeClasses({
        root: ["root", !S && E && "hidden"],
        backdrop: ["backdrop"]
    }, getModalUtilityClass, M)
}
  , ModalRoot = styled("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, !E.open && E.exited && S.hidden]
    }
})(({theme: C, ownerState: S})=>_extends$3({
    position: "fixed",
    zIndex: (C.vars || C).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
}, !S.open && S.exited && {
    visibility: "hidden"
}))
  , ModalBackdrop = styled(Backdrop$1, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (C,S)=>S.backdrop
})({
    zIndex: -1
})
  , Modal$1 = reactExports.forwardRef(function C(S, E) {
    var M, T, $, B, O, F;
    const N = useThemeProps$2({
        name: "MuiModal",
        props: S
    })
      , {BackdropComponent: U=ModalBackdrop, BackdropProps: H, className: Z, closeAfterTransition: J=!1, children: ie, container: oe, component: ae, components: se={}, componentsProps: le={}, disableAutoFocus: de=!1, disableEnforceFocus: fe=!1, disableEscapeKeyDown: pe=!1, disablePortal: ge=!1, disableRestoreFocus: we=!1, disableScrollLock: Ae=!1, hideBackdrop: Se=!1, keepMounted: ue=!1, onBackdropClick: V, open: W, slotProps: D, slots: I} = N
      , L = _objectWithoutPropertiesLoose(N, _excluded$9)
      , K = _extends$3({}, N, {
        closeAfterTransition: J,
        disableAutoFocus: de,
        disableEnforceFocus: fe,
        disableEscapeKeyDown: pe,
        disablePortal: ge,
        disableRestoreFocus: we,
        disableScrollLock: Ae,
        hideBackdrop: Se,
        keepMounted: ue
    })
      , {getRootProps: X, getBackdropProps: Y, getTransitionProps: j, portalRef: G, isTopModal: ne, exited: te, hasTransition: ce} = useModal(_extends$3({}, K, {
        rootRef: E
    }))
      , Ee = _extends$3({}, K, {
        exited: te
    })
      , Re = useUtilityClasses$2(Ee)
      , Te = {};
    if (ie.props.tabIndex === void 0 && (Te.tabIndex = "-1"),
    ce) {
        const {onEnter: ze, onExited: Ge} = j();
        Te.onEnter = ze,
        Te.onExited = Ge
    }
    const xe = (M = (T = I == null ? void 0 : I.root) != null ? T : se.Root) != null ? M : ModalRoot
      , ve = ($ = (B = I == null ? void 0 : I.backdrop) != null ? B : se.Backdrop) != null ? $ : U
      , Me = (O = D == null ? void 0 : D.root) != null ? O : le.root
      , Fe = (F = D == null ? void 0 : D.backdrop) != null ? F : le.backdrop
      , be = useSlotProps({
        elementType: xe,
        externalSlotProps: Me,
        externalForwardedProps: L,
        getSlotProps: X,
        additionalProps: {
            ref: E,
            as: ae
        },
        ownerState: Ee,
        className: clsx(Z, Me == null ? void 0 : Me.className, Re == null ? void 0 : Re.root, !Ee.open && Ee.exited && (Re == null ? void 0 : Re.hidden))
    })
      , Ce = useSlotProps({
        elementType: ve,
        externalSlotProps: Fe,
        additionalProps: H,
        getSlotProps: ze=>Y(_extends$3({}, ze, {
            onClick: Ge=>{
                V && V(Ge),
                ze != null && ze.onClick && ze.onClick(Ge)
            }
        })),
        className: clsx(Fe == null ? void 0 : Fe.className, H == null ? void 0 : H.className, Re == null ? void 0 : Re.backdrop),
        ownerState: Ee
    });
    return !ue && !W && (!ce || te) ? null : jsxRuntimeExports.jsx(Portal, {
        ref: G,
        container: oe,
        disablePortal: ge,
        children: jsxRuntimeExports.jsxs(xe, _extends$3({}, be, {
            children: [!Se && U ? jsxRuntimeExports.jsx(ve, _extends$3({}, Ce)) : null, jsxRuntimeExports.jsx(FocusTrap, {
                disableEnforceFocus: fe,
                disableAutoFocus: de,
                disableRestoreFocus: we,
                isEnabled: ne,
                open: W,
                children: reactExports.cloneElement(ie, Te)
            })]
        }))
    })
})
  , BaseModal = Modal$1
  , _excluded$8 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(C) {
    return `scale(${C}, ${C ** 2})`
}
const styles = {
    entering: {
        opacity: 1,
        transform: getScale(1)
    },
    entered: {
        opacity: 1,
        transform: "none"
    }
}
  , isWebKit154 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
  , Grow = reactExports.forwardRef(function C(S, E) {
    const {addEndListener: M, appear: T=!0, children: $, easing: B, in: O, onEnter: F, onEntered: N, onEntering: U, onExit: H, onExited: Z, onExiting: J, style: ie, timeout: oe="auto", TransitionComponent: ae=Transition$1} = S
      , se = _objectWithoutPropertiesLoose(S, _excluded$8)
      , le = useTimeout()
      , de = reactExports.useRef()
      , fe = useTheme$1()
      , pe = reactExports.useRef(null)
      , ge = useForkRef(pe, $.ref, E)
      , we = L=>K=>{
        if (L) {
            const X = pe.current;
            K === void 0 ? L(X) : L(X, K)
        }
    }
      , Ae = we(U)
      , Se = we((L,K)=>{
        reflow(L);
        const {duration: X, delay: Y, easing: j} = getTransitionProps({
            style: ie,
            timeout: oe,
            easing: B
        }, {
            mode: "enter"
        });
        let G;
        oe === "auto" ? (G = fe.transitions.getAutoHeightDuration(L.clientHeight),
        de.current = G) : G = X,
        L.style.transition = [fe.transitions.create("opacity", {
            duration: G,
            delay: Y
        }), fe.transitions.create("transform", {
            duration: isWebKit154 ? G : G * .666,
            delay: Y,
            easing: j
        })].join(","),
        F && F(L, K)
    }
    )
      , ue = we(N)
      , V = we(J)
      , W = we(L=>{
        const {duration: K, delay: X, easing: Y} = getTransitionProps({
            style: ie,
            timeout: oe,
            easing: B
        }, {
            mode: "exit"
        });
        let j;
        oe === "auto" ? (j = fe.transitions.getAutoHeightDuration(L.clientHeight),
        de.current = j) : j = K,
        L.style.transition = [fe.transitions.create("opacity", {
            duration: j,
            delay: X
        }), fe.transitions.create("transform", {
            duration: isWebKit154 ? j : j * .666,
            delay: isWebKit154 ? X : X || j * .333,
            easing: Y
        })].join(","),
        L.style.opacity = 0,
        L.style.transform = getScale(.75),
        H && H(L)
    }
    )
      , D = we(Z)
      , I = L=>{
        oe === "auto" && le.start(de.current || 0, L),
        M && M(pe.current, L)
    }
    ;
    return jsxRuntimeExports.jsx(ae, _extends$3({
        appear: T,
        in: O,
        nodeRef: pe,
        onEnter: Se,
        onEntered: ue,
        onEntering: Ae,
        onExit: W,
        onExited: D,
        onExiting: V,
        addEndListener: I,
        timeout: oe === "auto" ? null : oe
    }, se, {
        children: (L,K)=>reactExports.cloneElement($, _extends$3({
            style: _extends$3({
                opacity: 0,
                transform: getScale(.75),
                visibility: L === "exited" && !O ? "hidden" : void 0
            }, styles[L], ie, $.props.style),
            ref: ge
        }, K))
    }))
});
Grow.muiSupportAuto = !0;
const Grow$1 = Grow;
function getSnackbarContentUtilityClass(C) {
    return generateUtilityClass("MuiSnackbarContent", C)
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const _excluded$7 = ["action", "className", "message", "role"]
  , useUtilityClasses$1 = C=>{
    const {classes: S} = C;
    return composeClasses({
        root: ["root"],
        action: ["action"],
        message: ["message"]
    }, getSnackbarContentUtilityClass, S)
}
  , SnackbarContentRoot = styled(Paper$1, {
    name: "MuiSnackbarContent",
    slot: "Root",
    overridesResolver: (C,S)=>S.root
})(({theme: C})=>{
    const S = C.palette.mode === "light" ? .8 : .98
      , E = emphasize_1(C.palette.background.default, S);
    return _extends$3({}, C.typography.body2, {
        color: C.vars ? C.vars.palette.SnackbarContent.color : C.palette.getContrastText(E),
        backgroundColor: C.vars ? C.vars.palette.SnackbarContent.bg : E,
        display: "flex",
        alignItems: "center",
        flexWrap: "wrap",
        padding: "6px 16px",
        borderRadius: (C.vars || C).shape.borderRadius,
        flexGrow: 1,
        [C.breakpoints.up("sm")]: {
            flexGrow: "initial",
            minWidth: 288
        }
    })
}
)
  , SnackbarContentMessage = styled("div", {
    name: "MuiSnackbarContent",
    slot: "Message",
    overridesResolver: (C,S)=>S.message
})({
    padding: "8px 0"
})
  , SnackbarContentAction = styled("div", {
    name: "MuiSnackbarContent",
    slot: "Action",
    overridesResolver: (C,S)=>S.action
})({
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: 16,
    marginRight: -8
})
  , SnackbarContent = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiSnackbarContent"
    })
      , {action: T, className: $, message: B, role: O="alert"} = M
      , F = _objectWithoutPropertiesLoose(M, _excluded$7)
      , N = M
      , U = useUtilityClasses$1(N);
    return jsxRuntimeExports.jsxs(SnackbarContentRoot, _extends$3({
        role: O,
        square: !0,
        elevation: 6,
        className: clsx(U.root, $),
        ownerState: N,
        ref: E
    }, F, {
        children: [jsxRuntimeExports.jsx(SnackbarContentMessage, {
            className: U.message,
            ownerState: N,
            children: B
        }), T ? jsxRuntimeExports.jsx(SnackbarContentAction, {
            className: U.action,
            ownerState: N,
            children: T
        }) : null]
    }))
})
  , SnackbarContent$1 = SnackbarContent;
function getSnackbarUtilityClass(C) {
    return generateUtilityClass("MuiSnackbar", C)
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const _excluded$6 = ["onEnter", "onExited"]
  , _excluded2$1 = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"]
  , useUtilityClasses = C=>{
    const {classes: S, anchorOrigin: E} = C
      , M = {
        root: ["root", `anchorOrigin${capitalize$1(E.vertical)}${capitalize$1(E.horizontal)}`]
    };
    return composeClasses(M, getSnackbarUtilityClass, S)
}
  , SnackbarRoot = styled("div", {
    name: "MuiSnackbar",
    slot: "Root",
    overridesResolver: (C,S)=>{
        const {ownerState: E} = C;
        return [S.root, S[`anchorOrigin${capitalize$1(E.anchorOrigin.vertical)}${capitalize$1(E.anchorOrigin.horizontal)}`]]
    }
})(({theme: C, ownerState: S})=>{
    const E = {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
    };
    return _extends$3({
        zIndex: (C.vars || C).zIndex.snackbar,
        position: "fixed",
        display: "flex",
        left: 8,
        right: 8,
        justifyContent: "center",
        alignItems: "center"
    }, S.anchorOrigin.vertical === "top" ? {
        top: 8
    } : {
        bottom: 8
    }, S.anchorOrigin.horizontal === "left" && {
        justifyContent: "flex-start"
    }, S.anchorOrigin.horizontal === "right" && {
        justifyContent: "flex-end"
    }, {
        [C.breakpoints.up("sm")]: _extends$3({}, S.anchorOrigin.vertical === "top" ? {
            top: 24
        } : {
            bottom: 24
        }, S.anchorOrigin.horizontal === "center" && E, S.anchorOrigin.horizontal === "left" && {
            left: 24,
            right: "auto"
        }, S.anchorOrigin.horizontal === "right" && {
            right: 24,
            left: "auto"
        })
    })
}
)
  , Snackbar = reactExports.forwardRef(function C(S, E) {
    const M = useThemeProps$2({
        props: S,
        name: "MuiSnackbar"
    })
      , T = useTheme$1()
      , $ = {
        enter: T.transitions.duration.enteringScreen,
        exit: T.transitions.duration.leavingScreen
    }
      , {action: B, anchorOrigin: {vertical: O, horizontal: F}={
        vertical: "bottom",
        horizontal: "left"
    }, autoHideDuration: N=null, children: U, className: H, ClickAwayListenerProps: Z, ContentProps: J, disableWindowBlurListener: ie=!1, message: oe, open: ae, TransitionComponent: se=Grow$1, transitionDuration: le=$, TransitionProps: {onEnter: de, onExited: fe}={}} = M
      , pe = _objectWithoutPropertiesLoose(M.TransitionProps, _excluded$6)
      , ge = _objectWithoutPropertiesLoose(M, _excluded2$1)
      , we = _extends$3({}, M, {
        anchorOrigin: {
            vertical: O,
            horizontal: F
        },
        autoHideDuration: N,
        disableWindowBlurListener: ie,
        TransitionComponent: se,
        transitionDuration: le
    })
      , Ae = useUtilityClasses(we)
      , {getRootProps: Se, onClickAway: ue} = useSnackbar(_extends$3({}, we))
      , [V,W] = reactExports.useState(!0)
      , D = useSlotProps({
        elementType: SnackbarRoot,
        getSlotProps: Se,
        externalForwardedProps: ge,
        ownerState: we,
        additionalProps: {
            ref: E
        },
        className: [Ae.root, H]
    })
      , I = K=>{
        W(!0),
        fe && fe(K)
    }
      , L = (K,X)=>{
        W(!1),
        de && de(K, X)
    }
    ;
    return !ae && V ? null : jsxRuntimeExports.jsx(ClickAwayListener, _extends$3({
        onClickAway: ue
    }, Z, {
        children: jsxRuntimeExports.jsx(SnackbarRoot, _extends$3({}, D, {
            children: jsxRuntimeExports.jsx(se, _extends$3({
                appear: !0,
                in: ae,
                timeout: le,
                direction: O === "top" ? "down" : "up",
                onEnter: L,
                onExited: I
            }, pe, {
                children: U || jsxRuntimeExports.jsx(SnackbarContent$1, _extends$3({
                    message: oe,
                    action: B
                }, J))
            }))
        }))
    }))
})
  , Snackbar$1 = Snackbar
  , classes$4 = {}
  , AlertSnackbar = observer(({severity: C, title: S, body: E, duration: M=5e3, open: T, onClose: $})=>jsxRuntimeExports.jsx(Snackbar$1, {
    open: T,
    autoHideDuration: M,
    anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
    },
    onClose: $,
    children: jsxRuntimeExports.jsxs(Alert$1, {
        severity: C,
        className: classes$4.snackbarAlert,
        style: {
            fontSize: "8px"
        },
        children: [!!S && jsxRuntimeExports.jsx(AlertTitle$1, {
            children: S
        }), E]
    })
}));
observer(({hide: C, children: S})=>C ? null : S);
const modalInner = "_modalInner_1eoer_1"
  , modal = "_modal_1eoer_1"
  , container$1 = "_container_1eoer_19"
  , closeImg = "_closeImg_1eoer_23"
  , classes$3 = {
    modalInner,
    modal,
    container: container$1,
    closeImg
}
  , Modal = observer(({children: C, className: S, onClose: E, isOpen: M})=>jsxRuntimeExports.jsx(BaseModal, {
    disableScrollLock: !0,
    className: classes$3.modal,
    open: M,
    onClose: E,
    children: jsxRuntimeExports.jsx("div", {
        className: clsx(classes$3.modalInner, S),
        children: C
    })
}))
  , container = "_container_1y81e_9"
  , slide = "_slide_1y81e_1"
  , classes$2 = {
    container,
    slide
}
  , PageLayout = observer(({className: C, children: S})=>jsxRuntimeExports.jsx("div", {
    className: clsx(classes$2.page, C),
    style: {
        width: "100vw"
    },
    children: jsxRuntimeExports.jsx("div", {
        className: classes$2.container,
        children: S
    })
}))
  , txt = "_txt_jwdyc_1"
  , _sm = "__sm_jwdyc_4"
  , _md = "__md_jwdyc_7"
  , lg = "_lg_jwdyc_15"
  , classes$1 = {
    txt,
    _sm,
    _md,
    lg
}
  , Txt = observer(({children: C, size: S, className: E, ...M})=>jsxRuntimeExports.jsx("span", {
    className: clsx(E, classes$1.txt, {
        [classes$1._sm]: S === "sm",
        [classes$1._md]: S === "md",
        [classes$1._lg]: S === "lg"
    }),
    ...M,
    children: C
}));
function TransactionLoader({open: C, onClose: S}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(TransactionLoaderContainer, {
            onClose: S
        })
    })
}
function stringifyError(C) {
    if (typeof C == "string")
        return C;
    if (C instanceof Object && "reason"in C && typeof C.reason == "string")
        return C.reason || "Unknown error with empty reason";
    if (C instanceof Object && "code"in C && typeof C.code == "number" && "message"in C && typeof C.message == "string") {
        try {
            const E = JSON.parse(C.message);
            if (E.message)
                return E.message
        } catch {}
        return C.message
    }
    if (C instanceof Error)
        return C.stack ? C.stack : `${C.name}: ${C.message}`;
    let S;
    try {
        S = JSON.stringify(C),
        S === "{}" && (S = `${C}`)
    } catch {
        S = `${C}`
    }
    return S
}
function errorResponseToMessage(C) {
    return C ? `${C.message}${C.detail ? `: ${C.detail}` : ""}` : "received nullish error from the backend, but request was not successful"
}
function tap$1(C) {
    return S=>(C(S),
    S)
}
const storeRequestGeneric = (C,S,E,M,T,$)=>{
    if (T || !C.currentRequest) {
        C.isLoading = !0;
        const B = {
            id: C.requestCount++
        }
          , O = F=>{
            var N;
            ((N = C.currentRequest) == null ? void 0 : N.id) === B.id ? (C.currentRequest = void 0,
            C.isLoading = !1,
            F()) : $ == null || $()
        }
        ;
        B.req = S().then(tap$1(action$1(F=>{
            O(()=>{
                E(F)
            }
            )
        }
        ))).catch(action$1(F=>{
            O(()=>{
                M(F)
            }
            )
        }
        )),
        C.currentRequest = B
    } else
        $ == null || $()
}
  , storeRequest = (C,S,E,M)=>{
    const T = $=>{
        var B;
        (!(M != null && M.hideError) || typeof M.hideError == "function" && !M.hideError($)) && C.errorStore.showError($),
        (B = M == null ? void 0 : M.onError) == null || B.call(M, $)
    }
    ;
    storeRequestGeneric(C, S, action$1($=>{
        $.ok ? (C.isLoaded = !0,
        E($.data)) : T(errorResponseToMessage($))
    }
    ), action$1($=>{
        $ instanceof Response && "error"in $ ? T(errorResponseToMessage($)) : (console.error($),
        T(stringifyError($)))
    }
    ), M == null ? void 0 : M.cancel, M == null ? void 0 : M.onCancel)
}
;
class ConfigStore {
    constructor({errorStore: S}) {
        jt(this, "isActivated", !1);
        jt(this, "errorStore");
        jt(this, "isLoading", !1);
        jt(this, "isLoaded", !1);
        jt(this, "requestCount", 0);
        jt(this, "currentRequest");
        jt(this, "config");
        makeAutoObservable(this),
        this.errorStore = S
    }
    request() {
        storeRequest(this, ()=>api.v1StorageConfigList(), S=>{
            let E;
            ((S == null ? void 0 : S.fields_amount) ?? 0) < 2e4 && (E = 2e4),
            ((S == null ? void 0 : S.fields_amount) ?? 0) >= 2e4 && ((S == null ? void 0 : S.fields_amount) ?? 0) < 45e3 && (E = 45e3),
            ((S == null ? void 0 : S.fields_amount) ?? 0) >= 45e3 && ((S == null ? void 0 : S.fields_amount) ?? 0) < 75e3 && (E = 75e3),
            ((S == null ? void 0 : S.fields_amount) ?? 0) >= 75e3 && (E = 125e3),
            this.config = {
                ...S,
                field_per_stage: E ?? (S == null ? void 0 : S.field_per_stage)
            }
        }
        )
    }
    increaseFields(S) {
        var E;
        (E = this.config) != null && E.fields_amount && (this.config.fields_amount += S)
    }
    activate() {
        this.request()
    }
    reload() {
        console.log("RELOAD"),
        this.request()
    }
    reset() {
        this.isActivated = !1,
        this.isLoading = !1,
        this.isLoaded = !1,
        this.requestCount = 0,
        this.currentRequest = void 0,
        this.config = void 0
    }
    deactivate() {
        this.reset()
    }
}
class DialogRef {
    constructor(S, E) {
        jt(this, "closeListeners", []);
        this.id = S,
        this.dialogStore = E
    }
    close() {
        this.dialogStore.closeById(this.id)
    }
    onClose(S) {
        this.closeListeners.push(S)
    }
}
class DialogStore {
    constructor() {
        jt(this, "instances", []);
        jt(this, "count", 0);
        makeAutoObservable(this, {
            count: !1
        })
    }
    open(S) {
        this.count++;
        const E = this.count
          , M = new DialogRef(E,this);
        return this.instances.push({
            ...S,
            id: E,
            open: !0,
            onClose: ()=>{
                M.closeListeners.forEach(T=>T())
            }
        }),
        M
    }
    closeByIndex(S) {
        var M;
        if (S < 0)
            return;
        const E = this.instances[S];
        E.open = !1,
        (M = E.onClose) == null || M.call(E),
        setTimeout(action$1(()=>{
            this.instances = this.instances.filter(({id: T})=>T !== E.id)
        }
        ), 1e3)
    }
    closeById(S) {
        const E = this.instances.findIndex(M=>M.id === S);
        this.closeByIndex(E)
    }
    showError(S) {
        return this.open({
            Component: AlertSnackbar,
            props: {
                severity: "error",
                body: S
            }
        })
    }
    showSuccess(S) {
        return this.open({
            Component: AlertSnackbar,
            props: {
                severity: "success",
                body: S
            }
        })
    }
    showWarning(S) {
        return this.open({
            Component: AlertSnackbar,
            props: {
                severity: "warning",
                body: S
            }
        })
    }
    close(S) {
        const E = this.instances.findIndex(({Component: M})=>M === S);
        this.closeByIndex(E)
    }
    get openCount() {
        return this.instances.length
    }
}
class ErrorStore {
    constructor({dialogStore: S}) {
        jt(this, "dialogStore");
        jt(this, "showError", S=>{
            this.dialogStore.showError(S)
        }
        );
        this.dialogStore = S,
        makeAutoObservable(this, {
            dialogStore: !1
        })
    }
}
class MarketStore {
    constructor({errorStore: S}) {
        jt(this, "isActivated", !1);
        jt(this, "errorStore");
        jt(this, "isLoading", !1);
        jt(this, "isLoaded", !1);
        jt(this, "requestCount", 0);
        jt(this, "currentRequest");
        jt(this, "config");
        makeAutoObservable(this),
        this.errorStore = S
    }
    request() {
        storeRequest(this, ()=>api.v1StorageMarketList(), S=>{
            this.config = S
        }
        )
    }
    activate() {
        this.request()
    }
    reload() {
        this.request()
    }
    reset() {
        this.isActivated = !1,
        this.isLoading = !1,
        this.isLoaded = !1,
        this.requestCount = 0,
        this.currentRequest = void 0,
        this.config = void 0
    }
    deactivate() {
        this.reset()
    }
}
const limit = 10;
class OrdersStore {
    constructor({errorStore: S}) {
        jt(this, "sortParams");
        jt(this, "isActivated", !1);
        jt(this, "errorStore");
        jt(this, "isLoading", !1);
        jt(this, "isLoaded", !1);
        jt(this, "requestCount", 0);
        jt(this, "currentRequest");
        jt(this, "orders");
        jt(this, "offset", 0);
        jt(this, "total", 0);
        this.sortParams = {
            direction: "ASC",
            sort: "price"
        },
        makeAutoObservable(this),
        this.errorStore = S
    }
    request() {
        storeRequest(this, ()=>{
            var S, E;
            return api.v1OrdersActiveList({
                limit: limit.toString(),
                offset: "0",
                sort: this.sortParams.sort,
                direction: this.sortParams.direction,
                address: this.sortParams.address,
                from: (S = this.sortParams.filterParams) == null ? void 0 : S.from,
                to: (E = this.sortParams.filterParams) == null ? void 0 : E.to
            })
        }
        , S=>{
            this.orders = S.orders,
            this.offset += limit,
            this.total = S.total ?? 0
        }
        )
    }
    requestMore() {
        storeRequest(this, ()=>{
            var S, E;
            return api.v1OrdersActiveList({
                limit: limit.toString(),
                offset: this.offset.toString(),
                sort: this.sortParams.sort,
                direction: this.sortParams.direction,
                address: this.sortParams.address,
                from: (S = this.sortParams.filterParams) == null ? void 0 : S.from,
                to: (E = this.sortParams.filterParams) == null ? void 0 : E.to
            })
        }
        , S=>{
            S.orders && this.orders && (this.orders = [...this.orders, ...S.orders]),
            this.total = S.total ?? 0
        }
        )
    }
    get hasMore() {
        var S;
        return this.total > (((S = this.orders) == null ? void 0 : S.length) ?? 0)
    }
    activate() {
        this.request()
    }
    reset() {
        var S;
        this.isActivated = !1,
        this.isLoading = !1,
        this.isLoaded = !1,
        this.requestCount = 0,
        this.offset = 0,
        this.currentRequest = void 0,
        this.orders = (S = this.orders) == null ? void 0 : S.map(E=>({
            id: E.id
        }))
    }
    setSort(S) {
        this.sortParams.sort !== S && (this.sortParams.sort = S,
        this.reload())
    }
    setDirection(S) {
        this.sortParams.direction !== S && (this.sortParams.direction = S,
        this.reload())
    }
    setFromTo({from: S, to: E}) {
        console.log(S),
        console.log(E),
        this.sortParams.filterParams = {
            from: S,
            to: E
        },
        this.reload()
    }
    setAddress(S) {
        this.sortParams.address !== S && (this.sortParams.address = S,
        this.reload())
    }
    deactivate() {
        this.reset()
    }
    reload() {
        this.reset(),
        this.activate()
    }
}
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", {
    value: !0
});
var Api_1 = dist$1.Api = HttpClient_1 = dist$1.HttpClient = dist$1.ContentType = dist$1.PoolImplementationType = dist$1.JettonVerificationType = dist$1.BouncePhaseType = dist$1.ComputeSkipReason = dist$1.AccStatusChange = dist$1.TransactionType = dist$1.AccountStatus = void 0, AccountStatus;
(function(C) {
    C.Nonexist = "nonexist",
    C.Uninit = "uninit",
    C.Active = "active",
    C.Frozen = "frozen"
}
)(AccountStatus || (dist$1.AccountStatus = AccountStatus = {}));
var TransactionType;
(function(C) {
    C.TransOrd = "TransOrd",
    C.TransTickTock = "TransTickTock",
    C.TransSplitPrepare = "TransSplitPrepare",
    C.TransSplitInstall = "TransSplitInstall",
    C.TransMergePrepare = "TransMergePrepare",
    C.TransMergeInstall = "TransMergeInstall",
    C.TransStorage = "TransStorage"
}
)(TransactionType || (dist$1.TransactionType = TransactionType = {}));
var AccStatusChange;
(function(C) {
    C.AcstUnchanged = "acst_unchanged",
    C.AcstFrozen = "acst_frozen",
    C.AcstDeleted = "acst_deleted"
}
)(AccStatusChange || (dist$1.AccStatusChange = AccStatusChange = {}));
var ComputeSkipReason;
(function(C) {
    C.CskipNoState = "cskip_no_state",
    C.CskipBadState = "cskip_bad_state",
    C.CskipNoGas = "cskip_no_gas"
}
)(ComputeSkipReason || (dist$1.ComputeSkipReason = ComputeSkipReason = {}));
var BouncePhaseType;
(function(C) {
    C.TrPhaseBounceNegfunds = "TrPhaseBounceNegfunds",
    C.TrPhaseBounceNofunds = "TrPhaseBounceNofunds",
    C.TrPhaseBounceOk = "TrPhaseBounceOk"
}
)(BouncePhaseType || (dist$1.BouncePhaseType = BouncePhaseType = {}));
var JettonVerificationType;
(function(C) {
    C.Whitelist = "whitelist",
    C.Blacklist = "blacklist",
    C.None = "none"
}
)(JettonVerificationType || (dist$1.JettonVerificationType = JettonVerificationType = {}));
var PoolImplementationType;
(function(C) {
    C.Whales = "whales",
    C.Tf = "tf",
    C.LiquidTF = "liquidTF"
}
)(PoolImplementationType || (dist$1.PoolImplementationType = PoolImplementationType = {}));
var ContentType;
(function(C) {
    C.Json = "application/json",
    C.FormData = "multipart/form-data",
    C.UrlEncoded = "application/x-www-form-urlencoded",
    C.Text = "text/plain"
}
)(ContentType || (dist$1.ContentType = ContentType = {}));
class HttpClient {
    constructor(S={}) {
        jt(this, "baseUrl", "https://tonapi.io");
        jt(this, "securityData", null);
        jt(this, "securityWorker");
        jt(this, "abortControllers", new Map);
        jt(this, "customFetch", (...S)=>fetch(...S));
        jt(this, "baseApiParams", {
            credentials: "same-origin",
            headers: {},
            redirect: "follow",
            referrerPolicy: "no-referrer"
        });
        jt(this, "setSecurityData", S=>{
            this.securityData = S
        }
        );
        jt(this, "contentFormatters", {
            [ContentType.Json]: S=>S !== null && (typeof S == "object" || typeof S == "string") ? JSON.stringify(S) : S,
            [ContentType.Text]: S=>S !== null && typeof S != "string" ? JSON.stringify(S) : S,
            [ContentType.FormData]: S=>Object.keys(S || {}).reduce((E,M)=>{
                const T = S[M];
                return E.append(M, T instanceof Blob ? T : typeof T == "object" && T !== null ? JSON.stringify(T) : `${T}`),
                E
            }
            , new FormData),
            [ContentType.UrlEncoded]: S=>this.toQueryString(S)
        });
        jt(this, "createAbortSignal", S=>{
            if (this.abortControllers.has(S)) {
                const M = this.abortControllers.get(S);
                return M ? M.signal : void 0
            }
            const E = new AbortController;
            return this.abortControllers.set(S, E),
            E.signal
        }
        );
        jt(this, "abortRequest", S=>{
            const E = this.abortControllers.get(S);
            E && (E.abort(),
            this.abortControllers.delete(S))
        }
        );
        jt(this, "request", async({body: S, secure: E, path: M, type: T, query: $, format: B, baseUrl: O, cancelToken: F, ...N})=>{
            const U = (typeof E == "boolean" ? E : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {}
              , H = this.mergeRequestParams(N, U)
              , Z = $ && this.toQueryString($)
              , J = this.contentFormatters[T || ContentType.Json]
              , ie = B || H.format;
            return this.customFetch(`${O || this.baseUrl || ""}${M}${Z ? `?${Z}` : ""}`, {
                ...H,
                headers: {
                    ...H.headers || {},
                    ...T && T !== ContentType.FormData ? {
                        "Content-Type": T
                    } : {}
                },
                signal: (F ? this.createAbortSignal(F) : H.signal) || null,
                body: typeof S > "u" || S === null ? null : J(S)
            }).then(async oe=>{
                const ae = oe;
                ae.data = null,
                ae.error = null;
                const se = ie ? await oe[ie]().then(le=>(ae.ok ? ae.data = le : ae.error = le,
                ae)).catch(le=>(ae.error = le,
                ae)) : ae;
                if (F && this.abortControllers.delete(F),
                !oe.ok)
                    throw se;
                return se.data
            }
            )
        }
        );
        Object.assign(this, S)
    }
    encodeQueryParam(S, E) {
        return `${encodeURIComponent(S)}=${encodeURIComponent(typeof E == "number" ? E : `${E}`)}`
    }
    addQueryParam(S, E) {
        return this.encodeQueryParam(E, S[E])
    }
    addArrayQueryParam(S, E) {
        return S[E].map(T=>this.encodeQueryParam(E, T)).join("&")
    }
    toQueryString(S) {
        const E = S || {};
        return Object.keys(E).filter(T=>typeof E[T] < "u").map(T=>Array.isArray(E[T]) ? this.addArrayQueryParam(E, T) : this.addQueryParam(E, T)).join("&")
    }
    addQueryParams(S) {
        const E = this.toQueryString(S);
        return E ? `?${E}` : ""
    }
    mergeRequestParams(S, E) {
        return {
            ...this.baseApiParams,
            ...S,
            ...E || {},
            headers: {
                ...this.baseApiParams.headers || {},
                ...S.headers || {},
                ...E && E.headers || {}
            }
        }
    }
}
var HttpClient_1 = dist$1.HttpClient = HttpClient;
class Api {
    constructor(S) {
        jt(this, "http");
        jt(this, "blockchain", {
            reduceIndexingLatency: (S={})=>this.http.request({
                path: "/v2/status",
                method: "GET",
                format: "json",
                ...S
            }),
            getBlockchainBlock: (S,E={})=>this.http.request({
                path: `/v2/blockchain/blocks/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainMasterchainShards: (S,E={})=>this.http.request({
                path: `/v2/blockchain/masterchain/${S}/shards`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainMasterchainBlocks: (S,E={})=>this.http.request({
                path: `/v2/blockchain/masterchain/${S}/blocks`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainMasterchainTransactions: (S,E={})=>this.http.request({
                path: `/v2/blockchain/masterchain/${S}/transactions`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainConfigFromBlock: (S,E={})=>this.http.request({
                path: `/v2/blockchain/masterchain/${S}/config`,
                method: "GET",
                format: "json",
                ...E
            }),
            getRawBlockchainConfigFromBlock: (S,E={})=>this.http.request({
                path: `/v2/blockchain/masterchain/${S}/config/raw`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainBlockTransactions: (S,E={})=>this.http.request({
                path: `/v2/blockchain/blocks/${S}/transactions`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainTransaction: (S,E={})=>this.http.request({
                path: `/v2/blockchain/transactions/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainTransactionByMessageHash: (S,E={})=>this.http.request({
                path: `/v2/blockchain/messages/${S}/transaction`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainValidators: (S={})=>this.http.request({
                path: "/v2/blockchain/validators",
                method: "GET",
                format: "json",
                ...S
            }),
            getBlockchainMasterchainHead: (S={})=>this.http.request({
                path: "/v2/blockchain/masterchain-head",
                method: "GET",
                format: "json",
                ...S
            }),
            getBlockchainRawAccount: (S,E={})=>this.http.request({
                path: `/v2/blockchain/accounts/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getBlockchainAccountTransactions: (S,E,M={})=>this.http.request({
                path: `/v2/blockchain/accounts/${S}/transactions`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            execGetMethodForBlockchainAccount: (S,E,M,T={})=>this.http.request({
                path: `/v2/blockchain/accounts/${S}/methods/${E}`,
                method: "GET",
                query: M,
                format: "json",
                ...T
            }),
            sendBlockchainMessage: (S,E={})=>this.http.request({
                path: "/v2/blockchain/message",
                method: "POST",
                body: S,
                ...E
            }),
            getBlockchainConfig: (S={})=>this.http.request({
                path: "/v2/blockchain/config",
                method: "GET",
                format: "json",
                ...S
            }),
            getRawBlockchainConfig: (S={})=>this.http.request({
                path: "/v2/blockchain/config/raw",
                method: "GET",
                format: "json",
                ...S
            }),
            blockchainAccountInspect: (S,E={})=>this.http.request({
                path: `/v2/blockchain/accounts/${S}/inspect`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        jt(this, "emulation", {
            decodeMessage: (S,E={})=>this.http.request({
                path: "/v2/message/decode",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            emulateMessageToEvent: (S,E,M={})=>this.http.request({
                path: "/v2/events/emulate",
                method: "POST",
                query: E,
                body: S,
                format: "json",
                ...M
            }),
            emulateMessageToTrace: (S,E,M={})=>this.http.request({
                path: "/v2/traces/emulate",
                method: "POST",
                query: E,
                body: S,
                format: "json",
                ...M
            }),
            emulateMessageToWallet: (S,E={})=>this.http.request({
                path: "/v2/wallet/emulate",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            emulateMessageToAccountEvent: (S,E,M,T={})=>this.http.request({
                path: `/v2/accounts/${S}/events/emulate`,
                method: "POST",
                query: M,
                body: E,
                format: "json",
                ...T
            })
        });
        jt(this, "accounts", {
            addressParse: (S,E={})=>this.http.request({
                path: `/v2/address/${S}/parse`,
                method: "GET",
                format: "json",
                ...E
            }),
            getAccounts: (S,E={})=>this.http.request({
                path: "/v2/accounts/_bulk",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            getAccount: (S,E={})=>this.http.request({
                path: `/v2/accounts/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            accountDnsBackResolve: (S,E={})=>this.http.request({
                path: `/v2/accounts/${S}/dns/backresolve`,
                method: "GET",
                format: "json",
                ...E
            }),
            getAccountJettonsBalances: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/jettons`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountJettonsHistory: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/jettons/history`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountJettonHistoryById: (S,E,M,T={})=>this.http.request({
                path: `/v2/accounts/${S}/jettons/${E}/history`,
                method: "GET",
                query: M,
                format: "json",
                ...T
            }),
            getAccountNftItems: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/nfts`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountEvents: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/events`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountEvent: (S,E,M,T={})=>this.http.request({
                path: `/v2/accounts/${S}/events/${E}`,
                method: "GET",
                query: M,
                format: "json",
                ...T
            }),
            getAccountTraces: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/traces`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountSubscriptions: (S,E={})=>this.http.request({
                path: `/v2/accounts/${S}/subscriptions`,
                method: "GET",
                format: "json",
                ...E
            }),
            reindexAccount: (S,E={})=>this.http.request({
                path: `/v2/accounts/${S}/reindex`,
                method: "POST",
                ...E
            }),
            searchAccounts: (S,E={})=>this.http.request({
                path: "/v2/accounts/search",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getAccountDnsExpiring: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/dns/expiring`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountPublicKey: (S,E={})=>this.http.request({
                path: `/v2/accounts/${S}/publickey`,
                method: "GET",
                format: "json",
                ...E
            }),
            getAccountDiff: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/diff`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            })
        });
        jt(this, "nft", {
            getAccountNftHistory: (S,E,M={})=>this.http.request({
                path: `/v2/accounts/${S}/nfts/history`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getNftCollections: (S,E={})=>this.http.request({
                path: "/v2/nfts/collections",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getNftCollection: (S,E={})=>this.http.request({
                path: `/v2/nfts/collections/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getItemsFromCollection: (S,E,M={})=>this.http.request({
                path: `/v2/nfts/collections/${S}/items`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getNftItemsByAddresses: (S,E={})=>this.http.request({
                path: "/v2/nfts/_bulk",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            getNftItemByAddress: (S,E={})=>this.http.request({
                path: `/v2/nfts/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getNftHistoryById: (S,E,M={})=>this.http.request({
                path: `/v2/nfts/${S}/history`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            })
        });
        jt(this, "dns", {
            getDnsInfo: (S,E={})=>this.http.request({
                path: `/v2/dns/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            dnsResolve: (S,E={})=>this.http.request({
                path: `/v2/dns/${S}/resolve`,
                method: "GET",
                format: "json",
                ...E
            }),
            getDomainBids: (S,E={})=>this.http.request({
                path: `/v2/dns/${S}/bids`,
                method: "GET",
                format: "json",
                ...E
            }),
            getAllAuctions: (S,E={})=>this.http.request({
                path: "/v2/dns/auctions",
                method: "GET",
                query: S,
                format: "json",
                ...E
            })
        });
        jt(this, "traces", {
            getTrace: (S,E={})=>this.http.request({
                path: `/v2/traces/${S}`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        jt(this, "events", {
            getEvent: (S,E={})=>this.http.request({
                path: `/v2/events/${S}`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        jt(this, "inscriptions", {
            getAccountInscriptions: (S,E,M={})=>this.http.request({
                path: `/v2/experimental/accounts/${S}/inscriptions`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountInscriptionsHistory: (S,E,M={})=>this.http.request({
                path: `/v2/experimental/accounts/${S}/inscriptions/history`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAccountInscriptionsHistoryByTicker: (S,E,M,T={})=>this.http.request({
                path: `/v2/experimental/accounts/${S}/inscriptions/${E}/history`,
                method: "GET",
                query: M,
                format: "json",
                ...T
            }),
            getInscriptionOpTemplate: (S,E={})=>this.http.request({
                path: "/v2/experimental/inscriptions/op-template",
                method: "GET",
                query: S,
                format: "json",
                ...E
            })
        });
        jt(this, "jettons", {
            getJettons: (S,E={})=>this.http.request({
                path: "/v2/jettons",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getJettonInfo: (S,E={})=>this.http.request({
                path: `/v2/jettons/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getJettonHolders: (S,E,M={})=>this.http.request({
                path: `/v2/jettons/${S}/holders`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getJettonsEvents: (S,E={})=>this.http.request({
                path: `/v2/events/${S}/jettons`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        jt(this, "staking", {
            getAccountNominatorsPools: (S,E={})=>this.http.request({
                path: `/v2/staking/nominator/${S}/pools`,
                method: "GET",
                format: "json",
                ...E
            }),
            getStakingPoolInfo: (S,E={})=>this.http.request({
                path: `/v2/staking/pool/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getStakingPoolHistory: (S,E={})=>this.http.request({
                path: `/v2/staking/pool/${S}/history`,
                method: "GET",
                format: "json",
                ...E
            }),
            getStakingPools: (S,E={})=>this.http.request({
                path: "/v2/staking/pools",
                method: "GET",
                query: S,
                format: "json",
                ...E
            })
        });
        jt(this, "storage", {
            getStorageProviders: (S={})=>this.http.request({
                path: "/v2/storage/providers",
                method: "GET",
                format: "json",
                ...S
            })
        });
        jt(this, "rates", {
            getRates: (S,E={})=>this.http.request({
                path: "/v2/rates",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getChartRates: (S,E={})=>this.http.request({
                path: "/v2/rates/chart",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getMarketsRates: (S={})=>this.http.request({
                path: "/v2/rates/markets",
                method: "GET",
                format: "json",
                ...S
            })
        });
        jt(this, "connect", {
            getTonConnectPayload: (S={})=>this.http.request({
                path: "/v2/tonconnect/payload",
                method: "GET",
                format: "json",
                ...S
            }),
            getAccountInfoByStateInit: (S,E={})=>this.http.request({
                path: "/v2/tonconnect/stateinit",
                method: "POST",
                body: S,
                format: "json",
                ...E
            })
        });
        jt(this, "wallet", {
            getWalletBackup: (S={})=>this.http.request({
                path: "/v2/wallet/backup",
                method: "GET",
                format: "json",
                ...S
            }),
            setWalletBackup: (S,E={})=>this.http.request({
                path: "/v2/wallet/backup",
                method: "PUT",
                body: S,
                ...E
            }),
            tonConnectProof: (S,E={})=>this.http.request({
                path: "/v2/wallet/auth/proof",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            getWalletsByPublicKey: (S,E={})=>this.http.request({
                path: `/v2/pubkeys/${S}/wallets`,
                method: "GET",
                format: "json",
                ...E
            }),
            getAccountSeqno: (S,E={})=>this.http.request({
                path: `/v2/wallet/${S}/seqno`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        jt(this, "liteServer", {
            getRawMasterchainInfo: (S={})=>this.http.request({
                path: "/v2/liteserver/get_masterchain_info",
                method: "GET",
                format: "json",
                ...S
            }),
            getRawMasterchainInfoExt: (S,E={})=>this.http.request({
                path: "/v2/liteserver/get_masterchain_info_ext",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getRawTime: (S={})=>this.http.request({
                path: "/v2/liteserver/get_time",
                method: "GET",
                format: "json",
                ...S
            }),
            getRawBlockchainBlock: (S,E={})=>this.http.request({
                path: `/v2/liteserver/get_block/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getRawBlockchainBlockState: (S,E={})=>this.http.request({
                path: `/v2/liteserver/get_state/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getRawBlockchainBlockHeader: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/get_block_header/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            sendRawMessage: (S,E={})=>this.http.request({
                path: "/v2/liteserver/send_message",
                method: "POST",
                body: S,
                format: "json",
                ...E
            }),
            getRawAccountState: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/get_account_state/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getRawShardInfo: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/get_shard_info/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getAllRawShardsInfo: (S,E={})=>this.http.request({
                path: `/v2/liteserver/get_all_shards_info/${S}`,
                method: "GET",
                format: "json",
                ...E
            }),
            getRawTransactions: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/get_transactions/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getRawListBlockTransactions: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/list_block_transactions/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getRawBlockProof: (S,E={})=>this.http.request({
                path: "/v2/liteserver/get_block_proof",
                method: "GET",
                query: S,
                format: "json",
                ...E
            }),
            getRawConfig: (S,E,M={})=>this.http.request({
                path: `/v2/liteserver/get_config_all/${S}`,
                method: "GET",
                query: E,
                format: "json",
                ...M
            }),
            getRawShardBlockProof: (S,E={})=>this.http.request({
                path: `/v2/liteserver/get_shard_block_proof/${S}`,
                method: "GET",
                format: "json",
                ...E
            })
        });
        this.http = S
    }
}
Api_1 = dist$1.Api = Api;
const httpClient = new HttpClient_1({
    baseUrl: "https://testnet.tonapi.io/",
    baseApiParams: {
        headers: {
            Authorization: "Bearer AG2S7LKL4PTNZNYAAAAOYXZZNFSEOVFQCXXPJ7AWCIVBWN6M6LU36AAJMM3LYA7RSQSMPSA",
            "Content-type": "application/json"
        }
    }
})
  , client = new Api_1(httpClient);
class TokenCurrencyStore {
    constructor() {
        jt(this, "currency");
        jt(this, "isActivated", !1);
        makeAutoObservable(this)
    }
    async activate() {
        var S;
        this.currency = (S = (await client.rates.getRates({
            tokens: ["ton"],
            currencies: ["usd"]
        })).rates.TON.prices) == null ? void 0 : S.USD
    }
    convert(S) {
        return this.currency ? this.currency * S : 0
    }
    reset() {
        this.currency = 0
    }
    deactivate() {
        this.reset()
    }
}
class TonUserStore {
    constructor() {
        jt(this, "balance", 0n);
        jt(this, "isActivated", !1);
        makeAutoObservable(this)
    }
    async activate(S) {
        if (console.log(S),
        S === "" || !dist$4.Address.isFriendly(S))
            return;
        console.log("REQ");
        const E = await getClient();
        this.balance = await E.getBalance(dist$4.Address.parse(S))
    }
    reset() {
        this.balance = 0n,
        this.isActivated = !1
    }
    deactivate() {
        this.reset()
    }
}
class UserStore {
    constructor({errorStore: S}) {
        jt(this, "isActivated", !1);
        jt(this, "errorStore");
        jt(this, "isLoading", !1);
        jt(this, "isLoaded", !1);
        jt(this, "requestCount", 0);
        jt(this, "currentRequest");
        jt(this, "user");
        jt(this, "address");
        makeAutoObservable(this),
        this.errorStore = S
    }
    requestCreate(S, E) {
        storeRequest(this, ()=>api.v1UsersCreateCreate(S), M=>{
            this.user = M,
            E == null || E()
        }
        , {
            hideError: !0
        })
    }
    requestInfo(S, E, M) {
        storeRequest(this, ()=>api.v1UsersUserDetail(S), T=>{
            this.user = T,
            M == null || M()
        }
        , {
            onError: ()=>{
                this.requestCreate({
                    address: S,
                    ...E
                }, M)
            }
            ,
            hideError: !0
        })
    }
    increaseFields(S) {
        var E;
        (E = this.user) != null && E.fields_amount && (this.user.fields_amount += S)
    }
    decreasePotato(S) {
        var E;
        (E = this.user) != null && E.potato_amount && (this.user.potato_amount -= S)
    }
    activate({address: S, ...E}, M) {
        S === "" || !dist$4.Address.isFriendly(S) || (this.address = S,
        this.requestInfo(S, E, M))
    }
    reset() {
        this.isActivated = !1,
        this.isLoading = !1,
        this.isLoaded = !1,
        this.requestCount = 0,
        this.currentRequest = void 0,
        this.user = void 0
    }
    reload() {
        this.address && this.activate({
            address: this.address
        })
    }
    deactivate() {
        this.reset()
    }
}
enableStaticRendering(typeof window > "u");
class RootStore {
    constructor() {
        jt(this, "errorStore");
        jt(this, "dialogStore");
        jt(this, "userStore");
        jt(this, "tokenCurrencyStore");
        jt(this, "tonUserStore");
        jt(this, "configStore");
        jt(this, "ordersStore");
        jt(this, "marketStore");
        this.dialogStore = new DialogStore,
        this.tonUserStore = new TonUserStore,
        this.tokenCurrencyStore = new TokenCurrencyStore,
        this.errorStore = new ErrorStore(this),
        this.userStore = new UserStore(this),
        this.configStore = new ConfigStore(this),
        this.ordersStore = new OrdersStore(this),
        this.marketStore = new MarketStore(this)
    }
}
new RootStore;
let store;
function initializeStore() {
    const C = store ?? new RootStore;
    return typeof window > "u" || store || (store = C),
    C
}
const StoreContext = reactExports.createContext(initializeStore());
function useStores() {
    const C = reactExports.useContext(StoreContext);
    if (C === void 0)
        throw new Error("useStore must be used within StoreProvider");
    return C
}
const StoreProvider = observer(({children: C})=>{
    const S = initializeStore();
    return jsxRuntimeExports.jsx(StoreContext.Provider, {
        value: S,
        children: C
    })
}
);
function useStatusState() {
    const {dialogStore: C} = useStores()
      , [S,E] = reactExports.useState(!1)
      , [M,T] = reactExports.useState()
      , [$,B] = reactExports.useState()
      , O = reactExports.useCallback(()=>C.open({
        Component: TransactionLoader
    }), [C])
      , F = reactExports.useCallback(N=>async U=>{
        E(!0),
        T(void 0),
        B(void 0);
        const H = O();
        try {
            const Z = await N(U);
            return E(!1),
            B(Z),
            H == null || H.close(),
            Z
        } catch (Z) {
            throw E(!1),
            T(JSON.stringify(Z)),
            H == null || H.close(),
            Z
        } finally {}
    }
    , [E, T, B]);
    return {
        statuses: {
            isLoading: S,
            error: M,
            result: $
        },
        setIsLoading: E,
        setError: T,
        setResult: B,
        wrapPromise: F
    }
}
const useBuy = ()=>{
    const [C] = useTonConnectUI()
      , {isConnected: S, connect: E} = useConnectWallet()
      , {wrapPromise: M} = useStatusState()
      , T = useTonAddress();
    return {
        buy: reactExports.useCallback(M(async({onSuccess: O, seller: F, price: N, id: U, onError: H})=>{
            if (!S || T === "") {
                await E();
                return
            }
            if ((await api.v1OrdersDetail(U.toString())).data.status !== OrderStatus.Open) {
                H == null || H();
                return
            }
            if ((await api.v1OrdersUpdateCreate({
                buyer_address: T,
                order_id: U.toString()
            })).data.status !== OrderStatus.InProgress) {
                H == null || H();
                return
            }
            C.setConnectRequestParameters({
                state: "loading"
            }),
            await C.sendTransaction({
                validUntil: Date.now() + 5 * 60 * 1e3,
                messages: [{
                    address: "EQBgmi4dsim7qBiu_6rzPnJaj7s9FlKKYDNkXwaivQmIhhxb",
                    amount: dist$4.toNano(N * 1.01 + .1).toString(),
                    payload: dist$4.beginCell().store(storeBuyPotato({
                        $$type: "BuyPotato",
                        sellerAddress: F,
                        price: dist$4.toNano(N),
                        id: BigInt(U)
                    })).endCell().toBoc().toString("base64")
                }]
            }),
            console.log(dist$4.toNano(N)),
            await waitTx(dist$4.Address.parse(T)),
            C.setConnectRequestParameters(null),
            O == null || O()
        }
        ), [S, E, C, T, "EQBg_6NAPwh63Pm2Ynurj3p629DET-SP8bKfY75SuuwvOjBS"])
    }
}
  , useCreateOrder = ()=>{
    const {isConnected: C} = useConnectWallet()
      , {wrapPromise: S} = useStatusState()
      , {userStore: E} = useStores()
      , M = useTonAddress();
    return {
        create: reactExports.useCallback(S(async({onSuccess: $, order: B})=>{
            if (!C || M === "" || !E.user)
                return;
            const O = await api.v1OrdersCreateCreate(B);
            $ == null || $(O.data)
        }
        ), [C, M])
    }
}
  , CreatOrderButton = ()=>{
    const C = useTonAddress()
      , S = reactExports.useCallback(async()=>{}
    , [C]);
    return jsxRuntimeExports.jsx("button", {
        onClick: ()=>{
            S()
        }
        ,
        children: "Create"
    })
}
;
var warned = {}
  , preMessage = function C(S) {};
function warning$1(C, S) {}
function note(C, S) {}
function resetWarned() {
    warned = {}
}
function call(C, S, E) {
    !S && !warned[E] && (C(!1, E),
    warned[E] = !0)
}
function warningOnce(C, S) {
    call(warning$1, C, S)
}
function noteOnce(C, S) {
    call(note, C, S)
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
function _defineProperty(C, S, E) {
    return S = toPropertyKey(S),
    S in C ? Object.defineProperty(C, S, {
        value: E,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : C[S] = E,
    C
}
function ownKeys(C, S) {
    var E = Object.keys(C);
    if (Object.getOwnPropertySymbols) {
        var M = Object.getOwnPropertySymbols(C);
        S && (M = M.filter(function(T) {
            return Object.getOwnPropertyDescriptor(C, T).enumerable
        })),
        E.push.apply(E, M)
    }
    return E
}
function _objectSpread2(C) {
    for (var S = 1; S < arguments.length; S++) {
        var E = arguments[S] != null ? arguments[S] : {};
        S % 2 ? ownKeys(Object(E), !0).forEach(function(M) {
            _defineProperty(C, M, E[M])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(C, Object.getOwnPropertyDescriptors(E)) : ownKeys(Object(E)).forEach(function(M) {
            Object.defineProperty(C, M, Object.getOwnPropertyDescriptor(E, M))
        })
    }
    return C
}
function isDOM(C) {
    return C instanceof HTMLElement || C instanceof SVGElement
}
function findDOMNode(C) {
    return isDOM(C) ? C : C instanceof React$1.Component ? ReactDOM.findDOMNode(C) : null
}
function useMemo(C, S, E) {
    var M = reactExports.useRef({});
    return (!("value"in M.current) || E(M.current.condition, S)) && (M.current.value = C(),
    M.current.condition = S),
    M.current.value
}
function fillRef(C, S) {
    typeof C == "function" ? C(S) : _typeof(C) === "object" && C && "current"in C && (C.current = S)
}
function supportRef(C) {
    var S, E, M = reactIsExports.isMemo(C) ? C.type.type : C.type;
    return !(typeof M == "function" && !((S = M.prototype) !== null && S !== void 0 && S.render) && M.$$typeof !== reactIsExports.ForwardRef || typeof C == "function" && !((E = C.prototype) !== null && E !== void 0 && E.render) && C.$$typeof !== reactIsExports.ForwardRef)
}
function _classCallCheck(C, S) {
    if (!(C instanceof S))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties(C, S) {
    for (var E = 0; E < S.length; E++) {
        var M = S[E];
        M.enumerable = M.enumerable || !1,
        M.configurable = !0,
        "value"in M && (M.writable = !0),
        Object.defineProperty(C, toPropertyKey(M.key), M)
    }
}
function _createClass(C, S, E) {
    return S && _defineProperties(C.prototype, S),
    E && _defineProperties(C, E),
    Object.defineProperty(C, "prototype", {
        writable: !1
    }),
    C
}
function _inherits(C, S) {
    if (typeof S != "function" && S !== null)
        throw new TypeError("Super expression must either be null or a function");
    C.prototype = Object.create(S && S.prototype, {
        constructor: {
            value: C,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(C, "prototype", {
        writable: !1
    }),
    S && _setPrototypeOf(C, S)
}
function _getPrototypeOf(C) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
        return E.__proto__ || Object.getPrototypeOf(E)
    }
    ,
    _getPrototypeOf(C)
}
function _isNativeReflectConstruct() {
    try {
        var C = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (_isNativeReflectConstruct = function() {
        return !!C
    }
    )()
}
function _possibleConstructorReturn(C, S) {
    if (S && (_typeof(S) === "object" || typeof S == "function"))
        return S;
    if (S !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(C)
}
function _createSuper(C) {
    var S = _isNativeReflectConstruct();
    return function() {
        var M = _getPrototypeOf(C), T;
        if (S) {
            var $ = _getPrototypeOf(this).constructor;
            T = Reflect.construct(M, arguments, $)
        } else
            T = M.apply(this, arguments);
        return _possibleConstructorReturn(this, T)
    }
}
function _arrayLikeToArray(C, S) {
    (S == null || S > C.length) && (S = C.length);
    for (var E = 0, M = new Array(S); E < S; E++)
        M[E] = C[E];
    return M
}
function _arrayWithoutHoles(C) {
    if (Array.isArray(C))
        return _arrayLikeToArray(C)
}
function _iterableToArray(C) {
    if (typeof Symbol < "u" && C[Symbol.iterator] != null || C["@@iterator"] != null)
        return Array.from(C)
}
function _unsupportedIterableToArray(C, S) {
    if (C) {
        if (typeof C == "string")
            return _arrayLikeToArray(C, S);
        var E = Object.prototype.toString.call(C).slice(8, -1);
        if (E === "Object" && C.constructor && (E = C.constructor.name),
        E === "Map" || E === "Set")
            return Array.from(C);
        if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E))
            return _arrayLikeToArray(C, S)
    }
}
function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function _toConsumableArray(C) {
    return _arrayWithoutHoles(C) || _iterableToArray(C) || _unsupportedIterableToArray(C) || _nonIterableSpread()
}
var raf = function C(S) {
    return +setTimeout(S, 16)
}
  , caf = function C(S) {
    return clearTimeout(S)
};
typeof window < "u" && "requestAnimationFrame"in window && (raf = function(S) {
    return window.requestAnimationFrame(S)
}
,
caf = function(S) {
    return window.cancelAnimationFrame(S)
}
);
var rafUUID = 0
  , rafIds = new Map;
function cleanup(C) {
    rafIds.delete(C)
}
var wrapperRaf = function C(S) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    var M = rafUUID;
    function T($) {
        if ($ === 0)
            cleanup(M),
            S();
        else {
            var B = raf(function() {
                T($ - 1)
            });
            rafIds.set(M, B)
        }
    }
    return T(E),
    M
};
wrapperRaf.cancel = function(C) {
    var S = rafIds.get(C);
    return cleanup(C),
    caf(S)
}
;
function _arrayWithHoles(C) {
    if (Array.isArray(C))
        return C
}
function _iterableToArrayLimit(C, S) {
    var E = C == null ? null : typeof Symbol < "u" && C[Symbol.iterator] || C["@@iterator"];
    if (E != null) {
        var M, T, $, B, O = [], F = !0, N = !1;
        try {
            if ($ = (E = E.call(C)).next,
            S === 0) {
                if (Object(E) !== E)
                    return;
                F = !1
            } else
                for (; !(F = (M = $.call(E)).done) && (O.push(M.value),
                O.length !== S); F = !0)
                    ;
        } catch (U) {
            N = !0,
            T = U
        } finally {
            try {
                if (!F && E.return != null && (B = E.return(),
                Object(B) !== B))
                    return
            } finally {
                if (N)
                    throw T
            }
        }
        return O
    }
}
function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function _slicedToArray(C, S) {
    return _arrayWithHoles(C) || _iterableToArrayLimit(C, S) || _unsupportedIterableToArray(C, S) || _nonIterableRest()
}
function murmur2(C) {
    for (var S = 0, E, M = 0, T = C.length; T >= 4; ++M,
    T -= 4)
        E = C.charCodeAt(M) & 255 | (C.charCodeAt(++M) & 255) << 8 | (C.charCodeAt(++M) & 255) << 16 | (C.charCodeAt(++M) & 255) << 24,
        E = (E & 65535) * 1540483477 + ((E >>> 16) * 59797 << 16),
        E ^= E >>> 24,
        S = (E & 65535) * 1540483477 + ((E >>> 16) * 59797 << 16) ^ (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16);
    switch (T) {
    case 3:
        S ^= (C.charCodeAt(M + 2) & 255) << 16;
    case 2:
        S ^= (C.charCodeAt(M + 1) & 255) << 8;
    case 1:
        S ^= C.charCodeAt(M) & 255,
        S = (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16)
    }
    return S ^= S >>> 13,
    S = (S & 65535) * 1540483477 + ((S >>> 16) * 59797 << 16),
    ((S ^ S >>> 15) >>> 0).toString(36)
}
function canUseDom() {
    return !!(typeof window < "u" && window.document && window.document.createElement)
}
function contains(C, S) {
    if (!C)
        return !1;
    if (C.contains)
        return C.contains(S);
    for (var E = S; E; ) {
        if (E === C)
            return !0;
        E = E.parentNode
    }
    return !1
}
var APPEND_ORDER = "data-rc-order"
  , APPEND_PRIORITY = "data-rc-priority"
  , MARK_KEY = "rc-util-key"
  , containerCache = new Map;
function getMark() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , S = C.mark;
    return S ? S.startsWith("data-") ? S : "data-".concat(S) : MARK_KEY
}
function getContainer(C) {
    if (C.attachTo)
        return C.attachTo;
    var S = document.querySelector("head");
    return S || document.body
}
function getOrder(C) {
    return C === "queue" ? "prependQueue" : C ? "prepend" : "append"
}
function findStyles(C) {
    return Array.from((containerCache.get(C) || C).children).filter(function(S) {
        return S.tagName === "STYLE"
    })
}
function injectCSS(C) {
    var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom())
        return null;
    var E = S.csp
      , M = S.prepend
      , T = S.priority
      , $ = T === void 0 ? 0 : T
      , B = getOrder(M)
      , O = B === "prependQueue"
      , F = document.createElement("style");
    F.setAttribute(APPEND_ORDER, B),
    O && $ && F.setAttribute(APPEND_PRIORITY, "".concat($)),
    E != null && E.nonce && (F.nonce = E == null ? void 0 : E.nonce),
    F.innerHTML = C;
    var N = getContainer(S)
      , U = N.firstChild;
    if (M) {
        if (O) {
            var H = (S.styles || findStyles(N)).filter(function(Z) {
                if (!["prepend", "prependQueue"].includes(Z.getAttribute(APPEND_ORDER)))
                    return !1;
                var J = Number(Z.getAttribute(APPEND_PRIORITY) || 0);
                return $ >= J
            });
            if (H.length)
                return N.insertBefore(F, H[H.length - 1].nextSibling),
                F
        }
        N.insertBefore(F, U)
    } else
        N.appendChild(F);
    return F
}
function findExistNode(C) {
    var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , E = getContainer(S);
    return (S.styles || findStyles(E)).find(function(M) {
        return M.getAttribute(getMark(S)) === C
    })
}
function removeCSS(C) {
    var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , E = findExistNode(C, S);
    if (E) {
        var M = getContainer(S);
        M.removeChild(E)
    }
}
function syncRealContainer(C, S) {
    var E = containerCache.get(C);
    if (!E || !contains(document, E)) {
        var M = injectCSS("", S)
          , T = M.parentNode;
        containerCache.set(C, T),
        C.removeChild(M)
    }
}
function updateCSS(C, S) {
    var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , M = getContainer(E)
      , T = findStyles(M)
      , $ = _objectSpread2(_objectSpread2({}, E), {}, {
        styles: T
    });
    syncRealContainer(M, $);
    var B = findExistNode(S, $);
    if (B) {
        var O, F;
        if ((O = $.csp) !== null && O !== void 0 && O.nonce && B.nonce !== ((F = $.csp) === null || F === void 0 ? void 0 : F.nonce)) {
            var N;
            B.nonce = (N = $.csp) === null || N === void 0 ? void 0 : N.nonce
        }
        return B.innerHTML !== C && (B.innerHTML = C),
        B
    }
    var U = injectCSS(C, $);
    return U.setAttribute(getMark($), S),
    U
}
function _objectWithoutProperties(C, S) {
    if (C == null)
        return {};
    var E = _objectWithoutPropertiesLoose(C, S), M, T;
    if (Object.getOwnPropertySymbols) {
        var $ = Object.getOwnPropertySymbols(C);
        for (T = 0; T < $.length; T++)
            M = $[T],
            !(S.indexOf(M) >= 0) && Object.prototype.propertyIsEnumerable.call(C, M) && (E[M] = C[M])
    }
    return E
}
function isEqual(C, S) {
    var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
      , M = new Set;
    function T($, B) {
        var O = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
          , F = M.has($);
        if (warningOnce(!F, "Warning: There may be circular references"),
        F)
            return !1;
        if ($ === B)
            return !0;
        if (E && O > 1)
            return !1;
        M.add($);
        var N = O + 1;
        if (Array.isArray($)) {
            if (!Array.isArray(B) || $.length !== B.length)
                return !1;
            for (var U = 0; U < $.length; U++)
                if (!T($[U], B[U], N))
                    return !1;
            return !0
        }
        if ($ && B && _typeof($) === "object" && _typeof(B) === "object") {
            var H = Object.keys($);
            return H.length !== Object.keys(B).length ? !1 : H.every(function(Z) {
                return T($[Z], B[Z], N)
            })
        }
        return !1
    }
    return T(C, S)
}
var SPLIT = "%";
function pathKey(C) {
    return C.join(SPLIT)
}
var Entity = function() {
    function C(S) {
        _classCallCheck(this, C),
        _defineProperty(this, "instanceId", void 0),
        _defineProperty(this, "cache", new Map),
        this.instanceId = S
    }
    return _createClass(C, [{
        key: "get",
        value: function(E) {
            return this.opGet(pathKey(E))
        }
    }, {
        key: "opGet",
        value: function(E) {
            return this.cache.get(E) || null
        }
    }, {
        key: "update",
        value: function(E, M) {
            return this.opUpdate(pathKey(E), M)
        }
    }, {
        key: "opUpdate",
        value: function(E, M) {
            var T = this.cache.get(E)
              , $ = M(T);
            $ === null ? this.cache.delete(E) : this.cache.set(E, $)
        }
    }]),
    C
}()
  , ATTR_TOKEN = "data-token-hash"
  , ATTR_MARK = "data-css-hash"
  , CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
    var C = Math.random().toString(12).slice(2);
    if (typeof document < "u" && document.head && document.body) {
        var S = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || []
          , E = document.head.firstChild;
        Array.from(S).forEach(function(T) {
            T[CSS_IN_JS_INSTANCE] = T[CSS_IN_JS_INSTANCE] || C,
            T[CSS_IN_JS_INSTANCE] === C && document.head.insertBefore(T, E)
        });
        var M = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(T) {
            var $ = T.getAttribute(ATTR_MARK);
            if (M[$]) {
                if (T[CSS_IN_JS_INSTANCE] === C) {
                    var B;
                    (B = T.parentNode) === null || B === void 0 || B.removeChild(T)
                }
            } else
                M[$] = !0
        })
    }
    return new Entity(C)
}
var StyleContext = reactExports.createContext({
    hashPriority: "low",
    cache: createCache(),
    defaultCache: !0
});
function sameDerivativeOption(C, S) {
    if (C.length !== S.length)
        return !1;
    for (var E = 0; E < C.length; E++)
        if (C[E] !== S[E])
            return !1;
    return !0
}
var ThemeCache = function() {
    function C() {
        _classCallCheck(this, C),
        _defineProperty(this, "cache", void 0),
        _defineProperty(this, "keys", void 0),
        _defineProperty(this, "cacheCallTimes", void 0),
        this.cache = new Map,
        this.keys = [],
        this.cacheCallTimes = 0
    }
    return _createClass(C, [{
        key: "size",
        value: function() {
            return this.keys.length
        }
    }, {
        key: "internalGet",
        value: function(E) {
            var M, T, $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, B = {
                map: this.cache
            };
            return E.forEach(function(O) {
                if (!B)
                    B = void 0;
                else {
                    var F;
                    B = (F = B) === null || F === void 0 || (F = F.map) === null || F === void 0 ? void 0 : F.get(O)
                }
            }),
            (M = B) !== null && M !== void 0 && M.value && $ && (B.value[1] = this.cacheCallTimes++),
            (T = B) === null || T === void 0 ? void 0 : T.value
        }
    }, {
        key: "get",
        value: function(E) {
            var M;
            return (M = this.internalGet(E, !0)) === null || M === void 0 ? void 0 : M[0]
        }
    }, {
        key: "has",
        value: function(E) {
            return !!this.internalGet(E)
        }
    }, {
        key: "set",
        value: function(E, M) {
            var T = this;
            if (!this.has(E)) {
                if (this.size() + 1 > C.MAX_CACHE_SIZE + C.MAX_CACHE_OFFSET) {
                    var $ = this.keys.reduce(function(N, U) {
                        var H = _slicedToArray(N, 2)
                          , Z = H[1];
                        return T.internalGet(U)[1] < Z ? [U, T.internalGet(U)[1]] : N
                    }, [this.keys[0], this.cacheCallTimes])
                      , B = _slicedToArray($, 1)
                      , O = B[0];
                    this.delete(O)
                }
                this.keys.push(E)
            }
            var F = this.cache;
            E.forEach(function(N, U) {
                if (U === E.length - 1)
                    F.set(N, {
                        value: [M, T.cacheCallTimes++]
                    });
                else {
                    var H = F.get(N);
                    H ? H.map || (H.map = new Map) : F.set(N, {
                        map: new Map
                    }),
                    F = F.get(N).map
                }
            })
        }
    }, {
        key: "deleteByPath",
        value: function(E, M) {
            var T = E.get(M[0]);
            if (M.length === 1) {
                var $;
                return T.map ? E.set(M[0], {
                    map: T.map
                }) : E.delete(M[0]),
                ($ = T.value) === null || $ === void 0 ? void 0 : $[0]
            }
            var B = this.deleteByPath(T.map, M.slice(1));
            return (!T.map || T.map.size === 0) && !T.value && E.delete(M[0]),
            B
        }
    }, {
        key: "delete",
        value: function(E) {
            if (this.has(E))
                return this.keys = this.keys.filter(function(M) {
                    return !sameDerivativeOption(M, E)
                }),
                this.deleteByPath(this.cache, E)
        }
    }]),
    C
}();
_defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
_defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);
var uuid = 0
  , Theme = function() {
    function C(S) {
        _classCallCheck(this, C),
        _defineProperty(this, "derivatives", void 0),
        _defineProperty(this, "id", void 0),
        this.derivatives = Array.isArray(S) ? S : [S],
        this.id = uuid,
        S.length === 0 && (S.length > 0,
        void 0),
        uuid += 1
    }
    return _createClass(C, [{
        key: "getDerivativeToken",
        value: function(E) {
            return this.derivatives.reduce(function(M, T) {
                return T(E, M)
            }, void 0)
        }
    }]),
    C
}()
  , cacheThemes = new ThemeCache;
function createTheme(C) {
    var S = Array.isArray(C) ? C : [C];
    return cacheThemes.has(S) || cacheThemes.set(S, new Theme(S)),
    cacheThemes.get(S)
}
var resultCache = new WeakMap
  , RESULT_VALUE = {};
function memoResult(C, S) {
    for (var E = resultCache, M = 0; M < S.length; M += 1) {
        var T = S[M];
        E.has(T) || E.set(T, new WeakMap),
        E = E.get(T)
    }
    return E.has(RESULT_VALUE) || E.set(RESULT_VALUE, C()),
    E.get(RESULT_VALUE)
}
var flattenTokenCache = new WeakMap;
function flattenToken(C) {
    var S = flattenTokenCache.get(C) || "";
    return S || (Object.keys(C).forEach(function(E) {
        var M = C[E];
        S += E,
        M instanceof Theme ? S += M.id : M && _typeof(M) === "object" ? S += flattenToken(M) : S += M
    }),
    flattenTokenCache.set(C, S)),
    S
}
function token2key(C, S) {
    return murmur2("".concat(S, "_").concat(flattenToken(C)))
}
var isClientSide = canUseDom();
function unit$1(C) {
    return typeof C == "number" ? "".concat(C, "px") : C
}
function toStyleStr(C, S, E) {
    var M, T = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, $ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    if ($)
        return C;
    var B = _objectSpread2(_objectSpread2({}, T), {}, (M = {},
    _defineProperty(M, ATTR_TOKEN, S),
    _defineProperty(M, ATTR_MARK, E),
    M))
      , O = Object.keys(B).map(function(F) {
        var N = B[F];
        return N ? "".concat(F, '="').concat(N, '"') : null
    }).filter(function(F) {
        return F
    }).join(" ");
    return "<style ".concat(O, ">").concat(C, "</style>")
}
var token2CSSVar = function C(S) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "--".concat(E ? "".concat(E, "-") : "").concat(S).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase()
}
  , serializeCSSVar = function C(S, E, M) {
    return Object.keys(S).length ? ".".concat(E).concat(M != null && M.scope ? ".".concat(M.scope) : "", "{").concat(Object.entries(S).map(function(T) {
        var $ = _slicedToArray(T, 2)
          , B = $[0]
          , O = $[1];
        return "".concat(B, ":").concat(O, ";")
    }).join(""), "}") : ""
}
  , transformToken = function C(S, E, M) {
    var T = {}
      , $ = {};
    return Object.entries(S).forEach(function(B) {
        var O, F, N = _slicedToArray(B, 2), U = N[0], H = N[1];
        if (M != null && (O = M.preserve) !== null && O !== void 0 && O[U])
            $[U] = H;
        else if ((typeof H == "string" || typeof H == "number") && !(M != null && (F = M.ignore) !== null && F !== void 0 && F[U])) {
            var Z, J = token2CSSVar(U, M == null ? void 0 : M.prefix);
            T[J] = typeof H == "number" && !(M != null && (Z = M.unitless) !== null && Z !== void 0 && Z[U]) ? "".concat(H, "px") : String(H),
            $[U] = "var(".concat(J, ")")
        }
    }),
    [$, serializeCSSVar(T, E, {
        scope: M == null ? void 0 : M.scope
    })]
}
  , useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect
  , useLayoutEffect = function C(S, E) {
    var M = reactExports.useRef(!0);
    useInternalLayoutEffect(function() {
        return S(M.current)
    }, E),
    useInternalLayoutEffect(function() {
        return M.current = !1,
        function() {
            M.current = !0
        }
    }, [])
}
  , fullClone$3 = _objectSpread2({}, React)
  , useInsertionEffect$1 = fullClone$3.useInsertionEffect
  , useInsertionEffectPolyfill = function C(S, E, M) {
    reactExports.useMemo(S, M),
    useLayoutEffect(function() {
        return E(!0)
    }, M)
}
  , useCompatibleInsertionEffect = useInsertionEffect$1 ? function(C, S, E) {
    return useInsertionEffect$1(function() {
        return C(),
        S()
    }, E)
}
: useInsertionEffectPolyfill
  , fullClone$2 = _objectSpread2({}, React)
  , useInsertionEffect = fullClone$2.useInsertionEffect
  , useCleanupRegister = function C(S) {
    var E = []
      , M = !1;
    function T($) {
        M || E.push($)
    }
    return reactExports.useEffect(function() {
        return M = !1,
        function() {
            M = !0,
            E.length && E.forEach(function($) {
                return $()
            })
        }
    }, S),
    T
}
  , useRun = function C() {
    return function(S) {
        S()
    }
}
  , useEffectCleanupRegister = typeof useInsertionEffect < "u" ? useCleanupRegister : useRun;
function useGlobalCache(C, S, E, M, T) {
    var $ = reactExports.useContext(StyleContext)
      , B = $.cache
      , O = [C].concat(_toConsumableArray(S))
      , F = pathKey(O)
      , N = useEffectCleanupRegister([F])
      , U = function(ie) {
        B.opUpdate(F, function(oe) {
            var ae = oe || [void 0, void 0]
              , se = _slicedToArray(ae, 2)
              , le = se[0]
              , de = le === void 0 ? 0 : le
              , fe = se[1]
              , pe = fe
              , ge = pe || E()
              , we = [de, ge];
            return ie ? ie(we) : we
        })
    };
    reactExports.useMemo(function() {
        U()
    }, [F]);
    var H = B.opGet(F)
      , Z = H[1];
    return useCompatibleInsertionEffect(function() {
        T == null || T(Z)
    }, function(J) {
        return U(function(ie) {
            var oe = _slicedToArray(ie, 2)
              , ae = oe[0]
              , se = oe[1];
            return J && ae === 0 && (T == null || T(Z)),
            [ae + 1, se]
        }),
        function() {
            B.opUpdate(F, function(ie) {
                var oe = ie || []
                  , ae = _slicedToArray(oe, 2)
                  , se = ae[0]
                  , le = se === void 0 ? 0 : se
                  , de = ae[1]
                  , fe = le - 1;
                return fe === 0 ? (N(function() {
                    (J || !B.opGet(F)) && (M == null || M(de, !1))
                }),
                null) : [le - 1, de]
            })
        }
    }, [F]),
    Z
}
var EMPTY_OVERRIDE = {}
  , hashPrefix = "css"
  , tokenKeys = new Map;
function recordCleanToken(C) {
    tokenKeys.set(C, (tokenKeys.get(C) || 0) + 1)
}
function removeStyleTags(C, S) {
    if (typeof document < "u") {
        var E = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(C, '"]'));
        E.forEach(function(M) {
            if (M[CSS_IN_JS_INSTANCE] === S) {
                var T;
                (T = M.parentNode) === null || T === void 0 || T.removeChild(M)
            }
        })
    }
}
var TOKEN_THRESHOLD = 0;
function cleanTokenStyle(C, S) {
    tokenKeys.set(C, (tokenKeys.get(C) || 0) - 1);
    var E = Array.from(tokenKeys.keys())
      , M = E.filter(function(T) {
        var $ = tokenKeys.get(T) || 0;
        return $ <= 0
    });
    E.length - M.length > TOKEN_THRESHOLD && M.forEach(function(T) {
        removeStyleTags(T, S),
        tokenKeys.delete(T)
    })
}
var getComputedToken$1 = function C(S, E, M, T) {
    var $ = M.getDerivativeToken(S)
      , B = _objectSpread2(_objectSpread2({}, $), E);
    return T && (B = T(B)),
    B
}
  , TOKEN_PREFIX = "token";
function useCacheToken(C, S) {
    var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , M = reactExports.useContext(StyleContext)
      , T = M.cache.instanceId
      , $ = M.container
      , B = E.salt
      , O = B === void 0 ? "" : B
      , F = E.override
      , N = F === void 0 ? EMPTY_OVERRIDE : F
      , U = E.formatToken
      , H = E.getComputedToken
      , Z = E.cssVar
      , J = memoResult(function() {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(S)))
    }, S)
      , ie = flattenToken(J)
      , oe = flattenToken(N)
      , ae = Z ? flattenToken(Z) : ""
      , se = useGlobalCache(TOKEN_PREFIX, [O, C.id, ie, oe, ae], function() {
        var le, de = H ? H(J, N, C) : getComputedToken$1(J, N, C, U), fe = _objectSpread2({}, de), pe = "";
        if (Z) {
            var ge = transformToken(de, Z.key, {
                prefix: Z.prefix,
                ignore: Z.ignore,
                unitless: Z.unitless,
                preserve: Z.preserve
            })
              , we = _slicedToArray(ge, 2);
            de = we[0],
            pe = we[1]
        }
        var Ae = token2key(de, O);
        de._tokenKey = Ae,
        fe._tokenKey = token2key(fe, O);
        var Se = (le = Z == null ? void 0 : Z.key) !== null && le !== void 0 ? le : Ae;
        de._themeKey = Se,
        recordCleanToken(Se);
        var ue = "".concat(hashPrefix, "-").concat(murmur2(Ae));
        return de._hashId = ue,
        [de, ue, fe, pe, (Z == null ? void 0 : Z.key) || ""]
    }, function(le) {
        cleanTokenStyle(le[0]._themeKey, T)
    }, function(le) {
        var de = _slicedToArray(le, 4)
          , fe = de[0]
          , pe = de[3];
        if (Z && pe) {
            var ge = updateCSS(pe, murmur2("css-variables-".concat(fe._themeKey)), {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: $,
                priority: -999
            });
            ge[CSS_IN_JS_INSTANCE] = T,
            ge.setAttribute(ATTR_TOKEN, fe._themeKey)
        }
    });
    return se
}
var extract$2 = function C(S, E, M) {
    var T = _slicedToArray(S, 5)
      , $ = T[2]
      , B = T[3]
      , O = T[4]
      , F = M || {}
      , N = F.plain;
    if (!B)
        return null;
    var U = $._tokenKey
      , H = -999
      , Z = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(H)
    }
      , J = toStyleStr(B, O, U, Z, N);
    return [H, U, J]
}
  , unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , COMMENT = "comm"
  , RULESET = "rule"
  , DECLARATION = "decl"
  , IMPORT = "@import"
  , KEYFRAMES = "@keyframes"
  , LAYER = "@layer"
  , abs = Math.abs
  , from$1 = String.fromCharCode;
function trim$1(C) {
    return C.trim()
}
function replace(C, S, E) {
    return C.replace(S, E)
}
function indexof(C, S, E) {
    return C.indexOf(S, E)
}
function charat(C, S) {
    return C.charCodeAt(S) | 0
}
function substr(C, S, E) {
    return C.slice(S, E)
}
function strlen(C) {
    return C.length
}
function sizeof(C) {
    return C.length
}
function append(C, S) {
    return S.push(C),
    C
}
var line = 1
  , column = 1
  , length = 0
  , position = 0
  , character = 0
  , characters = "";
function node(C, S, E, M, T, $, B, O) {
    return {
        value: C,
        root: S,
        parent: E,
        type: M,
        props: T,
        children: $,
        line,
        column,
        length: B,
        return: "",
        siblings: O
    }
}
function char() {
    return character
}
function prev() {
    return character = position > 0 ? charat(characters, --position) : 0,
    column--,
    character === 10 && (column = 1,
    line--),
    character
}
function next() {
    return character = position < length ? charat(characters, position++) : 0,
    column++,
    character === 10 && (column = 1,
    line++),
    character
}
function peek() {
    return charat(characters, position)
}
function caret() {
    return position
}
function slice(C, S) {
    return substr(characters, C, S)
}
function token(C) {
    switch (C) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function alloc(C) {
    return line = column = 1,
    length = strlen(characters = C),
    position = 0,
    []
}
function dealloc(C) {
    return characters = "",
    C
}
function delimit(C) {
    return trim$1(slice(position - 1, delimiter(C === 91 ? C + 2 : C === 40 ? C + 1 : C)))
}
function whitespace(C) {
    for (; (character = peek()) && character < 33; )
        next();
    return token(C) > 2 || token(character) > 3 ? "" : " "
}
function escaping(C, S) {
    for (; --S && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
        ;
    return slice(C, caret() + (S < 6 && peek() == 32 && next() == 32))
}
function delimiter(C) {
    for (; next(); )
        switch (character) {
        case C:
            return position;
        case 34:
        case 39:
            C !== 34 && C !== 39 && delimiter(character);
            break;
        case 40:
            C === 41 && delimiter(C);
            break;
        case 92:
            next();
            break
        }
    return position
}
function commenter(C, S) {
    for (; next() && C + character !== 57; )
        if (C + character === 84 && peek() === 47)
            break;
    return "/*" + slice(S, position - 1) + "*" + from$1(C === 47 ? C : next())
}
function identifier(C) {
    for (; !token(peek()); )
        next();
    return slice(C, position)
}
function compile(C) {
    return dealloc(parse$8("", null, null, null, [""], C = alloc(C), 0, [0], C))
}
function parse$8(C, S, E, M, T, $, B, O, F) {
    for (var N = 0, U = 0, H = B, Z = 0, J = 0, ie = 0, oe = 1, ae = 1, se = 1, le = 0, de = "", fe = T, pe = $, ge = M, we = de; ae; )
        switch (ie = le,
        le = next()) {
        case 40:
            if (ie != 108 && charat(we, H - 1) == 58) {
                indexof(we += replace(delimit(le), "&", "&\f"), "&\f", abs(N ? O[N - 1] : 0)) != -1 && (se = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            we += delimit(le);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            we += whitespace(ie);
            break;
        case 92:
            we += escaping(caret() - 1, 7);
            continue;
        case 47:
            switch (peek()) {
            case 42:
            case 47:
                append(comment(commenter(next(), caret()), S, E, F), F);
                break;
            default:
                we += "/"
            }
            break;
        case 123 * oe:
            O[N++] = strlen(we) * se;
        case 125 * oe:
        case 59:
        case 0:
            switch (le) {
            case 0:
            case 125:
                ae = 0;
            case 59 + U:
                se == -1 && (we = replace(we, /\f/g, "")),
                J > 0 && strlen(we) - H && append(J > 32 ? declaration(we + ";", M, E, H - 1, F) : declaration(replace(we, " ", "") + ";", M, E, H - 2, F), F);
                break;
            case 59:
                we += ";";
            default:
                if (append(ge = ruleset(we, S, E, N, U, T, O, de, fe = [], pe = [], H, $), $),
                le === 123)
                    if (U === 0)
                        parse$8(we, S, ge, ge, fe, $, H, O, pe);
                    else
                        switch (Z === 99 && charat(we, 3) === 110 ? 100 : Z) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            parse$8(C, ge, ge, M && append(ruleset(C, ge, ge, 0, 0, T, O, de, T, fe = [], H, pe), pe), T, pe, H, O, M ? fe : pe);
                            break;
                        default:
                            parse$8(we, ge, ge, ge, [""], pe, 0, O, pe)
                        }
            }
            N = U = J = 0,
            oe = se = 1,
            de = we = "",
            H = B;
            break;
        case 58:
            H = 1 + strlen(we),
            J = ie;
        default:
            if (oe < 1) {
                if (le == 123)
                    --oe;
                else if (le == 125 && oe++ == 0 && prev() == 125)
                    continue
            }
            switch (we += from$1(le),
            le * oe) {
            case 38:
                se = U > 0 ? 1 : (we += "\f",
                -1);
                break;
            case 44:
                O[N++] = (strlen(we) - 1) * se,
                se = 1;
                break;
            case 64:
                peek() === 45 && (we += delimit(next())),
                Z = peek(),
                U = H = strlen(de = we += identifier(caret())),
                le++;
                break;
            case 45:
                ie === 45 && strlen(we) == 2 && (oe = 0)
            }
        }
    return $
}
function ruleset(C, S, E, M, T, $, B, O, F, N, U, H) {
    for (var Z = T - 1, J = T === 0 ? $ : [""], ie = sizeof(J), oe = 0, ae = 0, se = 0; oe < M; ++oe)
        for (var le = 0, de = substr(C, Z + 1, Z = abs(ae = B[oe])), fe = C; le < ie; ++le)
            (fe = trim$1(ae > 0 ? J[le] + " " + de : replace(de, /&\f/g, J[le]))) && (F[se++] = fe);
    return node(C, S, E, T === 0 ? RULESET : O, F, N, U, H)
}
function comment(C, S, E, M) {
    return node(C, S, E, COMMENT, from$1(char()), substr(C, 2, -2), 0, M)
}
function declaration(C, S, E, M, T) {
    return node(C, S, E, DECLARATION, substr(C, 0, M), substr(C, M + 1, -1), M, T)
}
function serialize(C, S) {
    for (var E = "", M = 0; M < C.length; M++)
        E += S(C[M], M, C, S) || "";
    return E
}
function stringify(C, S, E, M) {
    switch (C.type) {
    case LAYER:
        if (C.children.length)
            break;
    case IMPORT:
    case DECLARATION:
        return C.return = C.return || C.value;
    case COMMENT:
        return "";
    case KEYFRAMES:
        return C.return = C.value + "{" + serialize(C.children, M) + "}";
    case RULESET:
        if (!strlen(C.value = C.props.join(",")))
            return ""
    }
    return strlen(E = serialize(C.children, M)) ? C.return = C.value + "{" + E + "}" : ""
}
var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path", CSS_FILE_STYLE = "_FILE_STYLE__", cachePathMap, fromCSSFile = !0;
function prepare() {
    if (!cachePathMap && (cachePathMap = {},
    canUseDom())) {
        var C = document.createElement("div");
        C.className = ATTR_CACHE_MAP,
        C.style.position = "fixed",
        C.style.visibility = "hidden",
        C.style.top = "-9999px",
        document.body.appendChild(C);
        var S = getComputedStyle(C).content || "";
        S = S.replace(/^"/, "").replace(/"$/, ""),
        S.split(";").forEach(function(T) {
            var $ = T.split(":")
              , B = _slicedToArray($, 2)
              , O = B[0]
              , F = B[1];
            cachePathMap[O] = F
        });
        var E = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
        if (E) {
            var M;
            fromCSSFile = !1,
            (M = E.parentNode) === null || M === void 0 || M.removeChild(E)
        }
        document.body.removeChild(C)
    }
}
function existPath(C) {
    return prepare(),
    !!cachePathMap[C]
}
function getStyleAndHash(C) {
    var S = cachePathMap[C]
      , E = null;
    if (S && canUseDom())
        if (fromCSSFile)
            E = CSS_FILE_STYLE;
        else {
            var M = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[C], '"]'));
            M ? E = M.innerHTML : delete cachePathMap[C]
        }
    return [E, S]
}
var SKIP_CHECK = "_skip_check_"
  , MULTI_VALUE = "_multi_value_";
function normalizeStyle(C) {
    var S = serialize(compile(C), stringify);
    return S.replace(/\{%%%\:[^;];}/g, ";")
}
function isCompoundCSSProperty(C) {
    return _typeof(C) === "object" && C && (SKIP_CHECK in C || MULTI_VALUE in C)
}
function injectSelectorHash(C, S, E) {
    if (!S)
        return C;
    var M = ".".concat(S)
      , T = E === "low" ? ":where(".concat(M, ")") : M
      , $ = C.split(",").map(function(B) {
        var O, F = B.trim().split(/\s+/), N = F[0] || "", U = ((O = N.match(/^\w+/)) === null || O === void 0 ? void 0 : O[0]) || "";
        return N = "".concat(U).concat(T).concat(N.slice(U.length)),
        [N].concat(_toConsumableArray(F.slice(1))).join(" ")
    });
    return $.join(",")
}
var parseStyle = function C(S) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , M = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: !0,
        parentSelectors: []
    }
      , T = M.root
      , $ = M.injectHash
      , B = M.parentSelectors
      , O = E.hashId
      , F = E.layer;
    E.path;
    var N = E.hashPriority
      , U = E.transformers
      , H = U === void 0 ? [] : U;
    E.linters;
    var Z = ""
      , J = {};
    function ie(se) {
        var le = se.getName(O);
        if (!J[le]) {
            var de = C(se.style, E, {
                root: !1,
                parentSelectors: B
            })
              , fe = _slicedToArray(de, 1)
              , pe = fe[0];
            J[le] = "@keyframes ".concat(se.getName(O)).concat(pe)
        }
    }
    function oe(se) {
        var le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        return se.forEach(function(de) {
            Array.isArray(de) ? oe(de, le) : de && le.push(de)
        }),
        le
    }
    var ae = oe(Array.isArray(S) ? S : [S]);
    return ae.forEach(function(se) {
        var le = typeof se == "string" && !T ? {} : se;
        if (typeof le == "string")
            Z += "".concat(le, `
`);
        else if (le._keyframe)
            ie(le);
        else {
            var de = H.reduce(function(fe, pe) {
                var ge;
                return (pe == null || (ge = pe.visit) === null || ge === void 0 ? void 0 : ge.call(pe, fe)) || fe
            }, le);
            Object.keys(de).forEach(function(fe) {
                var pe = de[fe];
                if (_typeof(pe) === "object" && pe && (fe !== "animationName" || !pe._keyframe) && !isCompoundCSSProperty(pe)) {
                    var ge = !1
                      , we = fe.trim()
                      , Ae = !1;
                    (T || $) && O ? we.startsWith("@") ? ge = !0 : we = injectSelectorHash(fe, O, N) : T && !O && (we === "&" || we === "") && (we = "",
                    Ae = !0);
                    var Se = C(pe, E, {
                        root: Ae,
                        injectHash: ge,
                        parentSelectors: [].concat(_toConsumableArray(B), [we])
                    })
                      , ue = _slicedToArray(Se, 2)
                      , V = ue[0]
                      , W = ue[1];
                    J = _objectSpread2(_objectSpread2({}, J), W),
                    Z += "".concat(we).concat(V)
                } else {
                    let L = function(K, X) {
                        var Y = K.replace(/[A-Z]/g, function(G) {
                            return "-".concat(G.toLowerCase())
                        })
                          , j = X;
                        !unitlessKeys[K] && typeof j == "number" && j !== 0 && (j = "".concat(j, "px")),
                        K === "animationName" && X !== null && X !== void 0 && X._keyframe && (ie(X),
                        j = X.getName(O)),
                        Z += "".concat(Y, ":").concat(j, ";")
                    };
                    var D, I = (D = pe == null ? void 0 : pe.value) !== null && D !== void 0 ? D : pe;
                    _typeof(pe) === "object" && pe !== null && pe !== void 0 && pe[MULTI_VALUE] && Array.isArray(I) ? I.forEach(function(K) {
                        L(fe, K)
                    }) : L(fe, I)
                }
            })
        }
    }),
    T ? F && (Z = "@layer ".concat(F.name, " {").concat(Z, "}"),
    F.dependencies && (J["@layer ".concat(F.name)] = F.dependencies.map(function(se) {
        return "@layer ".concat(se, ", ").concat(F.name, ";")
    }).join(`
`))) : Z = "{".concat(Z, "}"),
    [Z, J]
};
function uniqueHash(C, S) {
    return murmur2("".concat(C.join("%")).concat(S))
}
function Empty() {
    return null
}
var STYLE_PREFIX = "style";
function useStyleRegister(C, S) {
    var E = C.token
      , M = C.path
      , T = C.hashId
      , $ = C.layer
      , B = C.nonce
      , O = C.clientOnly
      , F = C.order
      , N = F === void 0 ? 0 : F
      , U = reactExports.useContext(StyleContext)
      , H = U.autoClear;
    U.mock;
    var Z = U.defaultCache
      , J = U.hashPriority
      , ie = U.container
      , oe = U.ssrInline
      , ae = U.transformers
      , se = U.linters
      , le = U.cache
      , de = U.layer
      , fe = E._tokenKey
      , pe = [fe];
    de && pe.push("layer"),
    pe.push.apply(pe, _toConsumableArray(M));
    var ge = isClientSide
      , we = useGlobalCache(STYLE_PREFIX, pe, function() {
        var W = pe.join("|");
        if (existPath(W)) {
            var D = getStyleAndHash(W)
              , I = _slicedToArray(D, 2)
              , L = I[0]
              , K = I[1];
            if (L)
                return [L, fe, K, {}, O, N]
        }
        var X = S()
          , Y = parseStyle(X, {
            hashId: T,
            hashPriority: J,
            layer: de ? $ : void 0,
            path: M.join("-"),
            transformers: ae,
            linters: se
        })
          , j = _slicedToArray(Y, 2)
          , G = j[0]
          , ne = j[1]
          , te = normalizeStyle(G)
          , ce = uniqueHash(pe, te);
        return [te, fe, ce, ne, O, N]
    }, function(W, D) {
        var I = _slicedToArray(W, 3)
          , L = I[2];
        (D || H) && isClientSide && removeCSS(L, {
            mark: ATTR_MARK
        })
    }, function(W) {
        var D = _slicedToArray(W, 4)
          , I = D[0];
        D[1];
        var L = D[2]
          , K = D[3];
        if (ge && I !== CSS_FILE_STYLE) {
            var X = {
                mark: ATTR_MARK,
                prepend: de ? !1 : "queue",
                attachTo: ie,
                priority: N
            }
              , Y = typeof B == "function" ? B() : B;
            Y && (X.csp = {
                nonce: Y
            });
            var j = []
              , G = [];
            Object.keys(K).forEach(function(te) {
                te.startsWith("@layer") ? j.push(te) : G.push(te)
            }),
            j.forEach(function(te) {
                updateCSS(normalizeStyle(K[te]), "_layer-".concat(te), _objectSpread2(_objectSpread2({}, X), {}, {
                    prepend: !0
                }))
            });
            var ne = updateCSS(I, L, X);
            ne[CSS_IN_JS_INSTANCE] = le.instanceId,
            ne.setAttribute(ATTR_TOKEN, fe),
            G.forEach(function(te) {
                updateCSS(normalizeStyle(K[te]), "_effect-".concat(te), X)
            })
        }
    })
      , Ae = _slicedToArray(we, 3)
      , Se = Ae[0]
      , ue = Ae[1]
      , V = Ae[2];
    return function(W) {
        var D;
        if (!oe || ge || !Z)
            D = reactExports.createElement(Empty, null);
        else {
            var I;
            D = reactExports.createElement("style", _extends$3({}, (I = {},
            _defineProperty(I, ATTR_TOKEN, ue),
            _defineProperty(I, ATTR_MARK, V),
            I), {
                dangerouslySetInnerHTML: {
                    __html: Se
                }
            }))
        }
        return reactExports.createElement(reactExports.Fragment, null, D, W)
    }
}
var extract$1 = function C(S, E, M) {
    var T = _slicedToArray(S, 6)
      , $ = T[0]
      , B = T[1]
      , O = T[2]
      , F = T[3]
      , N = T[4]
      , U = T[5]
      , H = M || {}
      , Z = H.plain;
    if (N)
        return null;
    var J = $
      , ie = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(U)
    };
    return J = toStyleStr($, B, O, ie, Z),
    F && Object.keys(F).forEach(function(oe) {
        if (!E[oe]) {
            E[oe] = !0;
            var ae = normalizeStyle(F[oe])
              , se = toStyleStr(ae, B, "_effect-".concat(oe), ie, Z);
            oe.startsWith("@layer") ? J = se + J : J += se
        }
    }),
    [U, O, J]
}, CSS_VAR_PREFIX = "cssVar", useCSSVarRegister = function C(S, E) {
    var M = S.key
      , T = S.prefix
      , $ = S.unitless
      , B = S.ignore
      , O = S.token
      , F = S.scope
      , N = F === void 0 ? "" : F
      , U = reactExports.useContext(StyleContext)
      , H = U.cache.instanceId
      , Z = U.container
      , J = O._tokenKey
      , ie = [].concat(_toConsumableArray(S.path), [M, N, J])
      , oe = useGlobalCache(CSS_VAR_PREFIX, ie, function() {
        var ae = E()
          , se = transformToken(ae, M, {
            prefix: T,
            unitless: $,
            ignore: B,
            scope: N
        })
          , le = _slicedToArray(se, 2)
          , de = le[0]
          , fe = le[1]
          , pe = uniqueHash(ie, fe);
        return [de, fe, pe, M]
    }, function(ae) {
        var se = _slicedToArray(ae, 3)
          , le = se[2];
        isClientSide && removeCSS(le, {
            mark: ATTR_MARK
        })
    }, function(ae) {
        var se = _slicedToArray(ae, 3)
          , le = se[1]
          , de = se[2];
        if (le) {
            var fe = updateCSS(le, de, {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: Z,
                priority: -999
            });
            fe[CSS_IN_JS_INSTANCE] = H,
            fe.setAttribute(ATTR_TOKEN, M)
        }
    });
    return oe
}, extract = function C(S, E, M) {
    var T = _slicedToArray(S, 4)
      , $ = T[1]
      , B = T[2]
      , O = T[3]
      , F = M || {}
      , N = F.plain;
    if (!$)
        return null;
    var U = -999
      , H = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(U)
    }
      , Z = toStyleStr($, O, B, H, N);
    return [U, B, Z]
}, _ExtractStyleFns;
_ExtractStyleFns = {},
_defineProperty(_ExtractStyleFns, STYLE_PREFIX, extract$1),
_defineProperty(_ExtractStyleFns, TOKEN_PREFIX, extract$2),
_defineProperty(_ExtractStyleFns, CSS_VAR_PREFIX, extract);
var Keyframe = function() {
    function C(S, E) {
        _classCallCheck(this, C),
        _defineProperty(this, "name", void 0),
        _defineProperty(this, "style", void 0),
        _defineProperty(this, "_keyframe", !0),
        this.name = S,
        this.style = E
    }
    return _createClass(C, [{
        key: "getName",
        value: function() {
            var E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return E ? "".concat(E, "-").concat(this.name) : this.name
        }
    }]),
    C
}();
function noSplit(C) {
    return C.notSplit = !0,
    C
}
noSplit(["borderTop", "borderBottom"]),
noSplit(["borderTop"]),
noSplit(["borderBottom"]),
noSplit(["borderLeft", "borderRight"]),
noSplit(["borderLeft"]),
noSplit(["borderRight"]);
var IconContext = reactExports.createContext({});
function _toArray(C) {
    return _arrayWithHoles(C) || _iterableToArray(C) || _unsupportedIterableToArray(C) || _nonIterableRest()
}
function get$1(C, S) {
    for (var E = C, M = 0; M < S.length; M += 1) {
        if (E == null)
            return;
        E = E[S[M]]
    }
    return E
}
function internalSet(C, S, E, M) {
    if (!S.length)
        return E;
    var T = _toArray(S), $ = T[0], B = T.slice(1), O;
    return !C && typeof $ == "number" ? O = [] : Array.isArray(C) ? O = _toConsumableArray(C) : O = _objectSpread2({}, C),
    M && E === void 0 && B.length === 1 ? delete O[$][B[0]] : O[$] = internalSet(O[$], B, E, M),
    O
}
function set(C, S, E) {
    var M = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return S.length && M && E === void 0 && !get$1(C, S.slice(0, -1)) ? C : internalSet(C, S, E, M)
}
function isObject$1(C) {
    return _typeof(C) === "object" && C !== null && Object.getPrototypeOf(C) === Object.prototype
}
function createEmpty(C) {
    return Array.isArray(C) ? [] : {}
}
var keys = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function merge$2() {
    for (var C = arguments.length, S = new Array(C), E = 0; E < C; E++)
        S[E] = arguments[E];
    var M = createEmpty(S[0]);
    return S.forEach(function(T) {
        function $(B, O) {
            var F = new Set(O)
              , N = get$1(T, B)
              , U = Array.isArray(N);
            if (U || isObject$1(N)) {
                if (!F.has(N)) {
                    F.add(N);
                    var H = get$1(M, B);
                    U ? M = set(M, B, []) : (!H || _typeof(H) !== "object") && (M = set(M, B, createEmpty(N))),
                    keys(N).forEach(function(Z) {
                        $([].concat(_toConsumableArray(B), [Z]), F)
                    })
                }
            } else
                M = set(M, B, N)
        }
        $([])
    }),
    M
}
const WarningContext = reactExports.createContext({})
  , ValidateMessagesContext = reactExports.createContext(void 0);
var locale$3 = {
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
}
  , locale$2 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: !0,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
};
const locale$1 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
}
  , TimePicker = locale$1
  , locale = {
    lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
    }, locale$2),
    timePickerLocale: Object.assign({}, TimePicker)
}
  , enUS = locale
  , typeTemplate = "${label} is not a valid ${type}"
  , localeValues = {
    locale: "en",
    Pagination: locale$3,
    DatePicker: enUS,
    TimePicker,
    Calendar: enUS,
    global: {
        placeholder: "Please select"
    },
    Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
    },
    Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
    },
    Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
    },
    Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
    },
    Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
    },
    Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
    },
    Empty: {
        description: "No data"
    },
    Icon: {
        icon: "icon"
    },
    Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand",
        collapse: "Collapse"
    },
    Form: {
        optional: "(optional)",
        defaultValidateMessages: {
            default: "Field validation error for ${label}",
            required: "Please enter ${label}",
            enum: "${label} must be one of [${enum}]",
            whitespace: "${label} cannot be a blank character",
            date: {
                format: "${label} date format is invalid",
                parse: "${label} cannot be converted to a date",
                invalid: "${label} is an invalid date"
            },
            types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
            },
            string: {
                len: "${label} must be ${len} characters",
                min: "${label} must be at least ${min} characters",
                max: "${label} must be up to ${max} characters",
                range: "${label} must be between ${min}-${max} characters"
            },
            number: {
                len: "${label} must be equal to ${len}",
                min: "${label} must be minimum ${min}",
                max: "${label} must be maximum ${max}",
                range: "${label} must be between ${min}-${max}"
            },
            array: {
                len: "Must be ${len} ${label}",
                min: "At least ${min} ${label}",
                max: "At most ${max} ${label}",
                range: "The amount of ${label} must be between ${min}-${max}"
            },
            pattern: {
                mismatch: "${label} does not match the pattern ${pattern}"
            }
        }
    },
    Image: {
        preview: "Preview"
    },
    QRCode: {
        expired: "QR code expired",
        refresh: "Refresh",
        scanned: "Scanned"
    },
    ColorPicker: {
        presetEmpty: "Empty"
    }
};
Object.assign({}, localeValues.Modal);
let localeList = [];
const generateLocale = ()=>localeList.reduce((C,S)=>Object.assign(Object.assign({}, C), S), localeValues.Modal);
function changeConfirmLocale(C) {
    if (C) {
        const S = Object.assign({}, C);
        return localeList.push(S),
        generateLocale(),
        ()=>{
            localeList = localeList.filter(E=>E !== S),
            generateLocale()
        }
    }
    Object.assign({}, localeValues.Modal)
}
const LocaleContext = reactExports.createContext(void 0)
  , LocaleContext$1 = LocaleContext
  , ANT_MARK = "internalMark"
  , LocaleProvider = C=>{
    const {locale: S={}, children: E, _ANT_MARK__: M} = C;
    reactExports.useEffect(()=>changeConfirmLocale(S && S.Modal), [S]);
    const T = reactExports.useMemo(()=>Object.assign(Object.assign({}, S), {
        exist: !0
    }), [S]);
    return reactExports.createElement(LocaleContext$1.Provider, {
        value: T
    }, E)
}
  , LocaleProvider$1 = LocaleProvider;
function bound01(C, S) {
    isOnePointZero(C) && (C = "100%");
    var E = isPercentage(C);
    return C = S === 360 ? C : Math.min(S, Math.max(0, parseFloat(C))),
    E && (C = parseInt(String(C * S), 10) / 100),
    Math.abs(C - S) < 1e-6 ? 1 : (S === 360 ? C = (C < 0 ? C % S + S : C % S) / parseFloat(String(S)) : C = C % S / parseFloat(String(S)),
    C)
}
function clamp01(C) {
    return Math.min(1, Math.max(0, C))
}
function isOnePointZero(C) {
    return typeof C == "string" && C.indexOf(".") !== -1 && parseFloat(C) === 1
}
function isPercentage(C) {
    return typeof C == "string" && C.indexOf("%") !== -1
}
function boundAlpha(C) {
    return C = parseFloat(C),
    (isNaN(C) || C < 0 || C > 1) && (C = 1),
    C
}
function convertToPercentage(C) {
    return C <= 1 ? "".concat(Number(C) * 100, "%") : C
}
function pad2(C) {
    return C.length === 1 ? "0" + C : String(C)
}
function rgbToRgb(C, S, E) {
    return {
        r: bound01(C, 255) * 255,
        g: bound01(S, 255) * 255,
        b: bound01(E, 255) * 255
    }
}
function rgbToHsl(C, S, E) {
    C = bound01(C, 255),
    S = bound01(S, 255),
    E = bound01(E, 255);
    var M = Math.max(C, S, E)
      , T = Math.min(C, S, E)
      , $ = 0
      , B = 0
      , O = (M + T) / 2;
    if (M === T)
        B = 0,
        $ = 0;
    else {
        var F = M - T;
        switch (B = O > .5 ? F / (2 - M - T) : F / (M + T),
        M) {
        case C:
            $ = (S - E) / F + (S < E ? 6 : 0);
            break;
        case S:
            $ = (E - C) / F + 2;
            break;
        case E:
            $ = (C - S) / F + 4;
            break
        }
        $ /= 6
    }
    return {
        h: $,
        s: B,
        l: O
    }
}
function hue2rgb(C, S, E) {
    return E < 0 && (E += 1),
    E > 1 && (E -= 1),
    E < 1 / 6 ? C + (S - C) * (6 * E) : E < 1 / 2 ? S : E < 2 / 3 ? C + (S - C) * (2 / 3 - E) * 6 : C
}
function hslToRgb(C, S, E) {
    var M, T, $;
    if (C = bound01(C, 360),
    S = bound01(S, 100),
    E = bound01(E, 100),
    S === 0)
        T = E,
        $ = E,
        M = E;
    else {
        var B = E < .5 ? E * (1 + S) : E + S - E * S
          , O = 2 * E - B;
        M = hue2rgb(O, B, C + 1 / 3),
        T = hue2rgb(O, B, C),
        $ = hue2rgb(O, B, C - 1 / 3)
    }
    return {
        r: M * 255,
        g: T * 255,
        b: $ * 255
    }
}
function rgbToHsv(C, S, E) {
    C = bound01(C, 255),
    S = bound01(S, 255),
    E = bound01(E, 255);
    var M = Math.max(C, S, E)
      , T = Math.min(C, S, E)
      , $ = 0
      , B = M
      , O = M - T
      , F = M === 0 ? 0 : O / M;
    if (M === T)
        $ = 0;
    else {
        switch (M) {
        case C:
            $ = (S - E) / O + (S < E ? 6 : 0);
            break;
        case S:
            $ = (E - C) / O + 2;
            break;
        case E:
            $ = (C - S) / O + 4;
            break
        }
        $ /= 6
    }
    return {
        h: $,
        s: F,
        v: B
    }
}
function hsvToRgb(C, S, E) {
    C = bound01(C, 360) * 6,
    S = bound01(S, 100),
    E = bound01(E, 100);
    var M = Math.floor(C)
      , T = C - M
      , $ = E * (1 - S)
      , B = E * (1 - T * S)
      , O = E * (1 - (1 - T) * S)
      , F = M % 6
      , N = [E, B, $, $, O, E][F]
      , U = [O, E, E, B, $, $][F]
      , H = [$, $, O, E, E, B][F];
    return {
        r: N * 255,
        g: U * 255,
        b: H * 255
    }
}
function rgbToHex(C, S, E, M) {
    var T = [pad2(Math.round(C).toString(16)), pad2(Math.round(S).toString(16)), pad2(Math.round(E).toString(16))];
    return M && T[0].startsWith(T[0].charAt(1)) && T[1].startsWith(T[1].charAt(1)) && T[2].startsWith(T[2].charAt(1)) ? T[0].charAt(0) + T[1].charAt(0) + T[2].charAt(0) : T.join("")
}
function rgbaToHex(C, S, E, M, T) {
    var $ = [pad2(Math.round(C).toString(16)), pad2(Math.round(S).toString(16)), pad2(Math.round(E).toString(16)), pad2(convertDecimalToHex(M))];
    return T && $[0].startsWith($[0].charAt(1)) && $[1].startsWith($[1].charAt(1)) && $[2].startsWith($[2].charAt(1)) && $[3].startsWith($[3].charAt(1)) ? $[0].charAt(0) + $[1].charAt(0) + $[2].charAt(0) + $[3].charAt(0) : $.join("")
}
function convertDecimalToHex(C) {
    return Math.round(parseFloat(C) * 255).toString(16)
}
function convertHexToDecimal(C) {
    return parseIntFromHex(C) / 255
}
function parseIntFromHex(C) {
    return parseInt(C, 16)
}
function numberInputToObject(C) {
    return {
        r: C >> 16,
        g: (C & 65280) >> 8,
        b: C & 255
    }
}
var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};
function inputToRGB(C) {
    var S = {
        r: 0,
        g: 0,
        b: 0
    }
      , E = 1
      , M = null
      , T = null
      , $ = null
      , B = !1
      , O = !1;
    return typeof C == "string" && (C = stringInputToObject(C)),
    typeof C == "object" && (isValidCSSUnit(C.r) && isValidCSSUnit(C.g) && isValidCSSUnit(C.b) ? (S = rgbToRgb(C.r, C.g, C.b),
    B = !0,
    O = String(C.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(C.h) && isValidCSSUnit(C.s) && isValidCSSUnit(C.v) ? (M = convertToPercentage(C.s),
    T = convertToPercentage(C.v),
    S = hsvToRgb(C.h, M, T),
    B = !0,
    O = "hsv") : isValidCSSUnit(C.h) && isValidCSSUnit(C.s) && isValidCSSUnit(C.l) && (M = convertToPercentage(C.s),
    $ = convertToPercentage(C.l),
    S = hslToRgb(C.h, M, $),
    B = !0,
    O = "hsl"),
    Object.prototype.hasOwnProperty.call(C, "a") && (E = C.a)),
    E = boundAlpha(E),
    {
        ok: B,
        format: C.format || O,
        r: Math.min(255, Math.max(S.r, 0)),
        g: Math.min(255, Math.max(S.g, 0)),
        b: Math.min(255, Math.max(S.b, 0)),
        a: E
    }
}
var CSS_INTEGER = "[-\\+]?\\d+%?"
  , CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?"
  , CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")")
  , PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?")
  , PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?")
  , matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(C) {
    if (C = C.trim().toLowerCase(),
    C.length === 0)
        return !1;
    var S = !1;
    if (names[C])
        C = names[C],
        S = !0;
    else if (C === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    var E = matchers.rgb.exec(C);
    return E ? {
        r: E[1],
        g: E[2],
        b: E[3]
    } : (E = matchers.rgba.exec(C),
    E ? {
        r: E[1],
        g: E[2],
        b: E[3],
        a: E[4]
    } : (E = matchers.hsl.exec(C),
    E ? {
        h: E[1],
        s: E[2],
        l: E[3]
    } : (E = matchers.hsla.exec(C),
    E ? {
        h: E[1],
        s: E[2],
        l: E[3],
        a: E[4]
    } : (E = matchers.hsv.exec(C),
    E ? {
        h: E[1],
        s: E[2],
        v: E[3]
    } : (E = matchers.hsva.exec(C),
    E ? {
        h: E[1],
        s: E[2],
        v: E[3],
        a: E[4]
    } : (E = matchers.hex8.exec(C),
    E ? {
        r: parseIntFromHex(E[1]),
        g: parseIntFromHex(E[2]),
        b: parseIntFromHex(E[3]),
        a: convertHexToDecimal(E[4]),
        format: S ? "name" : "hex8"
    } : (E = matchers.hex6.exec(C),
    E ? {
        r: parseIntFromHex(E[1]),
        g: parseIntFromHex(E[2]),
        b: parseIntFromHex(E[3]),
        format: S ? "name" : "hex"
    } : (E = matchers.hex4.exec(C),
    E ? {
        r: parseIntFromHex(E[1] + E[1]),
        g: parseIntFromHex(E[2] + E[2]),
        b: parseIntFromHex(E[3] + E[3]),
        a: convertHexToDecimal(E[4] + E[4]),
        format: S ? "name" : "hex8"
    } : (E = matchers.hex3.exec(C),
    E ? {
        r: parseIntFromHex(E[1] + E[1]),
        g: parseIntFromHex(E[2] + E[2]),
        b: parseIntFromHex(E[3] + E[3]),
        format: S ? "name" : "hex"
    } : !1)))))))))
}
function isValidCSSUnit(C) {
    return !!matchers.CSS_UNIT.exec(String(C))
}
var TinyColor = function() {
    function C(S, E) {
        S === void 0 && (S = ""),
        E === void 0 && (E = {});
        var M;
        if (S instanceof C)
            return S;
        typeof S == "number" && (S = numberInputToObject(S)),
        this.originalInput = S;
        var T = inputToRGB(S);
        this.originalInput = S,
        this.r = T.r,
        this.g = T.g,
        this.b = T.b,
        this.a = T.a,
        this.roundA = Math.round(100 * this.a) / 100,
        this.format = (M = E.format) !== null && M !== void 0 ? M : T.format,
        this.gradientType = E.gradientType,
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        this.isValid = T.ok
    }
    return C.prototype.isDark = function() {
        return this.getBrightness() < 128
    }
    ,
    C.prototype.isLight = function() {
        return !this.isDark()
    }
    ,
    C.prototype.getBrightness = function() {
        var S = this.toRgb();
        return (S.r * 299 + S.g * 587 + S.b * 114) / 1e3
    }
    ,
    C.prototype.getLuminance = function() {
        var S = this.toRgb(), E, M, T, $ = S.r / 255, B = S.g / 255, O = S.b / 255;
        return $ <= .03928 ? E = $ / 12.92 : E = Math.pow(($ + .055) / 1.055, 2.4),
        B <= .03928 ? M = B / 12.92 : M = Math.pow((B + .055) / 1.055, 2.4),
        O <= .03928 ? T = O / 12.92 : T = Math.pow((O + .055) / 1.055, 2.4),
        .2126 * E + .7152 * M + .0722 * T
    }
    ,
    C.prototype.getAlpha = function() {
        return this.a
    }
    ,
    C.prototype.setAlpha = function(S) {
        return this.a = boundAlpha(S),
        this.roundA = Math.round(100 * this.a) / 100,
        this
    }
    ,
    C.prototype.isMonochrome = function() {
        var S = this.toHsl().s;
        return S === 0
    }
    ,
    C.prototype.toHsv = function() {
        var S = rgbToHsv(this.r, this.g, this.b);
        return {
            h: S.h * 360,
            s: S.s,
            v: S.v,
            a: this.a
        }
    }
    ,
    C.prototype.toHsvString = function() {
        var S = rgbToHsv(this.r, this.g, this.b)
          , E = Math.round(S.h * 360)
          , M = Math.round(S.s * 100)
          , T = Math.round(S.v * 100);
        return this.a === 1 ? "hsv(".concat(E, ", ").concat(M, "%, ").concat(T, "%)") : "hsva(".concat(E, ", ").concat(M, "%, ").concat(T, "%, ").concat(this.roundA, ")")
    }
    ,
    C.prototype.toHsl = function() {
        var S = rgbToHsl(this.r, this.g, this.b);
        return {
            h: S.h * 360,
            s: S.s,
            l: S.l,
            a: this.a
        }
    }
    ,
    C.prototype.toHslString = function() {
        var S = rgbToHsl(this.r, this.g, this.b)
          , E = Math.round(S.h * 360)
          , M = Math.round(S.s * 100)
          , T = Math.round(S.l * 100);
        return this.a === 1 ? "hsl(".concat(E, ", ").concat(M, "%, ").concat(T, "%)") : "hsla(".concat(E, ", ").concat(M, "%, ").concat(T, "%, ").concat(this.roundA, ")")
    }
    ,
    C.prototype.toHex = function(S) {
        return S === void 0 && (S = !1),
        rgbToHex(this.r, this.g, this.b, S)
    }
    ,
    C.prototype.toHexString = function(S) {
        return S === void 0 && (S = !1),
        "#" + this.toHex(S)
    }
    ,
    C.prototype.toHex8 = function(S) {
        return S === void 0 && (S = !1),
        rgbaToHex(this.r, this.g, this.b, this.a, S)
    }
    ,
    C.prototype.toHex8String = function(S) {
        return S === void 0 && (S = !1),
        "#" + this.toHex8(S)
    }
    ,
    C.prototype.toHexShortString = function(S) {
        return S === void 0 && (S = !1),
        this.a === 1 ? this.toHexString(S) : this.toHex8String(S)
    }
    ,
    C.prototype.toRgb = function() {
        return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
        }
    }
    ,
    C.prototype.toRgbString = function() {
        var S = Math.round(this.r)
          , E = Math.round(this.g)
          , M = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(S, ", ").concat(E, ", ").concat(M, ")") : "rgba(".concat(S, ", ").concat(E, ", ").concat(M, ", ").concat(this.roundA, ")")
    }
    ,
    C.prototype.toPercentageRgb = function() {
        var S = function(E) {
            return "".concat(Math.round(bound01(E, 255) * 100), "%")
        };
        return {
            r: S(this.r),
            g: S(this.g),
            b: S(this.b),
            a: this.a
        }
    }
    ,
    C.prototype.toPercentageRgbString = function() {
        var S = function(E) {
            return Math.round(bound01(E, 255) * 100)
        };
        return this.a === 1 ? "rgb(".concat(S(this.r), "%, ").concat(S(this.g), "%, ").concat(S(this.b), "%)") : "rgba(".concat(S(this.r), "%, ").concat(S(this.g), "%, ").concat(S(this.b), "%, ").concat(this.roundA, ")")
    }
    ,
    C.prototype.toName = function() {
        if (this.a === 0)
            return "transparent";
        if (this.a < 1)
            return !1;
        for (var S = "#" + rgbToHex(this.r, this.g, this.b, !1), E = 0, M = Object.entries(names); E < M.length; E++) {
            var T = M[E]
              , $ = T[0]
              , B = T[1];
            if (S === B)
                return $
        }
        return !1
    }
    ,
    C.prototype.toString = function(S) {
        var E = !!S;
        S = S ?? this.format;
        var M = !1
          , T = this.a < 1 && this.a >= 0
          , $ = !E && T && (S.startsWith("hex") || S === "name");
        return $ ? S === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (S === "rgb" && (M = this.toRgbString()),
        S === "prgb" && (M = this.toPercentageRgbString()),
        (S === "hex" || S === "hex6") && (M = this.toHexString()),
        S === "hex3" && (M = this.toHexString(!0)),
        S === "hex4" && (M = this.toHex8String(!0)),
        S === "hex8" && (M = this.toHex8String()),
        S === "name" && (M = this.toName()),
        S === "hsl" && (M = this.toHslString()),
        S === "hsv" && (M = this.toHsvString()),
        M || this.toHexString())
    }
    ,
    C.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    ,
    C.prototype.clone = function() {
        return new C(this.toString())
    }
    ,
    C.prototype.lighten = function(S) {
        S === void 0 && (S = 10);
        var E = this.toHsl();
        return E.l += S / 100,
        E.l = clamp01(E.l),
        new C(E)
    }
    ,
    C.prototype.brighten = function(S) {
        S === void 0 && (S = 10);
        var E = this.toRgb();
        return E.r = Math.max(0, Math.min(255, E.r - Math.round(255 * -(S / 100)))),
        E.g = Math.max(0, Math.min(255, E.g - Math.round(255 * -(S / 100)))),
        E.b = Math.max(0, Math.min(255, E.b - Math.round(255 * -(S / 100)))),
        new C(E)
    }
    ,
    C.prototype.darken = function(S) {
        S === void 0 && (S = 10);
        var E = this.toHsl();
        return E.l -= S / 100,
        E.l = clamp01(E.l),
        new C(E)
    }
    ,
    C.prototype.tint = function(S) {
        return S === void 0 && (S = 10),
        this.mix("white", S)
    }
    ,
    C.prototype.shade = function(S) {
        return S === void 0 && (S = 10),
        this.mix("black", S)
    }
    ,
    C.prototype.desaturate = function(S) {
        S === void 0 && (S = 10);
        var E = this.toHsl();
        return E.s -= S / 100,
        E.s = clamp01(E.s),
        new C(E)
    }
    ,
    C.prototype.saturate = function(S) {
        S === void 0 && (S = 10);
        var E = this.toHsl();
        return E.s += S / 100,
        E.s = clamp01(E.s),
        new C(E)
    }
    ,
    C.prototype.greyscale = function() {
        return this.desaturate(100)
    }
    ,
    C.prototype.spin = function(S) {
        var E = this.toHsl()
          , M = (E.h + S) % 360;
        return E.h = M < 0 ? 360 + M : M,
        new C(E)
    }
    ,
    C.prototype.mix = function(S, E) {
        E === void 0 && (E = 50);
        var M = this.toRgb()
          , T = new C(S).toRgb()
          , $ = E / 100
          , B = {
            r: (T.r - M.r) * $ + M.r,
            g: (T.g - M.g) * $ + M.g,
            b: (T.b - M.b) * $ + M.b,
            a: (T.a - M.a) * $ + M.a
        };
        return new C(B)
    }
    ,
    C.prototype.analogous = function(S, E) {
        S === void 0 && (S = 6),
        E === void 0 && (E = 30);
        var M = this.toHsl()
          , T = 360 / E
          , $ = [this];
        for (M.h = (M.h - (T * S >> 1) + 720) % 360; --S; )
            M.h = (M.h + T) % 360,
            $.push(new C(M));
        return $
    }
    ,
    C.prototype.complement = function() {
        var S = this.toHsl();
        return S.h = (S.h + 180) % 360,
        new C(S)
    }
    ,
    C.prototype.monochromatic = function(S) {
        S === void 0 && (S = 6);
        for (var E = this.toHsv(), M = E.h, T = E.s, $ = E.v, B = [], O = 1 / S; S--; )
            B.push(new C({
                h: M,
                s: T,
                v: $
            })),
            $ = ($ + O) % 1;
        return B
    }
    ,
    C.prototype.splitcomplement = function() {
        var S = this.toHsl()
          , E = S.h;
        return [this, new C({
            h: (E + 72) % 360,
            s: S.s,
            l: S.l
        }), new C({
            h: (E + 216) % 360,
            s: S.s,
            l: S.l
        })]
    }
    ,
    C.prototype.onBackground = function(S) {
        var E = this.toRgb()
          , M = new C(S).toRgb()
          , T = E.a + M.a * (1 - E.a);
        return new C({
            r: (E.r * E.a + M.r * M.a * (1 - E.a)) / T,
            g: (E.g * E.a + M.g * M.a * (1 - E.a)) / T,
            b: (E.b * E.a + M.b * M.a * (1 - E.a)) / T,
            a: T
        })
    }
    ,
    C.prototype.triad = function() {
        return this.polyad(3)
    }
    ,
    C.prototype.tetrad = function() {
        return this.polyad(4)
    }
    ,
    C.prototype.polyad = function(S) {
        for (var E = this.toHsl(), M = E.h, T = [this], $ = 360 / S, B = 1; B < S; B++)
            T.push(new C({
                h: (M + B * $) % 360,
                s: E.s,
                l: E.l
            }));
        return T
    }
    ,
    C.prototype.equals = function(S) {
        return this.toRgbString() === new C(S).toRgbString()
    }
    ,
    C
}()
  , hueStep = 2
  , saturationStep = .16
  , saturationStep2 = .05
  , brightnessStep1 = .05
  , brightnessStep2 = .15
  , lightColorCount = 5
  , darkColorCount = 4
  , darkColorMap = [{
    index: 7,
    opacity: .15
}, {
    index: 6,
    opacity: .25
}, {
    index: 5,
    opacity: .3
}, {
    index: 5,
    opacity: .45
}, {
    index: 5,
    opacity: .65
}, {
    index: 5,
    opacity: .85
}, {
    index: 4,
    opacity: .9
}, {
    index: 3,
    opacity: .95
}, {
    index: 2,
    opacity: .97
}, {
    index: 1,
    opacity: .98
}];
function toHsv(C) {
    var S = C.r
      , E = C.g
      , M = C.b
      , T = rgbToHsv(S, E, M);
    return {
        h: T.h * 360,
        s: T.s,
        v: T.v
    }
}
function toHex(C) {
    var S = C.r
      , E = C.g
      , M = C.b;
    return "#".concat(rgbToHex(S, E, M, !1))
}
function mix(C, S, E) {
    var M = E / 100
      , T = {
        r: (S.r - C.r) * M + C.r,
        g: (S.g - C.g) * M + C.g,
        b: (S.b - C.b) * M + C.b
    };
    return T
}
function getHue(C, S, E) {
    var M;
    return Math.round(C.h) >= 60 && Math.round(C.h) <= 240 ? M = E ? Math.round(C.h) - hueStep * S : Math.round(C.h) + hueStep * S : M = E ? Math.round(C.h) + hueStep * S : Math.round(C.h) - hueStep * S,
    M < 0 ? M += 360 : M >= 360 && (M -= 360),
    M
}
function getSaturation(C, S, E) {
    if (C.h === 0 && C.s === 0)
        return C.s;
    var M;
    return E ? M = C.s - saturationStep * S : S === darkColorCount ? M = C.s + saturationStep : M = C.s + saturationStep2 * S,
    M > 1 && (M = 1),
    E && S === lightColorCount && M > .1 && (M = .1),
    M < .06 && (M = .06),
    Number(M.toFixed(2))
}
function getValue(C, S, E) {
    var M;
    return E ? M = C.v + brightnessStep1 * S : M = C.v - brightnessStep2 * S,
    M > 1 && (M = 1),
    Number(M.toFixed(2))
}
function generate$2(C) {
    for (var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, E = [], M = inputToRGB(C), T = lightColorCount; T > 0; T -= 1) {
        var $ = toHsv(M)
          , B = toHex(inputToRGB({
            h: getHue($, T, !0),
            s: getSaturation($, T, !0),
            v: getValue($, T, !0)
        }));
        E.push(B)
    }
    E.push(toHex(M));
    for (var O = 1; O <= darkColorCount; O += 1) {
        var F = toHsv(M)
          , N = toHex(inputToRGB({
            h: getHue(F, O),
            s: getSaturation(F, O),
            v: getValue(F, O)
        }));
        E.push(N)
    }
    return S.theme === "dark" ? darkColorMap.map(function(U) {
        var H = U.index
          , Z = U.opacity
          , J = toHex(mix(inputToRGB(S.backgroundColor || "#141414"), inputToRGB(E[H]), Z * 100));
        return J
    }) : E
}
var presetPrimaryColors = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
}
  , presetPalettes = {}
  , presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(C) {
    presetPalettes[C] = generate$2(presetPrimaryColors[C]),
    presetPalettes[C].primary = presetPalettes[C][5],
    presetDarkPalettes[C] = generate$2(presetPrimaryColors[C], {
        theme: "dark",
        backgroundColor: "#141414"
    }),
    presetDarkPalettes[C].primary = presetDarkPalettes[C][5]
});
var blue = presetPalettes.blue;
const defaultPresetColors = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
}
  , seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
    fontSize: 14,
    lineWidth: 1,
    lineType: "solid",
    motionUnit: .1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
    motion: !0
})
  , seedToken$1 = seedToken;
function genColorMapToken(C, S) {
    let {generateColorPalettes: E, generateNeutralColorPalettes: M} = S;
    const {colorSuccess: T, colorWarning: $, colorError: B, colorInfo: O, colorPrimary: F, colorBgBase: N, colorTextBase: U} = C
      , H = E(F)
      , Z = E(T)
      , J = E($)
      , ie = E(B)
      , oe = E(O)
      , ae = M(N, U)
      , se = C.colorLink || C.colorInfo
      , le = E(se);
    return Object.assign(Object.assign({}, ae), {
        colorPrimaryBg: H[1],
        colorPrimaryBgHover: H[2],
        colorPrimaryBorder: H[3],
        colorPrimaryBorderHover: H[4],
        colorPrimaryHover: H[5],
        colorPrimary: H[6],
        colorPrimaryActive: H[7],
        colorPrimaryTextHover: H[8],
        colorPrimaryText: H[9],
        colorPrimaryTextActive: H[10],
        colorSuccessBg: Z[1],
        colorSuccessBgHover: Z[2],
        colorSuccessBorder: Z[3],
        colorSuccessBorderHover: Z[4],
        colorSuccessHover: Z[4],
        colorSuccess: Z[6],
        colorSuccessActive: Z[7],
        colorSuccessTextHover: Z[8],
        colorSuccessText: Z[9],
        colorSuccessTextActive: Z[10],
        colorErrorBg: ie[1],
        colorErrorBgHover: ie[2],
        colorErrorBorder: ie[3],
        colorErrorBorderHover: ie[4],
        colorErrorHover: ie[5],
        colorError: ie[6],
        colorErrorActive: ie[7],
        colorErrorTextHover: ie[8],
        colorErrorText: ie[9],
        colorErrorTextActive: ie[10],
        colorWarningBg: J[1],
        colorWarningBgHover: J[2],
        colorWarningBorder: J[3],
        colorWarningBorderHover: J[4],
        colorWarningHover: J[4],
        colorWarning: J[6],
        colorWarningActive: J[7],
        colorWarningTextHover: J[8],
        colorWarningText: J[9],
        colorWarningTextActive: J[10],
        colorInfoBg: oe[1],
        colorInfoBgHover: oe[2],
        colorInfoBorder: oe[3],
        colorInfoBorderHover: oe[4],
        colorInfoHover: oe[4],
        colorInfo: oe[6],
        colorInfoActive: oe[7],
        colorInfoTextHover: oe[8],
        colorInfoText: oe[9],
        colorInfoTextActive: oe[10],
        colorLinkHover: le[4],
        colorLink: le[6],
        colorLinkActive: le[7],
        colorBgMask: new TinyColor("#000").setAlpha(.45).toRgbString(),
        colorWhite: "#fff"
    })
}
const genRadius = C=>{
    let S = C
      , E = C
      , M = C
      , T = C;
    return C < 6 && C >= 5 ? S = C + 1 : C < 16 && C >= 6 ? S = C + 2 : C >= 16 && (S = 16),
    C < 7 && C >= 5 ? E = 4 : C < 8 && C >= 7 ? E = 5 : C < 14 && C >= 8 ? E = 6 : C < 16 && C >= 14 ? E = 7 : C >= 16 && (E = 8),
    C < 6 && C >= 2 ? M = 1 : C >= 6 && (M = 2),
    C > 4 && C < 8 ? T = 4 : C >= 8 && (T = 6),
    {
        borderRadius: C,
        borderRadiusXS: M,
        borderRadiusSM: E,
        borderRadiusLG: S,
        borderRadiusOuter: T
    }
}
;
function genCommonMapToken(C) {
    const {motionUnit: S, motionBase: E, borderRadius: M, lineWidth: T} = C;
    return Object.assign({
        motionDurationFast: `${(E + S).toFixed(1)}s`,
        motionDurationMid: `${(E + S * 2).toFixed(1)}s`,
        motionDurationSlow: `${(E + S * 3).toFixed(1)}s`,
        lineWidthBold: T + 1
    }, genRadius(M))
}
const genControlHeight = C=>{
    const {controlHeight: S} = C;
    return {
        controlHeightSM: S * .75,
        controlHeightXS: S * .5,
        controlHeightLG: S * 1.25
    }
}
;
function getLineHeight(C) {
    return (C + 8) / C
}
function getFontSizes(C) {
    const S = new Array(10).fill(null).map((E,M)=>{
        const T = M - 1
          , $ = C * Math.pow(2.71828, T / 5)
          , B = M > 1 ? Math.floor($) : Math.ceil($);
        return Math.floor(B / 2) * 2
    }
    );
    return S[1] = C,
    S.map(E=>({
        size: E,
        lineHeight: getLineHeight(E)
    }))
}
const genFontMapToken = C=>{
    const S = getFontSizes(C)
      , E = S.map(U=>U.size)
      , M = S.map(U=>U.lineHeight)
      , T = E[1]
      , $ = E[0]
      , B = E[2]
      , O = M[1]
      , F = M[0]
      , N = M[2];
    return {
        fontSizeSM: $,
        fontSize: T,
        fontSizeLG: B,
        fontSizeXL: E[3],
        fontSizeHeading1: E[6],
        fontSizeHeading2: E[5],
        fontSizeHeading3: E[4],
        fontSizeHeading4: E[3],
        fontSizeHeading5: E[2],
        lineHeight: O,
        lineHeightLG: N,
        lineHeightSM: F,
        fontHeight: Math.round(O * T),
        fontHeightLG: Math.round(N * B),
        fontHeightSM: Math.round(F * $),
        lineHeightHeading1: M[6],
        lineHeightHeading2: M[5],
        lineHeightHeading3: M[4],
        lineHeightHeading4: M[3],
        lineHeightHeading5: M[2]
    }
}
;
function genSizeMapToken(C) {
    const {sizeUnit: S, sizeStep: E} = C;
    return {
        sizeXXL: S * (E + 8),
        sizeXL: S * (E + 4),
        sizeLG: S * (E + 2),
        sizeMD: S * (E + 1),
        sizeMS: S * E,
        size: S * E,
        sizeSM: S * (E - 1),
        sizeXS: S * (E - 2),
        sizeXXS: S * (E - 3)
    }
}
const getAlphaColor$1 = (C,S)=>new TinyColor(C).setAlpha(S).toRgbString()
  , getSolidColor = (C,S)=>new TinyColor(C).darken(S).toHexString()
  , generateColorPalettes = C=>{
    const S = generate$2(C);
    return {
        1: S[0],
        2: S[1],
        3: S[2],
        4: S[3],
        5: S[4],
        6: S[5],
        7: S[6],
        8: S[4],
        9: S[5],
        10: S[6]
    }
}
  , generateNeutralColorPalettes = (C,S)=>{
    const E = C || "#fff"
      , M = S || "#000";
    return {
        colorBgBase: E,
        colorTextBase: M,
        colorText: getAlphaColor$1(M, .88),
        colorTextSecondary: getAlphaColor$1(M, .65),
        colorTextTertiary: getAlphaColor$1(M, .45),
        colorTextQuaternary: getAlphaColor$1(M, .25),
        colorFill: getAlphaColor$1(M, .15),
        colorFillSecondary: getAlphaColor$1(M, .06),
        colorFillTertiary: getAlphaColor$1(M, .04),
        colorFillQuaternary: getAlphaColor$1(M, .02),
        colorBgLayout: getSolidColor(E, 4),
        colorBgContainer: getSolidColor(E, 0),
        colorBgElevated: getSolidColor(E, 0),
        colorBgSpotlight: getAlphaColor$1(M, .85),
        colorBgBlur: "transparent",
        colorBorder: getSolidColor(E, 15),
        colorBorderSecondary: getSolidColor(E, 6)
    }
}
;
function derivative(C) {
    const S = Object.keys(defaultPresetColors).map(E=>{
        const M = generate$2(C[E]);
        return new Array(10).fill(1).reduce((T,$,B)=>(T[`${E}-${B + 1}`] = M[B],
        T[`${E}${B + 1}`] = M[B],
        T), {})
    }
    ).reduce((E,M)=>(E = Object.assign(Object.assign({}, E), M),
    E), {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, C), S), genColorMapToken(C, {
        generateColorPalettes,
        generateNeutralColorPalettes
    })), genFontMapToken(C.fontSize)), genSizeMapToken(C)), genControlHeight(C)), genCommonMapToken(C))
}
const defaultTheme = createTheme(derivative)
  , defaultConfig = {
    token: seedToken$1,
    override: {
        override: seedToken$1
    },
    hashed: !0
}
  , DesignTokenContext = React$1.createContext(defaultConfig)
  , defaultIconPrefixCls = "anticon"
  , defaultGetPrefixCls = (C,S)=>S || (C ? `ant-${C}` : "ant")
  , ConfigContext = reactExports.createContext({
    getPrefixCls: defaultGetPrefixCls,
    iconPrefixCls: defaultIconPrefixCls
})
  , dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle(C, S) {
    const E = {}
      , M = (B,O)=>{
        let F = B.clone();
        return F = (O == null ? void 0 : O(F)) || F,
        F.toRgbString()
    }
      , T = (B,O)=>{
        const F = new TinyColor(B)
          , N = generate$2(F.toRgbString());
        E[`${O}-color`] = M(F),
        E[`${O}-color-disabled`] = N[1],
        E[`${O}-color-hover`] = N[4],
        E[`${O}-color-active`] = N[6],
        E[`${O}-color-outline`] = F.clone().setAlpha(.2).toRgbString(),
        E[`${O}-color-deprecated-bg`] = N[0],
        E[`${O}-color-deprecated-border`] = N[2]
    }
    ;
    if (S.primaryColor) {
        T(S.primaryColor, "primary");
        const B = new TinyColor(S.primaryColor)
          , O = generate$2(B.toRgbString());
        O.forEach((N,U)=>{
            E[`primary-${U + 1}`] = N
        }
        ),
        E["primary-color-deprecated-l-35"] = M(B, N=>N.lighten(35)),
        E["primary-color-deprecated-l-20"] = M(B, N=>N.lighten(20)),
        E["primary-color-deprecated-t-20"] = M(B, N=>N.tint(20)),
        E["primary-color-deprecated-t-50"] = M(B, N=>N.tint(50)),
        E["primary-color-deprecated-f-12"] = M(B, N=>N.setAlpha(N.getAlpha() * .12));
        const F = new TinyColor(O[0]);
        E["primary-color-active-deprecated-f-30"] = M(F, N=>N.setAlpha(N.getAlpha() * .3)),
        E["primary-color-active-deprecated-d-02"] = M(F, N=>N.darken(2))
    }
    return S.successColor && T(S.successColor, "success"),
    S.warningColor && T(S.warningColor, "warning"),
    S.errorColor && T(S.errorColor, "error"),
    S.infoColor && T(S.infoColor, "info"),
    `
  :root {
    ${Object.keys(E).map(B=>`--${C}-${B}: ${E[B]};`).join(`
`)}
  }
  `.trim()
}
function registerTheme(C, S) {
    const E = getStyle(C, S);
    canUseDom() && updateCSS(E, `${dynamicStyleMark}-dynamic-theme`)
}
const DisabledContext = reactExports.createContext(!1)
  , DisabledContextProvider = C=>{
    let {children: S, disabled: E} = C;
    const M = reactExports.useContext(DisabledContext);
    return reactExports.createElement(DisabledContext.Provider, {
        value: E ?? M
    }, S)
}
  , DisabledContext$1 = DisabledContext
  , SizeContext = reactExports.createContext(void 0)
  , SizeContextProvider = C=>{
    let {children: S, size: E} = C;
    const M = reactExports.useContext(SizeContext);
    return reactExports.createElement(SizeContext.Provider, {
        value: E || M
    }, S)
}
  , SizeContext$1 = SizeContext;
function useConfig() {
    const C = reactExports.useContext(DisabledContext$1)
      , S = reactExports.useContext(SizeContext$1);
    return {
        componentDisabled: C,
        componentSize: S
    }
}
const version$2 = "5.16.1";
function isStableColor(C) {
    return C >= 0 && C <= 255
}
function getAlphaColor(C, S) {
    const {r: E, g: M, b: T, a: $} = new TinyColor(C).toRgb();
    if ($ < 1)
        return C;
    const {r: B, g: O, b: F} = new TinyColor(S).toRgb();
    for (let N = .01; N <= 1; N += .01) {
        const U = Math.round((E - B * (1 - N)) / N)
          , H = Math.round((M - O * (1 - N)) / N)
          , Z = Math.round((T - F * (1 - N)) / N);
        if (isStableColor(U) && isStableColor(H) && isStableColor(Z))
            return new TinyColor({
                r: U,
                g: H,
                b: Z,
                a: Math.round(N * 100) / 100
            }).toRgbString()
    }
    return new TinyColor({
        r: E,
        g: M,
        b: T,
        a: 1
    }).toRgbString()
}
var __rest$4 = function(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
};
function formatToken(C) {
    const {override: S} = C
      , E = __rest$4(C, ["override"])
      , M = Object.assign({}, S);
    Object.keys(seedToken$1).forEach(Z=>{
        delete M[Z]
    }
    );
    const T = Object.assign(Object.assign({}, E), M)
      , $ = 480
      , B = 576
      , O = 768
      , F = 992
      , N = 1200
      , U = 1600;
    if (T.motion === !1) {
        const Z = "0s";
        T.motionDurationFast = Z,
        T.motionDurationMid = Z,
        T.motionDurationSlow = Z
    }
    return Object.assign(Object.assign(Object.assign({}, T), {
        colorFillContent: T.colorFillSecondary,
        colorFillContentHover: T.colorFill,
        colorFillAlter: T.colorFillQuaternary,
        colorBgContainerDisabled: T.colorFillTertiary,
        colorBorderBg: T.colorBgContainer,
        colorSplit: getAlphaColor(T.colorBorderSecondary, T.colorBgContainer),
        colorTextPlaceholder: T.colorTextQuaternary,
        colorTextDisabled: T.colorTextQuaternary,
        colorTextHeading: T.colorText,
        colorTextLabel: T.colorTextSecondary,
        colorTextDescription: T.colorTextTertiary,
        colorTextLightSolid: T.colorWhite,
        colorHighlight: T.colorError,
        colorBgTextHover: T.colorFillSecondary,
        colorBgTextActive: T.colorFill,
        colorIcon: T.colorTextTertiary,
        colorIconHover: T.colorText,
        colorErrorOutline: getAlphaColor(T.colorErrorBg, T.colorBgContainer),
        colorWarningOutline: getAlphaColor(T.colorWarningBg, T.colorBgContainer),
        fontSizeIcon: T.fontSizeSM,
        lineWidthFocus: T.lineWidth * 4,
        lineWidth: T.lineWidth,
        controlOutlineWidth: T.lineWidth * 2,
        controlInteractiveSize: T.controlHeight / 2,
        controlItemBgHover: T.colorFillTertiary,
        controlItemBgActive: T.colorPrimaryBg,
        controlItemBgActiveHover: T.colorPrimaryBgHover,
        controlItemBgActiveDisabled: T.colorFill,
        controlTmpOutline: T.colorFillQuaternary,
        controlOutline: getAlphaColor(T.colorPrimaryBg, T.colorBgContainer),
        lineType: T.lineType,
        borderRadius: T.borderRadius,
        borderRadiusXS: T.borderRadiusXS,
        borderRadiusSM: T.borderRadiusSM,
        borderRadiusLG: T.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: .65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: T.sizeXXS,
        paddingXS: T.sizeXS,
        paddingSM: T.sizeSM,
        padding: T.size,
        paddingMD: T.sizeMD,
        paddingLG: T.sizeLG,
        paddingXL: T.sizeXL,
        paddingContentHorizontalLG: T.sizeLG,
        paddingContentVerticalLG: T.sizeMS,
        paddingContentHorizontal: T.sizeMS,
        paddingContentVertical: T.sizeSM,
        paddingContentHorizontalSM: T.size,
        paddingContentVerticalSM: T.sizeXS,
        marginXXS: T.sizeXXS,
        marginXS: T.sizeXS,
        marginSM: T.sizeSM,
        margin: T.size,
        marginMD: T.sizeMD,
        marginLG: T.sizeLG,
        marginXL: T.sizeXL,
        marginXXL: T.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS: $,
        screenXSMin: $,
        screenXSMax: B - 1,
        screenSM: B,
        screenSMMin: B,
        screenSMMax: O - 1,
        screenMD: O,
        screenMDMin: O,
        screenMDMax: F - 1,
        screenLG: F,
        screenLGMin: F,
        screenLGMax: N - 1,
        screenXL: N,
        screenXLMin: N,
        screenXLMax: U - 1,
        screenXXL: U,
        screenXXLMin: U,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), M)
}
var __rest$3 = function(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
};
const unitless = {
    lineHeight: !0,
    lineHeightSM: !0,
    lineHeightLG: !0,
    lineHeightHeading1: !0,
    lineHeightHeading2: !0,
    lineHeightHeading3: !0,
    lineHeightHeading4: !0,
    lineHeightHeading5: !0,
    opacityLoading: !0,
    fontWeightStrong: !0,
    zIndexPopupBase: !0,
    zIndexBase: !0
}
  , ignore = {
    size: !0,
    sizeSM: !0,
    sizeLG: !0,
    sizeMD: !0,
    sizeXS: !0,
    sizeXXS: !0,
    sizeMS: !0,
    sizeXL: !0,
    sizeXXL: !0,
    sizeUnit: !0,
    sizeStep: !0,
    motionBase: !0,
    motionUnit: !0
}
  , preserve = {
    screenXS: !0,
    screenXSMin: !0,
    screenXSMax: !0,
    screenSM: !0,
    screenSMMin: !0,
    screenSMMax: !0,
    screenMD: !0,
    screenMDMin: !0,
    screenMDMax: !0,
    screenLG: !0,
    screenLGMin: !0,
    screenLGMax: !0,
    screenXL: !0,
    screenXLMin: !0,
    screenXLMax: !0,
    screenXXL: !0,
    screenXXLMin: !0
}
  , getComputedToken = (C,S,E)=>{
    const M = E.getDerivativeToken(C)
      , {override: T} = S
      , $ = __rest$3(S, ["override"]);
    let B = Object.assign(Object.assign({}, M), {
        override: T
    });
    return B = formatToken(B),
    $ && Object.entries($).forEach(O=>{
        let[F,N] = O;
        const {theme: U} = N
          , H = __rest$3(N, ["theme"]);
        let Z = H;
        U && (Z = getComputedToken(Object.assign(Object.assign({}, B), H), {
            override: H
        }, U)),
        B[F] = Z
    }
    ),
    B
}
;
function useToken() {
    const {token: C, hashed: S, theme: E, override: M, cssVar: T} = React$1.useContext(DesignTokenContext)
      , $ = `${version$2}-${S || ""}`
      , B = E || defaultTheme
      , [O,F,N] = useCacheToken(B, [seedToken$1, C], {
        salt: $,
        override: M,
        getComputedToken,
        formatToken,
        cssVar: T && {
            prefix: T.prefix,
            key: T.key,
            unitless,
            ignore,
            preserve
        }
    });
    return [B, N, S ? F : "", O, T]
}
function useSafeState(C) {
    var S = reactExports.useRef(!1)
      , E = reactExports.useState(C)
      , M = _slicedToArray(E, 2)
      , T = M[0]
      , $ = M[1];
    reactExports.useEffect(function() {
        return S.current = !1,
        function() {
            S.current = !0
        }
    }, []);
    function B(O, F) {
        F && S.current || $(O)
    }
    return [T, B]
}
const resetComponent = function(C) {
    let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return {
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: C.colorText,
        fontSize: C.fontSize,
        lineHeight: C.lineHeight,
        listStyle: "none",
        fontFamily: S ? "inherit" : C.fontFamily
    }
}
  , resetIcon = ()=>({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
        lineHeight: 1
    },
    svg: {
        display: "inline-block"
    }
})
  , genLinkStyle = C=>({
    a: {
        color: C.colorLink,
        textDecoration: C.linkDecoration,
        backgroundColor: "transparent",
        outline: "none",
        cursor: "pointer",
        transition: `color ${C.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        "&:hover": {
            color: C.colorLinkHover
        },
        "&:active": {
            color: C.colorLinkActive
        },
        "&:active,\n  &:hover": {
            textDecoration: C.linkHoverDecoration,
            outline: 0
        },
        "&:focus": {
            textDecoration: C.linkFocusDecoration,
            outline: 0
        },
        "&[disabled]": {
            color: C.colorTextDisabled,
            cursor: "not-allowed"
        }
    }
})
  , genCommonStyle = (C,S,E)=>{
    const {fontFamily: M, fontSize: T} = C
      , $ = `[class^="${S}"], [class*=" ${S}"]`;
    return {
        [E ? `.${E}` : $]: {
            fontFamily: M,
            fontSize: T,
            boxSizing: "border-box",
            "&::before, &::after": {
                boxSizing: "border-box"
            },
            [$]: {
                boxSizing: "border-box",
                "&::before, &::after": {
                    boxSizing: "border-box"
                }
            }
        }
    }
}
  , genFocusOutline = C=>({
    outline: `${unit$1(C.lineWidthFocus)} solid ${C.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
})
  , genFocusStyle = C=>({
    "&:focus-visible": Object.assign({}, genFocusOutline(C))
});
function _callSuper(C, S, E) {
    return S = _getPrototypeOf(S),
    _possibleConstructorReturn(C, _isNativeReflectConstruct() ? Reflect.construct(S, E || [], _getPrototypeOf(C).constructor) : S.apply(C, E))
}
let AbstractCalculator = _createClass(function C() {
    _classCallCheck(this, C)
});
const AbstractCalculator$1 = AbstractCalculator;
let NumCalculator = function(C) {
    function S(E) {
        var M;
        return _classCallCheck(this, S),
        M = _callSuper(this, S),
        M.result = 0,
        E instanceof S ? M.result = E.result : typeof E == "number" && (M.result = E),
        M
    }
    return _inherits(S, C),
    _createClass(S, [{
        key: "add",
        value: function(M) {
            return M instanceof S ? this.result += M.result : typeof M == "number" && (this.result += M),
            this
        }
    }, {
        key: "sub",
        value: function(M) {
            return M instanceof S ? this.result -= M.result : typeof M == "number" && (this.result -= M),
            this
        }
    }, {
        key: "mul",
        value: function(M) {
            return M instanceof S ? this.result *= M.result : typeof M == "number" && (this.result *= M),
            this
        }
    }, {
        key: "div",
        value: function(M) {
            return M instanceof S ? this.result /= M.result : typeof M == "number" && (this.result /= M),
            this
        }
    }, {
        key: "equal",
        value: function() {
            return this.result
        }
    }])
}(AbstractCalculator$1);
const CALC_UNIT = "CALC_UNIT";
function unit(C) {
    return typeof C == "number" ? `${C}${CALC_UNIT}` : C
}
let CSSCalculator = function(C) {
    function S(E) {
        var M;
        return _classCallCheck(this, S),
        M = _callSuper(this, S),
        M.result = "",
        E instanceof S ? M.result = `(${E.result})` : typeof E == "number" ? M.result = unit(E) : typeof E == "string" && (M.result = E),
        M
    }
    return _inherits(S, C),
    _createClass(S, [{
        key: "add",
        value: function(M) {
            return M instanceof S ? this.result = `${this.result} + ${M.getResult()}` : (typeof M == "number" || typeof M == "string") && (this.result = `${this.result} + ${unit(M)}`),
            this.lowPriority = !0,
            this
        }
    }, {
        key: "sub",
        value: function(M) {
            return M instanceof S ? this.result = `${this.result} - ${M.getResult()}` : (typeof M == "number" || typeof M == "string") && (this.result = `${this.result} - ${unit(M)}`),
            this.lowPriority = !0,
            this
        }
    }, {
        key: "mul",
        value: function(M) {
            return this.lowPriority && (this.result = `(${this.result})`),
            M instanceof S ? this.result = `${this.result} * ${M.getResult(!0)}` : (typeof M == "number" || typeof M == "string") && (this.result = `${this.result} * ${M}`),
            this.lowPriority = !1,
            this
        }
    }, {
        key: "div",
        value: function(M) {
            return this.lowPriority && (this.result = `(${this.result})`),
            M instanceof S ? this.result = `${this.result} / ${M.getResult(!0)}` : (typeof M == "number" || typeof M == "string") && (this.result = `${this.result} / ${M}`),
            this.lowPriority = !1,
            this
        }
    }, {
        key: "getResult",
        value: function(M) {
            return this.lowPriority || M ? `(${this.result})` : this.result
        }
    }, {
        key: "equal",
        value: function(M) {
            const {unit: T=!0} = M || {}
              , $ = new RegExp(`${CALC_UNIT}`,"g");
            return this.result = this.result.replace($, T ? "px" : ""),
            typeof this.lowPriority < "u" ? `calc(${this.result})` : this.result
        }
    }])
}(AbstractCalculator$1);
const genCalc = C=>{
    const S = C === "css" ? CSSCalculator : NumCalculator;
    return E=>new S(E)
}
;
function genMaxMin(C) {
    return C === "js" ? {
        max: Math.max,
        min: Math.min
    } : {
        max: function() {
            for (var S = arguments.length, E = new Array(S), M = 0; M < S; M++)
                E[M] = arguments[M];
            return `max(${E.map(T=>unit$1(T)).join(",")})`
        },
        min: function() {
            for (var S = arguments.length, E = new Array(S), M = 0; M < S; M++)
                E[M] = arguments[M];
            return `min(${E.map(T=>unit$1(T)).join(",")})`
        }
    }
}
const enableStatistic = typeof CSSINJS_STATISTIC < "u";
let recording = !0;
function merge$1() {
    for (var C = arguments.length, S = new Array(C), E = 0; E < C; E++)
        S[E] = arguments[E];
    if (!enableStatistic)
        return Object.assign.apply(Object, [{}].concat(S));
    recording = !1;
    const M = {};
    return S.forEach(T=>{
        Object.keys(T).forEach(B=>{
            Object.defineProperty(M, B, {
                configurable: !0,
                enumerable: !0,
                get: ()=>T[B]
            })
        }
        )
    }
    ),
    recording = !0,
    M
}
const statistic = {};
function noop$1() {}
const statisticToken = C=>{
    let S, E = C, M = noop$1;
    return enableStatistic && typeof Proxy < "u" && (S = new Set,
    E = new Proxy(C,{
        get(T, $) {
            return recording && S.add($),
            T[$]
        }
    }),
    M = (T,$)=>{
        var B;
        statistic[T] = {
            global: Array.from(S),
            component: Object.assign(Object.assign({}, (B = statistic[T]) === null || B === void 0 ? void 0 : B.component), $)
        }
    }
    ),
    {
        token: E,
        keys: S,
        flush: M
    }
}
  , useResetIconStyle = (C,S)=>{
    const [E,M] = useToken();
    return useStyleRegister({
        theme: E,
        token: M,
        hashId: "",
        path: ["ant-design-icons", C],
        nonce: ()=>S == null ? void 0 : S.nonce
    }, ()=>[{
        [`.${C}`]: Object.assign(Object.assign({}, resetIcon()), {
            [`.${C} .${C}-icon`]: {
                display: "block"
            }
        })
    }])
}
  , getDefaultComponentToken = (C,S,E)=>{
    var M;
    return typeof E == "function" ? E(merge$1(S, (M = S[C]) !== null && M !== void 0 ? M : {})) : E ?? {}
}
  , getComponentToken = (C,S,E,M)=>{
    const T = Object.assign({}, S[C]);
    if (M != null && M.deprecatedTokens) {
        const {deprecatedTokens: B} = M;
        B.forEach(O=>{
            let[F,N] = O;
            var U;
            (T != null && T[F] || T != null && T[N]) && ((U = T[N]) !== null && U !== void 0 || (T[N] = T == null ? void 0 : T[F]))
        }
        )
    }
    const $ = Object.assign(Object.assign({}, E), T);
    return Object.keys($).forEach(B=>{
        $[B] === S[B] && delete $[B]
    }
    ),
    $
}
  , getCompVarPrefix = (C,S)=>`${[S, C.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
function genComponentStyleHook(C, S, E) {
    let M = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const T = Array.isArray(C) ? C : [C, C]
      , [$] = T
      , B = T.join("-");
    return function(O) {
        let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : O;
        const [N,U,H,Z,J] = useToken()
          , {getPrefixCls: ie, iconPrefixCls: oe, csp: ae} = reactExports.useContext(ConfigContext)
          , se = ie()
          , le = J ? "css" : "js"
          , de = genCalc(le)
          , {max: fe, min: pe} = genMaxMin(le)
          , ge = {
            theme: N,
            token: Z,
            hashId: H,
            nonce: ()=>ae == null ? void 0 : ae.nonce,
            clientOnly: M.clientOnly,
            order: M.order || -999
        };
        return useStyleRegister(Object.assign(Object.assign({}, ge), {
            clientOnly: !1,
            path: ["Shared", se]
        }), ()=>[{
            "&": genLinkStyle(Z)
        }]),
        useResetIconStyle(oe, ae),
        [useStyleRegister(Object.assign(Object.assign({}, ge), {
            path: [B, O, oe]
        }), ()=>{
            if (M.injectStyle === !1)
                return [];
            const {token: Ae, flush: Se} = statisticToken(Z)
              , ue = getDefaultComponentToken($, U, E)
              , V = `.${O}`
              , W = getComponentToken($, U, ue, {
                deprecatedTokens: M.deprecatedTokens
            });
            J && Object.keys(ue).forEach(L=>{
                ue[L] = `var(${token2CSSVar(L, getCompVarPrefix($, J.prefix))})`
            }
            );
            const D = merge$1(Ae, {
                componentCls: V,
                prefixCls: O,
                iconCls: `.${oe}`,
                antCls: `.${se}`,
                calc: de,
                max: fe,
                min: pe
            }, J ? ue : W)
              , I = S(D, {
                hashId: H,
                prefixCls: O,
                rootPrefixCls: se,
                iconPrefixCls: oe
            });
            return Se($, W),
            [M.resetStyle === !1 ? null : genCommonStyle(D, O, F), I]
        }
        ), H]
    }
}
const genSubStyleComponent = (C,S,E,M)=>{
    const T = genComponentStyleHook(C, S, E, Object.assign({
        resetStyle: !1,
        order: -998
    }, M));
    return B=>{
        let {prefixCls: O, rootCls: F=O} = B;
        return T(O, F),
        null
    }
}
  , genCSSVarRegister = (C,S,E)=>{
    function M(N) {
        return `${C}${N.slice(0, 1).toUpperCase()}${N.slice(1)}`
    }
    const {unitless: T={}, injectStyle: $=!0} = E ?? {}
      , B = {
        [M("zIndexPopup")]: !0
    };
    Object.keys(T).forEach(N=>{
        B[M(N)] = T[N]
    }
    );
    const O = N=>{
        let {rootCls: U, cssVar: H} = N;
        const [,Z] = useToken();
        return useCSSVarRegister({
            path: [C],
            prefix: H.prefix,
            key: H == null ? void 0 : H.key,
            unitless: Object.assign(Object.assign({}, unitless), B),
            ignore,
            token: Z,
            scope: U
        }, ()=>{
            const J = getDefaultComponentToken(C, Z, S)
              , ie = getComponentToken(C, Z, J, {
                deprecatedTokens: E == null ? void 0 : E.deprecatedTokens
            });
            return Object.keys(J).forEach(oe=>{
                ie[M(oe)] = ie[oe],
                delete ie[oe]
            }
            ),
            ie
        }
        ),
        null
    }
    ;
    return N=>{
        const [,,,,U] = useToken();
        return [H=>$ && U ? React$1.createElement(React$1.Fragment, null, React$1.createElement(O, {
            rootCls: N,
            cssVar: U,
            component: C
        }), H) : H, U == null ? void 0 : U.key]
    }
}
  , genStyleHooks = (C,S,E,M)=>{
    const T = genComponentStyleHook(C, S, E, M)
      , $ = genCSSVarRegister(Array.isArray(C) ? C[0] : C, E, M);
    return function(B) {
        let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : B;
        const [,F] = T(B, O)
          , [N,U] = $(O);
        return [N, F, U]
    }
}
  , fullClone$1 = Object.assign({}, React)
  , {useId} = fullClone$1
  , useEmptyId = ()=>""
  , useThemeKey = typeof useId > "u" ? useEmptyId : useId;
function useTheme(C, S, E) {
    var M;
    const T = C || {}
      , $ = T.inherit === !1 || !S ? Object.assign(Object.assign({}, defaultConfig), {
        hashed: (M = S == null ? void 0 : S.hashed) !== null && M !== void 0 ? M : defaultConfig.hashed,
        cssVar: S == null ? void 0 : S.cssVar
    }) : S
      , B = useThemeKey();
    return useMemo(()=>{
        var O, F;
        if (!C)
            return S;
        const N = Object.assign({}, $.components);
        Object.keys(C.components || {}).forEach(Z=>{
            N[Z] = Object.assign(Object.assign({}, N[Z]), C.components[Z])
        }
        );
        const U = `css-var-${B.replace(/:/g, "")}`
          , H = ((O = T.cssVar) !== null && O !== void 0 ? O : $.cssVar) && Object.assign(Object.assign(Object.assign({
            prefix: E == null ? void 0 : E.prefixCls
        }, typeof $.cssVar == "object" ? $.cssVar : {}), typeof T.cssVar == "object" ? T.cssVar : {}), {
            key: typeof T.cssVar == "object" && ((F = T.cssVar) === null || F === void 0 ? void 0 : F.key) || U
        });
        return Object.assign(Object.assign(Object.assign({}, $), T), {
            token: Object.assign(Object.assign({}, $.token), T.token),
            components: N,
            cssVar: H
        })
    }
    , [T, $], (O,F)=>O.some((N,U)=>{
        const H = F[U];
        return !isEqual(N, H, !0)
    }
    ))
}
var _excluded$5 = ["children"]
  , Context = reactExports.createContext({});
function MotionProvider(C) {
    var S = C.children
      , E = _objectWithoutProperties(C, _excluded$5);
    return reactExports.createElement(Context.Provider, {
        value: E
    }, S)
}
var DomWrapper = function(C) {
    _inherits(E, C);
    var S = _createSuper(E);
    function E() {
        return _classCallCheck(this, E),
        S.apply(this, arguments)
    }
    return _createClass(E, [{
        key: "render",
        value: function() {
            return this.props.children
        }
    }]),
    E
}(reactExports.Component)
  , STATUS_NONE = "none"
  , STATUS_APPEAR = "appear"
  , STATUS_ENTER = "enter"
  , STATUS_LEAVE = "leave"
  , STEP_NONE = "none"
  , STEP_PREPARE = "prepare"
  , STEP_START = "start"
  , STEP_ACTIVE = "active"
  , STEP_ACTIVATED = "end"
  , STEP_PREPARED = "prepared";
function makePrefixMap(C, S) {
    var E = {};
    return E[C.toLowerCase()] = S.toLowerCase(),
    E["Webkit".concat(C)] = "webkit".concat(S),
    E["Moz".concat(C)] = "moz".concat(S),
    E["ms".concat(C)] = "MS".concat(S),
    E["O".concat(C)] = "o".concat(S.toLowerCase()),
    E
}
function getVendorPrefixes(C, S) {
    var E = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    return C && ("AnimationEvent"in S || delete E.animationend.animation,
    "TransitionEvent"in S || delete E.transitionend.transition),
    E
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window < "u" ? window : {})
  , style = {};
if (canUseDom()) {
    var _document$createEleme = document.createElement("div");
    style = _document$createEleme.style
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(C) {
    if (prefixedEventNames[C])
        return prefixedEventNames[C];
    var S = vendorPrefixes[C];
    if (S)
        for (var E = Object.keys(S), M = E.length, T = 0; T < M; T += 1) {
            var $ = E[T];
            if (Object.prototype.hasOwnProperty.call(S, $) && $ in style)
                return prefixedEventNames[C] = S[$],
                prefixedEventNames[C]
        }
    return ""
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend")
  , internalTransitionEndName = getVendorPrefixedEventName("transitionend")
  , supportTransition = !!(internalAnimationEndName && internalTransitionEndName)
  , animationEndName = internalAnimationEndName || "animationend"
  , transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName(C, S) {
    if (!C)
        return null;
    if (_typeof(C) === "object") {
        var E = S.replace(/-\w/g, function(M) {
            return M[1].toUpperCase()
        });
        return C[E]
    }
    return "".concat(C, "-").concat(S)
}
const useDomMotionEvents = function(C) {
    var S = reactExports.useRef()
      , E = reactExports.useRef(C);
    E.current = C;
    var M = reactExports.useCallback(function(B) {
        E.current(B)
    }, []);
    function T(B) {
        B && (B.removeEventListener(transitionEndName, M),
        B.removeEventListener(animationEndName, M))
    }
    function $(B) {
        S.current && S.current !== B && T(S.current),
        B && B !== S.current && (B.addEventListener(transitionEndName, M),
        B.addEventListener(animationEndName, M),
        S.current = B)
    }
    return reactExports.useEffect(function() {
        return function() {
            T(S.current)
        }
    }, []),
    [$, T]
};
var useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
const useNextFrame = function() {
    var C = reactExports.useRef(null);
    function S() {
        wrapperRaf.cancel(C.current)
    }
    function E(M) {
        var T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        S();
        var $ = wrapperRaf(function() {
            T <= 1 ? M({
                isCanceled: function() {
                    return $ !== C.current
                }
            }) : E(M, T - 1)
        });
        C.current = $
    }
    return reactExports.useEffect(function() {
        return function() {
            S()
        }
    }, []),
    [E, S]
};
var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED]
  , SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED]
  , SkipStep = !1
  , DoStep = !0;
function isActive(C) {
    return C === STEP_ACTIVE || C === STEP_ACTIVATED
}
const useStepQueue = function(C, S, E) {
    var M = useSafeState(STEP_NONE)
      , T = _slicedToArray(M, 2)
      , $ = T[0]
      , B = T[1]
      , O = useNextFrame()
      , F = _slicedToArray(O, 2)
      , N = F[0]
      , U = F[1];
    function H() {
        B(STEP_PREPARE, !0)
    }
    var Z = S ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    return useIsomorphicLayoutEffect(function() {
        if ($ !== STEP_NONE && $ !== STEP_ACTIVATED) {
            var J = Z.indexOf($)
              , ie = Z[J + 1]
              , oe = E($);
            oe === SkipStep ? B(ie, !0) : ie && N(function(ae) {
                function se() {
                    ae.isCanceled() || B(ie, !0)
                }
                oe === !0 ? se() : Promise.resolve(oe).then(se)
            })
        }
    }, [C, $]),
    reactExports.useEffect(function() {
        return function() {
            U()
        }
    }, []),
    [H, $]
};
function useStatus(C, S, E, M) {
    var T = M.motionEnter
      , $ = T === void 0 ? !0 : T
      , B = M.motionAppear
      , O = B === void 0 ? !0 : B
      , F = M.motionLeave
      , N = F === void 0 ? !0 : F
      , U = M.motionDeadline
      , H = M.motionLeaveImmediately
      , Z = M.onAppearPrepare
      , J = M.onEnterPrepare
      , ie = M.onLeavePrepare
      , oe = M.onAppearStart
      , ae = M.onEnterStart
      , se = M.onLeaveStart
      , le = M.onAppearActive
      , de = M.onEnterActive
      , fe = M.onLeaveActive
      , pe = M.onAppearEnd
      , ge = M.onEnterEnd
      , we = M.onLeaveEnd
      , Ae = M.onVisibleChanged
      , Se = useSafeState()
      , ue = _slicedToArray(Se, 2)
      , V = ue[0]
      , W = ue[1]
      , D = useSafeState(STATUS_NONE)
      , I = _slicedToArray(D, 2)
      , L = I[0]
      , K = I[1]
      , X = useSafeState(null)
      , Y = _slicedToArray(X, 2)
      , j = Y[0]
      , G = Y[1]
      , ne = reactExports.useRef(!1)
      , te = reactExports.useRef(null);
    function ce() {
        return E()
    }
    var Ee = reactExports.useRef(!1);
    function Re() {
        K(STATUS_NONE, !0),
        G(null, !0)
    }
    function Te(Ue) {
        var We = ce();
        if (!(Ue && !Ue.deadline && Ue.target !== We)) {
            var Xe = Ee.current, ht;
            L === STATUS_APPEAR && Xe ? ht = pe == null ? void 0 : pe(We, Ue) : L === STATUS_ENTER && Xe ? ht = ge == null ? void 0 : ge(We, Ue) : L === STATUS_LEAVE && Xe && (ht = we == null ? void 0 : we(We, Ue)),
            L !== STATUS_NONE && Xe && ht !== !1 && Re()
        }
    }
    var xe = useDomMotionEvents(Te)
      , ve = _slicedToArray(xe, 1)
      , Me = ve[0]
      , Fe = function(We) {
        var Xe, ht, Je;
        switch (We) {
        case STATUS_APPEAR:
            return Xe = {},
            _defineProperty(Xe, STEP_PREPARE, Z),
            _defineProperty(Xe, STEP_START, oe),
            _defineProperty(Xe, STEP_ACTIVE, le),
            Xe;
        case STATUS_ENTER:
            return ht = {},
            _defineProperty(ht, STEP_PREPARE, J),
            _defineProperty(ht, STEP_START, ae),
            _defineProperty(ht, STEP_ACTIVE, de),
            ht;
        case STATUS_LEAVE:
            return Je = {},
            _defineProperty(Je, STEP_PREPARE, ie),
            _defineProperty(Je, STEP_START, se),
            _defineProperty(Je, STEP_ACTIVE, fe),
            Je;
        default:
            return {}
        }
    }
      , be = reactExports.useMemo(function() {
        return Fe(L)
    }, [L])
      , Ce = useStepQueue(L, !C, function(Ue) {
        if (Ue === STEP_PREPARE) {
            var We = be[STEP_PREPARE];
            return We ? We(ce()) : SkipStep
        }
        if (nt in be) {
            var Xe;
            G(((Xe = be[nt]) === null || Xe === void 0 ? void 0 : Xe.call(be, ce(), null)) || null)
        }
        return nt === STEP_ACTIVE && (Me(ce()),
        U > 0 && (clearTimeout(te.current),
        te.current = setTimeout(function() {
            Te({
                deadline: !0
            })
        }, U))),
        nt === STEP_PREPARED && Re(),
        DoStep
    })
      , ze = _slicedToArray(Ce, 2)
      , Ge = ze[0]
      , nt = ze[1]
      , bt = isActive(nt);
    Ee.current = bt,
    useIsomorphicLayoutEffect(function() {
        W(S);
        var Ue = ne.current;
        ne.current = !0;
        var We;
        !Ue && S && O && (We = STATUS_APPEAR),
        Ue && S && $ && (We = STATUS_ENTER),
        (Ue && !S && N || !Ue && H && !S && N) && (We = STATUS_LEAVE);
        var Xe = Fe(We);
        We && (C || Xe[STEP_PREPARE]) ? (K(We),
        Ge()) : K(STATUS_NONE)
    }, [S]),
    reactExports.useEffect(function() {
        (L === STATUS_APPEAR && !O || L === STATUS_ENTER && !$ || L === STATUS_LEAVE && !N) && K(STATUS_NONE)
    }, [O, $, N]),
    reactExports.useEffect(function() {
        return function() {
            ne.current = !1,
            clearTimeout(te.current)
        }
    }, []);
    var ct = reactExports.useRef(!1);
    reactExports.useEffect(function() {
        V && (ct.current = !0),
        V !== void 0 && L === STATUS_NONE && ((ct.current || V) && (Ae == null || Ae(V)),
        ct.current = !0)
    }, [V, L]);
    var De = j;
    return be[STEP_PREPARE] && nt === STEP_START && (De = _objectSpread2({
        transition: "none"
    }, De)),
    [L, nt, De, V ?? S]
}
function genCSSMotion(C) {
    var S = C;
    _typeof(C) === "object" && (S = C.transitionSupport);
    function E(T, $) {
        return !!(T.motionName && S && $ !== !1)
    }
    var M = reactExports.forwardRef(function(T, $) {
        var B = T.visible
          , O = B === void 0 ? !0 : B
          , F = T.removeOnLeave
          , N = F === void 0 ? !0 : F
          , U = T.forceRender
          , H = T.children
          , Z = T.motionName
          , J = T.leavedClassName
          , ie = T.eventProps
          , oe = reactExports.useContext(Context)
          , ae = oe.motion
          , se = E(T, ae)
          , le = reactExports.useRef()
          , de = reactExports.useRef();
        function fe() {
            try {
                return le.current instanceof HTMLElement ? le.current : findDOMNode(de.current)
            } catch {
                return null
            }
        }
        var pe = useStatus(se, O, fe, T)
          , ge = _slicedToArray(pe, 4)
          , we = ge[0]
          , Ae = ge[1]
          , Se = ge[2]
          , ue = ge[3]
          , V = reactExports.useRef(ue);
        ue && (V.current = !0);
        var W = reactExports.useCallback(function(G) {
            le.current = G,
            fillRef($, G)
        }, [$]), D, I = _objectSpread2(_objectSpread2({}, ie), {}, {
            visible: O
        });
        if (!H)
            D = null;
        else if (we === STATUS_NONE)
            ue ? D = H(_objectSpread2({}, I), W) : !N && V.current && J ? D = H(_objectSpread2(_objectSpread2({}, I), {}, {
                className: J
            }), W) : U || !N && !J ? D = H(_objectSpread2(_objectSpread2({}, I), {}, {
                style: {
                    display: "none"
                }
            }), W) : D = null;
        else {
            var L, K;
            Ae === STEP_PREPARE ? K = "prepare" : isActive(Ae) ? K = "active" : Ae === STEP_START && (K = "start");
            var X = getTransitionName(Z, "".concat(we, "-").concat(K));
            D = H(_objectSpread2(_objectSpread2({}, I), {}, {
                className: classNames(getTransitionName(Z, we), (L = {},
                _defineProperty(L, X, X && K),
                _defineProperty(L, Z, typeof Z == "string"),
                L)),
                style: Se
            }), W)
        }
        if (reactExports.isValidElement(D) && supportRef(D)) {
            var Y = D
              , j = Y.ref;
            j || (D = reactExports.cloneElement(D, {
                ref: W
            }))
        }
        return reactExports.createElement(DomWrapper, {
            ref: de
        }, D)
    });
    return M.displayName = "CSSMotion",
    M
}
const CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add"
  , STATUS_KEEP = "keep"
  , STATUS_REMOVE = "remove"
  , STATUS_REMOVED = "removed";
function wrapKeyToObject(C) {
    var S;
    return C && _typeof(C) === "object" && "key"in C ? S = C : S = {
        key: C
    },
    _objectSpread2(_objectSpread2({}, S), {}, {
        key: String(S.key)
    })
}
function parseKeys() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return C.map(wrapKeyToObject)
}
function diffKeys() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
      , S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
      , E = []
      , M = 0
      , T = S.length
      , $ = parseKeys(C)
      , B = parseKeys(S);
    $.forEach(function(N) {
        for (var U = !1, H = M; H < T; H += 1) {
            var Z = B[H];
            if (Z.key === N.key) {
                M < H && (E = E.concat(B.slice(M, H).map(function(J) {
                    return _objectSpread2(_objectSpread2({}, J), {}, {
                        status: STATUS_ADD
                    })
                })),
                M = H),
                E.push(_objectSpread2(_objectSpread2({}, Z), {}, {
                    status: STATUS_KEEP
                })),
                M += 1,
                U = !0;
                break
            }
        }
        U || E.push(_objectSpread2(_objectSpread2({}, N), {}, {
            status: STATUS_REMOVE
        }))
    }),
    M < T && (E = E.concat(B.slice(M).map(function(N) {
        return _objectSpread2(_objectSpread2({}, N), {}, {
            status: STATUS_ADD
        })
    })));
    var O = {};
    E.forEach(function(N) {
        var U = N.key;
        O[U] = (O[U] || 0) + 1
    });
    var F = Object.keys(O).filter(function(N) {
        return O[N] > 1
    });
    return F.forEach(function(N) {
        E = E.filter(function(U) {
            var H = U.key
              , Z = U.status;
            return H !== N || Z !== STATUS_REMOVE
        }),
        E.forEach(function(U) {
            U.key === N && (U.status = STATUS_KEEP)
        })
    }),
    E
}
var _excluded$4 = ["component", "children", "onVisibleChanged", "onAllRemoved"]
  , _excluded2 = ["status"]
  , MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(C) {
    var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion
      , E = function(M) {
        _inherits($, M);
        var T = _createSuper($);
        function $() {
            var B;
            _classCallCheck(this, $);
            for (var O = arguments.length, F = new Array(O), N = 0; N < O; N++)
                F[N] = arguments[N];
            return B = T.call.apply(T, [this].concat(F)),
            _defineProperty(_assertThisInitialized(B), "state", {
                keyEntities: []
            }),
            _defineProperty(_assertThisInitialized(B), "removeKey", function(U) {
                var H = B.state.keyEntities
                  , Z = H.map(function(J) {
                    return J.key !== U ? J : _objectSpread2(_objectSpread2({}, J), {}, {
                        status: STATUS_REMOVED
                    })
                });
                return B.setState({
                    keyEntities: Z
                }),
                Z.filter(function(J) {
                    var ie = J.status;
                    return ie !== STATUS_REMOVED
                }).length
            }),
            B
        }
        return _createClass($, [{
            key: "render",
            value: function() {
                var O = this
                  , F = this.state.keyEntities
                  , N = this.props
                  , U = N.component
                  , H = N.children
                  , Z = N.onVisibleChanged
                  , J = N.onAllRemoved
                  , ie = _objectWithoutProperties(N, _excluded$4)
                  , oe = U || reactExports.Fragment
                  , ae = {};
                return MOTION_PROP_NAMES.forEach(function(se) {
                    ae[se] = ie[se],
                    delete ie[se]
                }),
                delete ie.keys,
                reactExports.createElement(oe, ie, F.map(function(se, le) {
                    var de = se.status
                      , fe = _objectWithoutProperties(se, _excluded2)
                      , pe = de === STATUS_ADD || de === STATUS_KEEP;
                    return reactExports.createElement(S, _extends$3({}, ae, {
                        key: fe.key,
                        visible: pe,
                        eventProps: fe,
                        onVisibleChanged: function(we) {
                            if (Z == null || Z(we, {
                                key: fe.key
                            }),
                            !we) {
                                var Ae = O.removeKey(fe.key);
                                Ae === 0 && J && J()
                            }
                        }
                    }), function(ge, we) {
                        return H(_objectSpread2(_objectSpread2({}, ge), {}, {
                            index: le
                        }), we)
                    })
                }))
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function(O, F) {
                var N = O.keys
                  , U = F.keyEntities
                  , H = parseKeys(N)
                  , Z = diffKeys(U, H);
                return {
                    keyEntities: Z.filter(function(J) {
                        var ie = U.find(function(oe) {
                            var ae = oe.key;
                            return J.key === ae
                        });
                        return !(ie && ie.status === STATUS_REMOVED && J.status === STATUS_REMOVE)
                    })
                }
            }
        }]),
        $
    }(reactExports.Component);
    return _defineProperty(E, "defaultProps", {
        component: "div"
    }),
    E
}
const CSSMotionList = genCSSMotionList(supportTransition);
function MotionWrapper(C) {
    const {children: S} = C
      , [,E] = useToken()
      , {motion: M} = E
      , T = reactExports.useRef(!1);
    return T.current = T.current || M === !1,
    T.current ? reactExports.createElement(MotionProvider, {
        motion: M
    }, S) : S
}
const PropWarning = ()=>null;
var __rest$2 = function(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
};
const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"]
  , defaultPrefixCls = "ant";
let globalPrefixCls, globalIconPrefixCls, globalTheme, globalHolderRender;
function getGlobalPrefixCls() {
    return globalPrefixCls || defaultPrefixCls
}
function getGlobalIconPrefixCls() {
    return globalIconPrefixCls || defaultIconPrefixCls
}
function isLegacyTheme(C) {
    return Object.keys(C).some(S=>S.endsWith("Color"))
}
const setGlobalConfig = C=>{
    const {prefixCls: S, iconPrefixCls: E, theme: M, holderRender: T} = C;
    S !== void 0 && (globalPrefixCls = S),
    E !== void 0 && (globalIconPrefixCls = E),
    "holderRender"in C && (globalHolderRender = T),
    M && (isLegacyTheme(M) ? registerTheme(getGlobalPrefixCls(), M) : globalTheme = M)
}
  , globalConfig = ()=>({
    getPrefixCls: (C,S)=>S || (C ? `${getGlobalPrefixCls()}-${C}` : getGlobalPrefixCls()),
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: ()=>globalPrefixCls || getGlobalPrefixCls(),
    getTheme: ()=>globalTheme,
    holderRender: globalHolderRender
})
  , ProviderChildren = C=>{
    const {children: S, csp: E, autoInsertSpaceInButton: M, alert: T, anchor: $, form: B, locale: O, componentSize: F, direction: N, space: U, virtual: H, dropdownMatchSelectWidth: Z, popupMatchSelectWidth: J, popupOverflow: ie, legacyLocale: oe, parentContext: ae, iconPrefixCls: se, theme: le, componentDisabled: de, segmented: fe, statistic: pe, spin: ge, calendar: we, carousel: Ae, cascader: Se, collapse: ue, typography: V, checkbox: W, descriptions: D, divider: I, drawer: L, skeleton: K, steps: X, image: Y, layout: j, list: G, mentions: ne, modal: te, progress: ce, result: Ee, slider: Re, breadcrumb: Te, menu: xe, pagination: ve, input: Me, textArea: Fe, empty: be, badge: Ce, radio: ze, rate: Ge, switch: nt, transfer: bt, avatar: ct, message: De, tag: Ue, table: We, card: Xe, tabs: ht, timeline: Je, timePicker: ot, upload: je, notification: $e, tree: Ie, colorPicker: He, datePicker: qe, rangePicker: Ne, flex: at, wave: Ye, dropdown: it, warning: At, tour: pt, floatButtonGroup: ut} = C
      , Rt = reactExports.useCallback(($t,Gt)=>{
        const {prefixCls: Ot} = C;
        if (Gt)
            return Gt;
        const Bt = Ot || ae.getPrefixCls("");
        return $t ? `${Bt}-${$t}` : Bt
    }
    , [ae.getPrefixCls, C.prefixCls])
      , yt = se || ae.iconPrefixCls || defaultIconPrefixCls
      , st = E || ae.csp;
    useResetIconStyle(yt, st);
    const Wt = useTheme(le, ae.theme, {
        prefixCls: Rt("")
    })
      , Ct = {
        csp: st,
        autoInsertSpaceInButton: M,
        alert: T,
        anchor: $,
        locale: O || oe,
        direction: N,
        space: U,
        virtual: H,
        popupMatchSelectWidth: J ?? Z,
        popupOverflow: ie,
        getPrefixCls: Rt,
        iconPrefixCls: yt,
        theme: Wt,
        segmented: fe,
        statistic: pe,
        spin: ge,
        calendar: we,
        carousel: Ae,
        cascader: Se,
        collapse: ue,
        typography: V,
        checkbox: W,
        descriptions: D,
        divider: I,
        drawer: L,
        skeleton: K,
        steps: X,
        image: Y,
        input: Me,
        textArea: Fe,
        layout: j,
        list: G,
        mentions: ne,
        modal: te,
        progress: ce,
        result: Ee,
        slider: Re,
        breadcrumb: Te,
        menu: xe,
        pagination: ve,
        empty: be,
        badge: Ce,
        radio: ze,
        rate: Ge,
        switch: nt,
        transfer: bt,
        avatar: ct,
        message: De,
        tag: Ue,
        table: We,
        card: Xe,
        tabs: ht,
        timeline: Je,
        timePicker: ot,
        upload: je,
        notification: $e,
        tree: Ie,
        colorPicker: He,
        datePicker: qe,
        rangePicker: Ne,
        flex: at,
        wave: Ye,
        dropdown: it,
        warning: At,
        tour: pt,
        floatButtonGroup: ut
    }
      , Mt = Object.assign({}, ae);
    Object.keys(Ct).forEach($t=>{
        Ct[$t] !== void 0 && (Mt[$t] = Ct[$t])
    }
    ),
    PASSED_PROPS.forEach($t=>{
        const Gt = C[$t];
        Gt && (Mt[$t] = Gt)
    }
    );
    const Kt = useMemo(()=>Mt, Mt, ($t,Gt)=>{
        const Ot = Object.keys($t)
          , Bt = Object.keys(Gt);
        return Ot.length !== Bt.length || Ot.some(Yt=>$t[Yt] !== Gt[Yt])
    }
    )
      , Pt = reactExports.useMemo(()=>({
        prefixCls: yt,
        csp: st
    }), [yt, st]);
    let St = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(PropWarning, {
        dropdownMatchSelectWidth: Z
    }), S);
    const Zt = reactExports.useMemo(()=>{
        var $t, Gt, Ot, Bt;
        return merge$2((($t = localeValues.Form) === null || $t === void 0 ? void 0 : $t.defaultValidateMessages) || {}, ((Ot = (Gt = Kt.locale) === null || Gt === void 0 ? void 0 : Gt.Form) === null || Ot === void 0 ? void 0 : Ot.defaultValidateMessages) || {}, ((Bt = Kt.form) === null || Bt === void 0 ? void 0 : Bt.validateMessages) || {}, (B == null ? void 0 : B.validateMessages) || {})
    }
    , [Kt, B == null ? void 0 : B.validateMessages]);
    Object.keys(Zt).length > 0 && (St = reactExports.createElement(ValidateMessagesContext.Provider, {
        value: Zt
    }, St)),
    O && (St = reactExports.createElement(LocaleProvider$1, {
        locale: O,
        _ANT_MARK__: ANT_MARK
    }, St)),
    (yt || st) && (St = reactExports.createElement(IconContext.Provider, {
        value: Pt
    }, St)),
    F && (St = reactExports.createElement(SizeContextProvider, {
        size: F
    }, St)),
    St = reactExports.createElement(MotionWrapper, null, St);
    const Nt = reactExports.useMemo(()=>{
        const $t = Wt || {}
          , {algorithm: Gt, token: Ot, components: Bt, cssVar: Yt} = $t
          , ye = __rest$2($t, ["algorithm", "token", "components", "cssVar"])
          , Be = Gt && (!Array.isArray(Gt) || Gt.length > 0) ? createTheme(Gt) : defaultTheme
          , Oe = {};
        Object.entries(Bt || {}).forEach(Pe=>{
            let[rt,Ze] = Pe;
            const tt = Object.assign({}, Ze);
            "algorithm"in tt && (tt.algorithm === !0 ? tt.theme = Be : (Array.isArray(tt.algorithm) || typeof tt.algorithm == "function") && (tt.theme = createTheme(tt.algorithm)),
            delete tt.algorithm),
            Oe[rt] = tt
        }
        );
        const he = Object.assign(Object.assign({}, seedToken$1), Ot);
        return Object.assign(Object.assign({}, ye), {
            theme: Be,
            token: he,
            components: Oe,
            override: Object.assign({
                override: he
            }, Oe),
            cssVar: Yt
        })
    }
    , [Wt]);
    return le && (St = reactExports.createElement(DesignTokenContext.Provider, {
        value: Nt
    }, St)),
    Kt.warning && (St = reactExports.createElement(WarningContext.Provider, {
        value: Kt.warning
    }, St)),
    de !== void 0 && (St = reactExports.createElement(DisabledContextProvider, {
        disabled: de
    }, St)),
    reactExports.createElement(ConfigContext.Provider, {
        value: Kt
    }, St)
}
  , ConfigProvider$1 = C=>{
    const S = reactExports.useContext(ConfigContext)
      , E = reactExports.useContext(LocaleContext$1);
    return reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: S,
        legacyLocale: E
    }, C))
}
;
ConfigProvider$1.ConfigContext = ConfigContext;
ConfigProvider$1.SizeContext = SizeContext$1;
ConfigProvider$1.config = setGlobalConfig;
ConfigProvider$1.useConfig = useConfig;
Object.defineProperty(ConfigProvider$1, "SizeContext", {
    get: ()=>SizeContext$1
});
var CheckCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
            }
        }]
    },
    name: "check-circle",
    theme: "filled"
};
const CheckCircleFilledSvg = CheckCircleFilled$2;
function getRoot(C) {
    var S;
    return C == null || (S = C.getRootNode) === null || S === void 0 ? void 0 : S.call(C)
}
function inShadow(C) {
    return getRoot(C)instanceof ShadowRoot
}
function getShadowRoot(C) {
    return inShadow(C) ? getRoot(C) : null
}
function camelCase(C) {
    return C.replace(/-(.)/g, function(S, E) {
        return E.toUpperCase()
    })
}
function warning(C, S) {
    warningOnce(C, "[@ant-design/icons] ".concat(S))
}
function isIconDefinition(C) {
    return _typeof(C) === "object" && typeof C.name == "string" && typeof C.theme == "string" && (_typeof(C.icon) === "object" || typeof C.icon == "function")
}
function normalizeAttrs() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.keys(C).reduce(function(S, E) {
        var M = C[E];
        switch (E) {
        case "class":
            S.className = M,
            delete S.class;
            break;
        default:
            delete S[E],
            S[camelCase(E)] = M
        }
        return S
    }, {})
}
function generate$1(C, S, E) {
    return E ? React$1.createElement(C.tag, _objectSpread2(_objectSpread2({
        key: S
    }, normalizeAttrs(C.attrs)), E), (C.children || []).map(function(M, T) {
        return generate$1(M, "".concat(S, "-").concat(C.tag, "-").concat(T))
    })) : React$1.createElement(C.tag, _objectSpread2({
        key: S
    }, normalizeAttrs(C.attrs)), (C.children || []).map(function(M, T) {
        return generate$1(M, "".concat(S, "-").concat(C.tag, "-").concat(T))
    }))
}
function getSecondaryColor(C) {
    return generate$2(C)[0]
}
function normalizeTwoToneColors(C) {
    return C ? Array.isArray(C) ? C : [C] : []
}
var iconStyles = `
.anticon {
  display: inline-flex;
  alignItems: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`
  , useInsertStyles = function C(S) {
    var E = reactExports.useContext(IconContext)
      , M = E.csp
      , T = E.prefixCls
      , $ = iconStyles;
    T && ($ = $.replace(/anticon/g, T)),
    reactExports.useEffect(function() {
        var B = S.current
          , O = getShadowRoot(B);
        updateCSS($, "@ant-design-icons", {
            prepend: !0,
            csp: M,
            attachTo: O
        })
    }, [])
}
  , _excluded$3 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"]
  , twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: !1
};
function setTwoToneColors(C) {
    var S = C.primaryColor
      , E = C.secondaryColor;
    twoToneColorPalette.primaryColor = S,
    twoToneColorPalette.secondaryColor = E || getSecondaryColor(S),
    twoToneColorPalette.calculated = !!E
}
function getTwoToneColors() {
    return _objectSpread2({}, twoToneColorPalette)
}
var IconBase = function C(S) {
    var E = S.icon
      , M = S.className
      , T = S.onClick
      , $ = S.style
      , B = S.primaryColor
      , O = S.secondaryColor
      , F = _objectWithoutProperties(S, _excluded$3)
      , N = reactExports.useRef()
      , U = twoToneColorPalette;
    if (B && (U = {
        primaryColor: B,
        secondaryColor: O || getSecondaryColor(B)
    }),
    useInsertStyles(N),
    warning(isIconDefinition(E), "icon should be icon definiton, but got ".concat(E)),
    !isIconDefinition(E))
        return null;
    var H = E;
    return H && typeof H.icon == "function" && (H = _objectSpread2(_objectSpread2({}, H), {}, {
        icon: H.icon(U.primaryColor, U.secondaryColor)
    })),
    generate$1(H.icon, "svg-".concat(H.name), _objectSpread2(_objectSpread2({
        className: M,
        onClick: T,
        style: $,
        "data-icon": H.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
    }, F), {}, {
        ref: N
    }))
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const ReactIcon = IconBase;
function setTwoToneColor(C) {
    var S = normalizeTwoToneColors(C)
      , E = _slicedToArray(S, 2)
      , M = E[0]
      , T = E[1];
    return ReactIcon.setTwoToneColors({
        primaryColor: M,
        secondaryColor: T
    })
}
function getTwoToneColor() {
    var C = ReactIcon.getTwoToneColors();
    return C.calculated ? [C.primaryColor, C.secondaryColor] : C.primaryColor
}
var _excluded$2 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor(blue.primary);
var Icon$1 = reactExports.forwardRef(function(C, S) {
    var E = C.className
      , M = C.icon
      , T = C.spin
      , $ = C.rotate
      , B = C.tabIndex
      , O = C.onClick
      , F = C.twoToneColor
      , N = _objectWithoutProperties(C, _excluded$2)
      , U = reactExports.useContext(IconContext)
      , H = U.prefixCls
      , Z = H === void 0 ? "anticon" : H
      , J = U.rootClassName
      , ie = classNames(J, Z, _defineProperty(_defineProperty({}, "".concat(Z, "-").concat(M.name), !!M.name), "".concat(Z, "-spin"), !!T || M.name === "loading"), E)
      , oe = B;
    oe === void 0 && O && (oe = -1);
    var ae = $ ? {
        msTransform: "rotate(".concat($, "deg)"),
        transform: "rotate(".concat($, "deg)")
    } : void 0
      , se = normalizeTwoToneColors(F)
      , le = _slicedToArray(se, 2)
      , de = le[0]
      , fe = le[1];
    return reactExports.createElement("span", _extends$3({
        role: "img",
        "aria-label": M.name
    }, N, {
        ref: S,
        tabIndex: oe,
        onClick: O,
        className: ie
    }), reactExports.createElement(ReactIcon, {
        icon: M,
        primaryColor: de,
        secondaryColor: fe,
        style: ae
    }))
});
Icon$1.displayName = "AntdIcon";
Icon$1.getTwoToneColor = getTwoToneColor;
Icon$1.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon$1;
var CheckCircleFilled = function C(S, E) {
    return reactExports.createElement(AntdIcon, _extends$3({}, S, {
        ref: E,
        icon: CheckCircleFilledSvg
    }))
}
  , RefIcon$5 = reactExports.forwardRef(CheckCircleFilled);
const CheckCircleFilled$1 = RefIcon$5;
var CloseCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            "fill-rule": "evenodd",
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z"
            }
        }]
    },
    name: "close-circle",
    theme: "filled"
};
const CloseCircleFilledSvg = CloseCircleFilled$2;
var CloseCircleFilled = function C(S, E) {
    return reactExports.createElement(AntdIcon, _extends$3({}, S, {
        ref: E,
        icon: CloseCircleFilledSvg
    }))
}
  , RefIcon$4 = reactExports.forwardRef(CloseCircleFilled);
const CloseCircleFilled$1 = RefIcon$4;
var CloseOutlined$2 = {
    icon: {
        tag: "svg",
        attrs: {
            "fill-rule": "evenodd",
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z"
            }
        }]
    },
    name: "close",
    theme: "outlined"
};
const CloseOutlinedSvg = CloseOutlined$2;
var CloseOutlined = function C(S, E) {
    return reactExports.createElement(AntdIcon, _extends$3({}, S, {
        ref: E,
        icon: CloseOutlinedSvg
    }))
}
  , RefIcon$3 = reactExports.forwardRef(CloseOutlined);
const CloseOutlined$1 = RefIcon$3;
var ExclamationCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
            }
        }]
    },
    name: "exclamation-circle",
    theme: "filled"
};
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
var ExclamationCircleFilled = function C(S, E) {
    return reactExports.createElement(AntdIcon, _extends$3({}, S, {
        ref: E,
        icon: ExclamationCircleFilledSvg
    }))
}
  , RefIcon$2 = reactExports.forwardRef(ExclamationCircleFilled);
const ExclamationCircleFilled$1 = RefIcon$2;
var InfoCircleFilled$2 = {
    icon: {
        tag: "svg",
        attrs: {
            viewBox: "64 64 896 896",
            focusable: "false"
        },
        children: [{
            tag: "path",
            attrs: {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
            }
        }]
    },
    name: "info-circle",
    theme: "filled"
};
const InfoCircleFilledSvg = InfoCircleFilled$2;
var InfoCircleFilled = function C(S, E) {
    return reactExports.createElement(AntdIcon, _extends$3({}, S, {
        ref: E,
        icon: InfoCircleFilledSvg
    }))
}
  , RefIcon$1 = reactExports.forwardRef(InfoCircleFilled);
const InfoCircleFilled$1 = RefIcon$1;
var attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`
  , eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`
  , propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/)
  , ariaPrefix = "aria-"
  , dataPrefix = "data-";
function match$1(C, S) {
    return C.indexOf(S) === 0
}
function pickAttrs(C) {
    var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, E;
    S === !1 ? E = {
        aria: !0,
        data: !0,
        attr: !0
    } : S === !0 ? E = {
        aria: !0
    } : E = _objectSpread2({}, S);
    var M = {};
    return Object.keys(C).forEach(function(T) {
        (E.aria && (T === "role" || match$1(T, ariaPrefix)) || E.data && match$1(T, dataPrefix) || E.attr && propList.includes(T)) && (M[T] = C[T])
    }),
    M
}
const useCSSVarCls = C=>{
    const [,,,,S] = useToken();
    return S ? `${C}-css-var` : ""
}
;
var KeyCode = {
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    QUESTION_MARK: 63,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    WIN_IME: 229,
    isTextModifyingKeyEvent: function C(S) {
        var E = S.keyCode;
        if (S.altKey && !S.ctrlKey || S.metaKey || E >= KeyCode.F1 && E <= KeyCode.F12)
            return !1;
        switch (E) {
        case KeyCode.ALT:
        case KeyCode.CAPS_LOCK:
        case KeyCode.CONTEXT_MENU:
        case KeyCode.CTRL:
        case KeyCode.DOWN:
        case KeyCode.END:
        case KeyCode.ESC:
        case KeyCode.HOME:
        case KeyCode.INSERT:
        case KeyCode.LEFT:
        case KeyCode.MAC_FF_META:
        case KeyCode.META:
        case KeyCode.NUMLOCK:
        case KeyCode.NUM_CENTER:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAUSE:
        case KeyCode.PRINT_SCREEN:
        case KeyCode.RIGHT:
        case KeyCode.SHIFT:
        case KeyCode.UP:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_RIGHT:
            return !1;
        default:
            return !0
        }
    },
    isCharacterKey: function C(S) {
        if (S >= KeyCode.ZERO && S <= KeyCode.NINE || S >= KeyCode.NUM_ZERO && S <= KeyCode.NUM_MULTIPLY || S >= KeyCode.A && S <= KeyCode.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && S === 0)
            return !0;
        switch (S) {
        case KeyCode.SPACE:
        case KeyCode.QUESTION_MARK:
        case KeyCode.NUM_PLUS:
        case KeyCode.NUM_MINUS:
        case KeyCode.NUM_PERIOD:
        case KeyCode.NUM_DIVISION:
        case KeyCode.SEMICOLON:
        case KeyCode.DASH:
        case KeyCode.EQUALS:
        case KeyCode.COMMA:
        case KeyCode.PERIOD:
        case KeyCode.SLASH:
        case KeyCode.APOSTROPHE:
        case KeyCode.SINGLE_QUOTE:
        case KeyCode.OPEN_SQUARE_BRACKET:
        case KeyCode.BACKSLASH:
        case KeyCode.CLOSE_SQUARE_BRACKET:
            return !0;
        default:
            return !1
        }
    }
}
  , Notify = reactExports.forwardRef(function(C, S) {
    var E = C.prefixCls
      , M = C.style
      , T = C.className
      , $ = C.duration
      , B = $ === void 0 ? 4.5 : $
      , O = C.eventKey
      , F = C.content
      , N = C.closable
      , U = C.closeIcon
      , H = U === void 0 ? "x" : U
      , Z = C.props
      , J = C.onClick
      , ie = C.onNoticeClose
      , oe = C.times
      , ae = C.hovering
      , se = reactExports.useState(!1)
      , le = _slicedToArray(se, 2)
      , de = le[0]
      , fe = le[1]
      , pe = ae || de
      , ge = function() {
        ie(O)
    }
      , we = function(W) {
        (W.key === "Enter" || W.code === "Enter" || W.keyCode === KeyCode.ENTER) && ge()
    };
    reactExports.useEffect(function() {
        if (!pe && B > 0) {
            var V = setTimeout(function() {
                ge()
            }, B * 1e3);
            return function() {
                clearTimeout(V)
            }
        }
    }, [B, pe, oe]);
    var Ae = reactExports.useMemo(function() {
        return _typeof(N) === "object" && N !== null ? N : N ? {
            closeIcon: H
        } : {}
    }, [N, H])
      , Se = pickAttrs(Ae, !0)
      , ue = "".concat(E, "-notice");
    return reactExports.createElement("div", _extends$3({}, Z, {
        ref: S,
        className: classNames(ue, T, _defineProperty({}, "".concat(ue, "-closable"), N)),
        style: M,
        onMouseEnter: function(W) {
            var D;
            fe(!0),
            Z == null || (D = Z.onMouseEnter) === null || D === void 0 || D.call(Z, W)
        },
        onMouseLeave: function(W) {
            var D;
            fe(!1),
            Z == null || (D = Z.onMouseLeave) === null || D === void 0 || D.call(Z, W)
        },
        onClick: J
    }), reactExports.createElement("div", {
        className: "".concat(ue, "-content")
    }, F), N && reactExports.createElement("a", _extends$3({
        tabIndex: 0,
        className: "".concat(ue, "-close"),
        onKeyDown: we,
        "aria-label": "Close"
    }, Se, {
        onClick: function(W) {
            W.preventDefault(),
            W.stopPropagation(),
            ge()
        }
    }), Ae.closeIcon))
})
  , NotificationContext = React$1.createContext({})
  , NotificationProvider = function C(S) {
    var E = S.children
      , M = S.classNames;
    return React$1.createElement(NotificationContext.Provider, {
        value: {
            classNames: M
        }
    }, E)
}
  , DEFAULT_OFFSET$1 = 8
  , DEFAULT_THRESHOLD = 3
  , DEFAULT_GAP = 16
  , useStack = function C(S) {
    var E = {
        offset: DEFAULT_OFFSET$1,
        threshold: DEFAULT_THRESHOLD,
        gap: DEFAULT_GAP
    };
    if (S && _typeof(S) === "object") {
        var M, T, $;
        E.offset = (M = S.offset) !== null && M !== void 0 ? M : DEFAULT_OFFSET$1,
        E.threshold = (T = S.threshold) !== null && T !== void 0 ? T : DEFAULT_THRESHOLD,
        E.gap = ($ = S.gap) !== null && $ !== void 0 ? $ : DEFAULT_GAP
    }
    return [!!S, E]
}
  , _excluded$1 = ["className", "style", "classNames", "styles"]
  , NoticeList = function C(S) {
    var E = S.configList
      , M = S.placement
      , T = S.prefixCls
      , $ = S.className
      , B = S.style
      , O = S.motion
      , F = S.onAllNoticeRemoved
      , N = S.onNoticeClose
      , U = S.stack
      , H = reactExports.useContext(NotificationContext)
      , Z = H.classNames
      , J = reactExports.useRef({})
      , ie = reactExports.useState(null)
      , oe = _slicedToArray(ie, 2)
      , ae = oe[0]
      , se = oe[1]
      , le = reactExports.useState([])
      , de = _slicedToArray(le, 2)
      , fe = de[0]
      , pe = de[1]
      , ge = E.map(function(K) {
        return {
            config: K,
            key: String(K.key)
        }
    })
      , we = useStack(U)
      , Ae = _slicedToArray(we, 2)
      , Se = Ae[0]
      , ue = Ae[1]
      , V = ue.offset
      , W = ue.threshold
      , D = ue.gap
      , I = Se && (fe.length > 0 || ge.length <= W)
      , L = typeof O == "function" ? O(M) : O;
    return reactExports.useEffect(function() {
        Se && fe.length > 1 && pe(function(K) {
            return K.filter(function(X) {
                return ge.some(function(Y) {
                    var j = Y.key;
                    return X === j
                })
            })
        })
    }, [fe, ge, Se]),
    reactExports.useEffect(function() {
        var K;
        if (Se && J.current[(K = ge[ge.length - 1]) === null || K === void 0 ? void 0 : K.key]) {
            var X;
            se(J.current[(X = ge[ge.length - 1]) === null || X === void 0 ? void 0 : X.key])
        }
    }, [ge, Se]),
    React$1.createElement(CSSMotionList, _extends$3({
        key: M,
        className: classNames(T, "".concat(T, "-").concat(M), Z == null ? void 0 : Z.list, $, _defineProperty(_defineProperty({}, "".concat(T, "-stack"), !!Se), "".concat(T, "-stack-expanded"), I)),
        style: B,
        keys: ge,
        motionAppear: !0
    }, L, {
        onAllRemoved: function() {
            F(M)
        }
    }), function(K, X) {
        var Y = K.config
          , j = K.className
          , G = K.style
          , ne = K.index
          , te = Y
          , ce = te.key
          , Ee = te.times
          , Re = String(ce)
          , Te = Y
          , xe = Te.className
          , ve = Te.style
          , Me = Te.classNames
          , Fe = Te.styles
          , be = _objectWithoutProperties(Te, _excluded$1)
          , Ce = ge.findIndex(function(ot) {
            return ot.key === Re
        })
          , ze = {};
        if (Se) {
            var Ge = ge.length - 1 - (Ce > -1 ? Ce : ne - 1)
              , nt = M === "top" || M === "bottom" ? "-50%" : "0";
            if (Ge > 0) {
                var bt, ct, De;
                ze.height = I ? (bt = J.current[Re]) === null || bt === void 0 ? void 0 : bt.offsetHeight : ae == null ? void 0 : ae.offsetHeight;
                for (var Ue = 0, We = 0; We < Ge; We++) {
                    var Xe;
                    Ue += ((Xe = J.current[ge[ge.length - 1 - We].key]) === null || Xe === void 0 ? void 0 : Xe.offsetHeight) + D
                }
                var ht = (I ? Ue : Ge * V) * (M.startsWith("top") ? 1 : -1)
                  , Je = !I && ae !== null && ae !== void 0 && ae.offsetWidth && (ct = J.current[Re]) !== null && ct !== void 0 && ct.offsetWidth ? ((ae == null ? void 0 : ae.offsetWidth) - V * 2 * (Ge < 3 ? Ge : 3)) / ((De = J.current[Re]) === null || De === void 0 ? void 0 : De.offsetWidth) : 1;
                ze.transform = "translate3d(".concat(nt, ", ").concat(ht, "px, 0) scaleX(").concat(Je, ")")
            } else
                ze.transform = "translate3d(".concat(nt, ", 0, 0)")
        }
        return React$1.createElement("div", {
            ref: X,
            className: classNames("".concat(T, "-notice-wrapper"), j, Me == null ? void 0 : Me.wrapper),
            style: _objectSpread2(_objectSpread2(_objectSpread2({}, G), ze), Fe == null ? void 0 : Fe.wrapper),
            onMouseEnter: function() {
                return pe(function(je) {
                    return je.includes(Re) ? je : [].concat(_toConsumableArray(je), [Re])
                })
            },
            onMouseLeave: function() {
                return pe(function(je) {
                    return je.filter(function($e) {
                        return $e !== Re
                    })
                })
            }
        }, React$1.createElement(Notify, _extends$3({}, be, {
            ref: function(je) {
                Ce > -1 ? J.current[Re] = je : delete J.current[Re]
            },
            prefixCls: T,
            classNames: Me,
            styles: Fe,
            className: classNames(xe, Z == null ? void 0 : Z.notice),
            style: ve,
            times: Ee,
            key: ce,
            eventKey: ce,
            onNoticeClose: N,
            hovering: Se && fe.length > 0
        })))
    })
}
  , Notifications = reactExports.forwardRef(function(C, S) {
    var E = C.prefixCls
      , M = E === void 0 ? "rc-notification" : E
      , T = C.container
      , $ = C.motion
      , B = C.maxCount
      , O = C.className
      , F = C.style
      , N = C.onAllRemoved
      , U = C.stack
      , H = C.renderNotifications
      , Z = reactExports.useState([])
      , J = _slicedToArray(Z, 2)
      , ie = J[0]
      , oe = J[1]
      , ae = function(Se) {
        var ue, V = ie.find(function(W) {
            return W.key === Se
        });
        V == null || (ue = V.onClose) === null || ue === void 0 || ue.call(V),
        oe(function(W) {
            return W.filter(function(D) {
                return D.key !== Se
            })
        })
    };
    reactExports.useImperativeHandle(S, function() {
        return {
            open: function(Se) {
                oe(function(ue) {
                    var V = _toConsumableArray(ue)
                      , W = V.findIndex(function(L) {
                        return L.key === Se.key
                    })
                      , D = _objectSpread2({}, Se);
                    if (W >= 0) {
                        var I;
                        D.times = (((I = ue[W]) === null || I === void 0 ? void 0 : I.times) || 0) + 1,
                        V[W] = D
                    } else
                        D.times = 0,
                        V.push(D);
                    return B > 0 && V.length > B && (V = V.slice(-B)),
                    V
                })
            },
            close: function(Se) {
                ae(Se)
            },
            destroy: function() {
                oe([])
            }
        }
    });
    var se = reactExports.useState({})
      , le = _slicedToArray(se, 2)
      , de = le[0]
      , fe = le[1];
    reactExports.useEffect(function() {
        var Ae = {};
        ie.forEach(function(Se) {
            var ue = Se.placement
              , V = ue === void 0 ? "topRight" : ue;
            V && (Ae[V] = Ae[V] || [],
            Ae[V].push(Se))
        }),
        Object.keys(de).forEach(function(Se) {
            Ae[Se] = Ae[Se] || []
        }),
        fe(Ae)
    }, [ie]);
    var pe = function(Se) {
        fe(function(ue) {
            var V = _objectSpread2({}, ue)
              , W = V[Se] || [];
            return W.length || delete V[Se],
            V
        })
    }
      , ge = reactExports.useRef(!1);
    if (reactExports.useEffect(function() {
        Object.keys(de).length > 0 ? ge.current = !0 : ge.current && (N == null || N(),
        ge.current = !1)
    }, [de]),
    !T)
        return null;
    var we = Object.keys(de);
    return reactDomExports.createPortal(reactExports.createElement(reactExports.Fragment, null, we.map(function(Ae) {
        var Se = de[Ae]
          , ue = reactExports.createElement(NoticeList, {
            key: Ae,
            configList: Se,
            placement: Ae,
            prefixCls: M,
            className: O == null ? void 0 : O(Ae),
            style: F == null ? void 0 : F(Ae),
            motion: $,
            onNoticeClose: ae,
            onAllNoticeRemoved: pe,
            stack: U
        });
        return H ? H(ue, {
            prefixCls: M,
            key: Ae
        }) : ue
    })), T)
})
  , _excluded = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"]
  , defaultGetContainer = function C() {
    return document.body
}
  , uniqueKey = 0;
function mergeConfig() {
    for (var C = {}, S = arguments.length, E = new Array(S), M = 0; M < S; M++)
        E[M] = arguments[M];
    return E.forEach(function(T) {
        T && Object.keys(T).forEach(function($) {
            var B = T[$];
            B !== void 0 && (C[$] = B)
        })
    }),
    C
}
function useNotification$1() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , S = C.getContainer
      , E = S === void 0 ? defaultGetContainer : S
      , M = C.motion
      , T = C.prefixCls
      , $ = C.maxCount
      , B = C.className
      , O = C.style
      , F = C.onAllRemoved
      , N = C.stack
      , U = C.renderNotifications
      , H = _objectWithoutProperties(C, _excluded)
      , Z = reactExports.useState()
      , J = _slicedToArray(Z, 2)
      , ie = J[0]
      , oe = J[1]
      , ae = reactExports.useRef()
      , se = reactExports.createElement(Notifications, {
        container: ie,
        ref: ae,
        prefixCls: T,
        motion: M,
        maxCount: $,
        className: B,
        style: O,
        onAllRemoved: F,
        stack: N,
        renderNotifications: U
    })
      , le = reactExports.useState([])
      , de = _slicedToArray(le, 2)
      , fe = de[0]
      , pe = de[1]
      , ge = reactExports.useMemo(function() {
        return {
            open: function(Ae) {
                var Se = mergeConfig(H, Ae);
                (Se.key === null || Se.key === void 0) && (Se.key = "rc-notification-".concat(uniqueKey),
                uniqueKey += 1),
                pe(function(ue) {
                    return [].concat(_toConsumableArray(ue), [{
                        type: "open",
                        config: Se
                    }])
                })
            },
            close: function(Ae) {
                pe(function(Se) {
                    return [].concat(_toConsumableArray(Se), [{
                        type: "close",
                        key: Ae
                    }])
                })
            },
            destroy: function() {
                pe(function(Ae) {
                    return [].concat(_toConsumableArray(Ae), [{
                        type: "destroy"
                    }])
                })
            }
        }
    }, []);
    return reactExports.useEffect(function() {
        oe(E())
    }),
    reactExports.useEffect(function() {
        ae.current && fe.length && (fe.forEach(function(we) {
            switch (we.type) {
            case "open":
                ae.current.open(we.config);
                break;
            case "close":
                ae.current.close(we.key);
                break;
            case "destroy":
                ae.current.destroy();
                break
            }
        }),
        pe(function(we) {
            return we.filter(function(Ae) {
                return !fe.includes(Ae)
            })
        }))
    }, [fe]),
    [ge, se]
}
const CONTAINER_OFFSET = 100
  , CONTAINER_OFFSET_MAX_COUNT = 10
  , CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
var fullClone = _objectSpread2({}, ReactDOM$1)
  , version$1 = fullClone.version
  , reactRender = fullClone.render;
fullClone.unmountComponentAtNode;
var createRoot;
try {
    var mainVersion = Number((version$1 || "").split(".")[0]);
    mainVersion >= 18 && (createRoot = fullClone.createRoot)
} catch (C) {}
function toggleWarning(C) {
    var S = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    S && _typeof(S) === "object" && (S.usingClientEntryPoint = C)
}
var MARK = "__rc_react_root__";
function modernRender(C, S) {
    toggleWarning(!0);
    var E = S[MARK] || createRoot(S);
    toggleWarning(!1),
    E.render(C),
    S[MARK] = E
}
function legacyRender(C, S) {
    reactRender(C, S)
}
function render(C, S) {
    if (createRoot) {
        modernRender(C, S);
        return
    }
    legacyRender(C, S)
}
const genNotificationPlacementStyle = C=>{
    const {componentCls: S, notificationMarginEdge: E, animationMaxHeight: M} = C
      , T = `${S}-notice`
      , $ = new Keyframe("antNotificationFadeIn",{
        "0%": {
            transform: "translate3d(100%, 0, 0)",
            opacity: 0
        },
        "100%": {
            transform: "translate3d(0, 0, 0)",
            opacity: 1
        }
    })
      , B = new Keyframe("antNotificationTopFadeIn",{
        "0%": {
            top: -M,
            opacity: 0
        },
        "100%": {
            top: 0,
            opacity: 1
        }
    })
      , O = new Keyframe("antNotificationBottomFadeIn",{
        "0%": {
            bottom: C.calc(M).mul(-1).equal(),
            opacity: 0
        },
        "100%": {
            bottom: 0,
            opacity: 1
        }
    })
      , F = new Keyframe("antNotificationLeftFadeIn",{
        "0%": {
            transform: "translate3d(-100%, 0, 0)",
            opacity: 0
        },
        "100%": {
            transform: "translate3d(0, 0, 0)",
            opacity: 1
        }
    });
    return {
        [S]: {
            [`&${S}-top, &${S}-bottom`]: {
                marginInline: 0,
                [T]: {
                    marginInline: "auto auto"
                }
            },
            [`&${S}-top`]: {
                [`${S}-fade-enter${S}-fade-enter-active, ${S}-fade-appear${S}-fade-appear-active`]: {
                    animationName: B
                }
            },
            [`&${S}-bottom`]: {
                [`${S}-fade-enter${S}-fade-enter-active, ${S}-fade-appear${S}-fade-appear-active`]: {
                    animationName: O
                }
            },
            [`&${S}-topRight, &${S}-bottomRight`]: {
                [`${S}-fade-enter${S}-fade-enter-active, ${S}-fade-appear${S}-fade-appear-active`]: {
                    animationName: $
                }
            },
            [`&${S}-topLeft, &${S}-bottomLeft`]: {
                marginRight: {
                    value: 0,
                    _skip_check_: !0
                },
                marginLeft: {
                    value: E,
                    _skip_check_: !0
                },
                [T]: {
                    marginInlineEnd: "auto",
                    marginInlineStart: 0
                },
                [`${S}-fade-enter${S}-fade-enter-active, ${S}-fade-appear${S}-fade-appear-active`]: {
                    animationName: F
                }
            }
        }
    }
}
  , genNotificationPlacementStyle$1 = genNotificationPlacementStyle
  , NotificationPlacements = ["top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"]
  , placementAlignProperty = {
    topLeft: "left",
    topRight: "right",
    bottomLeft: "left",
    bottomRight: "right",
    top: "left",
    bottom: "left"
}
  , genPlacementStackStyle = (C,S)=>{
    const {componentCls: E} = C;
    return {
        [`${E}-${S}`]: {
            [`&${E}-stack > ${E}-notice-wrapper`]: {
                [S.startsWith("top") ? "top" : "bottom"]: 0,
                [placementAlignProperty[S]]: {
                    value: 0,
                    _skip_check_: !0
                }
            }
        }
    }
}
  , genStackChildrenStyle = C=>{
    const S = {};
    for (let E = 1; E < C.notificationStackLayer; E++)
        S[`&:nth-last-child(${E + 1})`] = {
            overflow: "hidden",
            [`& > ${C.componentCls}-notice`]: {
                opacity: 0,
                transition: `opacity ${C.motionDurationMid}`
            }
        };
    return Object.assign({
        [`&:not(:nth-last-child(-n+${C.notificationStackLayer}))`]: {
            opacity: 0,
            overflow: "hidden",
            color: "transparent",
            pointerEvents: "none"
        }
    }, S)
}
  , genStackedNoticeStyle = C=>{
    const S = {};
    for (let E = 1; E < C.notificationStackLayer; E++)
        S[`&:nth-last-child(${E + 1})`] = {
            background: C.colorBgBlur,
            backdropFilter: "blur(10px)",
            "-webkit-backdrop-filter": "blur(10px)"
        };
    return Object.assign({}, S)
}
  , genStackStyle = C=>{
    const {componentCls: S} = C;
    return Object.assign({
        [`${S}-stack`]: {
            [`& > ${S}-notice-wrapper`]: Object.assign({
                transition: `all ${C.motionDurationSlow}, backdrop-filter 0s`,
                position: "absolute"
            }, genStackChildrenStyle(C))
        },
        [`${S}-stack:not(${S}-stack-expanded)`]: {
            [`& > ${S}-notice-wrapper`]: Object.assign({}, genStackedNoticeStyle(C))
        },
        [`${S}-stack${S}-stack-expanded`]: {
            [`& > ${S}-notice-wrapper`]: {
                "&:not(:nth-last-child(-n + 1))": {
                    opacity: 1,
                    overflow: "unset",
                    color: "inherit",
                    pointerEvents: "auto",
                    [`& > ${C.componentCls}-notice`]: {
                        opacity: 1
                    }
                },
                "&:after": {
                    content: '""',
                    position: "absolute",
                    height: C.margin,
                    width: "100%",
                    insetInline: 0,
                    bottom: C.calc(C.margin).mul(-1).equal(),
                    background: "transparent",
                    pointerEvents: "auto"
                }
            }
        }
    }, NotificationPlacements.map(E=>genPlacementStackStyle(C, E)).reduce((E,M)=>Object.assign(Object.assign({}, E), M), {}))
}
  , genStackStyle$1 = genStackStyle
  , genNoticeStyle = C=>{
    const {iconCls: S, componentCls: E, boxShadow: M, fontSizeLG: T, notificationMarginBottom: $, borderRadiusLG: B, colorSuccess: O, colorInfo: F, colorWarning: N, colorError: U, colorTextHeading: H, notificationBg: Z, notificationPadding: J, notificationMarginEdge: ie, fontSize: oe, lineHeight: ae, width: se, notificationIconSize: le, colorText: de} = C
      , fe = `${E}-notice`;
    return {
        position: "relative",
        marginBottom: $,
        marginInlineStart: "auto",
        background: Z,
        borderRadius: B,
        boxShadow: M,
        [fe]: {
            padding: J,
            width: se,
            maxWidth: `calc(100vw - ${unit$1(C.calc(ie).mul(2).equal())})`,
            overflow: "hidden",
            lineHeight: ae,
            wordWrap: "break-word"
        },
        [`${fe}-message`]: {
            marginBottom: C.marginXS,
            color: H,
            fontSize: T,
            lineHeight: C.lineHeightLG
        },
        [`${fe}-description`]: {
            fontSize: oe,
            color: de
        },
        [`${fe}-closable ${fe}-message`]: {
            paddingInlineEnd: C.paddingLG
        },
        [`${fe}-with-icon ${fe}-message`]: {
            marginBottom: C.marginXS,
            marginInlineStart: C.calc(C.marginSM).add(le).equal(),
            fontSize: T
        },
        [`${fe}-with-icon ${fe}-description`]: {
            marginInlineStart: C.calc(C.marginSM).add(le).equal(),
            fontSize: oe
        },
        [`${fe}-icon`]: {
            position: "absolute",
            fontSize: le,
            lineHeight: 1,
            [`&-success${S}`]: {
                color: O
            },
            [`&-info${S}`]: {
                color: F
            },
            [`&-warning${S}`]: {
                color: N
            },
            [`&-error${S}`]: {
                color: U
            }
        },
        [`${fe}-close`]: Object.assign({
            position: "absolute",
            top: C.notificationPaddingVertical,
            insetInlineEnd: C.notificationPaddingHorizontal,
            color: C.colorIcon,
            outline: "none",
            width: C.notificationCloseButtonSize,
            height: C.notificationCloseButtonSize,
            borderRadius: C.borderRadiusSM,
            transition: `background-color ${C.motionDurationMid}, color ${C.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
                color: C.colorIconHover,
                backgroundColor: C.colorBgTextHover
            },
            "&:active": {
                backgroundColor: C.colorBgTextActive
            }
        }, genFocusStyle(C)),
        [`${fe}-btn`]: {
            float: "right",
            marginTop: C.marginSM
        }
    }
}
  , genNotificationStyle = C=>{
    const {componentCls: S, notificationMarginBottom: E, notificationMarginEdge: M, motionDurationMid: T, motionEaseInOut: $} = C
      , B = `${S}-notice`
      , O = new Keyframe("antNotificationFadeOut",{
        "0%": {
            maxHeight: C.animationMaxHeight,
            marginBottom: E
        },
        "100%": {
            maxHeight: 0,
            marginBottom: 0,
            paddingTop: 0,
            paddingBottom: 0,
            opacity: 0
        }
    });
    return [{
        [S]: Object.assign(Object.assign({}, resetComponent(C)), {
            position: "fixed",
            zIndex: C.zIndexPopup,
            marginRight: {
                value: M,
                _skip_check_: !0
            },
            [`${S}-hook-holder`]: {
                position: "relative"
            },
            [`${S}-fade-appear-prepare`]: {
                opacity: "0 !important"
            },
            [`${S}-fade-enter, ${S}-fade-appear`]: {
                animationDuration: C.motionDurationMid,
                animationTimingFunction: $,
                animationFillMode: "both",
                opacity: 0,
                animationPlayState: "paused"
            },
            [`${S}-fade-leave`]: {
                animationTimingFunction: $,
                animationFillMode: "both",
                animationDuration: T,
                animationPlayState: "paused"
            },
            [`${S}-fade-enter${S}-fade-enter-active, ${S}-fade-appear${S}-fade-appear-active`]: {
                animationPlayState: "running"
            },
            [`${S}-fade-leave${S}-fade-leave-active`]: {
                animationName: O,
                animationPlayState: "running"
            },
            "&-rtl": {
                direction: "rtl",
                [`${B}-btn`]: {
                    float: "left"
                }
            }
        })
    }, {
        [S]: {
            [`${B}-wrapper`]: Object.assign({}, genNoticeStyle(C))
        }
    }]
}
  , prepareComponentToken = C=>({
    zIndexPopup: C.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
    width: 384
})
  , prepareNotificationToken = C=>{
    const S = C.paddingMD
      , E = C.paddingLG;
    return merge$1(C, {
        notificationBg: C.colorBgElevated,
        notificationPaddingVertical: S,
        notificationPaddingHorizontal: E,
        notificationIconSize: C.calc(C.fontSizeLG).mul(C.lineHeightLG).equal(),
        notificationCloseButtonSize: C.calc(C.controlHeightLG).mul(.55).equal(),
        notificationMarginBottom: C.margin,
        notificationPadding: `${unit$1(C.paddingMD)} ${unit$1(C.paddingContentHorizontalLG)}`,
        notificationMarginEdge: C.marginLG,
        animationMaxHeight: 150,
        notificationStackLayer: 3
    })
}
  , useStyle = genStyleHooks("Notification", C=>{
    const S = prepareNotificationToken(C);
    return [genNotificationStyle(S), genNotificationPlacementStyle$1(S), genStackStyle$1(S)]
}
, prepareComponentToken)
  , PurePanelStyle = genSubStyleComponent(["Notification", "PurePanel"], C=>{
    const S = `${C.componentCls}-notice`
      , E = prepareNotificationToken(C);
    return {
        [`${S}-pure-panel`]: Object.assign(Object.assign({}, genNoticeStyle(E)), {
            width: E.width,
            maxWidth: `calc(100vw - ${unit$1(C.calc(E.notificationMarginEdge).mul(2).equal())})`,
            margin: 0
        })
    }
}
, prepareComponentToken);
var __rest$1 = function(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
};
function getCloseIcon(C, S) {
    return S === null || S === !1 ? null : S || reactExports.createElement(CloseOutlined$1, {
        className: `${C}-close-icon`
    })
}
const typeToIcon = {
    success: CheckCircleFilled$1,
    info: InfoCircleFilled$1,
    error: CloseCircleFilled$1,
    warning: ExclamationCircleFilled$1
}
  , PureContent = C=>{
    const {prefixCls: S, icon: E, type: M, message: T, description: $, btn: B, role: O="alert"} = C;
    let F = null;
    return E ? F = reactExports.createElement("span", {
        className: `${S}-icon`
    }, E) : M && (F = reactExports.createElement(typeToIcon[M] || null, {
        className: classNames(`${S}-icon`, `${S}-icon-${M}`)
    })),
    reactExports.createElement("div", {
        className: classNames({
            [`${S}-with-icon`]: F
        }),
        role: O
    }, F, reactExports.createElement("div", {
        className: `${S}-message`
    }, T), reactExports.createElement("div", {
        className: `${S}-description`
    }, $), B && reactExports.createElement("div", {
        className: `${S}-btn`
    }, B))
}
  , PurePanel = C=>{
    const {prefixCls: S, className: E, icon: M, type: T, message: $, description: B, btn: O, closable: F=!0, closeIcon: N, className: U} = C
      , H = __rest$1(C, ["prefixCls", "className", "icon", "type", "message", "description", "btn", "closable", "closeIcon", "className"])
      , {getPrefixCls: Z} = reactExports.useContext(ConfigContext)
      , J = S || Z("notification")
      , ie = `${J}-notice`
      , oe = useCSSVarCls(J)
      , [ae,se,le] = useStyle(J, oe);
    return ae(reactExports.createElement("div", {
        className: classNames(`${ie}-pure-panel`, se, E, le, oe)
    }, reactExports.createElement(PurePanelStyle, {
        prefixCls: J
    }), reactExports.createElement(Notify, Object.assign({}, H, {
        prefixCls: J,
        eventKey: "pure",
        duration: null,
        closable: F,
        className: classNames({
            notificationClassName: U
        }),
        closeIcon: getCloseIcon(J, N),
        content: reactExports.createElement(PureContent, {
            prefixCls: ie,
            icon: M,
            type: T,
            message: $,
            description: B,
            btn: O
        })
    }))))
}
  , PurePanel$1 = PurePanel;
function getPlacementStyle(C, S, E) {
    let M;
    switch (C) {
    case "top":
        M = {
            left: "50%",
            transform: "translateX(-50%)",
            right: "auto",
            top: S,
            bottom: "auto"
        };
        break;
    case "topLeft":
        M = {
            left: 0,
            top: S,
            bottom: "auto"
        };
        break;
    case "topRight":
        M = {
            right: 0,
            top: S,
            bottom: "auto"
        };
        break;
    case "bottom":
        M = {
            left: "50%",
            transform: "translateX(-50%)",
            right: "auto",
            top: "auto",
            bottom: E
        };
        break;
    case "bottomLeft":
        M = {
            left: 0,
            top: "auto",
            bottom: E
        };
        break;
    default:
        M = {
            right: 0,
            top: "auto",
            bottom: E
        };
        break
    }
    return M
}
function getMotion(C) {
    return {
        motionName: `${C}-fade`
    }
}
var __rest = function(C, S) {
    var E = {};
    for (var M in C)
        Object.prototype.hasOwnProperty.call(C, M) && S.indexOf(M) < 0 && (E[M] = C[M]);
    if (C != null && typeof Object.getOwnPropertySymbols == "function")
        for (var T = 0, M = Object.getOwnPropertySymbols(C); T < M.length; T++)
            S.indexOf(M[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, M[T]) && (E[M[T]] = C[M[T]]);
    return E
};
const DEFAULT_OFFSET = 24
  , DEFAULT_DURATION = 4.5
  , DEFAULT_PLACEMENT = "topRight"
  , Wrapper$1 = C=>{
    let {children: S, prefixCls: E} = C;
    const M = useCSSVarCls(E)
      , [T,$,B] = useStyle(E, M);
    return T(React$1.createElement(NotificationProvider, {
        classNames: {
            list: classNames($, B, M)
        }
    }, S))
}
  , renderNotifications = (C,S)=>{
    let {prefixCls: E, key: M} = S;
    return React$1.createElement(Wrapper$1, {
        prefixCls: E,
        key: M
    }, C)
}
  , Holder = React$1.forwardRef((C,S)=>{
    const {top: E, bottom: M, prefixCls: T, getContainer: $, maxCount: B, rtl: O, onAllRemoved: F, stack: N, duration: U} = C
      , {getPrefixCls: H, getPopupContainer: Z, notification: J, direction: ie} = reactExports.useContext(ConfigContext)
      , [,oe] = useToken()
      , ae = T || H("notification")
      , se = ge=>getPlacementStyle(ge, E ?? DEFAULT_OFFSET, M ?? DEFAULT_OFFSET)
      , le = ()=>classNames({
        [`${ae}-rtl`]: O ?? ie === "rtl"
    })
      , de = ()=>getMotion(ae)
      , [fe,pe] = useNotification$1({
        prefixCls: ae,
        style: se,
        className: le,
        motion: de,
        closable: !0,
        closeIcon: getCloseIcon(ae),
        duration: U ?? DEFAULT_DURATION,
        getContainer: ()=>($ == null ? void 0 : $()) || (Z == null ? void 0 : Z()) || document.body,
        maxCount: B,
        onAllRemoved: F,
        renderNotifications,
        stack: N === !1 ? !1 : {
            threshold: typeof N == "object" ? N == null ? void 0 : N.threshold : void 0,
            offset: 8,
            gap: oe.margin
        }
    });
    return React$1.useImperativeHandle(S, ()=>Object.assign(Object.assign({}, fe), {
        prefixCls: ae,
        notification: J
    })),
    pe
}
);
function useInternalNotification(C) {
    const S = React$1.useRef(null);
    return [React$1.useMemo(()=>{
        const M = O=>{
            var F;
            if (!S.current)
                return;
            const {open: N, prefixCls: U, notification: H} = S.current
              , Z = `${U}-notice`
              , {message: J, description: ie, icon: oe, type: ae, btn: se, className: le, style: de, role: fe="alert", closeIcon: pe, closable: ge} = O
              , we = __rest(O, ["message", "description", "icon", "type", "btn", "className", "style", "role", "closeIcon", "closable"])
              , Ae = getCloseIcon(Z, typeof pe < "u" ? pe : H == null ? void 0 : H.closeIcon);
            return N(Object.assign(Object.assign({
                placement: (F = C == null ? void 0 : C.placement) !== null && F !== void 0 ? F : DEFAULT_PLACEMENT
            }, we), {
                content: React$1.createElement(PureContent, {
                    prefixCls: Z,
                    icon: oe,
                    type: ae,
                    message: J,
                    description: ie,
                    btn: se,
                    role: fe
                }),
                className: classNames(ae && `${Z}-${ae}`, le, H == null ? void 0 : H.className),
                style: Object.assign(Object.assign({}, H == null ? void 0 : H.style), de),
                closeIcon: Ae,
                closable: ge ?? !!Ae
            }))
        }
          , $ = {
            open: M,
            destroy: O=>{
                var F, N;
                O !== void 0 ? (F = S.current) === null || F === void 0 || F.close(O) : (N = S.current) === null || N === void 0 || N.destroy()
            }
        };
        return ["success", "info", "warning", "error"].forEach(O=>{
            $[O] = F=>M(Object.assign(Object.assign({}, F), {
                type: O
            }))
        }
        ),
        $
    }
    , []), React$1.createElement(Holder, Object.assign({
        key: "notification-holder"
    }, C, {
        ref: S
    }))]
}
function useNotification(C) {
    return useInternalNotification(C)
}
const AppConfigContext = React$1.createContext({});
let notification = null
  , act = C=>C()
  , taskQueue = []
  , defaultGlobalConfig = {};
function getGlobalContext() {
    const {getContainer: C, rtl: S, maxCount: E, top: M, bottom: T} = defaultGlobalConfig
      , $ = (C == null ? void 0 : C()) || document.body;
    return {
        getContainer: ()=>$,
        rtl: S,
        maxCount: E,
        top: M,
        bottom: T
    }
}
const GlobalHolder = React$1.forwardRef((C,S)=>{
    const {notificationConfig: E, sync: M} = C
      , {getPrefixCls: T} = reactExports.useContext(ConfigContext)
      , $ = defaultGlobalConfig.prefixCls || T("notification")
      , B = reactExports.useContext(AppConfigContext)
      , [O,F] = useInternalNotification(Object.assign(Object.assign(Object.assign({}, E), {
        prefixCls: $
    }), B.notification));
    return React$1.useEffect(M, []),
    React$1.useImperativeHandle(S, ()=>{
        const N = Object.assign({}, O);
        return Object.keys(N).forEach(U=>{
            N[U] = function() {
                return M(),
                O[U].apply(O, arguments)
            }
        }
        ),
        {
            instance: N,
            sync: M
        }
    }
    ),
    F
}
)
  , GlobalHolderWrapper = React$1.forwardRef((C,S)=>{
    const [E,M] = React$1.useState(getGlobalContext)
      , T = ()=>{
        M(getGlobalContext)
    }
    ;
    React$1.useEffect(T, []);
    const $ = globalConfig()
      , B = $.getRootPrefixCls()
      , O = $.getIconPrefixCls()
      , F = $.getTheme()
      , N = React$1.createElement(GlobalHolder, {
        ref: S,
        sync: T,
        notificationConfig: E
    });
    return React$1.createElement(ConfigProvider$1, {
        prefixCls: B,
        iconPrefixCls: O,
        theme: F
    }, $.holderRender ? $.holderRender(N) : N)
}
);
function flushNotice() {
    if (!notification) {
        const C = document.createDocumentFragment()
          , S = {
            fragment: C
        };
        notification = S,
        act(()=>{
            render(React$1.createElement(GlobalHolderWrapper, {
                ref: E=>{
                    const {instance: M, sync: T} = E || {};
                    Promise.resolve().then(()=>{
                        !S.instance && M && (S.instance = M,
                        S.sync = T,
                        flushNotice())
                    }
                    )
                }
            }), C)
        }
        );
        return
    }
    notification.instance && (taskQueue.forEach(C=>{
        switch (C.type) {
        case "open":
            {
                act(()=>{
                    notification.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), C.config))
                }
                );
                break
            }
        case "destroy":
            act(()=>{
                notification == null || notification.instance.destroy(C.key)
            }
            );
            break
        }
    }
    ),
    taskQueue = [])
}
function setNotificationGlobalConfig(C) {
    defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), C),
    act(()=>{
        var S;
        (S = notification == null ? void 0 : notification.sync) === null || S === void 0 || S.call(notification)
    }
    )
}
function open$1(C) {
    taskQueue.push({
        type: "open",
        config: C
    }),
    flushNotice()
}
const destroy = C=>{
    taskQueue.push({
        type: "destroy",
        key: C
    }),
    flushNotice()
}
  , methods = ["success", "info", "warning", "error"]
  , baseStaticMethods = {
    open: open$1,
    destroy,
    config: setNotificationGlobalConfig,
    useNotification,
    _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$1
}
  , staticMethods = baseStaticMethods;
methods.forEach(C=>{
    staticMethods[C] = S=>open$1(Object.assign(Object.assign({}, S), {
        type: C
    }))
}
);
var bn$2 = {
    exports: {}
};
bn$2.exports;
(function(C) {
    (function(S, E) {
        function M(W, D) {
            if (!W)
                throw new Error(D || "Assertion failed")
        }
        function T(W, D) {
            W.super_ = D;
            var I = function() {};
            I.prototype = D.prototype,
            W.prototype = new I,
            W.prototype.constructor = W
        }
        function $(W, D, I) {
            if ($.isBN(W))
                return W;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            W !== null && ((D === "le" || D === "be") && (I = D,
            D = 10),
            this._init(W || 0, D || 10, I || "be"))
        }
        typeof S == "object" ? S.exports = $ : E.BN = $,
        $.BN = $,
        $.wordSize = 26;
        var B;
        try {
            B = require$$0$2.Buffer
        } catch {}
        $.isBN = function(D) {
            return D instanceof $ ? !0 : D !== null && typeof D == "object" && D.constructor.wordSize === $.wordSize && Array.isArray(D.words)
        }
        ,
        $.max = function(D, I) {
            return D.cmp(I) > 0 ? D : I
        }
        ,
        $.min = function(D, I) {
            return D.cmp(I) < 0 ? D : I
        }
        ,
        $.prototype._init = function(D, I, L) {
            if (typeof D == "number")
                return this._initNumber(D, I, L);
            if (typeof D == "object")
                return this._initArray(D, I, L);
            I === "hex" && (I = 16),
            M(I === (I | 0) && I >= 2 && I <= 36),
            D = D.toString().replace(/\s+/g, "");
            var K = 0;
            D[0] === "-" && K++,
            I === 16 ? this._parseHex(D, K) : this._parseBase(D, I, K),
            D[0] === "-" && (this.negative = 1),
            this._strip(),
            L === "le" && this._initArray(this.toArray(), I, L)
        }
        ,
        $.prototype._initNumber = function(D, I, L) {
            D < 0 && (this.negative = 1,
            D = -D),
            D < 67108864 ? (this.words = [D & 67108863],
            this.length = 1) : D < 4503599627370496 ? (this.words = [D & 67108863, D / 67108864 & 67108863],
            this.length = 2) : (M(D < 9007199254740992),
            this.words = [D & 67108863, D / 67108864 & 67108863, 1],
            this.length = 3),
            L === "le" && this._initArray(this.toArray(), I, L)
        }
        ,
        $.prototype._initArray = function(D, I, L) {
            if (M(typeof D.length == "number"),
            D.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(D.length / 3),
            this.words = new Array(this.length);
            for (var K = 0; K < this.length; K++)
                this.words[K] = 0;
            var X, Y, j = 0;
            if (L === "be")
                for (K = D.length - 1,
                X = 0; K >= 0; K -= 3)
                    Y = D[K] | D[K - 1] << 8 | D[K - 2] << 16,
                    this.words[X] |= Y << j & 67108863,
                    this.words[X + 1] = Y >>> 26 - j & 67108863,
                    j += 24,
                    j >= 26 && (j -= 26,
                    X++);
            else if (L === "le")
                for (K = 0,
                X = 0; K < D.length; K += 3)
                    Y = D[K] | D[K + 1] << 8 | D[K + 2] << 16,
                    this.words[X] |= Y << j & 67108863,
                    this.words[X + 1] = Y >>> 26 - j & 67108863,
                    j += 24,
                    j >= 26 && (j -= 26,
                    X++);
            return this._strip()
        }
        ;
        function O(W, D, I) {
            for (var L = 0, K = Math.min(W.length, I), X = 0, Y = D; Y < K; Y++) {
                var j = W.charCodeAt(Y) - 48;
                L <<= 4;
                var G;
                j >= 49 && j <= 54 ? G = j - 49 + 10 : j >= 17 && j <= 22 ? G = j - 17 + 10 : G = j,
                L |= G,
                X |= G
            }
            return M(!(X & 240), "Invalid character in " + W),
            L
        }
        $.prototype._parseHex = function(D, I) {
            this.length = Math.ceil((D.length - I) / 6),
            this.words = new Array(this.length);
            for (var L = 0; L < this.length; L++)
                this.words[L] = 0;
            var K, X, Y = 0;
            for (L = D.length - 6,
            K = 0; L >= I; L -= 6)
                X = O(D, L, L + 6),
                this.words[K] |= X << Y & 67108863,
                this.words[K + 1] |= X >>> 26 - Y & 4194303,
                Y += 24,
                Y >= 26 && (Y -= 26,
                K++);
            L + 6 !== I && (X = O(D, I, L + 6),
            this.words[K] |= X << Y & 67108863,
            this.words[K + 1] |= X >>> 26 - Y & 4194303),
            this._strip()
        }
        ;
        function F(W, D, I, L) {
            for (var K = 0, X = 0, Y = Math.min(W.length, I), j = D; j < Y; j++) {
                var G = W.charCodeAt(j) - 48;
                K *= L,
                G >= 49 ? X = G - 49 + 10 : G >= 17 ? X = G - 17 + 10 : X = G,
                M(G >= 0 && X < L, "Invalid character"),
                K += X
            }
            return K
        }
        $.prototype._parseBase = function(D, I, L) {
            this.words = [0],
            this.length = 1;
            for (var K = 0, X = 1; X <= 67108863; X *= I)
                K++;
            K--,
            X = X / I | 0;
            for (var Y = D.length - L, j = Y % K, G = Math.min(Y, Y - j) + L, ne = 0, te = L; te < G; te += K)
                ne = F(D, te, te + K, I),
                this.imuln(X),
                this.words[0] + ne < 67108864 ? this.words[0] += ne : this._iaddn(ne);
            if (j !== 0) {
                var ce = 1;
                for (ne = F(D, te, D.length, I),
                te = 0; te < j; te++)
                    ce *= I;
                this.imuln(ce),
                this.words[0] + ne < 67108864 ? this.words[0] += ne : this._iaddn(ne)
            }
        }
        ,
        $.prototype.copy = function(D) {
            D.words = new Array(this.length);
            for (var I = 0; I < this.length; I++)
                D.words[I] = this.words[I];
            D.length = this.length,
            D.negative = this.negative,
            D.red = this.red
        }
        ;
        function N(W, D) {
            W.words = D.words,
            W.length = D.length,
            W.negative = D.negative,
            W.red = D.red
        }
        $.prototype._move = function(D) {
            N(D, this)
        }
        ,
        $.prototype.clone = function() {
            var D = new $(null);
            return this.copy(D),
            D
        }
        ,
        $.prototype._expand = function(D) {
            for (; this.length < D; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        $.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        $.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function" ? $.prototype[Symbol.for("nodejs.util.inspect.custom")] = U : $.prototype.inspect = U;
        function U() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var H = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , Z = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , J = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        $.prototype.toString = function(D, I) {
            D = D || 10,
            I = I | 0 || 1;
            var L;
            if (D === 16 || D === "hex") {
                L = "";
                for (var K = 0, X = 0, Y = 0; Y < this.length; Y++) {
                    var j = this.words[Y]
                      , G = ((j << K | X) & 16777215).toString(16);
                    X = j >>> 24 - K & 16777215,
                    X !== 0 || Y !== this.length - 1 ? L = H[6 - G.length] + G + L : L = G + L,
                    K += 2,
                    K >= 26 && (K -= 26,
                    Y--)
                }
                for (X !== 0 && (L = X.toString(16) + L); L.length % I !== 0; )
                    L = "0" + L;
                return this.negative !== 0 && (L = "-" + L),
                L
            }
            if (D === (D | 0) && D >= 2 && D <= 36) {
                var ne = Z[D]
                  , te = J[D];
                L = "";
                var ce = this.clone();
                for (ce.negative = 0; !ce.isZero(); ) {
                    var Ee = ce.modrn(te).toString(D);
                    ce = ce.idivn(te),
                    ce.isZero() ? L = Ee + L : L = H[ne - Ee.length] + Ee + L
                }
                for (this.isZero() && (L = "0" + L); L.length % I !== 0; )
                    L = "0" + L;
                return this.negative !== 0 && (L = "-" + L),
                L
            }
            M(!1, "Base should be between 2 and 36")
        }
        ,
        $.prototype.toNumber = function() {
            var D = this.words[0];
            return this.length === 2 ? D += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? D += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -D : D
        }
        ,
        $.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        B && ($.prototype.toBuffer = function(D, I) {
            return this.toArrayLike(B, D, I)
        }
        ),
        $.prototype.toArray = function(D, I) {
            return this.toArrayLike(Array, D, I)
        }
        ;
        var ie = function(D, I) {
            return D.allocUnsafe ? D.allocUnsafe(I) : new D(I)
        };
        $.prototype.toArrayLike = function(D, I, L) {
            this._strip();
            var K = this.byteLength()
              , X = L || Math.max(1, K);
            M(K <= X, "byte array longer than desired length"),
            M(X > 0, "Requested array length <= 0");
            var Y = ie(D, X)
              , j = I === "le" ? "LE" : "BE";
            return this["_toArrayLike" + j](Y, K),
            Y
        }
        ,
        $.prototype._toArrayLikeLE = function(D, I) {
            for (var L = 0, K = 0, X = 0, Y = 0; X < this.length; X++) {
                var j = this.words[X] << Y | K;
                D[L++] = j & 255,
                L < D.length && (D[L++] = j >> 8 & 255),
                L < D.length && (D[L++] = j >> 16 & 255),
                Y === 6 ? (L < D.length && (D[L++] = j >> 24 & 255),
                K = 0,
                Y = 0) : (K = j >>> 24,
                Y += 2)
            }
            if (L < D.length)
                for (D[L++] = K; L < D.length; )
                    D[L++] = 0
        }
        ,
        $.prototype._toArrayLikeBE = function(D, I) {
            for (var L = D.length - 1, K = 0, X = 0, Y = 0; X < this.length; X++) {
                var j = this.words[X] << Y | K;
                D[L--] = j & 255,
                L >= 0 && (D[L--] = j >> 8 & 255),
                L >= 0 && (D[L--] = j >> 16 & 255),
                Y === 6 ? (L >= 0 && (D[L--] = j >> 24 & 255),
                K = 0,
                Y = 0) : (K = j >>> 24,
                Y += 2)
            }
            if (L >= 0)
                for (D[L--] = K; L >= 0; )
                    D[L--] = 0
        }
        ,
        Math.clz32 ? $.prototype._countBits = function(D) {
            return 32 - Math.clz32(D)
        }
        : $.prototype._countBits = function(D) {
            var I = D
              , L = 0;
            return I >= 4096 && (L += 13,
            I >>>= 13),
            I >= 64 && (L += 7,
            I >>>= 7),
            I >= 8 && (L += 4,
            I >>>= 4),
            I >= 2 && (L += 2,
            I >>>= 2),
            L + I
        }
        ,
        $.prototype._zeroBits = function(D) {
            if (D === 0)
                return 26;
            var I = D
              , L = 0;
            return I & 8191 || (L += 13,
            I >>>= 13),
            I & 127 || (L += 7,
            I >>>= 7),
            I & 15 || (L += 4,
            I >>>= 4),
            I & 3 || (L += 2,
            I >>>= 2),
            I & 1 || L++,
            L
        }
        ,
        $.prototype.bitLength = function() {
            var D = this.words[this.length - 1]
              , I = this._countBits(D);
            return (this.length - 1) * 26 + I
        }
        ;
        function oe(W) {
            for (var D = new Array(W.bitLength()), I = 0; I < D.length; I++) {
                var L = I / 26 | 0
                  , K = I % 26;
                D[I] = W.words[L] >>> K & 1
            }
            return D
        }
        $.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var D = 0, I = 0; I < this.length; I++) {
                var L = this._zeroBits(this.words[I]);
                if (D += L,
                L !== 26)
                    break
            }
            return D
        }
        ,
        $.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        $.prototype.toTwos = function(D) {
            return this.negative !== 0 ? this.abs().inotn(D).iaddn(1) : this.clone()
        }
        ,
        $.prototype.fromTwos = function(D) {
            return this.testn(D - 1) ? this.notn(D).iaddn(1).ineg() : this.clone()
        }
        ,
        $.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        $.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        $.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        $.prototype.iuor = function(D) {
            for (; this.length < D.length; )
                this.words[this.length++] = 0;
            for (var I = 0; I < D.length; I++)
                this.words[I] = this.words[I] | D.words[I];
            return this._strip()
        }
        ,
        $.prototype.ior = function(D) {
            return M((this.negative | D.negative) === 0),
            this.iuor(D)
        }
        ,
        $.prototype.or = function(D) {
            return this.length > D.length ? this.clone().ior(D) : D.clone().ior(this)
        }
        ,
        $.prototype.uor = function(D) {
            return this.length > D.length ? this.clone().iuor(D) : D.clone().iuor(this)
        }
        ,
        $.prototype.iuand = function(D) {
            var I;
            this.length > D.length ? I = D : I = this;
            for (var L = 0; L < I.length; L++)
                this.words[L] = this.words[L] & D.words[L];
            return this.length = I.length,
            this._strip()
        }
        ,
        $.prototype.iand = function(D) {
            return M((this.negative | D.negative) === 0),
            this.iuand(D)
        }
        ,
        $.prototype.and = function(D) {
            return this.length > D.length ? this.clone().iand(D) : D.clone().iand(this)
        }
        ,
        $.prototype.uand = function(D) {
            return this.length > D.length ? this.clone().iuand(D) : D.clone().iuand(this)
        }
        ,
        $.prototype.iuxor = function(D) {
            var I, L;
            this.length > D.length ? (I = this,
            L = D) : (I = D,
            L = this);
            for (var K = 0; K < L.length; K++)
                this.words[K] = I.words[K] ^ L.words[K];
            if (this !== I)
                for (; K < I.length; K++)
                    this.words[K] = I.words[K];
            return this.length = I.length,
            this._strip()
        }
        ,
        $.prototype.ixor = function(D) {
            return M((this.negative | D.negative) === 0),
            this.iuxor(D)
        }
        ,
        $.prototype.xor = function(D) {
            return this.length > D.length ? this.clone().ixor(D) : D.clone().ixor(this)
        }
        ,
        $.prototype.uxor = function(D) {
            return this.length > D.length ? this.clone().iuxor(D) : D.clone().iuxor(this)
        }
        ,
        $.prototype.inotn = function(D) {
            M(typeof D == "number" && D >= 0);
            var I = Math.ceil(D / 26) | 0
              , L = D % 26;
            this._expand(I),
            L > 0 && I--;
            for (var K = 0; K < I; K++)
                this.words[K] = ~this.words[K] & 67108863;
            return L > 0 && (this.words[K] = ~this.words[K] & 67108863 >> 26 - L),
            this._strip()
        }
        ,
        $.prototype.notn = function(D) {
            return this.clone().inotn(D)
        }
        ,
        $.prototype.setn = function(D, I) {
            M(typeof D == "number" && D >= 0);
            var L = D / 26 | 0
              , K = D % 26;
            return this._expand(L + 1),
            I ? this.words[L] = this.words[L] | 1 << K : this.words[L] = this.words[L] & ~(1 << K),
            this._strip()
        }
        ,
        $.prototype.iadd = function(D) {
            var I;
            if (this.negative !== 0 && D.negative === 0)
                return this.negative = 0,
                I = this.isub(D),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && D.negative !== 0)
                return D.negative = 0,
                I = this.isub(D),
                D.negative = 1,
                I._normSign();
            var L, K;
            this.length > D.length ? (L = this,
            K = D) : (L = D,
            K = this);
            for (var X = 0, Y = 0; Y < K.length; Y++)
                I = (L.words[Y] | 0) + (K.words[Y] | 0) + X,
                this.words[Y] = I & 67108863,
                X = I >>> 26;
            for (; X !== 0 && Y < L.length; Y++)
                I = (L.words[Y] | 0) + X,
                this.words[Y] = I & 67108863,
                X = I >>> 26;
            if (this.length = L.length,
            X !== 0)
                this.words[this.length] = X,
                this.length++;
            else if (L !== this)
                for (; Y < L.length; Y++)
                    this.words[Y] = L.words[Y];
            return this
        }
        ,
        $.prototype.add = function(D) {
            var I;
            return D.negative !== 0 && this.negative === 0 ? (D.negative = 0,
            I = this.sub(D),
            D.negative ^= 1,
            I) : D.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            I = D.sub(this),
            this.negative = 1,
            I) : this.length > D.length ? this.clone().iadd(D) : D.clone().iadd(this)
        }
        ,
        $.prototype.isub = function(D) {
            if (D.negative !== 0) {
                D.negative = 0;
                var I = this.iadd(D);
                return D.negative = 1,
                I._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(D),
                this.negative = 1,
                this._normSign();
            var L = this.cmp(D);
            if (L === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var K, X;
            L > 0 ? (K = this,
            X = D) : (K = D,
            X = this);
            for (var Y = 0, j = 0; j < X.length; j++)
                I = (K.words[j] | 0) - (X.words[j] | 0) + Y,
                Y = I >> 26,
                this.words[j] = I & 67108863;
            for (; Y !== 0 && j < K.length; j++)
                I = (K.words[j] | 0) + Y,
                Y = I >> 26,
                this.words[j] = I & 67108863;
            if (Y === 0 && j < K.length && K !== this)
                for (; j < K.length; j++)
                    this.words[j] = K.words[j];
            return this.length = Math.max(this.length, j),
            K !== this && (this.negative = 1),
            this._strip()
        }
        ,
        $.prototype.sub = function(D) {
            return this.clone().isub(D)
        }
        ;
        function ae(W, D, I) {
            I.negative = D.negative ^ W.negative;
            var L = W.length + D.length | 0;
            I.length = L,
            L = L - 1 | 0;
            var K = W.words[0] | 0
              , X = D.words[0] | 0
              , Y = K * X
              , j = Y & 67108863
              , G = Y / 67108864 | 0;
            I.words[0] = j;
            for (var ne = 1; ne < L; ne++) {
                for (var te = G >>> 26, ce = G & 67108863, Ee = Math.min(ne, D.length - 1), Re = Math.max(0, ne - W.length + 1); Re <= Ee; Re++) {
                    var Te = ne - Re | 0;
                    K = W.words[Te] | 0,
                    X = D.words[Re] | 0,
                    Y = K * X + ce,
                    te += Y / 67108864 | 0,
                    ce = Y & 67108863
                }
                I.words[ne] = ce | 0,
                G = te | 0
            }
            return G !== 0 ? I.words[ne] = G | 0 : I.length--,
            I._strip()
        }
        var se = function(D, I, L) {
            var K = D.words, X = I.words, Y = L.words, j = 0, G, ne, te, ce = K[0] | 0, Ee = ce & 8191, Re = ce >>> 13, Te = K[1] | 0, xe = Te & 8191, ve = Te >>> 13, Me = K[2] | 0, Fe = Me & 8191, be = Me >>> 13, Ce = K[3] | 0, ze = Ce & 8191, Ge = Ce >>> 13, nt = K[4] | 0, bt = nt & 8191, ct = nt >>> 13, De = K[5] | 0, Ue = De & 8191, We = De >>> 13, Xe = K[6] | 0, ht = Xe & 8191, Je = Xe >>> 13, ot = K[7] | 0, je = ot & 8191, $e = ot >>> 13, Ie = K[8] | 0, He = Ie & 8191, qe = Ie >>> 13, Ne = K[9] | 0, at = Ne & 8191, Ye = Ne >>> 13, it = X[0] | 0, At = it & 8191, pt = it >>> 13, ut = X[1] | 0, Rt = ut & 8191, yt = ut >>> 13, st = X[2] | 0, Wt = st & 8191, Ct = st >>> 13, Mt = X[3] | 0, Kt = Mt & 8191, Pt = Mt >>> 13, St = X[4] | 0, Zt = St & 8191, Nt = St >>> 13, $t = X[5] | 0, Gt = $t & 8191, Ot = $t >>> 13, Bt = X[6] | 0, Yt = Bt & 8191, ye = Bt >>> 13, Be = X[7] | 0, Oe = Be & 8191, he = Be >>> 13, Pe = X[8] | 0, rt = Pe & 8191, Ze = Pe >>> 13, tt = X[9] | 0, Et = tt & 8191, Tt = tt >>> 13;
            L.negative = D.negative ^ I.negative,
            L.length = 19,
            G = Math.imul(Ee, At),
            ne = Math.imul(Ee, pt),
            ne = ne + Math.imul(Re, At) | 0,
            te = Math.imul(Re, pt);
            var kt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (kt >>> 26) | 0,
            kt &= 67108863,
            G = Math.imul(xe, At),
            ne = Math.imul(xe, pt),
            ne = ne + Math.imul(ve, At) | 0,
            te = Math.imul(ve, pt),
            G = G + Math.imul(Ee, Rt) | 0,
            ne = ne + Math.imul(Ee, yt) | 0,
            ne = ne + Math.imul(Re, Rt) | 0,
            te = te + Math.imul(Re, yt) | 0;
            var Qt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Qt >>> 26) | 0,
            Qt &= 67108863,
            G = Math.imul(Fe, At),
            ne = Math.imul(Fe, pt),
            ne = ne + Math.imul(be, At) | 0,
            te = Math.imul(be, pt),
            G = G + Math.imul(xe, Rt) | 0,
            ne = ne + Math.imul(xe, yt) | 0,
            ne = ne + Math.imul(ve, Rt) | 0,
            te = te + Math.imul(ve, yt) | 0,
            G = G + Math.imul(Ee, Wt) | 0,
            ne = ne + Math.imul(Ee, Ct) | 0,
            ne = ne + Math.imul(Re, Wt) | 0,
            te = te + Math.imul(Re, Ct) | 0;
            var Vt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Vt >>> 26) | 0,
            Vt &= 67108863,
            G = Math.imul(ze, At),
            ne = Math.imul(ze, pt),
            ne = ne + Math.imul(Ge, At) | 0,
            te = Math.imul(Ge, pt),
            G = G + Math.imul(Fe, Rt) | 0,
            ne = ne + Math.imul(Fe, yt) | 0,
            ne = ne + Math.imul(be, Rt) | 0,
            te = te + Math.imul(be, yt) | 0,
            G = G + Math.imul(xe, Wt) | 0,
            ne = ne + Math.imul(xe, Ct) | 0,
            ne = ne + Math.imul(ve, Wt) | 0,
            te = te + Math.imul(ve, Ct) | 0,
            G = G + Math.imul(Ee, Kt) | 0,
            ne = ne + Math.imul(Ee, Pt) | 0,
            ne = ne + Math.imul(Re, Kt) | 0,
            te = te + Math.imul(Re, Pt) | 0;
            var Ve = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Ve >>> 26) | 0,
            Ve &= 67108863,
            G = Math.imul(bt, At),
            ne = Math.imul(bt, pt),
            ne = ne + Math.imul(ct, At) | 0,
            te = Math.imul(ct, pt),
            G = G + Math.imul(ze, Rt) | 0,
            ne = ne + Math.imul(ze, yt) | 0,
            ne = ne + Math.imul(Ge, Rt) | 0,
            te = te + Math.imul(Ge, yt) | 0,
            G = G + Math.imul(Fe, Wt) | 0,
            ne = ne + Math.imul(Fe, Ct) | 0,
            ne = ne + Math.imul(be, Wt) | 0,
            te = te + Math.imul(be, Ct) | 0,
            G = G + Math.imul(xe, Kt) | 0,
            ne = ne + Math.imul(xe, Pt) | 0,
            ne = ne + Math.imul(ve, Kt) | 0,
            te = te + Math.imul(ve, Pt) | 0,
            G = G + Math.imul(Ee, Zt) | 0,
            ne = ne + Math.imul(Ee, Nt) | 0,
            ne = ne + Math.imul(Re, Zt) | 0,
            te = te + Math.imul(Re, Nt) | 0;
            var me = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (me >>> 26) | 0,
            me &= 67108863,
            G = Math.imul(Ue, At),
            ne = Math.imul(Ue, pt),
            ne = ne + Math.imul(We, At) | 0,
            te = Math.imul(We, pt),
            G = G + Math.imul(bt, Rt) | 0,
            ne = ne + Math.imul(bt, yt) | 0,
            ne = ne + Math.imul(ct, Rt) | 0,
            te = te + Math.imul(ct, yt) | 0,
            G = G + Math.imul(ze, Wt) | 0,
            ne = ne + Math.imul(ze, Ct) | 0,
            ne = ne + Math.imul(Ge, Wt) | 0,
            te = te + Math.imul(Ge, Ct) | 0,
            G = G + Math.imul(Fe, Kt) | 0,
            ne = ne + Math.imul(Fe, Pt) | 0,
            ne = ne + Math.imul(be, Kt) | 0,
            te = te + Math.imul(be, Pt) | 0,
            G = G + Math.imul(xe, Zt) | 0,
            ne = ne + Math.imul(xe, Nt) | 0,
            ne = ne + Math.imul(ve, Zt) | 0,
            te = te + Math.imul(ve, Nt) | 0,
            G = G + Math.imul(Ee, Gt) | 0,
            ne = ne + Math.imul(Ee, Ot) | 0,
            ne = ne + Math.imul(Re, Gt) | 0,
            te = te + Math.imul(Re, Ot) | 0;
            var ke = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (ke >>> 26) | 0,
            ke &= 67108863,
            G = Math.imul(ht, At),
            ne = Math.imul(ht, pt),
            ne = ne + Math.imul(Je, At) | 0,
            te = Math.imul(Je, pt),
            G = G + Math.imul(Ue, Rt) | 0,
            ne = ne + Math.imul(Ue, yt) | 0,
            ne = ne + Math.imul(We, Rt) | 0,
            te = te + Math.imul(We, yt) | 0,
            G = G + Math.imul(bt, Wt) | 0,
            ne = ne + Math.imul(bt, Ct) | 0,
            ne = ne + Math.imul(ct, Wt) | 0,
            te = te + Math.imul(ct, Ct) | 0,
            G = G + Math.imul(ze, Kt) | 0,
            ne = ne + Math.imul(ze, Pt) | 0,
            ne = ne + Math.imul(Ge, Kt) | 0,
            te = te + Math.imul(Ge, Pt) | 0,
            G = G + Math.imul(Fe, Zt) | 0,
            ne = ne + Math.imul(Fe, Nt) | 0,
            ne = ne + Math.imul(be, Zt) | 0,
            te = te + Math.imul(be, Nt) | 0,
            G = G + Math.imul(xe, Gt) | 0,
            ne = ne + Math.imul(xe, Ot) | 0,
            ne = ne + Math.imul(ve, Gt) | 0,
            te = te + Math.imul(ve, Ot) | 0,
            G = G + Math.imul(Ee, Yt) | 0,
            ne = ne + Math.imul(Ee, ye) | 0,
            ne = ne + Math.imul(Re, Yt) | 0,
            te = te + Math.imul(Re, ye) | 0;
            var Le = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Le >>> 26) | 0,
            Le &= 67108863,
            G = Math.imul(je, At),
            ne = Math.imul(je, pt),
            ne = ne + Math.imul($e, At) | 0,
            te = Math.imul($e, pt),
            G = G + Math.imul(ht, Rt) | 0,
            ne = ne + Math.imul(ht, yt) | 0,
            ne = ne + Math.imul(Je, Rt) | 0,
            te = te + Math.imul(Je, yt) | 0,
            G = G + Math.imul(Ue, Wt) | 0,
            ne = ne + Math.imul(Ue, Ct) | 0,
            ne = ne + Math.imul(We, Wt) | 0,
            te = te + Math.imul(We, Ct) | 0,
            G = G + Math.imul(bt, Kt) | 0,
            ne = ne + Math.imul(bt, Pt) | 0,
            ne = ne + Math.imul(ct, Kt) | 0,
            te = te + Math.imul(ct, Pt) | 0,
            G = G + Math.imul(ze, Zt) | 0,
            ne = ne + Math.imul(ze, Nt) | 0,
            ne = ne + Math.imul(Ge, Zt) | 0,
            te = te + Math.imul(Ge, Nt) | 0,
            G = G + Math.imul(Fe, Gt) | 0,
            ne = ne + Math.imul(Fe, Ot) | 0,
            ne = ne + Math.imul(be, Gt) | 0,
            te = te + Math.imul(be, Ot) | 0,
            G = G + Math.imul(xe, Yt) | 0,
            ne = ne + Math.imul(xe, ye) | 0,
            ne = ne + Math.imul(ve, Yt) | 0,
            te = te + Math.imul(ve, ye) | 0,
            G = G + Math.imul(Ee, Oe) | 0,
            ne = ne + Math.imul(Ee, he) | 0,
            ne = ne + Math.imul(Re, Oe) | 0,
            te = te + Math.imul(Re, he) | 0;
            var Qe = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Qe >>> 26) | 0,
            Qe &= 67108863,
            G = Math.imul(He, At),
            ne = Math.imul(He, pt),
            ne = ne + Math.imul(qe, At) | 0,
            te = Math.imul(qe, pt),
            G = G + Math.imul(je, Rt) | 0,
            ne = ne + Math.imul(je, yt) | 0,
            ne = ne + Math.imul($e, Rt) | 0,
            te = te + Math.imul($e, yt) | 0,
            G = G + Math.imul(ht, Wt) | 0,
            ne = ne + Math.imul(ht, Ct) | 0,
            ne = ne + Math.imul(Je, Wt) | 0,
            te = te + Math.imul(Je, Ct) | 0,
            G = G + Math.imul(Ue, Kt) | 0,
            ne = ne + Math.imul(Ue, Pt) | 0,
            ne = ne + Math.imul(We, Kt) | 0,
            te = te + Math.imul(We, Pt) | 0,
            G = G + Math.imul(bt, Zt) | 0,
            ne = ne + Math.imul(bt, Nt) | 0,
            ne = ne + Math.imul(ct, Zt) | 0,
            te = te + Math.imul(ct, Nt) | 0,
            G = G + Math.imul(ze, Gt) | 0,
            ne = ne + Math.imul(ze, Ot) | 0,
            ne = ne + Math.imul(Ge, Gt) | 0,
            te = te + Math.imul(Ge, Ot) | 0,
            G = G + Math.imul(Fe, Yt) | 0,
            ne = ne + Math.imul(Fe, ye) | 0,
            ne = ne + Math.imul(be, Yt) | 0,
            te = te + Math.imul(be, ye) | 0,
            G = G + Math.imul(xe, Oe) | 0,
            ne = ne + Math.imul(xe, he) | 0,
            ne = ne + Math.imul(ve, Oe) | 0,
            te = te + Math.imul(ve, he) | 0,
            G = G + Math.imul(Ee, rt) | 0,
            ne = ne + Math.imul(Ee, Ze) | 0,
            ne = ne + Math.imul(Re, rt) | 0,
            te = te + Math.imul(Re, Ze) | 0;
            var Ke = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Ke >>> 26) | 0,
            Ke &= 67108863,
            G = Math.imul(at, At),
            ne = Math.imul(at, pt),
            ne = ne + Math.imul(Ye, At) | 0,
            te = Math.imul(Ye, pt),
            G = G + Math.imul(He, Rt) | 0,
            ne = ne + Math.imul(He, yt) | 0,
            ne = ne + Math.imul(qe, Rt) | 0,
            te = te + Math.imul(qe, yt) | 0,
            G = G + Math.imul(je, Wt) | 0,
            ne = ne + Math.imul(je, Ct) | 0,
            ne = ne + Math.imul($e, Wt) | 0,
            te = te + Math.imul($e, Ct) | 0,
            G = G + Math.imul(ht, Kt) | 0,
            ne = ne + Math.imul(ht, Pt) | 0,
            ne = ne + Math.imul(Je, Kt) | 0,
            te = te + Math.imul(Je, Pt) | 0,
            G = G + Math.imul(Ue, Zt) | 0,
            ne = ne + Math.imul(Ue, Nt) | 0,
            ne = ne + Math.imul(We, Zt) | 0,
            te = te + Math.imul(We, Nt) | 0,
            G = G + Math.imul(bt, Gt) | 0,
            ne = ne + Math.imul(bt, Ot) | 0,
            ne = ne + Math.imul(ct, Gt) | 0,
            te = te + Math.imul(ct, Ot) | 0,
            G = G + Math.imul(ze, Yt) | 0,
            ne = ne + Math.imul(ze, ye) | 0,
            ne = ne + Math.imul(Ge, Yt) | 0,
            te = te + Math.imul(Ge, ye) | 0,
            G = G + Math.imul(Fe, Oe) | 0,
            ne = ne + Math.imul(Fe, he) | 0,
            ne = ne + Math.imul(be, Oe) | 0,
            te = te + Math.imul(be, he) | 0,
            G = G + Math.imul(xe, rt) | 0,
            ne = ne + Math.imul(xe, Ze) | 0,
            ne = ne + Math.imul(ve, rt) | 0,
            te = te + Math.imul(ve, Ze) | 0,
            G = G + Math.imul(Ee, Et) | 0,
            ne = ne + Math.imul(Ee, Tt) | 0,
            ne = ne + Math.imul(Re, Et) | 0,
            te = te + Math.imul(Re, Tt) | 0;
            var vt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (vt >>> 26) | 0,
            vt &= 67108863,
            G = Math.imul(at, Rt),
            ne = Math.imul(at, yt),
            ne = ne + Math.imul(Ye, Rt) | 0,
            te = Math.imul(Ye, yt),
            G = G + Math.imul(He, Wt) | 0,
            ne = ne + Math.imul(He, Ct) | 0,
            ne = ne + Math.imul(qe, Wt) | 0,
            te = te + Math.imul(qe, Ct) | 0,
            G = G + Math.imul(je, Kt) | 0,
            ne = ne + Math.imul(je, Pt) | 0,
            ne = ne + Math.imul($e, Kt) | 0,
            te = te + Math.imul($e, Pt) | 0,
            G = G + Math.imul(ht, Zt) | 0,
            ne = ne + Math.imul(ht, Nt) | 0,
            ne = ne + Math.imul(Je, Zt) | 0,
            te = te + Math.imul(Je, Nt) | 0,
            G = G + Math.imul(Ue, Gt) | 0,
            ne = ne + Math.imul(Ue, Ot) | 0,
            ne = ne + Math.imul(We, Gt) | 0,
            te = te + Math.imul(We, Ot) | 0,
            G = G + Math.imul(bt, Yt) | 0,
            ne = ne + Math.imul(bt, ye) | 0,
            ne = ne + Math.imul(ct, Yt) | 0,
            te = te + Math.imul(ct, ye) | 0,
            G = G + Math.imul(ze, Oe) | 0,
            ne = ne + Math.imul(ze, he) | 0,
            ne = ne + Math.imul(Ge, Oe) | 0,
            te = te + Math.imul(Ge, he) | 0,
            G = G + Math.imul(Fe, rt) | 0,
            ne = ne + Math.imul(Fe, Ze) | 0,
            ne = ne + Math.imul(be, rt) | 0,
            te = te + Math.imul(be, Ze) | 0,
            G = G + Math.imul(xe, Et) | 0,
            ne = ne + Math.imul(xe, Tt) | 0,
            ne = ne + Math.imul(ve, Et) | 0,
            te = te + Math.imul(ve, Tt) | 0;
            var dt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (dt >>> 26) | 0,
            dt &= 67108863,
            G = Math.imul(at, Wt),
            ne = Math.imul(at, Ct),
            ne = ne + Math.imul(Ye, Wt) | 0,
            te = Math.imul(Ye, Ct),
            G = G + Math.imul(He, Kt) | 0,
            ne = ne + Math.imul(He, Pt) | 0,
            ne = ne + Math.imul(qe, Kt) | 0,
            te = te + Math.imul(qe, Pt) | 0,
            G = G + Math.imul(je, Zt) | 0,
            ne = ne + Math.imul(je, Nt) | 0,
            ne = ne + Math.imul($e, Zt) | 0,
            te = te + Math.imul($e, Nt) | 0,
            G = G + Math.imul(ht, Gt) | 0,
            ne = ne + Math.imul(ht, Ot) | 0,
            ne = ne + Math.imul(Je, Gt) | 0,
            te = te + Math.imul(Je, Ot) | 0,
            G = G + Math.imul(Ue, Yt) | 0,
            ne = ne + Math.imul(Ue, ye) | 0,
            ne = ne + Math.imul(We, Yt) | 0,
            te = te + Math.imul(We, ye) | 0,
            G = G + Math.imul(bt, Oe) | 0,
            ne = ne + Math.imul(bt, he) | 0,
            ne = ne + Math.imul(ct, Oe) | 0,
            te = te + Math.imul(ct, he) | 0,
            G = G + Math.imul(ze, rt) | 0,
            ne = ne + Math.imul(ze, Ze) | 0,
            ne = ne + Math.imul(Ge, rt) | 0,
            te = te + Math.imul(Ge, Ze) | 0,
            G = G + Math.imul(Fe, Et) | 0,
            ne = ne + Math.imul(Fe, Tt) | 0,
            ne = ne + Math.imul(be, Et) | 0,
            te = te + Math.imul(be, Tt) | 0;
            var It = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (It >>> 26) | 0,
            It &= 67108863,
            G = Math.imul(at, Kt),
            ne = Math.imul(at, Pt),
            ne = ne + Math.imul(Ye, Kt) | 0,
            te = Math.imul(Ye, Pt),
            G = G + Math.imul(He, Zt) | 0,
            ne = ne + Math.imul(He, Nt) | 0,
            ne = ne + Math.imul(qe, Zt) | 0,
            te = te + Math.imul(qe, Nt) | 0,
            G = G + Math.imul(je, Gt) | 0,
            ne = ne + Math.imul(je, Ot) | 0,
            ne = ne + Math.imul($e, Gt) | 0,
            te = te + Math.imul($e, Ot) | 0,
            G = G + Math.imul(ht, Yt) | 0,
            ne = ne + Math.imul(ht, ye) | 0,
            ne = ne + Math.imul(Je, Yt) | 0,
            te = te + Math.imul(Je, ye) | 0,
            G = G + Math.imul(Ue, Oe) | 0,
            ne = ne + Math.imul(Ue, he) | 0,
            ne = ne + Math.imul(We, Oe) | 0,
            te = te + Math.imul(We, he) | 0,
            G = G + Math.imul(bt, rt) | 0,
            ne = ne + Math.imul(bt, Ze) | 0,
            ne = ne + Math.imul(ct, rt) | 0,
            te = te + Math.imul(ct, Ze) | 0,
            G = G + Math.imul(ze, Et) | 0,
            ne = ne + Math.imul(ze, Tt) | 0,
            ne = ne + Math.imul(Ge, Et) | 0,
            te = te + Math.imul(Ge, Tt) | 0;
            var xt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (xt >>> 26) | 0,
            xt &= 67108863,
            G = Math.imul(at, Zt),
            ne = Math.imul(at, Nt),
            ne = ne + Math.imul(Ye, Zt) | 0,
            te = Math.imul(Ye, Nt),
            G = G + Math.imul(He, Gt) | 0,
            ne = ne + Math.imul(He, Ot) | 0,
            ne = ne + Math.imul(qe, Gt) | 0,
            te = te + Math.imul(qe, Ot) | 0,
            G = G + Math.imul(je, Yt) | 0,
            ne = ne + Math.imul(je, ye) | 0,
            ne = ne + Math.imul($e, Yt) | 0,
            te = te + Math.imul($e, ye) | 0,
            G = G + Math.imul(ht, Oe) | 0,
            ne = ne + Math.imul(ht, he) | 0,
            ne = ne + Math.imul(Je, Oe) | 0,
            te = te + Math.imul(Je, he) | 0,
            G = G + Math.imul(Ue, rt) | 0,
            ne = ne + Math.imul(Ue, Ze) | 0,
            ne = ne + Math.imul(We, rt) | 0,
            te = te + Math.imul(We, Ze) | 0,
            G = G + Math.imul(bt, Et) | 0,
            ne = ne + Math.imul(bt, Tt) | 0,
            ne = ne + Math.imul(ct, Et) | 0,
            te = te + Math.imul(ct, Tt) | 0;
            var Dt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (Dt >>> 26) | 0,
            Dt &= 67108863,
            G = Math.imul(at, Gt),
            ne = Math.imul(at, Ot),
            ne = ne + Math.imul(Ye, Gt) | 0,
            te = Math.imul(Ye, Ot),
            G = G + Math.imul(He, Yt) | 0,
            ne = ne + Math.imul(He, ye) | 0,
            ne = ne + Math.imul(qe, Yt) | 0,
            te = te + Math.imul(qe, ye) | 0,
            G = G + Math.imul(je, Oe) | 0,
            ne = ne + Math.imul(je, he) | 0,
            ne = ne + Math.imul($e, Oe) | 0,
            te = te + Math.imul($e, he) | 0,
            G = G + Math.imul(ht, rt) | 0,
            ne = ne + Math.imul(ht, Ze) | 0,
            ne = ne + Math.imul(Je, rt) | 0,
            te = te + Math.imul(Je, Ze) | 0,
            G = G + Math.imul(Ue, Et) | 0,
            ne = ne + Math.imul(Ue, Tt) | 0,
            ne = ne + Math.imul(We, Et) | 0,
            te = te + Math.imul(We, Tt) | 0;
            var qt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (qt >>> 26) | 0,
            qt &= 67108863,
            G = Math.imul(at, Yt),
            ne = Math.imul(at, ye),
            ne = ne + Math.imul(Ye, Yt) | 0,
            te = Math.imul(Ye, ye),
            G = G + Math.imul(He, Oe) | 0,
            ne = ne + Math.imul(He, he) | 0,
            ne = ne + Math.imul(qe, Oe) | 0,
            te = te + Math.imul(qe, he) | 0,
            G = G + Math.imul(je, rt) | 0,
            ne = ne + Math.imul(je, Ze) | 0,
            ne = ne + Math.imul($e, rt) | 0,
            te = te + Math.imul($e, Ze) | 0,
            G = G + Math.imul(ht, Et) | 0,
            ne = ne + Math.imul(ht, Tt) | 0,
            ne = ne + Math.imul(Je, Et) | 0,
            te = te + Math.imul(Je, Tt) | 0;
            var zt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (zt >>> 26) | 0,
            zt &= 67108863,
            G = Math.imul(at, Oe),
            ne = Math.imul(at, he),
            ne = ne + Math.imul(Ye, Oe) | 0,
            te = Math.imul(Ye, he),
            G = G + Math.imul(He, rt) | 0,
            ne = ne + Math.imul(He, Ze) | 0,
            ne = ne + Math.imul(qe, rt) | 0,
            te = te + Math.imul(qe, Ze) | 0,
            G = G + Math.imul(je, Et) | 0,
            ne = ne + Math.imul(je, Tt) | 0,
            ne = ne + Math.imul($e, Et) | 0,
            te = te + Math.imul($e, Tt) | 0;
            var mt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (mt >>> 26) | 0,
            mt &= 67108863,
            G = Math.imul(at, rt),
            ne = Math.imul(at, Ze),
            ne = ne + Math.imul(Ye, rt) | 0,
            te = Math.imul(Ye, Ze),
            G = G + Math.imul(He, Et) | 0,
            ne = ne + Math.imul(He, Tt) | 0,
            ne = ne + Math.imul(qe, Et) | 0,
            te = te + Math.imul(qe, Tt) | 0;
            var wt = (j + G | 0) + ((ne & 8191) << 13) | 0;
            j = (te + (ne >>> 13) | 0) + (wt >>> 26) | 0,
            wt &= 67108863,
            G = Math.imul(at, Et),
            ne = Math.imul(at, Tt),
            ne = ne + Math.imul(Ye, Et) | 0,
            te = Math.imul(Ye, Tt);
            var Ut = (j + G | 0) + ((ne & 8191) << 13) | 0;
            return j = (te + (ne >>> 13) | 0) + (Ut >>> 26) | 0,
            Ut &= 67108863,
            Y[0] = kt,
            Y[1] = Qt,
            Y[2] = Vt,
            Y[3] = Ve,
            Y[4] = me,
            Y[5] = ke,
            Y[6] = Le,
            Y[7] = Qe,
            Y[8] = Ke,
            Y[9] = vt,
            Y[10] = dt,
            Y[11] = It,
            Y[12] = xt,
            Y[13] = Dt,
            Y[14] = qt,
            Y[15] = zt,
            Y[16] = mt,
            Y[17] = wt,
            Y[18] = Ut,
            j !== 0 && (Y[19] = j,
            L.length++),
            L
        };
        Math.imul || (se = ae);
        function le(W, D, I) {
            I.negative = D.negative ^ W.negative,
            I.length = W.length + D.length;
            for (var L = 0, K = 0, X = 0; X < I.length - 1; X++) {
                var Y = K;
                K = 0;
                for (var j = L & 67108863, G = Math.min(X, D.length - 1), ne = Math.max(0, X - W.length + 1); ne <= G; ne++) {
                    var te = X - ne
                      , ce = W.words[te] | 0
                      , Ee = D.words[ne] | 0
                      , Re = ce * Ee
                      , Te = Re & 67108863;
                    Y = Y + (Re / 67108864 | 0) | 0,
                    Te = Te + j | 0,
                    j = Te & 67108863,
                    Y = Y + (Te >>> 26) | 0,
                    K += Y >>> 26,
                    Y &= 67108863
                }
                I.words[X] = j,
                L = Y,
                Y = K
            }
            return L !== 0 ? I.words[X] = L : I.length--,
            I._strip()
        }
        function de(W, D, I) {
            return le(W, D, I)
        }
        $.prototype.mulTo = function(D, I) {
            var L, K = this.length + D.length;
            return this.length === 10 && D.length === 10 ? L = se(this, D, I) : K < 63 ? L = ae(this, D, I) : K < 1024 ? L = le(this, D, I) : L = de(this, D, I),
            L
        }
        ,
        $.prototype.mul = function(D) {
            var I = new $(null);
            return I.words = new Array(this.length + D.length),
            this.mulTo(D, I)
        }
        ,
        $.prototype.mulf = function(D) {
            var I = new $(null);
            return I.words = new Array(this.length + D.length),
            de(this, D, I)
        }
        ,
        $.prototype.imul = function(D) {
            return this.clone().mulTo(D, this)
        }
        ,
        $.prototype.imuln = function(D) {
            var I = D < 0;
            I && (D = -D),
            M(typeof D == "number"),
            M(D < 67108864);
            for (var L = 0, K = 0; K < this.length; K++) {
                var X = (this.words[K] | 0) * D
                  , Y = (X & 67108863) + (L & 67108863);
                L >>= 26,
                L += X / 67108864 | 0,
                L += Y >>> 26,
                this.words[K] = Y & 67108863
            }
            return L !== 0 && (this.words[K] = L,
            this.length++),
            I ? this.ineg() : this
        }
        ,
        $.prototype.muln = function(D) {
            return this.clone().imuln(D)
        }
        ,
        $.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        $.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        $.prototype.pow = function(D) {
            var I = oe(D);
            if (I.length === 0)
                return new $(1);
            for (var L = this, K = 0; K < I.length && I[K] === 0; K++,
            L = L.sqr())
                ;
            if (++K < I.length)
                for (var X = L.sqr(); K < I.length; K++,
                X = X.sqr())
                    I[K] !== 0 && (L = L.mul(X));
            return L
        }
        ,
        $.prototype.iushln = function(D) {
            M(typeof D == "number" && D >= 0);
            var I = D % 26, L = (D - I) / 26, K = 67108863 >>> 26 - I << 26 - I, X;
            if (I !== 0) {
                var Y = 0;
                for (X = 0; X < this.length; X++) {
                    var j = this.words[X] & K
                      , G = (this.words[X] | 0) - j << I;
                    this.words[X] = G | Y,
                    Y = j >>> 26 - I
                }
                Y && (this.words[X] = Y,
                this.length++)
            }
            if (L !== 0) {
                for (X = this.length - 1; X >= 0; X--)
                    this.words[X + L] = this.words[X];
                for (X = 0; X < L; X++)
                    this.words[X] = 0;
                this.length += L
            }
            return this._strip()
        }
        ,
        $.prototype.ishln = function(D) {
            return M(this.negative === 0),
            this.iushln(D)
        }
        ,
        $.prototype.iushrn = function(D, I, L) {
            M(typeof D == "number" && D >= 0);
            var K;
            I ? K = (I - I % 26) / 26 : K = 0;
            var X = D % 26
              , Y = Math.min((D - X) / 26, this.length)
              , j = 67108863 ^ 67108863 >>> X << X
              , G = L;
            if (K -= Y,
            K = Math.max(0, K),
            G) {
                for (var ne = 0; ne < Y; ne++)
                    G.words[ne] = this.words[ne];
                G.length = Y
            }
            if (Y !== 0)
                if (this.length > Y)
                    for (this.length -= Y,
                    ne = 0; ne < this.length; ne++)
                        this.words[ne] = this.words[ne + Y];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var te = 0;
            for (ne = this.length - 1; ne >= 0 && (te !== 0 || ne >= K); ne--) {
                var ce = this.words[ne] | 0;
                this.words[ne] = te << 26 - X | ce >>> X,
                te = ce & j
            }
            return G && te !== 0 && (G.words[G.length++] = te),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        $.prototype.ishrn = function(D, I, L) {
            return M(this.negative === 0),
            this.iushrn(D, I, L)
        }
        ,
        $.prototype.shln = function(D) {
            return this.clone().ishln(D)
        }
        ,
        $.prototype.ushln = function(D) {
            return this.clone().iushln(D)
        }
        ,
        $.prototype.shrn = function(D) {
            return this.clone().ishrn(D)
        }
        ,
        $.prototype.ushrn = function(D) {
            return this.clone().iushrn(D)
        }
        ,
        $.prototype.testn = function(D) {
            M(typeof D == "number" && D >= 0);
            var I = D % 26
              , L = (D - I) / 26
              , K = 1 << I;
            if (this.length <= L)
                return !1;
            var X = this.words[L];
            return !!(X & K)
        }
        ,
        $.prototype.imaskn = function(D) {
            M(typeof D == "number" && D >= 0);
            var I = D % 26
              , L = (D - I) / 26;
            if (M(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= L)
                return this;
            if (I !== 0 && L++,
            this.length = Math.min(L, this.length),
            I !== 0) {
                var K = 67108863 ^ 67108863 >>> I << I;
                this.words[this.length - 1] &= K
            }
            return this._strip()
        }
        ,
        $.prototype.maskn = function(D) {
            return this.clone().imaskn(D)
        }
        ,
        $.prototype.iaddn = function(D) {
            return M(typeof D == "number"),
            M(D < 67108864),
            D < 0 ? this.isubn(-D) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= D ? (this.words[0] = D - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(D),
            this.negative = 1,
            this) : this._iaddn(D)
        }
        ,
        $.prototype._iaddn = function(D) {
            this.words[0] += D;
            for (var I = 0; I < this.length && this.words[I] >= 67108864; I++)
                this.words[I] -= 67108864,
                I === this.length - 1 ? this.words[I + 1] = 1 : this.words[I + 1]++;
            return this.length = Math.max(this.length, I + 1),
            this
        }
        ,
        $.prototype.isubn = function(D) {
            if (M(typeof D == "number"),
            M(D < 67108864),
            D < 0)
                return this.iaddn(-D);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(D),
                this.negative = 1,
                this;
            if (this.words[0] -= D,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var I = 0; I < this.length && this.words[I] < 0; I++)
                    this.words[I] += 67108864,
                    this.words[I + 1] -= 1;
            return this._strip()
        }
        ,
        $.prototype.addn = function(D) {
            return this.clone().iaddn(D)
        }
        ,
        $.prototype.subn = function(D) {
            return this.clone().isubn(D)
        }
        ,
        $.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        $.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        $.prototype._ishlnsubmul = function(D, I, L) {
            var K = D.length + L, X;
            this._expand(K);
            var Y, j = 0;
            for (X = 0; X < D.length; X++) {
                Y = (this.words[X + L] | 0) + j;
                var G = (D.words[X] | 0) * I;
                Y -= G & 67108863,
                j = (Y >> 26) - (G / 67108864 | 0),
                this.words[X + L] = Y & 67108863
            }
            for (; X < this.length - L; X++)
                Y = (this.words[X + L] | 0) + j,
                j = Y >> 26,
                this.words[X + L] = Y & 67108863;
            if (j === 0)
                return this._strip();
            for (M(j === -1),
            j = 0,
            X = 0; X < this.length; X++)
                Y = -(this.words[X] | 0) + j,
                j = Y >> 26,
                this.words[X] = Y & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        $.prototype._wordDiv = function(D, I) {
            var L = this.length - D.length
              , K = this.clone()
              , X = D
              , Y = X.words[X.length - 1] | 0
              , j = this._countBits(Y);
            L = 26 - j,
            L !== 0 && (X = X.ushln(L),
            K.iushln(L),
            Y = X.words[X.length - 1] | 0);
            var G = K.length - X.length, ne;
            if (I !== "mod") {
                ne = new $(null),
                ne.length = G + 1,
                ne.words = new Array(ne.length);
                for (var te = 0; te < ne.length; te++)
                    ne.words[te] = 0
            }
            var ce = K.clone()._ishlnsubmul(X, 1, G);
            ce.negative === 0 && (K = ce,
            ne && (ne.words[G] = 1));
            for (var Ee = G - 1; Ee >= 0; Ee--) {
                var Re = (K.words[X.length + Ee] | 0) * 67108864 + (K.words[X.length + Ee - 1] | 0);
                for (Re = Math.min(Re / Y | 0, 67108863),
                K._ishlnsubmul(X, Re, Ee); K.negative !== 0; )
                    Re--,
                    K.negative = 0,
                    K._ishlnsubmul(X, 1, Ee),
                    K.isZero() || (K.negative ^= 1);
                ne && (ne.words[Ee] = Re)
            }
            return ne && ne._strip(),
            K._strip(),
            I !== "div" && L !== 0 && K.iushrn(L),
            {
                div: ne || null,
                mod: K
            }
        }
        ,
        $.prototype.divmod = function(D, I, L) {
            if (M(!D.isZero()),
            this.isZero())
                return {
                    div: new $(0),
                    mod: new $(0)
                };
            var K, X, Y;
            return this.negative !== 0 && D.negative === 0 ? (Y = this.neg().divmod(D, I),
            I !== "mod" && (K = Y.div.neg()),
            I !== "div" && (X = Y.mod.neg(),
            L && X.negative !== 0 && X.iadd(D)),
            {
                div: K,
                mod: X
            }) : this.negative === 0 && D.negative !== 0 ? (Y = this.divmod(D.neg(), I),
            I !== "mod" && (K = Y.div.neg()),
            {
                div: K,
                mod: Y.mod
            }) : this.negative & D.negative ? (Y = this.neg().divmod(D.neg(), I),
            I !== "div" && (X = Y.mod.neg(),
            L && X.negative !== 0 && X.isub(D)),
            {
                div: Y.div,
                mod: X
            }) : D.length > this.length || this.cmp(D) < 0 ? {
                div: new $(0),
                mod: this
            } : D.length === 1 ? I === "div" ? {
                div: this.divn(D.words[0]),
                mod: null
            } : I === "mod" ? {
                div: null,
                mod: new $(this.modrn(D.words[0]))
            } : {
                div: this.divn(D.words[0]),
                mod: new $(this.modrn(D.words[0]))
            } : this._wordDiv(D, I)
        }
        ,
        $.prototype.div = function(D) {
            return this.divmod(D, "div", !1).div
        }
        ,
        $.prototype.mod = function(D) {
            return this.divmod(D, "mod", !1).mod
        }
        ,
        $.prototype.umod = function(D) {
            return this.divmod(D, "mod", !0).mod
        }
        ,
        $.prototype.divRound = function(D) {
            var I = this.divmod(D);
            if (I.mod.isZero())
                return I.div;
            var L = I.div.negative !== 0 ? I.mod.isub(D) : I.mod
              , K = D.ushrn(1)
              , X = D.andln(1)
              , Y = L.cmp(K);
            return Y < 0 || X === 1 && Y === 0 ? I.div : I.div.negative !== 0 ? I.div.isubn(1) : I.div.iaddn(1)
        }
        ,
        $.prototype.modrn = function(D) {
            var I = D < 0;
            I && (D = -D),
            M(D <= 67108863);
            for (var L = (1 << 26) % D, K = 0, X = this.length - 1; X >= 0; X--)
                K = (L * K + (this.words[X] | 0)) % D;
            return I ? -K : K
        }
        ,
        $.prototype.modn = function(D) {
            return this.modrn(D)
        }
        ,
        $.prototype.idivn = function(D) {
            var I = D < 0;
            I && (D = -D),
            M(D <= 67108863);
            for (var L = 0, K = this.length - 1; K >= 0; K--) {
                var X = (this.words[K] | 0) + L * 67108864;
                this.words[K] = X / D | 0,
                L = X % D
            }
            return this._strip(),
            I ? this.ineg() : this
        }
        ,
        $.prototype.divn = function(D) {
            return this.clone().idivn(D)
        }
        ,
        $.prototype.egcd = function(D) {
            M(D.negative === 0),
            M(!D.isZero());
            var I = this
              , L = D.clone();
            I.negative !== 0 ? I = I.umod(D) : I = I.clone();
            for (var K = new $(1), X = new $(0), Y = new $(0), j = new $(1), G = 0; I.isEven() && L.isEven(); )
                I.iushrn(1),
                L.iushrn(1),
                ++G;
            for (var ne = L.clone(), te = I.clone(); !I.isZero(); ) {
                for (var ce = 0, Ee = 1; !(I.words[0] & Ee) && ce < 26; ++ce,
                Ee <<= 1)
                    ;
                if (ce > 0)
                    for (I.iushrn(ce); ce-- > 0; )
                        (K.isOdd() || X.isOdd()) && (K.iadd(ne),
                        X.isub(te)),
                        K.iushrn(1),
                        X.iushrn(1);
                for (var Re = 0, Te = 1; !(L.words[0] & Te) && Re < 26; ++Re,
                Te <<= 1)
                    ;
                if (Re > 0)
                    for (L.iushrn(Re); Re-- > 0; )
                        (Y.isOdd() || j.isOdd()) && (Y.iadd(ne),
                        j.isub(te)),
                        Y.iushrn(1),
                        j.iushrn(1);
                I.cmp(L) >= 0 ? (I.isub(L),
                K.isub(Y),
                X.isub(j)) : (L.isub(I),
                Y.isub(K),
                j.isub(X))
            }
            return {
                a: Y,
                b: j,
                gcd: L.iushln(G)
            }
        }
        ,
        $.prototype._invmp = function(D) {
            M(D.negative === 0),
            M(!D.isZero());
            var I = this
              , L = D.clone();
            I.negative !== 0 ? I = I.umod(D) : I = I.clone();
            for (var K = new $(1), X = new $(0), Y = L.clone(); I.cmpn(1) > 0 && L.cmpn(1) > 0; ) {
                for (var j = 0, G = 1; !(I.words[0] & G) && j < 26; ++j,
                G <<= 1)
                    ;
                if (j > 0)
                    for (I.iushrn(j); j-- > 0; )
                        K.isOdd() && K.iadd(Y),
                        K.iushrn(1);
                for (var ne = 0, te = 1; !(L.words[0] & te) && ne < 26; ++ne,
                te <<= 1)
                    ;
                if (ne > 0)
                    for (L.iushrn(ne); ne-- > 0; )
                        X.isOdd() && X.iadd(Y),
                        X.iushrn(1);
                I.cmp(L) >= 0 ? (I.isub(L),
                K.isub(X)) : (L.isub(I),
                X.isub(K))
            }
            var ce;
            return I.cmpn(1) === 0 ? ce = K : ce = X,
            ce.cmpn(0) < 0 && ce.iadd(D),
            ce
        }
        ,
        $.prototype.gcd = function(D) {
            if (this.isZero())
                return D.abs();
            if (D.isZero())
                return this.abs();
            var I = this.clone()
              , L = D.clone();
            I.negative = 0,
            L.negative = 0;
            for (var K = 0; I.isEven() && L.isEven(); K++)
                I.iushrn(1),
                L.iushrn(1);
            do {
                for (; I.isEven(); )
                    I.iushrn(1);
                for (; L.isEven(); )
                    L.iushrn(1);
                var X = I.cmp(L);
                if (X < 0) {
                    var Y = I;
                    I = L,
                    L = Y
                } else if (X === 0 || L.cmpn(1) === 0)
                    break;
                I.isub(L)
            } while (!0);
            return L.iushln(K)
        }
        ,
        $.prototype.invm = function(D) {
            return this.egcd(D).a.umod(D)
        }
        ,
        $.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        $.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        $.prototype.andln = function(D) {
            return this.words[0] & D
        }
        ,
        $.prototype.bincn = function(D) {
            M(typeof D == "number");
            var I = D % 26
              , L = (D - I) / 26
              , K = 1 << I;
            if (this.length <= L)
                return this._expand(L + 1),
                this.words[L] |= K,
                this;
            for (var X = K, Y = L; X !== 0 && Y < this.length; Y++) {
                var j = this.words[Y] | 0;
                j += X,
                X = j >>> 26,
                j &= 67108863,
                this.words[Y] = j
            }
            return X !== 0 && (this.words[Y] = X,
            this.length++),
            this
        }
        ,
        $.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        $.prototype.cmpn = function(D) {
            var I = D < 0;
            if (this.negative !== 0 && !I)
                return -1;
            if (this.negative === 0 && I)
                return 1;
            this._strip();
            var L;
            if (this.length > 1)
                L = 1;
            else {
                I && (D = -D),
                M(D <= 67108863, "Number is too big");
                var K = this.words[0] | 0;
                L = K === D ? 0 : K < D ? -1 : 1
            }
            return this.negative !== 0 ? -L | 0 : L
        }
        ,
        $.prototype.cmp = function(D) {
            if (this.negative !== 0 && D.negative === 0)
                return -1;
            if (this.negative === 0 && D.negative !== 0)
                return 1;
            var I = this.ucmp(D);
            return this.negative !== 0 ? -I | 0 : I
        }
        ,
        $.prototype.ucmp = function(D) {
            if (this.length > D.length)
                return 1;
            if (this.length < D.length)
                return -1;
            for (var I = 0, L = this.length - 1; L >= 0; L--) {
                var K = this.words[L] | 0
                  , X = D.words[L] | 0;
                if (K !== X) {
                    K < X ? I = -1 : K > X && (I = 1);
                    break
                }
            }
            return I
        }
        ,
        $.prototype.gtn = function(D) {
            return this.cmpn(D) === 1
        }
        ,
        $.prototype.gt = function(D) {
            return this.cmp(D) === 1
        }
        ,
        $.prototype.gten = function(D) {
            return this.cmpn(D) >= 0
        }
        ,
        $.prototype.gte = function(D) {
            return this.cmp(D) >= 0
        }
        ,
        $.prototype.ltn = function(D) {
            return this.cmpn(D) === -1
        }
        ,
        $.prototype.lt = function(D) {
            return this.cmp(D) === -1
        }
        ,
        $.prototype.lten = function(D) {
            return this.cmpn(D) <= 0
        }
        ,
        $.prototype.lte = function(D) {
            return this.cmp(D) <= 0
        }
        ,
        $.prototype.eqn = function(D) {
            return this.cmpn(D) === 0
        }
        ,
        $.prototype.eq = function(D) {
            return this.cmp(D) === 0
        }
        ,
        $.red = function(D) {
            return new ue(D)
        }
        ,
        $.prototype.toRed = function(D) {
            return M(!this.red, "Already a number in reduction context"),
            M(this.negative === 0, "red works only with positives"),
            D.convertTo(this)._forceRed(D)
        }
        ,
        $.prototype.fromRed = function() {
            return M(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        $.prototype._forceRed = function(D) {
            return this.red = D,
            this
        }
        ,
        $.prototype.forceRed = function(D) {
            return M(!this.red, "Already a number in reduction context"),
            this._forceRed(D)
        }
        ,
        $.prototype.redAdd = function(D) {
            return M(this.red, "redAdd works only with red numbers"),
            this.red.add(this, D)
        }
        ,
        $.prototype.redIAdd = function(D) {
            return M(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, D)
        }
        ,
        $.prototype.redSub = function(D) {
            return M(this.red, "redSub works only with red numbers"),
            this.red.sub(this, D)
        }
        ,
        $.prototype.redISub = function(D) {
            return M(this.red, "redISub works only with red numbers"),
            this.red.isub(this, D)
        }
        ,
        $.prototype.redShl = function(D) {
            return M(this.red, "redShl works only with red numbers"),
            this.red.shl(this, D)
        }
        ,
        $.prototype.redMul = function(D) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, D),
            this.red.mul(this, D)
        }
        ,
        $.prototype.redIMul = function(D) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, D),
            this.red.imul(this, D)
        }
        ,
        $.prototype.redSqr = function() {
            return M(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        $.prototype.redISqr = function() {
            return M(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        $.prototype.redSqrt = function() {
            return M(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        $.prototype.redInvm = function() {
            return M(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        $.prototype.redNeg = function() {
            return M(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        $.prototype.redPow = function(D) {
            return M(this.red && !D.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, D)
        }
        ;
        var fe = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function pe(W, D) {
            this.name = W,
            this.p = new $(D,16),
            this.n = this.p.bitLength(),
            this.k = new $(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        pe.prototype._tmp = function() {
            var D = new $(null);
            return D.words = new Array(Math.ceil(this.n / 13)),
            D
        }
        ,
        pe.prototype.ireduce = function(D) {
            var I = D, L;
            do
                this.split(I, this.tmp),
                I = this.imulK(I),
                I = I.iadd(this.tmp),
                L = I.bitLength();
            while (L > this.n);
            var K = L < this.n ? -1 : I.ucmp(this.p);
            return K === 0 ? (I.words[0] = 0,
            I.length = 1) : K > 0 ? I.isub(this.p) : I._strip(),
            I
        }
        ,
        pe.prototype.split = function(D, I) {
            D.iushrn(this.n, 0, I)
        }
        ,
        pe.prototype.imulK = function(D) {
            return D.imul(this.k)
        }
        ;
        function ge() {
            pe.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        T(ge, pe),
        ge.prototype.split = function(D, I) {
            for (var L = 4194303, K = Math.min(D.length, 9), X = 0; X < K; X++)
                I.words[X] = D.words[X];
            if (I.length = K,
            D.length <= 9) {
                D.words[0] = 0,
                D.length = 1;
                return
            }
            var Y = D.words[9];
            for (I.words[I.length++] = Y & L,
            X = 10; X < D.length; X++) {
                var j = D.words[X] | 0;
                D.words[X - 10] = (j & L) << 4 | Y >>> 22,
                Y = j
            }
            Y >>>= 22,
            D.words[X - 10] = Y,
            Y === 0 && D.length > 10 ? D.length -= 10 : D.length -= 9
        }
        ,
        ge.prototype.imulK = function(D) {
            D.words[D.length] = 0,
            D.words[D.length + 1] = 0,
            D.length += 2;
            for (var I = 0, L = 0; L < D.length; L++) {
                var K = D.words[L] | 0;
                I += K * 977,
                D.words[L] = I & 67108863,
                I = K * 64 + (I / 67108864 | 0)
            }
            return D.words[D.length - 1] === 0 && (D.length--,
            D.words[D.length - 1] === 0 && D.length--),
            D
        }
        ;
        function we() {
            pe.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        T(we, pe);
        function Ae() {
            pe.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        T(Ae, pe);
        function Se() {
            pe.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        T(Se, pe),
        Se.prototype.imulK = function(D) {
            for (var I = 0, L = 0; L < D.length; L++) {
                var K = (D.words[L] | 0) * 19 + I
                  , X = K & 67108863;
                K >>>= 26,
                D.words[L] = X,
                I = K
            }
            return I !== 0 && (D.words[D.length++] = I),
            D
        }
        ,
        $._prime = function(D) {
            if (fe[D])
                return fe[D];
            var I;
            if (D === "k256")
                I = new ge;
            else if (D === "p224")
                I = new we;
            else if (D === "p192")
                I = new Ae;
            else if (D === "p25519")
                I = new Se;
            else
                throw new Error("Unknown prime " + D);
            return fe[D] = I,
            I
        }
        ;
        function ue(W) {
            if (typeof W == "string") {
                var D = $._prime(W);
                this.m = D.p,
                this.prime = D
            } else
                M(W.gtn(1), "modulus must be greater than 1"),
                this.m = W,
                this.prime = null
        }
        ue.prototype._verify1 = function(D) {
            M(D.negative === 0, "red works only with positives"),
            M(D.red, "red works only with red numbers")
        }
        ,
        ue.prototype._verify2 = function(D, I) {
            M((D.negative | I.negative) === 0, "red works only with positives"),
            M(D.red && D.red === I.red, "red works only with red numbers")
        }
        ,
        ue.prototype.imod = function(D) {
            return this.prime ? this.prime.ireduce(D)._forceRed(this) : (N(D, D.umod(this.m)._forceRed(this)),
            D)
        }
        ,
        ue.prototype.neg = function(D) {
            return D.isZero() ? D.clone() : this.m.sub(D)._forceRed(this)
        }
        ,
        ue.prototype.add = function(D, I) {
            this._verify2(D, I);
            var L = D.add(I);
            return L.cmp(this.m) >= 0 && L.isub(this.m),
            L._forceRed(this)
        }
        ,
        ue.prototype.iadd = function(D, I) {
            this._verify2(D, I);
            var L = D.iadd(I);
            return L.cmp(this.m) >= 0 && L.isub(this.m),
            L
        }
        ,
        ue.prototype.sub = function(D, I) {
            this._verify2(D, I);
            var L = D.sub(I);
            return L.cmpn(0) < 0 && L.iadd(this.m),
            L._forceRed(this)
        }
        ,
        ue.prototype.isub = function(D, I) {
            this._verify2(D, I);
            var L = D.isub(I);
            return L.cmpn(0) < 0 && L.iadd(this.m),
            L
        }
        ,
        ue.prototype.shl = function(D, I) {
            return this._verify1(D),
            this.imod(D.ushln(I))
        }
        ,
        ue.prototype.imul = function(D, I) {
            return this._verify2(D, I),
            this.imod(D.imul(I))
        }
        ,
        ue.prototype.mul = function(D, I) {
            return this._verify2(D, I),
            this.imod(D.mul(I))
        }
        ,
        ue.prototype.isqr = function(D) {
            return this.imul(D, D.clone())
        }
        ,
        ue.prototype.sqr = function(D) {
            return this.mul(D, D)
        }
        ,
        ue.prototype.sqrt = function(D) {
            if (D.isZero())
                return D.clone();
            var I = this.m.andln(3);
            if (M(I % 2 === 1),
            I === 3) {
                var L = this.m.add(new $(1)).iushrn(2);
                return this.pow(D, L)
            }
            for (var K = this.m.subn(1), X = 0; !K.isZero() && K.andln(1) === 0; )
                X++,
                K.iushrn(1);
            M(!K.isZero());
            var Y = new $(1).toRed(this)
              , j = Y.redNeg()
              , G = this.m.subn(1).iushrn(1)
              , ne = this.m.bitLength();
            for (ne = new $(2 * ne * ne).toRed(this); this.pow(ne, G).cmp(j) !== 0; )
                ne.redIAdd(j);
            for (var te = this.pow(ne, K), ce = this.pow(D, K.addn(1).iushrn(1)), Ee = this.pow(D, K), Re = X; Ee.cmp(Y) !== 0; ) {
                for (var Te = Ee, xe = 0; Te.cmp(Y) !== 0; xe++)
                    Te = Te.redSqr();
                M(xe < Re);
                var ve = this.pow(te, new $(1).iushln(Re - xe - 1));
                ce = ce.redMul(ve),
                te = ve.redSqr(),
                Ee = Ee.redMul(te),
                Re = xe
            }
            return ce
        }
        ,
        ue.prototype.invm = function(D) {
            var I = D._invmp(this.m);
            return I.negative !== 0 ? (I.negative = 0,
            this.imod(I).redNeg()) : this.imod(I)
        }
        ,
        ue.prototype.pow = function(D, I) {
            if (I.isZero())
                return new $(1).toRed(this);
            if (I.cmpn(1) === 0)
                return D.clone();
            var L = 4
              , K = new Array(1 << L);
            K[0] = new $(1).toRed(this),
            K[1] = D;
            for (var X = 2; X < K.length; X++)
                K[X] = this.mul(K[X - 1], D);
            var Y = K[0]
              , j = 0
              , G = 0
              , ne = I.bitLength() % 26;
            for (ne === 0 && (ne = 26),
            X = I.length - 1; X >= 0; X--) {
                for (var te = I.words[X], ce = ne - 1; ce >= 0; ce--) {
                    var Ee = te >> ce & 1;
                    if (Y !== K[0] && (Y = this.sqr(Y)),
                    Ee === 0 && j === 0) {
                        G = 0;
                        continue
                    }
                    j <<= 1,
                    j |= Ee,
                    G++,
                    !(G !== L && (X !== 0 || ce !== 0)) && (Y = this.mul(Y, K[j]),
                    G = 0,
                    j = 0)
                }
                ne = 26
            }
            return Y
        }
        ,
        ue.prototype.convertTo = function(D) {
            var I = D.umod(this.m);
            return I === D ? I.clone() : I
        }
        ,
        ue.prototype.convertFrom = function(D) {
            var I = D.clone();
            return I.red = null,
            I
        }
        ,
        $.mont = function(D) {
            return new V(D)
        }
        ;
        function V(W) {
            ue.call(this, W),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new $(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        T(V, ue),
        V.prototype.convertTo = function(D) {
            return this.imod(D.ushln(this.shift))
        }
        ,
        V.prototype.convertFrom = function(D) {
            var I = this.imod(D.mul(this.rinv));
            return I.red = null,
            I
        }
        ,
        V.prototype.imul = function(D, I) {
            if (D.isZero() || I.isZero())
                return D.words[0] = 0,
                D.length = 1,
                D;
            var L = D.imul(I)
              , K = L.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , X = L.isub(K).iushrn(this.shift)
              , Y = X;
            return X.cmp(this.m) >= 0 ? Y = X.isub(this.m) : X.cmpn(0) < 0 && (Y = X.iadd(this.m)),
            Y._forceRed(this)
        }
        ,
        V.prototype.mul = function(D, I) {
            if (D.isZero() || I.isZero())
                return new $(0)._forceRed(this);
            var L = D.mul(I)
              , K = L.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , X = L.isub(K).iushrn(this.shift)
              , Y = X;
            return X.cmp(this.m) >= 0 ? Y = X.isub(this.m) : X.cmpn(0) < 0 && (Y = X.iadd(this.m)),
            Y._forceRed(this)
        }
        ,
        V.prototype.invm = function(D) {
            var I = this.imod(D._invmp(this.m).mul(this.r2));
            return I._forceRed(this)
        }
    }
    )(C, commonjsGlobal)
}
)(bn$2);
var bnExports$2 = bn$2.exports
  , bn$1 = {
    exports: {}
};
bn$1.exports;
(function(C) {
    (function(S, E) {
        function M(ue, V) {
            if (!ue)
                throw new Error(V || "Assertion failed")
        }
        function T(ue, V) {
            ue.super_ = V;
            var W = function() {};
            W.prototype = V.prototype,
            ue.prototype = new W,
            ue.prototype.constructor = ue
        }
        function $(ue, V, W) {
            if ($.isBN(ue))
                return ue;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            ue !== null && ((V === "le" || V === "be") && (W = V,
            V = 10),
            this._init(ue || 0, V || 10, W || "be"))
        }
        typeof S == "object" ? S.exports = $ : E.BN = $,
        $.BN = $,
        $.wordSize = 26;
        var B;
        try {
            B = commonjsRequire("buffer").Buffer
        } catch {}
        $.isBN = function(V) {
            return V instanceof $ ? !0 : V !== null && typeof V == "object" && V.constructor.wordSize === $.wordSize && Array.isArray(V.words)
        }
        ,
        $.max = function(V, W) {
            return V.cmp(W) > 0 ? V : W
        }
        ,
        $.min = function(V, W) {
            return V.cmp(W) < 0 ? V : W
        }
        ,
        $.prototype._init = function(V, W, D) {
            if (typeof V == "number")
                return this._initNumber(V, W, D);
            if (typeof V == "object")
                return this._initArray(V, W, D);
            W === "hex" && (W = 16),
            M(W === (W | 0) && W >= 2 && W <= 36),
            V = V.toString().replace(/\s+/g, "");
            var I = 0;
            V[0] === "-" && I++,
            W === 16 ? this._parseHex(V, I) : this._parseBase(V, W, I),
            V[0] === "-" && (this.negative = 1),
            this.strip(),
            D === "le" && this._initArray(this.toArray(), W, D)
        }
        ,
        $.prototype._initNumber = function(V, W, D) {
            V < 0 && (this.negative = 1,
            V = -V),
            V < 67108864 ? (this.words = [V & 67108863],
            this.length = 1) : V < 4503599627370496 ? (this.words = [V & 67108863, V / 67108864 & 67108863],
            this.length = 2) : (M(V < 9007199254740992),
            this.words = [V & 67108863, V / 67108864 & 67108863, 1],
            this.length = 3),
            D === "le" && this._initArray(this.toArray(), W, D)
        }
        ,
        $.prototype._initArray = function(V, W, D) {
            if (M(typeof V.length == "number"),
            V.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(V.length / 3),
            this.words = new Array(this.length);
            for (var I = 0; I < this.length; I++)
                this.words[I] = 0;
            var L, K, X = 0;
            if (D === "be")
                for (I = V.length - 1,
                L = 0; I >= 0; I -= 3)
                    K = V[I] | V[I - 1] << 8 | V[I - 2] << 16,
                    this.words[L] |= K << X & 67108863,
                    this.words[L + 1] = K >>> 26 - X & 67108863,
                    X += 24,
                    X >= 26 && (X -= 26,
                    L++);
            else if (D === "le")
                for (I = 0,
                L = 0; I < V.length; I += 3)
                    K = V[I] | V[I + 1] << 8 | V[I + 2] << 16,
                    this.words[L] |= K << X & 67108863,
                    this.words[L + 1] = K >>> 26 - X & 67108863,
                    X += 24,
                    X >= 26 && (X -= 26,
                    L++);
            return this.strip()
        }
        ;
        function O(ue, V, W) {
            for (var D = 0, I = Math.min(ue.length, W), L = V; L < I; L++) {
                var K = ue.charCodeAt(L) - 48;
                D <<= 4,
                K >= 49 && K <= 54 ? D |= K - 49 + 10 : K >= 17 && K <= 22 ? D |= K - 17 + 10 : D |= K & 15
            }
            return D
        }
        $.prototype._parseHex = function(V, W) {
            this.length = Math.ceil((V.length - W) / 6),
            this.words = new Array(this.length);
            for (var D = 0; D < this.length; D++)
                this.words[D] = 0;
            var I, L, K = 0;
            for (D = V.length - 6,
            I = 0; D >= W; D -= 6)
                L = O(V, D, D + 6),
                this.words[I] |= L << K & 67108863,
                this.words[I + 1] |= L >>> 26 - K & 4194303,
                K += 24,
                K >= 26 && (K -= 26,
                I++);
            D + 6 !== W && (L = O(V, W, D + 6),
            this.words[I] |= L << K & 67108863,
            this.words[I + 1] |= L >>> 26 - K & 4194303),
            this.strip()
        }
        ;
        function F(ue, V, W, D) {
            for (var I = 0, L = Math.min(ue.length, W), K = V; K < L; K++) {
                var X = ue.charCodeAt(K) - 48;
                I *= D,
                X >= 49 ? I += X - 49 + 10 : X >= 17 ? I += X - 17 + 10 : I += X
            }
            return I
        }
        $.prototype._parseBase = function(V, W, D) {
            this.words = [0],
            this.length = 1;
            for (var I = 0, L = 1; L <= 67108863; L *= W)
                I++;
            I--,
            L = L / W | 0;
            for (var K = V.length - D, X = K % I, Y = Math.min(K, K - X) + D, j = 0, G = D; G < Y; G += I)
                j = F(V, G, G + I, W),
                this.imuln(L),
                this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
            if (X !== 0) {
                var ne = 1;
                for (j = F(V, G, V.length, W),
                G = 0; G < X; G++)
                    ne *= W;
                this.imuln(ne),
                this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j)
            }
        }
        ,
        $.prototype.copy = function(V) {
            V.words = new Array(this.length);
            for (var W = 0; W < this.length; W++)
                V.words[W] = this.words[W];
            V.length = this.length,
            V.negative = this.negative,
            V.red = this.red
        }
        ,
        $.prototype.clone = function() {
            var V = new $(null);
            return this.copy(V),
            V
        }
        ,
        $.prototype._expand = function(V) {
            for (; this.length < V; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        $.prototype.strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        $.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        $.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        ;
        var N = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , U = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , H = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        $.prototype.toString = function(V, W) {
            V = V || 10,
            W = W | 0 || 1;
            var D;
            if (V === 16 || V === "hex") {
                D = "";
                for (var I = 0, L = 0, K = 0; K < this.length; K++) {
                    var X = this.words[K]
                      , Y = ((X << I | L) & 16777215).toString(16);
                    L = X >>> 24 - I & 16777215,
                    L !== 0 || K !== this.length - 1 ? D = N[6 - Y.length] + Y + D : D = Y + D,
                    I += 2,
                    I >= 26 && (I -= 26,
                    K--)
                }
                for (L !== 0 && (D = L.toString(16) + D); D.length % W !== 0; )
                    D = "0" + D;
                return this.negative !== 0 && (D = "-" + D),
                D
            }
            if (V === (V | 0) && V >= 2 && V <= 36) {
                var j = U[V]
                  , G = H[V];
                D = "";
                var ne = this.clone();
                for (ne.negative = 0; !ne.isZero(); ) {
                    var te = ne.modn(G).toString(V);
                    ne = ne.idivn(G),
                    ne.isZero() ? D = te + D : D = N[j - te.length] + te + D
                }
                for (this.isZero() && (D = "0" + D); D.length % W !== 0; )
                    D = "0" + D;
                return this.negative !== 0 && (D = "-" + D),
                D
            }
            M(!1, "Base should be between 2 and 36")
        }
        ,
        $.prototype.toNumber = function() {
            var V = this.words[0];
            return this.length === 2 ? V += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? V += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -V : V
        }
        ,
        $.prototype.toJSON = function() {
            return this.toString(16)
        }
        ,
        $.prototype.toBuffer = function(V, W) {
            return M(typeof B < "u"),
            this.toArrayLike(B, V, W)
        }
        ,
        $.prototype.toArray = function(V, W) {
            return this.toArrayLike(Array, V, W)
        }
        ,
        $.prototype.toArrayLike = function(V, W, D) {
            var I = this.byteLength()
              , L = D || Math.max(1, I);
            M(I <= L, "byte array longer than desired length"),
            M(L > 0, "Requested array length <= 0"),
            this.strip();
            var K = W === "le", X = new V(L), Y, j, G = this.clone();
            if (K) {
                for (j = 0; !G.isZero(); j++)
                    Y = G.andln(255),
                    G.iushrn(8),
                    X[j] = Y;
                for (; j < L; j++)
                    X[j] = 0
            } else {
                for (j = 0; j < L - I; j++)
                    X[j] = 0;
                for (j = 0; !G.isZero(); j++)
                    Y = G.andln(255),
                    G.iushrn(8),
                    X[L - j - 1] = Y
            }
            return X
        }
        ,
        Math.clz32 ? $.prototype._countBits = function(V) {
            return 32 - Math.clz32(V)
        }
        : $.prototype._countBits = function(V) {
            var W = V
              , D = 0;
            return W >= 4096 && (D += 13,
            W >>>= 13),
            W >= 64 && (D += 7,
            W >>>= 7),
            W >= 8 && (D += 4,
            W >>>= 4),
            W >= 2 && (D += 2,
            W >>>= 2),
            D + W
        }
        ,
        $.prototype._zeroBits = function(V) {
            if (V === 0)
                return 26;
            var W = V
              , D = 0;
            return W & 8191 || (D += 13,
            W >>>= 13),
            W & 127 || (D += 7,
            W >>>= 7),
            W & 15 || (D += 4,
            W >>>= 4),
            W & 3 || (D += 2,
            W >>>= 2),
            W & 1 || D++,
            D
        }
        ,
        $.prototype.bitLength = function() {
            var V = this.words[this.length - 1]
              , W = this._countBits(V);
            return (this.length - 1) * 26 + W
        }
        ;
        function Z(ue) {
            for (var V = new Array(ue.bitLength()), W = 0; W < V.length; W++) {
                var D = W / 26 | 0
                  , I = W % 26;
                V[W] = (ue.words[D] & 1 << I) >>> I
            }
            return V
        }
        $.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var V = 0, W = 0; W < this.length; W++) {
                var D = this._zeroBits(this.words[W]);
                if (V += D,
                D !== 26)
                    break
            }
            return V
        }
        ,
        $.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        $.prototype.toTwos = function(V) {
            return this.negative !== 0 ? this.abs().inotn(V).iaddn(1) : this.clone()
        }
        ,
        $.prototype.fromTwos = function(V) {
            return this.testn(V - 1) ? this.notn(V).iaddn(1).ineg() : this.clone()
        }
        ,
        $.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        $.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        $.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        $.prototype.iuor = function(V) {
            for (; this.length < V.length; )
                this.words[this.length++] = 0;
            for (var W = 0; W < V.length; W++)
                this.words[W] = this.words[W] | V.words[W];
            return this.strip()
        }
        ,
        $.prototype.ior = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuor(V)
        }
        ,
        $.prototype.or = function(V) {
            return this.length > V.length ? this.clone().ior(V) : V.clone().ior(this)
        }
        ,
        $.prototype.uor = function(V) {
            return this.length > V.length ? this.clone().iuor(V) : V.clone().iuor(this)
        }
        ,
        $.prototype.iuand = function(V) {
            var W;
            this.length > V.length ? W = V : W = this;
            for (var D = 0; D < W.length; D++)
                this.words[D] = this.words[D] & V.words[D];
            return this.length = W.length,
            this.strip()
        }
        ,
        $.prototype.iand = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuand(V)
        }
        ,
        $.prototype.and = function(V) {
            return this.length > V.length ? this.clone().iand(V) : V.clone().iand(this)
        }
        ,
        $.prototype.uand = function(V) {
            return this.length > V.length ? this.clone().iuand(V) : V.clone().iuand(this)
        }
        ,
        $.prototype.iuxor = function(V) {
            var W, D;
            this.length > V.length ? (W = this,
            D = V) : (W = V,
            D = this);
            for (var I = 0; I < D.length; I++)
                this.words[I] = W.words[I] ^ D.words[I];
            if (this !== W)
                for (; I < W.length; I++)
                    this.words[I] = W.words[I];
            return this.length = W.length,
            this.strip()
        }
        ,
        $.prototype.ixor = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuxor(V)
        }
        ,
        $.prototype.xor = function(V) {
            return this.length > V.length ? this.clone().ixor(V) : V.clone().ixor(this)
        }
        ,
        $.prototype.uxor = function(V) {
            return this.length > V.length ? this.clone().iuxor(V) : V.clone().iuxor(this)
        }
        ,
        $.prototype.inotn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = Math.ceil(V / 26) | 0
              , D = V % 26;
            this._expand(W),
            D > 0 && W--;
            for (var I = 0; I < W; I++)
                this.words[I] = ~this.words[I] & 67108863;
            return D > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - D),
            this.strip()
        }
        ,
        $.prototype.notn = function(V) {
            return this.clone().inotn(V)
        }
        ,
        $.prototype.setn = function(V, W) {
            M(typeof V == "number" && V >= 0);
            var D = V / 26 | 0
              , I = V % 26;
            return this._expand(D + 1),
            W ? this.words[D] = this.words[D] | 1 << I : this.words[D] = this.words[D] & ~(1 << I),
            this.strip()
        }
        ,
        $.prototype.iadd = function(V) {
            var W;
            if (this.negative !== 0 && V.negative === 0)
                return this.negative = 0,
                W = this.isub(V),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && V.negative !== 0)
                return V.negative = 0,
                W = this.isub(V),
                V.negative = 1,
                W._normSign();
            var D, I;
            this.length > V.length ? (D = this,
            I = V) : (D = V,
            I = this);
            for (var L = 0, K = 0; K < I.length; K++)
                W = (D.words[K] | 0) + (I.words[K] | 0) + L,
                this.words[K] = W & 67108863,
                L = W >>> 26;
            for (; L !== 0 && K < D.length; K++)
                W = (D.words[K] | 0) + L,
                this.words[K] = W & 67108863,
                L = W >>> 26;
            if (this.length = D.length,
            L !== 0)
                this.words[this.length] = L,
                this.length++;
            else if (D !== this)
                for (; K < D.length; K++)
                    this.words[K] = D.words[K];
            return this
        }
        ,
        $.prototype.add = function(V) {
            var W;
            return V.negative !== 0 && this.negative === 0 ? (V.negative = 0,
            W = this.sub(V),
            V.negative ^= 1,
            W) : V.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            W = V.sub(this),
            this.negative = 1,
            W) : this.length > V.length ? this.clone().iadd(V) : V.clone().iadd(this)
        }
        ,
        $.prototype.isub = function(V) {
            if (V.negative !== 0) {
                V.negative = 0;
                var W = this.iadd(V);
                return V.negative = 1,
                W._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(V),
                this.negative = 1,
                this._normSign();
            var D = this.cmp(V);
            if (D === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var I, L;
            D > 0 ? (I = this,
            L = V) : (I = V,
            L = this);
            for (var K = 0, X = 0; X < L.length; X++)
                W = (I.words[X] | 0) - (L.words[X] | 0) + K,
                K = W >> 26,
                this.words[X] = W & 67108863;
            for (; K !== 0 && X < I.length; X++)
                W = (I.words[X] | 0) + K,
                K = W >> 26,
                this.words[X] = W & 67108863;
            if (K === 0 && X < I.length && I !== this)
                for (; X < I.length; X++)
                    this.words[X] = I.words[X];
            return this.length = Math.max(this.length, X),
            I !== this && (this.negative = 1),
            this.strip()
        }
        ,
        $.prototype.sub = function(V) {
            return this.clone().isub(V)
        }
        ;
        function J(ue, V, W) {
            W.negative = V.negative ^ ue.negative;
            var D = ue.length + V.length | 0;
            W.length = D,
            D = D - 1 | 0;
            var I = ue.words[0] | 0
              , L = V.words[0] | 0
              , K = I * L
              , X = K & 67108863
              , Y = K / 67108864 | 0;
            W.words[0] = X;
            for (var j = 1; j < D; j++) {
                for (var G = Y >>> 26, ne = Y & 67108863, te = Math.min(j, V.length - 1), ce = Math.max(0, j - ue.length + 1); ce <= te; ce++) {
                    var Ee = j - ce | 0;
                    I = ue.words[Ee] | 0,
                    L = V.words[ce] | 0,
                    K = I * L + ne,
                    G += K / 67108864 | 0,
                    ne = K & 67108863
                }
                W.words[j] = ne | 0,
                Y = G | 0
            }
            return Y !== 0 ? W.words[j] = Y | 0 : W.length--,
            W.strip()
        }
        var ie = function(V, W, D) {
            var I = V.words, L = W.words, K = D.words, X = 0, Y, j, G, ne = I[0] | 0, te = ne & 8191, ce = ne >>> 13, Ee = I[1] | 0, Re = Ee & 8191, Te = Ee >>> 13, xe = I[2] | 0, ve = xe & 8191, Me = xe >>> 13, Fe = I[3] | 0, be = Fe & 8191, Ce = Fe >>> 13, ze = I[4] | 0, Ge = ze & 8191, nt = ze >>> 13, bt = I[5] | 0, ct = bt & 8191, De = bt >>> 13, Ue = I[6] | 0, We = Ue & 8191, Xe = Ue >>> 13, ht = I[7] | 0, Je = ht & 8191, ot = ht >>> 13, je = I[8] | 0, $e = je & 8191, Ie = je >>> 13, He = I[9] | 0, qe = He & 8191, Ne = He >>> 13, at = L[0] | 0, Ye = at & 8191, it = at >>> 13, At = L[1] | 0, pt = At & 8191, ut = At >>> 13, Rt = L[2] | 0, yt = Rt & 8191, st = Rt >>> 13, Wt = L[3] | 0, Ct = Wt & 8191, Mt = Wt >>> 13, Kt = L[4] | 0, Pt = Kt & 8191, St = Kt >>> 13, Zt = L[5] | 0, Nt = Zt & 8191, $t = Zt >>> 13, Gt = L[6] | 0, Ot = Gt & 8191, Bt = Gt >>> 13, Yt = L[7] | 0, ye = Yt & 8191, Be = Yt >>> 13, Oe = L[8] | 0, he = Oe & 8191, Pe = Oe >>> 13, rt = L[9] | 0, Ze = rt & 8191, tt = rt >>> 13;
            D.negative = V.negative ^ W.negative,
            D.length = 19,
            Y = Math.imul(te, Ye),
            j = Math.imul(te, it),
            j = j + Math.imul(ce, Ye) | 0,
            G = Math.imul(ce, it);
            var Et = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Et >>> 26) | 0,
            Et &= 67108863,
            Y = Math.imul(Re, Ye),
            j = Math.imul(Re, it),
            j = j + Math.imul(Te, Ye) | 0,
            G = Math.imul(Te, it),
            Y = Y + Math.imul(te, pt) | 0,
            j = j + Math.imul(te, ut) | 0,
            j = j + Math.imul(ce, pt) | 0,
            G = G + Math.imul(ce, ut) | 0;
            var Tt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Tt >>> 26) | 0,
            Tt &= 67108863,
            Y = Math.imul(ve, Ye),
            j = Math.imul(ve, it),
            j = j + Math.imul(Me, Ye) | 0,
            G = Math.imul(Me, it),
            Y = Y + Math.imul(Re, pt) | 0,
            j = j + Math.imul(Re, ut) | 0,
            j = j + Math.imul(Te, pt) | 0,
            G = G + Math.imul(Te, ut) | 0,
            Y = Y + Math.imul(te, yt) | 0,
            j = j + Math.imul(te, st) | 0,
            j = j + Math.imul(ce, yt) | 0,
            G = G + Math.imul(ce, st) | 0;
            var kt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (kt >>> 26) | 0,
            kt &= 67108863,
            Y = Math.imul(be, Ye),
            j = Math.imul(be, it),
            j = j + Math.imul(Ce, Ye) | 0,
            G = Math.imul(Ce, it),
            Y = Y + Math.imul(ve, pt) | 0,
            j = j + Math.imul(ve, ut) | 0,
            j = j + Math.imul(Me, pt) | 0,
            G = G + Math.imul(Me, ut) | 0,
            Y = Y + Math.imul(Re, yt) | 0,
            j = j + Math.imul(Re, st) | 0,
            j = j + Math.imul(Te, yt) | 0,
            G = G + Math.imul(Te, st) | 0,
            Y = Y + Math.imul(te, Ct) | 0,
            j = j + Math.imul(te, Mt) | 0,
            j = j + Math.imul(ce, Ct) | 0,
            G = G + Math.imul(ce, Mt) | 0;
            var Qt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Qt >>> 26) | 0,
            Qt &= 67108863,
            Y = Math.imul(Ge, Ye),
            j = Math.imul(Ge, it),
            j = j + Math.imul(nt, Ye) | 0,
            G = Math.imul(nt, it),
            Y = Y + Math.imul(be, pt) | 0,
            j = j + Math.imul(be, ut) | 0,
            j = j + Math.imul(Ce, pt) | 0,
            G = G + Math.imul(Ce, ut) | 0,
            Y = Y + Math.imul(ve, yt) | 0,
            j = j + Math.imul(ve, st) | 0,
            j = j + Math.imul(Me, yt) | 0,
            G = G + Math.imul(Me, st) | 0,
            Y = Y + Math.imul(Re, Ct) | 0,
            j = j + Math.imul(Re, Mt) | 0,
            j = j + Math.imul(Te, Ct) | 0,
            G = G + Math.imul(Te, Mt) | 0,
            Y = Y + Math.imul(te, Pt) | 0,
            j = j + Math.imul(te, St) | 0,
            j = j + Math.imul(ce, Pt) | 0,
            G = G + Math.imul(ce, St) | 0;
            var Vt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Vt >>> 26) | 0,
            Vt &= 67108863,
            Y = Math.imul(ct, Ye),
            j = Math.imul(ct, it),
            j = j + Math.imul(De, Ye) | 0,
            G = Math.imul(De, it),
            Y = Y + Math.imul(Ge, pt) | 0,
            j = j + Math.imul(Ge, ut) | 0,
            j = j + Math.imul(nt, pt) | 0,
            G = G + Math.imul(nt, ut) | 0,
            Y = Y + Math.imul(be, yt) | 0,
            j = j + Math.imul(be, st) | 0,
            j = j + Math.imul(Ce, yt) | 0,
            G = G + Math.imul(Ce, st) | 0,
            Y = Y + Math.imul(ve, Ct) | 0,
            j = j + Math.imul(ve, Mt) | 0,
            j = j + Math.imul(Me, Ct) | 0,
            G = G + Math.imul(Me, Mt) | 0,
            Y = Y + Math.imul(Re, Pt) | 0,
            j = j + Math.imul(Re, St) | 0,
            j = j + Math.imul(Te, Pt) | 0,
            G = G + Math.imul(Te, St) | 0,
            Y = Y + Math.imul(te, Nt) | 0,
            j = j + Math.imul(te, $t) | 0,
            j = j + Math.imul(ce, Nt) | 0,
            G = G + Math.imul(ce, $t) | 0;
            var Ve = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Ve >>> 26) | 0,
            Ve &= 67108863,
            Y = Math.imul(We, Ye),
            j = Math.imul(We, it),
            j = j + Math.imul(Xe, Ye) | 0,
            G = Math.imul(Xe, it),
            Y = Y + Math.imul(ct, pt) | 0,
            j = j + Math.imul(ct, ut) | 0,
            j = j + Math.imul(De, pt) | 0,
            G = G + Math.imul(De, ut) | 0,
            Y = Y + Math.imul(Ge, yt) | 0,
            j = j + Math.imul(Ge, st) | 0,
            j = j + Math.imul(nt, yt) | 0,
            G = G + Math.imul(nt, st) | 0,
            Y = Y + Math.imul(be, Ct) | 0,
            j = j + Math.imul(be, Mt) | 0,
            j = j + Math.imul(Ce, Ct) | 0,
            G = G + Math.imul(Ce, Mt) | 0,
            Y = Y + Math.imul(ve, Pt) | 0,
            j = j + Math.imul(ve, St) | 0,
            j = j + Math.imul(Me, Pt) | 0,
            G = G + Math.imul(Me, St) | 0,
            Y = Y + Math.imul(Re, Nt) | 0,
            j = j + Math.imul(Re, $t) | 0,
            j = j + Math.imul(Te, Nt) | 0,
            G = G + Math.imul(Te, $t) | 0,
            Y = Y + Math.imul(te, Ot) | 0,
            j = j + Math.imul(te, Bt) | 0,
            j = j + Math.imul(ce, Ot) | 0,
            G = G + Math.imul(ce, Bt) | 0;
            var me = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (me >>> 26) | 0,
            me &= 67108863,
            Y = Math.imul(Je, Ye),
            j = Math.imul(Je, it),
            j = j + Math.imul(ot, Ye) | 0,
            G = Math.imul(ot, it),
            Y = Y + Math.imul(We, pt) | 0,
            j = j + Math.imul(We, ut) | 0,
            j = j + Math.imul(Xe, pt) | 0,
            G = G + Math.imul(Xe, ut) | 0,
            Y = Y + Math.imul(ct, yt) | 0,
            j = j + Math.imul(ct, st) | 0,
            j = j + Math.imul(De, yt) | 0,
            G = G + Math.imul(De, st) | 0,
            Y = Y + Math.imul(Ge, Ct) | 0,
            j = j + Math.imul(Ge, Mt) | 0,
            j = j + Math.imul(nt, Ct) | 0,
            G = G + Math.imul(nt, Mt) | 0,
            Y = Y + Math.imul(be, Pt) | 0,
            j = j + Math.imul(be, St) | 0,
            j = j + Math.imul(Ce, Pt) | 0,
            G = G + Math.imul(Ce, St) | 0,
            Y = Y + Math.imul(ve, Nt) | 0,
            j = j + Math.imul(ve, $t) | 0,
            j = j + Math.imul(Me, Nt) | 0,
            G = G + Math.imul(Me, $t) | 0,
            Y = Y + Math.imul(Re, Ot) | 0,
            j = j + Math.imul(Re, Bt) | 0,
            j = j + Math.imul(Te, Ot) | 0,
            G = G + Math.imul(Te, Bt) | 0,
            Y = Y + Math.imul(te, ye) | 0,
            j = j + Math.imul(te, Be) | 0,
            j = j + Math.imul(ce, ye) | 0,
            G = G + Math.imul(ce, Be) | 0;
            var ke = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (ke >>> 26) | 0,
            ke &= 67108863,
            Y = Math.imul($e, Ye),
            j = Math.imul($e, it),
            j = j + Math.imul(Ie, Ye) | 0,
            G = Math.imul(Ie, it),
            Y = Y + Math.imul(Je, pt) | 0,
            j = j + Math.imul(Je, ut) | 0,
            j = j + Math.imul(ot, pt) | 0,
            G = G + Math.imul(ot, ut) | 0,
            Y = Y + Math.imul(We, yt) | 0,
            j = j + Math.imul(We, st) | 0,
            j = j + Math.imul(Xe, yt) | 0,
            G = G + Math.imul(Xe, st) | 0,
            Y = Y + Math.imul(ct, Ct) | 0,
            j = j + Math.imul(ct, Mt) | 0,
            j = j + Math.imul(De, Ct) | 0,
            G = G + Math.imul(De, Mt) | 0,
            Y = Y + Math.imul(Ge, Pt) | 0,
            j = j + Math.imul(Ge, St) | 0,
            j = j + Math.imul(nt, Pt) | 0,
            G = G + Math.imul(nt, St) | 0,
            Y = Y + Math.imul(be, Nt) | 0,
            j = j + Math.imul(be, $t) | 0,
            j = j + Math.imul(Ce, Nt) | 0,
            G = G + Math.imul(Ce, $t) | 0,
            Y = Y + Math.imul(ve, Ot) | 0,
            j = j + Math.imul(ve, Bt) | 0,
            j = j + Math.imul(Me, Ot) | 0,
            G = G + Math.imul(Me, Bt) | 0,
            Y = Y + Math.imul(Re, ye) | 0,
            j = j + Math.imul(Re, Be) | 0,
            j = j + Math.imul(Te, ye) | 0,
            G = G + Math.imul(Te, Be) | 0,
            Y = Y + Math.imul(te, he) | 0,
            j = j + Math.imul(te, Pe) | 0,
            j = j + Math.imul(ce, he) | 0,
            G = G + Math.imul(ce, Pe) | 0;
            var Le = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Le >>> 26) | 0,
            Le &= 67108863,
            Y = Math.imul(qe, Ye),
            j = Math.imul(qe, it),
            j = j + Math.imul(Ne, Ye) | 0,
            G = Math.imul(Ne, it),
            Y = Y + Math.imul($e, pt) | 0,
            j = j + Math.imul($e, ut) | 0,
            j = j + Math.imul(Ie, pt) | 0,
            G = G + Math.imul(Ie, ut) | 0,
            Y = Y + Math.imul(Je, yt) | 0,
            j = j + Math.imul(Je, st) | 0,
            j = j + Math.imul(ot, yt) | 0,
            G = G + Math.imul(ot, st) | 0,
            Y = Y + Math.imul(We, Ct) | 0,
            j = j + Math.imul(We, Mt) | 0,
            j = j + Math.imul(Xe, Ct) | 0,
            G = G + Math.imul(Xe, Mt) | 0,
            Y = Y + Math.imul(ct, Pt) | 0,
            j = j + Math.imul(ct, St) | 0,
            j = j + Math.imul(De, Pt) | 0,
            G = G + Math.imul(De, St) | 0,
            Y = Y + Math.imul(Ge, Nt) | 0,
            j = j + Math.imul(Ge, $t) | 0,
            j = j + Math.imul(nt, Nt) | 0,
            G = G + Math.imul(nt, $t) | 0,
            Y = Y + Math.imul(be, Ot) | 0,
            j = j + Math.imul(be, Bt) | 0,
            j = j + Math.imul(Ce, Ot) | 0,
            G = G + Math.imul(Ce, Bt) | 0,
            Y = Y + Math.imul(ve, ye) | 0,
            j = j + Math.imul(ve, Be) | 0,
            j = j + Math.imul(Me, ye) | 0,
            G = G + Math.imul(Me, Be) | 0,
            Y = Y + Math.imul(Re, he) | 0,
            j = j + Math.imul(Re, Pe) | 0,
            j = j + Math.imul(Te, he) | 0,
            G = G + Math.imul(Te, Pe) | 0,
            Y = Y + Math.imul(te, Ze) | 0,
            j = j + Math.imul(te, tt) | 0,
            j = j + Math.imul(ce, Ze) | 0,
            G = G + Math.imul(ce, tt) | 0;
            var Qe = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Qe >>> 26) | 0,
            Qe &= 67108863,
            Y = Math.imul(qe, pt),
            j = Math.imul(qe, ut),
            j = j + Math.imul(Ne, pt) | 0,
            G = Math.imul(Ne, ut),
            Y = Y + Math.imul($e, yt) | 0,
            j = j + Math.imul($e, st) | 0,
            j = j + Math.imul(Ie, yt) | 0,
            G = G + Math.imul(Ie, st) | 0,
            Y = Y + Math.imul(Je, Ct) | 0,
            j = j + Math.imul(Je, Mt) | 0,
            j = j + Math.imul(ot, Ct) | 0,
            G = G + Math.imul(ot, Mt) | 0,
            Y = Y + Math.imul(We, Pt) | 0,
            j = j + Math.imul(We, St) | 0,
            j = j + Math.imul(Xe, Pt) | 0,
            G = G + Math.imul(Xe, St) | 0,
            Y = Y + Math.imul(ct, Nt) | 0,
            j = j + Math.imul(ct, $t) | 0,
            j = j + Math.imul(De, Nt) | 0,
            G = G + Math.imul(De, $t) | 0,
            Y = Y + Math.imul(Ge, Ot) | 0,
            j = j + Math.imul(Ge, Bt) | 0,
            j = j + Math.imul(nt, Ot) | 0,
            G = G + Math.imul(nt, Bt) | 0,
            Y = Y + Math.imul(be, ye) | 0,
            j = j + Math.imul(be, Be) | 0,
            j = j + Math.imul(Ce, ye) | 0,
            G = G + Math.imul(Ce, Be) | 0,
            Y = Y + Math.imul(ve, he) | 0,
            j = j + Math.imul(ve, Pe) | 0,
            j = j + Math.imul(Me, he) | 0,
            G = G + Math.imul(Me, Pe) | 0,
            Y = Y + Math.imul(Re, Ze) | 0,
            j = j + Math.imul(Re, tt) | 0,
            j = j + Math.imul(Te, Ze) | 0,
            G = G + Math.imul(Te, tt) | 0;
            var Ke = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Ke >>> 26) | 0,
            Ke &= 67108863,
            Y = Math.imul(qe, yt),
            j = Math.imul(qe, st),
            j = j + Math.imul(Ne, yt) | 0,
            G = Math.imul(Ne, st),
            Y = Y + Math.imul($e, Ct) | 0,
            j = j + Math.imul($e, Mt) | 0,
            j = j + Math.imul(Ie, Ct) | 0,
            G = G + Math.imul(Ie, Mt) | 0,
            Y = Y + Math.imul(Je, Pt) | 0,
            j = j + Math.imul(Je, St) | 0,
            j = j + Math.imul(ot, Pt) | 0,
            G = G + Math.imul(ot, St) | 0,
            Y = Y + Math.imul(We, Nt) | 0,
            j = j + Math.imul(We, $t) | 0,
            j = j + Math.imul(Xe, Nt) | 0,
            G = G + Math.imul(Xe, $t) | 0,
            Y = Y + Math.imul(ct, Ot) | 0,
            j = j + Math.imul(ct, Bt) | 0,
            j = j + Math.imul(De, Ot) | 0,
            G = G + Math.imul(De, Bt) | 0,
            Y = Y + Math.imul(Ge, ye) | 0,
            j = j + Math.imul(Ge, Be) | 0,
            j = j + Math.imul(nt, ye) | 0,
            G = G + Math.imul(nt, Be) | 0,
            Y = Y + Math.imul(be, he) | 0,
            j = j + Math.imul(be, Pe) | 0,
            j = j + Math.imul(Ce, he) | 0,
            G = G + Math.imul(Ce, Pe) | 0,
            Y = Y + Math.imul(ve, Ze) | 0,
            j = j + Math.imul(ve, tt) | 0,
            j = j + Math.imul(Me, Ze) | 0,
            G = G + Math.imul(Me, tt) | 0;
            var vt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (vt >>> 26) | 0,
            vt &= 67108863,
            Y = Math.imul(qe, Ct),
            j = Math.imul(qe, Mt),
            j = j + Math.imul(Ne, Ct) | 0,
            G = Math.imul(Ne, Mt),
            Y = Y + Math.imul($e, Pt) | 0,
            j = j + Math.imul($e, St) | 0,
            j = j + Math.imul(Ie, Pt) | 0,
            G = G + Math.imul(Ie, St) | 0,
            Y = Y + Math.imul(Je, Nt) | 0,
            j = j + Math.imul(Je, $t) | 0,
            j = j + Math.imul(ot, Nt) | 0,
            G = G + Math.imul(ot, $t) | 0,
            Y = Y + Math.imul(We, Ot) | 0,
            j = j + Math.imul(We, Bt) | 0,
            j = j + Math.imul(Xe, Ot) | 0,
            G = G + Math.imul(Xe, Bt) | 0,
            Y = Y + Math.imul(ct, ye) | 0,
            j = j + Math.imul(ct, Be) | 0,
            j = j + Math.imul(De, ye) | 0,
            G = G + Math.imul(De, Be) | 0,
            Y = Y + Math.imul(Ge, he) | 0,
            j = j + Math.imul(Ge, Pe) | 0,
            j = j + Math.imul(nt, he) | 0,
            G = G + Math.imul(nt, Pe) | 0,
            Y = Y + Math.imul(be, Ze) | 0,
            j = j + Math.imul(be, tt) | 0,
            j = j + Math.imul(Ce, Ze) | 0,
            G = G + Math.imul(Ce, tt) | 0;
            var dt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (dt >>> 26) | 0,
            dt &= 67108863,
            Y = Math.imul(qe, Pt),
            j = Math.imul(qe, St),
            j = j + Math.imul(Ne, Pt) | 0,
            G = Math.imul(Ne, St),
            Y = Y + Math.imul($e, Nt) | 0,
            j = j + Math.imul($e, $t) | 0,
            j = j + Math.imul(Ie, Nt) | 0,
            G = G + Math.imul(Ie, $t) | 0,
            Y = Y + Math.imul(Je, Ot) | 0,
            j = j + Math.imul(Je, Bt) | 0,
            j = j + Math.imul(ot, Ot) | 0,
            G = G + Math.imul(ot, Bt) | 0,
            Y = Y + Math.imul(We, ye) | 0,
            j = j + Math.imul(We, Be) | 0,
            j = j + Math.imul(Xe, ye) | 0,
            G = G + Math.imul(Xe, Be) | 0,
            Y = Y + Math.imul(ct, he) | 0,
            j = j + Math.imul(ct, Pe) | 0,
            j = j + Math.imul(De, he) | 0,
            G = G + Math.imul(De, Pe) | 0,
            Y = Y + Math.imul(Ge, Ze) | 0,
            j = j + Math.imul(Ge, tt) | 0,
            j = j + Math.imul(nt, Ze) | 0,
            G = G + Math.imul(nt, tt) | 0;
            var It = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (It >>> 26) | 0,
            It &= 67108863,
            Y = Math.imul(qe, Nt),
            j = Math.imul(qe, $t),
            j = j + Math.imul(Ne, Nt) | 0,
            G = Math.imul(Ne, $t),
            Y = Y + Math.imul($e, Ot) | 0,
            j = j + Math.imul($e, Bt) | 0,
            j = j + Math.imul(Ie, Ot) | 0,
            G = G + Math.imul(Ie, Bt) | 0,
            Y = Y + Math.imul(Je, ye) | 0,
            j = j + Math.imul(Je, Be) | 0,
            j = j + Math.imul(ot, ye) | 0,
            G = G + Math.imul(ot, Be) | 0,
            Y = Y + Math.imul(We, he) | 0,
            j = j + Math.imul(We, Pe) | 0,
            j = j + Math.imul(Xe, he) | 0,
            G = G + Math.imul(Xe, Pe) | 0,
            Y = Y + Math.imul(ct, Ze) | 0,
            j = j + Math.imul(ct, tt) | 0,
            j = j + Math.imul(De, Ze) | 0,
            G = G + Math.imul(De, tt) | 0;
            var xt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (xt >>> 26) | 0,
            xt &= 67108863,
            Y = Math.imul(qe, Ot),
            j = Math.imul(qe, Bt),
            j = j + Math.imul(Ne, Ot) | 0,
            G = Math.imul(Ne, Bt),
            Y = Y + Math.imul($e, ye) | 0,
            j = j + Math.imul($e, Be) | 0,
            j = j + Math.imul(Ie, ye) | 0,
            G = G + Math.imul(Ie, Be) | 0,
            Y = Y + Math.imul(Je, he) | 0,
            j = j + Math.imul(Je, Pe) | 0,
            j = j + Math.imul(ot, he) | 0,
            G = G + Math.imul(ot, Pe) | 0,
            Y = Y + Math.imul(We, Ze) | 0,
            j = j + Math.imul(We, tt) | 0,
            j = j + Math.imul(Xe, Ze) | 0,
            G = G + Math.imul(Xe, tt) | 0;
            var Dt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Dt >>> 26) | 0,
            Dt &= 67108863,
            Y = Math.imul(qe, ye),
            j = Math.imul(qe, Be),
            j = j + Math.imul(Ne, ye) | 0,
            G = Math.imul(Ne, Be),
            Y = Y + Math.imul($e, he) | 0,
            j = j + Math.imul($e, Pe) | 0,
            j = j + Math.imul(Ie, he) | 0,
            G = G + Math.imul(Ie, Pe) | 0,
            Y = Y + Math.imul(Je, Ze) | 0,
            j = j + Math.imul(Je, tt) | 0,
            j = j + Math.imul(ot, Ze) | 0,
            G = G + Math.imul(ot, tt) | 0;
            var qt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (qt >>> 26) | 0,
            qt &= 67108863,
            Y = Math.imul(qe, he),
            j = Math.imul(qe, Pe),
            j = j + Math.imul(Ne, he) | 0,
            G = Math.imul(Ne, Pe),
            Y = Y + Math.imul($e, Ze) | 0,
            j = j + Math.imul($e, tt) | 0,
            j = j + Math.imul(Ie, Ze) | 0,
            G = G + Math.imul(Ie, tt) | 0;
            var zt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (zt >>> 26) | 0,
            zt &= 67108863,
            Y = Math.imul(qe, Ze),
            j = Math.imul(qe, tt),
            j = j + Math.imul(Ne, Ze) | 0,
            G = Math.imul(Ne, tt);
            var mt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            return X = (G + (j >>> 13) | 0) + (mt >>> 26) | 0,
            mt &= 67108863,
            K[0] = Et,
            K[1] = Tt,
            K[2] = kt,
            K[3] = Qt,
            K[4] = Vt,
            K[5] = Ve,
            K[6] = me,
            K[7] = ke,
            K[8] = Le,
            K[9] = Qe,
            K[10] = Ke,
            K[11] = vt,
            K[12] = dt,
            K[13] = It,
            K[14] = xt,
            K[15] = Dt,
            K[16] = qt,
            K[17] = zt,
            K[18] = mt,
            X !== 0 && (K[19] = X,
            D.length++),
            D
        };
        Math.imul || (ie = J);
        function oe(ue, V, W) {
            W.negative = V.negative ^ ue.negative,
            W.length = ue.length + V.length;
            for (var D = 0, I = 0, L = 0; L < W.length - 1; L++) {
                var K = I;
                I = 0;
                for (var X = D & 67108863, Y = Math.min(L, V.length - 1), j = Math.max(0, L - ue.length + 1); j <= Y; j++) {
                    var G = L - j
                      , ne = ue.words[G] | 0
                      , te = V.words[j] | 0
                      , ce = ne * te
                      , Ee = ce & 67108863;
                    K = K + (ce / 67108864 | 0) | 0,
                    Ee = Ee + X | 0,
                    X = Ee & 67108863,
                    K = K + (Ee >>> 26) | 0,
                    I += K >>> 26,
                    K &= 67108863
                }
                W.words[L] = X,
                D = K,
                K = I
            }
            return D !== 0 ? W.words[L] = D : W.length--,
            W.strip()
        }
        function ae(ue, V, W) {
            var D = new se;
            return D.mulp(ue, V, W)
        }
        $.prototype.mulTo = function(V, W) {
            var D, I = this.length + V.length;
            return this.length === 10 && V.length === 10 ? D = ie(this, V, W) : I < 63 ? D = J(this, V, W) : I < 1024 ? D = oe(this, V, W) : D = ae(this, V, W),
            D
        }
        ;
        function se(ue, V) {
            this.x = ue,
            this.y = V
        }
        se.prototype.makeRBT = function(V) {
            for (var W = new Array(V), D = $.prototype._countBits(V) - 1, I = 0; I < V; I++)
                W[I] = this.revBin(I, D, V);
            return W
        }
        ,
        se.prototype.revBin = function(V, W, D) {
            if (V === 0 || V === D - 1)
                return V;
            for (var I = 0, L = 0; L < W; L++)
                I |= (V & 1) << W - L - 1,
                V >>= 1;
            return I
        }
        ,
        se.prototype.permute = function(V, W, D, I, L, K) {
            for (var X = 0; X < K; X++)
                I[X] = W[V[X]],
                L[X] = D[V[X]]
        }
        ,
        se.prototype.transform = function(V, W, D, I, L, K) {
            this.permute(K, V, W, D, I, L);
            for (var X = 1; X < L; X <<= 1)
                for (var Y = X << 1, j = Math.cos(2 * Math.PI / Y), G = Math.sin(2 * Math.PI / Y), ne = 0; ne < L; ne += Y)
                    for (var te = j, ce = G, Ee = 0; Ee < X; Ee++) {
                        var Re = D[ne + Ee]
                          , Te = I[ne + Ee]
                          , xe = D[ne + Ee + X]
                          , ve = I[ne + Ee + X]
                          , Me = te * xe - ce * ve;
                        ve = te * ve + ce * xe,
                        xe = Me,
                        D[ne + Ee] = Re + xe,
                        I[ne + Ee] = Te + ve,
                        D[ne + Ee + X] = Re - xe,
                        I[ne + Ee + X] = Te - ve,
                        Ee !== Y && (Me = j * te - G * ce,
                        ce = j * ce + G * te,
                        te = Me)
                    }
        }
        ,
        se.prototype.guessLen13b = function(V, W) {
            var D = Math.max(W, V) | 1
              , I = D & 1
              , L = 0;
            for (D = D / 2 | 0; D; D = D >>> 1)
                L++;
            return 1 << L + 1 + I
        }
        ,
        se.prototype.conjugate = function(V, W, D) {
            if (!(D <= 1))
                for (var I = 0; I < D / 2; I++) {
                    var L = V[I];
                    V[I] = V[D - I - 1],
                    V[D - I - 1] = L,
                    L = W[I],
                    W[I] = -W[D - I - 1],
                    W[D - I - 1] = -L
                }
        }
        ,
        se.prototype.normalize13b = function(V, W) {
            for (var D = 0, I = 0; I < W / 2; I++) {
                var L = Math.round(V[2 * I + 1] / W) * 8192 + Math.round(V[2 * I] / W) + D;
                V[I] = L & 67108863,
                L < 67108864 ? D = 0 : D = L / 67108864 | 0
            }
            return V
        }
        ,
        se.prototype.convert13b = function(V, W, D, I) {
            for (var L = 0, K = 0; K < W; K++)
                L = L + (V[K] | 0),
                D[2 * K] = L & 8191,
                L = L >>> 13,
                D[2 * K + 1] = L & 8191,
                L = L >>> 13;
            for (K = 2 * W; K < I; ++K)
                D[K] = 0;
            M(L === 0),
            M((L & -8192) === 0)
        }
        ,
        se.prototype.stub = function(V) {
            for (var W = new Array(V), D = 0; D < V; D++)
                W[D] = 0;
            return W
        }
        ,
        se.prototype.mulp = function(V, W, D) {
            var I = 2 * this.guessLen13b(V.length, W.length)
              , L = this.makeRBT(I)
              , K = this.stub(I)
              , X = new Array(I)
              , Y = new Array(I)
              , j = new Array(I)
              , G = new Array(I)
              , ne = new Array(I)
              , te = new Array(I)
              , ce = D.words;
            ce.length = I,
            this.convert13b(V.words, V.length, X, I),
            this.convert13b(W.words, W.length, G, I),
            this.transform(X, K, Y, j, I, L),
            this.transform(G, K, ne, te, I, L);
            for (var Ee = 0; Ee < I; Ee++) {
                var Re = Y[Ee] * ne[Ee] - j[Ee] * te[Ee];
                j[Ee] = Y[Ee] * te[Ee] + j[Ee] * ne[Ee],
                Y[Ee] = Re
            }
            return this.conjugate(Y, j, I),
            this.transform(Y, j, ce, K, I, L),
            this.conjugate(ce, K, I),
            this.normalize13b(ce, I),
            D.negative = V.negative ^ W.negative,
            D.length = V.length + W.length,
            D.strip()
        }
        ,
        $.prototype.mul = function(V) {
            var W = new $(null);
            return W.words = new Array(this.length + V.length),
            this.mulTo(V, W)
        }
        ,
        $.prototype.mulf = function(V) {
            var W = new $(null);
            return W.words = new Array(this.length + V.length),
            ae(this, V, W)
        }
        ,
        $.prototype.imul = function(V) {
            return this.clone().mulTo(V, this)
        }
        ,
        $.prototype.imuln = function(V) {
            M(typeof V == "number"),
            M(V < 67108864);
            for (var W = 0, D = 0; D < this.length; D++) {
                var I = (this.words[D] | 0) * V
                  , L = (I & 67108863) + (W & 67108863);
                W >>= 26,
                W += I / 67108864 | 0,
                W += L >>> 26,
                this.words[D] = L & 67108863
            }
            return W !== 0 && (this.words[D] = W,
            this.length++),
            this
        }
        ,
        $.prototype.muln = function(V) {
            return this.clone().imuln(V)
        }
        ,
        $.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        $.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        $.prototype.pow = function(V) {
            var W = Z(V);
            if (W.length === 0)
                return new $(1);
            for (var D = this, I = 0; I < W.length && W[I] === 0; I++,
            D = D.sqr())
                ;
            if (++I < W.length)
                for (var L = D.sqr(); I < W.length; I++,
                L = L.sqr())
                    W[I] !== 0 && (D = D.mul(L));
            return D
        }
        ,
        $.prototype.iushln = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26, D = (V - W) / 26, I = 67108863 >>> 26 - W << 26 - W, L;
            if (W !== 0) {
                var K = 0;
                for (L = 0; L < this.length; L++) {
                    var X = this.words[L] & I
                      , Y = (this.words[L] | 0) - X << W;
                    this.words[L] = Y | K,
                    K = X >>> 26 - W
                }
                K && (this.words[L] = K,
                this.length++)
            }
            if (D !== 0) {
                for (L = this.length - 1; L >= 0; L--)
                    this.words[L + D] = this.words[L];
                for (L = 0; L < D; L++)
                    this.words[L] = 0;
                this.length += D
            }
            return this.strip()
        }
        ,
        $.prototype.ishln = function(V) {
            return M(this.negative === 0),
            this.iushln(V)
        }
        ,
        $.prototype.iushrn = function(V, W, D) {
            M(typeof V == "number" && V >= 0);
            var I;
            W ? I = (W - W % 26) / 26 : I = 0;
            var L = V % 26
              , K = Math.min((V - L) / 26, this.length)
              , X = 67108863 ^ 67108863 >>> L << L
              , Y = D;
            if (I -= K,
            I = Math.max(0, I),
            Y) {
                for (var j = 0; j < K; j++)
                    Y.words[j] = this.words[j];
                Y.length = K
            }
            if (K !== 0)
                if (this.length > K)
                    for (this.length -= K,
                    j = 0; j < this.length; j++)
                        this.words[j] = this.words[j + K];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var G = 0;
            for (j = this.length - 1; j >= 0 && (G !== 0 || j >= I); j--) {
                var ne = this.words[j] | 0;
                this.words[j] = G << 26 - L | ne >>> L,
                G = ne & X
            }
            return Y && G !== 0 && (Y.words[Y.length++] = G),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this.strip()
        }
        ,
        $.prototype.ishrn = function(V, W, D) {
            return M(this.negative === 0),
            this.iushrn(V, W, D)
        }
        ,
        $.prototype.shln = function(V) {
            return this.clone().ishln(V)
        }
        ,
        $.prototype.ushln = function(V) {
            return this.clone().iushln(V)
        }
        ,
        $.prototype.shrn = function(V) {
            return this.clone().ishrn(V)
        }
        ,
        $.prototype.ushrn = function(V) {
            return this.clone().iushrn(V)
        }
        ,
        $.prototype.testn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26
              , D = (V - W) / 26
              , I = 1 << W;
            if (this.length <= D)
                return !1;
            var L = this.words[D];
            return !!(L & I)
        }
        ,
        $.prototype.imaskn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26
              , D = (V - W) / 26;
            if (M(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= D)
                return this;
            if (W !== 0 && D++,
            this.length = Math.min(D, this.length),
            W !== 0) {
                var I = 67108863 ^ 67108863 >>> W << W;
                this.words[this.length - 1] &= I
            }
            return this.strip()
        }
        ,
        $.prototype.maskn = function(V) {
            return this.clone().imaskn(V)
        }
        ,
        $.prototype.iaddn = function(V) {
            return M(typeof V == "number"),
            M(V < 67108864),
            V < 0 ? this.isubn(-V) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < V ? (this.words[0] = V - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(V),
            this.negative = 1,
            this) : this._iaddn(V)
        }
        ,
        $.prototype._iaddn = function(V) {
            this.words[0] += V;
            for (var W = 0; W < this.length && this.words[W] >= 67108864; W++)
                this.words[W] -= 67108864,
                W === this.length - 1 ? this.words[W + 1] = 1 : this.words[W + 1]++;
            return this.length = Math.max(this.length, W + 1),
            this
        }
        ,
        $.prototype.isubn = function(V) {
            if (M(typeof V == "number"),
            M(V < 67108864),
            V < 0)
                return this.iaddn(-V);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(V),
                this.negative = 1,
                this;
            if (this.words[0] -= V,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var W = 0; W < this.length && this.words[W] < 0; W++)
                    this.words[W] += 67108864,
                    this.words[W + 1] -= 1;
            return this.strip()
        }
        ,
        $.prototype.addn = function(V) {
            return this.clone().iaddn(V)
        }
        ,
        $.prototype.subn = function(V) {
            return this.clone().isubn(V)
        }
        ,
        $.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        $.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        $.prototype._ishlnsubmul = function(V, W, D) {
            var I = V.length + D, L;
            this._expand(I);
            var K, X = 0;
            for (L = 0; L < V.length; L++) {
                K = (this.words[L + D] | 0) + X;
                var Y = (V.words[L] | 0) * W;
                K -= Y & 67108863,
                X = (K >> 26) - (Y / 67108864 | 0),
                this.words[L + D] = K & 67108863
            }
            for (; L < this.length - D; L++)
                K = (this.words[L + D] | 0) + X,
                X = K >> 26,
                this.words[L + D] = K & 67108863;
            if (X === 0)
                return this.strip();
            for (M(X === -1),
            X = 0,
            L = 0; L < this.length; L++)
                K = -(this.words[L] | 0) + X,
                X = K >> 26,
                this.words[L] = K & 67108863;
            return this.negative = 1,
            this.strip()
        }
        ,
        $.prototype._wordDiv = function(V, W) {
            var D = this.length - V.length
              , I = this.clone()
              , L = V
              , K = L.words[L.length - 1] | 0
              , X = this._countBits(K);
            D = 26 - X,
            D !== 0 && (L = L.ushln(D),
            I.iushln(D),
            K = L.words[L.length - 1] | 0);
            var Y = I.length - L.length, j;
            if (W !== "mod") {
                j = new $(null),
                j.length = Y + 1,
                j.words = new Array(j.length);
                for (var G = 0; G < j.length; G++)
                    j.words[G] = 0
            }
            var ne = I.clone()._ishlnsubmul(L, 1, Y);
            ne.negative === 0 && (I = ne,
            j && (j.words[Y] = 1));
            for (var te = Y - 1; te >= 0; te--) {
                var ce = (I.words[L.length + te] | 0) * 67108864 + (I.words[L.length + te - 1] | 0);
                for (ce = Math.min(ce / K | 0, 67108863),
                I._ishlnsubmul(L, ce, te); I.negative !== 0; )
                    ce--,
                    I.negative = 0,
                    I._ishlnsubmul(L, 1, te),
                    I.isZero() || (I.negative ^= 1);
                j && (j.words[te] = ce)
            }
            return j && j.strip(),
            I.strip(),
            W !== "div" && D !== 0 && I.iushrn(D),
            {
                div: j || null,
                mod: I
            }
        }
        ,
        $.prototype.divmod = function(V, W, D) {
            if (M(!V.isZero()),
            this.isZero())
                return {
                    div: new $(0),
                    mod: new $(0)
                };
            var I, L, K;
            return this.negative !== 0 && V.negative === 0 ? (K = this.neg().divmod(V, W),
            W !== "mod" && (I = K.div.neg()),
            W !== "div" && (L = K.mod.neg(),
            D && L.negative !== 0 && L.iadd(V)),
            {
                div: I,
                mod: L
            }) : this.negative === 0 && V.negative !== 0 ? (K = this.divmod(V.neg(), W),
            W !== "mod" && (I = K.div.neg()),
            {
                div: I,
                mod: K.mod
            }) : this.negative & V.negative ? (K = this.neg().divmod(V.neg(), W),
            W !== "div" && (L = K.mod.neg(),
            D && L.negative !== 0 && L.isub(V)),
            {
                div: K.div,
                mod: L
            }) : V.length > this.length || this.cmp(V) < 0 ? {
                div: new $(0),
                mod: this
            } : V.length === 1 ? W === "div" ? {
                div: this.divn(V.words[0]),
                mod: null
            } : W === "mod" ? {
                div: null,
                mod: new $(this.modn(V.words[0]))
            } : {
                div: this.divn(V.words[0]),
                mod: new $(this.modn(V.words[0]))
            } : this._wordDiv(V, W)
        }
        ,
        $.prototype.div = function(V) {
            return this.divmod(V, "div", !1).div
        }
        ,
        $.prototype.mod = function(V) {
            return this.divmod(V, "mod", !1).mod
        }
        ,
        $.prototype.umod = function(V) {
            return this.divmod(V, "mod", !0).mod
        }
        ,
        $.prototype.divRound = function(V) {
            var W = this.divmod(V);
            if (W.mod.isZero())
                return W.div;
            var D = W.div.negative !== 0 ? W.mod.isub(V) : W.mod
              , I = V.ushrn(1)
              , L = V.andln(1)
              , K = D.cmp(I);
            return K < 0 || L === 1 && K === 0 ? W.div : W.div.negative !== 0 ? W.div.isubn(1) : W.div.iaddn(1)
        }
        ,
        $.prototype.modn = function(V) {
            M(V <= 67108863);
            for (var W = (1 << 26) % V, D = 0, I = this.length - 1; I >= 0; I--)
                D = (W * D + (this.words[I] | 0)) % V;
            return D
        }
        ,
        $.prototype.idivn = function(V) {
            M(V <= 67108863);
            for (var W = 0, D = this.length - 1; D >= 0; D--) {
                var I = (this.words[D] | 0) + W * 67108864;
                this.words[D] = I / V | 0,
                W = I % V
            }
            return this.strip()
        }
        ,
        $.prototype.divn = function(V) {
            return this.clone().idivn(V)
        }
        ,
        $.prototype.egcd = function(V) {
            M(V.negative === 0),
            M(!V.isZero());
            var W = this
              , D = V.clone();
            W.negative !== 0 ? W = W.umod(V) : W = W.clone();
            for (var I = new $(1), L = new $(0), K = new $(0), X = new $(1), Y = 0; W.isEven() && D.isEven(); )
                W.iushrn(1),
                D.iushrn(1),
                ++Y;
            for (var j = D.clone(), G = W.clone(); !W.isZero(); ) {
                for (var ne = 0, te = 1; !(W.words[0] & te) && ne < 26; ++ne,
                te <<= 1)
                    ;
                if (ne > 0)
                    for (W.iushrn(ne); ne-- > 0; )
                        (I.isOdd() || L.isOdd()) && (I.iadd(j),
                        L.isub(G)),
                        I.iushrn(1),
                        L.iushrn(1);
                for (var ce = 0, Ee = 1; !(D.words[0] & Ee) && ce < 26; ++ce,
                Ee <<= 1)
                    ;
                if (ce > 0)
                    for (D.iushrn(ce); ce-- > 0; )
                        (K.isOdd() || X.isOdd()) && (K.iadd(j),
                        X.isub(G)),
                        K.iushrn(1),
                        X.iushrn(1);
                W.cmp(D) >= 0 ? (W.isub(D),
                I.isub(K),
                L.isub(X)) : (D.isub(W),
                K.isub(I),
                X.isub(L))
            }
            return {
                a: K,
                b: X,
                gcd: D.iushln(Y)
            }
        }
        ,
        $.prototype._invmp = function(V) {
            M(V.negative === 0),
            M(!V.isZero());
            var W = this
              , D = V.clone();
            W.negative !== 0 ? W = W.umod(V) : W = W.clone();
            for (var I = new $(1), L = new $(0), K = D.clone(); W.cmpn(1) > 0 && D.cmpn(1) > 0; ) {
                for (var X = 0, Y = 1; !(W.words[0] & Y) && X < 26; ++X,
                Y <<= 1)
                    ;
                if (X > 0)
                    for (W.iushrn(X); X-- > 0; )
                        I.isOdd() && I.iadd(K),
                        I.iushrn(1);
                for (var j = 0, G = 1; !(D.words[0] & G) && j < 26; ++j,
                G <<= 1)
                    ;
                if (j > 0)
                    for (D.iushrn(j); j-- > 0; )
                        L.isOdd() && L.iadd(K),
                        L.iushrn(1);
                W.cmp(D) >= 0 ? (W.isub(D),
                I.isub(L)) : (D.isub(W),
                L.isub(I))
            }
            var ne;
            return W.cmpn(1) === 0 ? ne = I : ne = L,
            ne.cmpn(0) < 0 && ne.iadd(V),
            ne
        }
        ,
        $.prototype.gcd = function(V) {
            if (this.isZero())
                return V.abs();
            if (V.isZero())
                return this.abs();
            var W = this.clone()
              , D = V.clone();
            W.negative = 0,
            D.negative = 0;
            for (var I = 0; W.isEven() && D.isEven(); I++)
                W.iushrn(1),
                D.iushrn(1);
            do {
                for (; W.isEven(); )
                    W.iushrn(1);
                for (; D.isEven(); )
                    D.iushrn(1);
                var L = W.cmp(D);
                if (L < 0) {
                    var K = W;
                    W = D,
                    D = K
                } else if (L === 0 || D.cmpn(1) === 0)
                    break;
                W.isub(D)
            } while (!0);
            return D.iushln(I)
        }
        ,
        $.prototype.invm = function(V) {
            return this.egcd(V).a.umod(V)
        }
        ,
        $.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        $.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        $.prototype.andln = function(V) {
            return this.words[0] & V
        }
        ,
        $.prototype.bincn = function(V) {
            M(typeof V == "number");
            var W = V % 26
              , D = (V - W) / 26
              , I = 1 << W;
            if (this.length <= D)
                return this._expand(D + 1),
                this.words[D] |= I,
                this;
            for (var L = I, K = D; L !== 0 && K < this.length; K++) {
                var X = this.words[K] | 0;
                X += L,
                L = X >>> 26,
                X &= 67108863,
                this.words[K] = X
            }
            return L !== 0 && (this.words[K] = L,
            this.length++),
            this
        }
        ,
        $.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        $.prototype.cmpn = function(V) {
            var W = V < 0;
            if (this.negative !== 0 && !W)
                return -1;
            if (this.negative === 0 && W)
                return 1;
            this.strip();
            var D;
            if (this.length > 1)
                D = 1;
            else {
                W && (V = -V),
                M(V <= 67108863, "Number is too big");
                var I = this.words[0] | 0;
                D = I === V ? 0 : I < V ? -1 : 1
            }
            return this.negative !== 0 ? -D | 0 : D
        }
        ,
        $.prototype.cmp = function(V) {
            if (this.negative !== 0 && V.negative === 0)
                return -1;
            if (this.negative === 0 && V.negative !== 0)
                return 1;
            var W = this.ucmp(V);
            return this.negative !== 0 ? -W | 0 : W
        }
        ,
        $.prototype.ucmp = function(V) {
            if (this.length > V.length)
                return 1;
            if (this.length < V.length)
                return -1;
            for (var W = 0, D = this.length - 1; D >= 0; D--) {
                var I = this.words[D] | 0
                  , L = V.words[D] | 0;
                if (I !== L) {
                    I < L ? W = -1 : I > L && (W = 1);
                    break
                }
            }
            return W
        }
        ,
        $.prototype.gtn = function(V) {
            return this.cmpn(V) === 1
        }
        ,
        $.prototype.gt = function(V) {
            return this.cmp(V) === 1
        }
        ,
        $.prototype.gten = function(V) {
            return this.cmpn(V) >= 0
        }
        ,
        $.prototype.gte = function(V) {
            return this.cmp(V) >= 0
        }
        ,
        $.prototype.ltn = function(V) {
            return this.cmpn(V) === -1
        }
        ,
        $.prototype.lt = function(V) {
            return this.cmp(V) === -1
        }
        ,
        $.prototype.lten = function(V) {
            return this.cmpn(V) <= 0
        }
        ,
        $.prototype.lte = function(V) {
            return this.cmp(V) <= 0
        }
        ,
        $.prototype.eqn = function(V) {
            return this.cmpn(V) === 0
        }
        ,
        $.prototype.eq = function(V) {
            return this.cmp(V) === 0
        }
        ,
        $.red = function(V) {
            return new Ae(V)
        }
        ,
        $.prototype.toRed = function(V) {
            return M(!this.red, "Already a number in reduction context"),
            M(this.negative === 0, "red works only with positives"),
            V.convertTo(this)._forceRed(V)
        }
        ,
        $.prototype.fromRed = function() {
            return M(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        $.prototype._forceRed = function(V) {
            return this.red = V,
            this
        }
        ,
        $.prototype.forceRed = function(V) {
            return M(!this.red, "Already a number in reduction context"),
            this._forceRed(V)
        }
        ,
        $.prototype.redAdd = function(V) {
            return M(this.red, "redAdd works only with red numbers"),
            this.red.add(this, V)
        }
        ,
        $.prototype.redIAdd = function(V) {
            return M(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, V)
        }
        ,
        $.prototype.redSub = function(V) {
            return M(this.red, "redSub works only with red numbers"),
            this.red.sub(this, V)
        }
        ,
        $.prototype.redISub = function(V) {
            return M(this.red, "redISub works only with red numbers"),
            this.red.isub(this, V)
        }
        ,
        $.prototype.redShl = function(V) {
            return M(this.red, "redShl works only with red numbers"),
            this.red.shl(this, V)
        }
        ,
        $.prototype.redMul = function(V) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, V),
            this.red.mul(this, V)
        }
        ,
        $.prototype.redIMul = function(V) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, V),
            this.red.imul(this, V)
        }
        ,
        $.prototype.redSqr = function() {
            return M(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        $.prototype.redISqr = function() {
            return M(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        $.prototype.redSqrt = function() {
            return M(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        $.prototype.redInvm = function() {
            return M(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        $.prototype.redNeg = function() {
            return M(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        $.prototype.redPow = function(V) {
            return M(this.red && !V.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, V)
        }
        ;
        var le = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function de(ue, V) {
            this.name = ue,
            this.p = new $(V,16),
            this.n = this.p.bitLength(),
            this.k = new $(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        de.prototype._tmp = function() {
            var V = new $(null);
            return V.words = new Array(Math.ceil(this.n / 13)),
            V
        }
        ,
        de.prototype.ireduce = function(V) {
            var W = V, D;
            do
                this.split(W, this.tmp),
                W = this.imulK(W),
                W = W.iadd(this.tmp),
                D = W.bitLength();
            while (D > this.n);
            var I = D < this.n ? -1 : W.ucmp(this.p);
            return I === 0 ? (W.words[0] = 0,
            W.length = 1) : I > 0 ? W.isub(this.p) : W.strip(),
            W
        }
        ,
        de.prototype.split = function(V, W) {
            V.iushrn(this.n, 0, W)
        }
        ,
        de.prototype.imulK = function(V) {
            return V.imul(this.k)
        }
        ;
        function fe() {
            de.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        T(fe, de),
        fe.prototype.split = function(V, W) {
            for (var D = 4194303, I = Math.min(V.length, 9), L = 0; L < I; L++)
                W.words[L] = V.words[L];
            if (W.length = I,
            V.length <= 9) {
                V.words[0] = 0,
                V.length = 1;
                return
            }
            var K = V.words[9];
            for (W.words[W.length++] = K & D,
            L = 10; L < V.length; L++) {
                var X = V.words[L] | 0;
                V.words[L - 10] = (X & D) << 4 | K >>> 22,
                K = X
            }
            K >>>= 22,
            V.words[L - 10] = K,
            K === 0 && V.length > 10 ? V.length -= 10 : V.length -= 9
        }
        ,
        fe.prototype.imulK = function(V) {
            V.words[V.length] = 0,
            V.words[V.length + 1] = 0,
            V.length += 2;
            for (var W = 0, D = 0; D < V.length; D++) {
                var I = V.words[D] | 0;
                W += I * 977,
                V.words[D] = W & 67108863,
                W = I * 64 + (W / 67108864 | 0)
            }
            return V.words[V.length - 1] === 0 && (V.length--,
            V.words[V.length - 1] === 0 && V.length--),
            V
        }
        ;
        function pe() {
            de.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        T(pe, de);
        function ge() {
            de.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        T(ge, de);
        function we() {
            de.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        T(we, de),
        we.prototype.imulK = function(V) {
            for (var W = 0, D = 0; D < V.length; D++) {
                var I = (V.words[D] | 0) * 19 + W
                  , L = I & 67108863;
                I >>>= 26,
                V.words[D] = L,
                W = I
            }
            return W !== 0 && (V.words[V.length++] = W),
            V
        }
        ,
        $._prime = function(V) {
            if (le[V])
                return le[V];
            var W;
            if (V === "k256")
                W = new fe;
            else if (V === "p224")
                W = new pe;
            else if (V === "p192")
                W = new ge;
            else if (V === "p25519")
                W = new we;
            else
                throw new Error("Unknown prime " + V);
            return le[V] = W,
            W
        }
        ;
        function Ae(ue) {
            if (typeof ue == "string") {
                var V = $._prime(ue);
                this.m = V.p,
                this.prime = V
            } else
                M(ue.gtn(1), "modulus must be greater than 1"),
                this.m = ue,
                this.prime = null
        }
        Ae.prototype._verify1 = function(V) {
            M(V.negative === 0, "red works only with positives"),
            M(V.red, "red works only with red numbers")
        }
        ,
        Ae.prototype._verify2 = function(V, W) {
            M((V.negative | W.negative) === 0, "red works only with positives"),
            M(V.red && V.red === W.red, "red works only with red numbers")
        }
        ,
        Ae.prototype.imod = function(V) {
            return this.prime ? this.prime.ireduce(V)._forceRed(this) : V.umod(this.m)._forceRed(this)
        }
        ,
        Ae.prototype.neg = function(V) {
            return V.isZero() ? V.clone() : this.m.sub(V)._forceRed(this)
        }
        ,
        Ae.prototype.add = function(V, W) {
            this._verify2(V, W);
            var D = V.add(W);
            return D.cmp(this.m) >= 0 && D.isub(this.m),
            D._forceRed(this)
        }
        ,
        Ae.prototype.iadd = function(V, W) {
            this._verify2(V, W);
            var D = V.iadd(W);
            return D.cmp(this.m) >= 0 && D.isub(this.m),
            D
        }
        ,
        Ae.prototype.sub = function(V, W) {
            this._verify2(V, W);
            var D = V.sub(W);
            return D.cmpn(0) < 0 && D.iadd(this.m),
            D._forceRed(this)
        }
        ,
        Ae.prototype.isub = function(V, W) {
            this._verify2(V, W);
            var D = V.isub(W);
            return D.cmpn(0) < 0 && D.iadd(this.m),
            D
        }
        ,
        Ae.prototype.shl = function(V, W) {
            return this._verify1(V),
            this.imod(V.ushln(W))
        }
        ,
        Ae.prototype.imul = function(V, W) {
            return this._verify2(V, W),
            this.imod(V.imul(W))
        }
        ,
        Ae.prototype.mul = function(V, W) {
            return this._verify2(V, W),
            this.imod(V.mul(W))
        }
        ,
        Ae.prototype.isqr = function(V) {
            return this.imul(V, V.clone())
        }
        ,
        Ae.prototype.sqr = function(V) {
            return this.mul(V, V)
        }
        ,
        Ae.prototype.sqrt = function(V) {
            if (V.isZero())
                return V.clone();
            var W = this.m.andln(3);
            if (M(W % 2 === 1),
            W === 3) {
                var D = this.m.add(new $(1)).iushrn(2);
                return this.pow(V, D)
            }
            for (var I = this.m.subn(1), L = 0; !I.isZero() && I.andln(1) === 0; )
                L++,
                I.iushrn(1);
            M(!I.isZero());
            var K = new $(1).toRed(this)
              , X = K.redNeg()
              , Y = this.m.subn(1).iushrn(1)
              , j = this.m.bitLength();
            for (j = new $(2 * j * j).toRed(this); this.pow(j, Y).cmp(X) !== 0; )
                j.redIAdd(X);
            for (var G = this.pow(j, I), ne = this.pow(V, I.addn(1).iushrn(1)), te = this.pow(V, I), ce = L; te.cmp(K) !== 0; ) {
                for (var Ee = te, Re = 0; Ee.cmp(K) !== 0; Re++)
                    Ee = Ee.redSqr();
                M(Re < ce);
                var Te = this.pow(G, new $(1).iushln(ce - Re - 1));
                ne = ne.redMul(Te),
                G = Te.redSqr(),
                te = te.redMul(G),
                ce = Re
            }
            return ne
        }
        ,
        Ae.prototype.invm = function(V) {
            var W = V._invmp(this.m);
            return W.negative !== 0 ? (W.negative = 0,
            this.imod(W).redNeg()) : this.imod(W)
        }
        ,
        Ae.prototype.pow = function(V, W) {
            if (W.isZero())
                return new $(1);
            if (W.cmpn(1) === 0)
                return V.clone();
            var D = 4
              , I = new Array(1 << D);
            I[0] = new $(1).toRed(this),
            I[1] = V;
            for (var L = 2; L < I.length; L++)
                I[L] = this.mul(I[L - 1], V);
            var K = I[0]
              , X = 0
              , Y = 0
              , j = W.bitLength() % 26;
            for (j === 0 && (j = 26),
            L = W.length - 1; L >= 0; L--) {
                for (var G = W.words[L], ne = j - 1; ne >= 0; ne--) {
                    var te = G >> ne & 1;
                    if (K !== I[0] && (K = this.sqr(K)),
                    te === 0 && X === 0) {
                        Y = 0;
                        continue
                    }
                    X <<= 1,
                    X |= te,
                    Y++,
                    !(Y !== D && (L !== 0 || ne !== 0)) && (K = this.mul(K, I[X]),
                    Y = 0,
                    X = 0)
                }
                j = 26
            }
            return K
        }
        ,
        Ae.prototype.convertTo = function(V) {
            var W = V.umod(this.m);
            return W === V ? W.clone() : W
        }
        ,
        Ae.prototype.convertFrom = function(V) {
            var W = V.clone();
            return W.red = null,
            W
        }
        ,
        $.mont = function(V) {
            return new Se(V)
        }
        ;
        function Se(ue) {
            Ae.call(this, ue),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new $(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        T(Se, Ae),
        Se.prototype.convertTo = function(V) {
            return this.imod(V.ushln(this.shift))
        }
        ,
        Se.prototype.convertFrom = function(V) {
            var W = this.imod(V.mul(this.rinv));
            return W.red = null,
            W
        }
        ,
        Se.prototype.imul = function(V, W) {
            if (V.isZero() || W.isZero())
                return V.words[0] = 0,
                V.length = 1,
                V;
            var D = V.imul(W)
              , I = D.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , L = D.isub(I).iushrn(this.shift)
              , K = L;
            return L.cmp(this.m) >= 0 ? K = L.isub(this.m) : L.cmpn(0) < 0 && (K = L.iadd(this.m)),
            K._forceRed(this)
        }
        ,
        Se.prototype.mul = function(V, W) {
            if (V.isZero() || W.isZero())
                return new $(0)._forceRed(this);
            var D = V.mul(W)
              , I = D.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , L = D.isub(I).iushrn(this.shift)
              , K = L;
            return L.cmp(this.m) >= 0 ? K = L.isub(this.m) : L.cmpn(0) < 0 && (K = L.iadd(this.m)),
            K._forceRed(this)
        }
        ,
        Se.prototype.invm = function(V) {
            var W = this.imod(V._invmp(this.m).mul(this.r2));
            return W._forceRed(this)
        }
    }
    )(C, commonjsGlobal)
}
)(bn$1);
var bnExports$1 = bn$1.exports
  , bn = {
    exports: {}
};
bn.exports;
(function(C) {
    (function(S, E) {
        function M(ue, V) {
            if (!ue)
                throw new Error(V || "Assertion failed")
        }
        function T(ue, V) {
            ue.super_ = V;
            var W = function() {};
            W.prototype = V.prototype,
            ue.prototype = new W,
            ue.prototype.constructor = ue
        }
        function $(ue, V, W) {
            if ($.isBN(ue))
                return ue;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            ue !== null && ((V === "le" || V === "be") && (W = V,
            V = 10),
            this._init(ue || 0, V || 10, W || "be"))
        }
        typeof S == "object" ? S.exports = $ : E.BN = $,
        $.BN = $,
        $.wordSize = 26;
        var B;
        try {
            B = commonjsRequire("buffer").Buffer
        } catch {}
        $.isBN = function(V) {
            return V instanceof $ ? !0 : V !== null && typeof V == "object" && V.constructor.wordSize === $.wordSize && Array.isArray(V.words)
        }
        ,
        $.max = function(V, W) {
            return V.cmp(W) > 0 ? V : W
        }
        ,
        $.min = function(V, W) {
            return V.cmp(W) < 0 ? V : W
        }
        ,
        $.prototype._init = function(V, W, D) {
            if (typeof V == "number")
                return this._initNumber(V, W, D);
            if (typeof V == "object")
                return this._initArray(V, W, D);
            W === "hex" && (W = 16),
            M(W === (W | 0) && W >= 2 && W <= 36),
            V = V.toString().replace(/\s+/g, "");
            var I = 0;
            V[0] === "-" && I++,
            W === 16 ? this._parseHex(V, I) : this._parseBase(V, W, I),
            V[0] === "-" && (this.negative = 1),
            this.strip(),
            D === "le" && this._initArray(this.toArray(), W, D)
        }
        ,
        $.prototype._initNumber = function(V, W, D) {
            V < 0 && (this.negative = 1,
            V = -V),
            V < 67108864 ? (this.words = [V & 67108863],
            this.length = 1) : V < 4503599627370496 ? (this.words = [V & 67108863, V / 67108864 & 67108863],
            this.length = 2) : (M(V < 9007199254740992),
            this.words = [V & 67108863, V / 67108864 & 67108863, 1],
            this.length = 3),
            D === "le" && this._initArray(this.toArray(), W, D)
        }
        ,
        $.prototype._initArray = function(V, W, D) {
            if (M(typeof V.length == "number"),
            V.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(V.length / 3),
            this.words = new Array(this.length);
            for (var I = 0; I < this.length; I++)
                this.words[I] = 0;
            var L, K, X = 0;
            if (D === "be")
                for (I = V.length - 1,
                L = 0; I >= 0; I -= 3)
                    K = V[I] | V[I - 1] << 8 | V[I - 2] << 16,
                    this.words[L] |= K << X & 67108863,
                    this.words[L + 1] = K >>> 26 - X & 67108863,
                    X += 24,
                    X >= 26 && (X -= 26,
                    L++);
            else if (D === "le")
                for (I = 0,
                L = 0; I < V.length; I += 3)
                    K = V[I] | V[I + 1] << 8 | V[I + 2] << 16,
                    this.words[L] |= K << X & 67108863,
                    this.words[L + 1] = K >>> 26 - X & 67108863,
                    X += 24,
                    X >= 26 && (X -= 26,
                    L++);
            return this.strip()
        }
        ;
        function O(ue, V, W) {
            for (var D = 0, I = Math.min(ue.length, W), L = V; L < I; L++) {
                var K = ue.charCodeAt(L) - 48;
                D <<= 4,
                K >= 49 && K <= 54 ? D |= K - 49 + 10 : K >= 17 && K <= 22 ? D |= K - 17 + 10 : D |= K & 15
            }
            return D
        }
        $.prototype._parseHex = function(V, W) {
            this.length = Math.ceil((V.length - W) / 6),
            this.words = new Array(this.length);
            for (var D = 0; D < this.length; D++)
                this.words[D] = 0;
            var I, L, K = 0;
            for (D = V.length - 6,
            I = 0; D >= W; D -= 6)
                L = O(V, D, D + 6),
                this.words[I] |= L << K & 67108863,
                this.words[I + 1] |= L >>> 26 - K & 4194303,
                K += 24,
                K >= 26 && (K -= 26,
                I++);
            D + 6 !== W && (L = O(V, W, D + 6),
            this.words[I] |= L << K & 67108863,
            this.words[I + 1] |= L >>> 26 - K & 4194303),
            this.strip()
        }
        ;
        function F(ue, V, W, D) {
            for (var I = 0, L = Math.min(ue.length, W), K = V; K < L; K++) {
                var X = ue.charCodeAt(K) - 48;
                I *= D,
                X >= 49 ? I += X - 49 + 10 : X >= 17 ? I += X - 17 + 10 : I += X
            }
            return I
        }
        $.prototype._parseBase = function(V, W, D) {
            this.words = [0],
            this.length = 1;
            for (var I = 0, L = 1; L <= 67108863; L *= W)
                I++;
            I--,
            L = L / W | 0;
            for (var K = V.length - D, X = K % I, Y = Math.min(K, K - X) + D, j = 0, G = D; G < Y; G += I)
                j = F(V, G, G + I, W),
                this.imuln(L),
                this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
            if (X !== 0) {
                var ne = 1;
                for (j = F(V, G, V.length, W),
                G = 0; G < X; G++)
                    ne *= W;
                this.imuln(ne),
                this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j)
            }
        }
        ,
        $.prototype.copy = function(V) {
            V.words = new Array(this.length);
            for (var W = 0; W < this.length; W++)
                V.words[W] = this.words[W];
            V.length = this.length,
            V.negative = this.negative,
            V.red = this.red
        }
        ,
        $.prototype.clone = function() {
            var V = new $(null);
            return this.copy(V),
            V
        }
        ,
        $.prototype._expand = function(V) {
            for (; this.length < V; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        $.prototype.strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        $.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        $.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        ;
        var N = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , U = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , H = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        $.prototype.toString = function(V, W) {
            V = V || 10,
            W = W | 0 || 1;
            var D;
            if (V === 16 || V === "hex") {
                D = "";
                for (var I = 0, L = 0, K = 0; K < this.length; K++) {
                    var X = this.words[K]
                      , Y = ((X << I | L) & 16777215).toString(16);
                    L = X >>> 24 - I & 16777215,
                    L !== 0 || K !== this.length - 1 ? D = N[6 - Y.length] + Y + D : D = Y + D,
                    I += 2,
                    I >= 26 && (I -= 26,
                    K--)
                }
                for (L !== 0 && (D = L.toString(16) + D); D.length % W !== 0; )
                    D = "0" + D;
                return this.negative !== 0 && (D = "-" + D),
                D
            }
            if (V === (V | 0) && V >= 2 && V <= 36) {
                var j = U[V]
                  , G = H[V];
                D = "";
                var ne = this.clone();
                for (ne.negative = 0; !ne.isZero(); ) {
                    var te = ne.modn(G).toString(V);
                    ne = ne.idivn(G),
                    ne.isZero() ? D = te + D : D = N[j - te.length] + te + D
                }
                for (this.isZero() && (D = "0" + D); D.length % W !== 0; )
                    D = "0" + D;
                return this.negative !== 0 && (D = "-" + D),
                D
            }
            M(!1, "Base should be between 2 and 36")
        }
        ,
        $.prototype.toNumber = function() {
            var V = this.words[0];
            return this.length === 2 ? V += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? V += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && M(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -V : V
        }
        ,
        $.prototype.toJSON = function() {
            return this.toString(16)
        }
        ,
        $.prototype.toBuffer = function(V, W) {
            return M(typeof B < "u"),
            this.toArrayLike(B, V, W)
        }
        ,
        $.prototype.toArray = function(V, W) {
            return this.toArrayLike(Array, V, W)
        }
        ,
        $.prototype.toArrayLike = function(V, W, D) {
            var I = this.byteLength()
              , L = D || Math.max(1, I);
            M(I <= L, "byte array longer than desired length"),
            M(L > 0, "Requested array length <= 0"),
            this.strip();
            var K = W === "le", X = new V(L), Y, j, G = this.clone();
            if (K) {
                for (j = 0; !G.isZero(); j++)
                    Y = G.andln(255),
                    G.iushrn(8),
                    X[j] = Y;
                for (; j < L; j++)
                    X[j] = 0
            } else {
                for (j = 0; j < L - I; j++)
                    X[j] = 0;
                for (j = 0; !G.isZero(); j++)
                    Y = G.andln(255),
                    G.iushrn(8),
                    X[L - j - 1] = Y
            }
            return X
        }
        ,
        Math.clz32 ? $.prototype._countBits = function(V) {
            return 32 - Math.clz32(V)
        }
        : $.prototype._countBits = function(V) {
            var W = V
              , D = 0;
            return W >= 4096 && (D += 13,
            W >>>= 13),
            W >= 64 && (D += 7,
            W >>>= 7),
            W >= 8 && (D += 4,
            W >>>= 4),
            W >= 2 && (D += 2,
            W >>>= 2),
            D + W
        }
        ,
        $.prototype._zeroBits = function(V) {
            if (V === 0)
                return 26;
            var W = V
              , D = 0;
            return W & 8191 || (D += 13,
            W >>>= 13),
            W & 127 || (D += 7,
            W >>>= 7),
            W & 15 || (D += 4,
            W >>>= 4),
            W & 3 || (D += 2,
            W >>>= 2),
            W & 1 || D++,
            D
        }
        ,
        $.prototype.bitLength = function() {
            var V = this.words[this.length - 1]
              , W = this._countBits(V);
            return (this.length - 1) * 26 + W
        }
        ;
        function Z(ue) {
            for (var V = new Array(ue.bitLength()), W = 0; W < V.length; W++) {
                var D = W / 26 | 0
                  , I = W % 26;
                V[W] = (ue.words[D] & 1 << I) >>> I
            }
            return V
        }
        $.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var V = 0, W = 0; W < this.length; W++) {
                var D = this._zeroBits(this.words[W]);
                if (V += D,
                D !== 26)
                    break
            }
            return V
        }
        ,
        $.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        $.prototype.toTwos = function(V) {
            return this.negative !== 0 ? this.abs().inotn(V).iaddn(1) : this.clone()
        }
        ,
        $.prototype.fromTwos = function(V) {
            return this.testn(V - 1) ? this.notn(V).iaddn(1).ineg() : this.clone()
        }
        ,
        $.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        $.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        $.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        $.prototype.iuor = function(V) {
            for (; this.length < V.length; )
                this.words[this.length++] = 0;
            for (var W = 0; W < V.length; W++)
                this.words[W] = this.words[W] | V.words[W];
            return this.strip()
        }
        ,
        $.prototype.ior = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuor(V)
        }
        ,
        $.prototype.or = function(V) {
            return this.length > V.length ? this.clone().ior(V) : V.clone().ior(this)
        }
        ,
        $.prototype.uor = function(V) {
            return this.length > V.length ? this.clone().iuor(V) : V.clone().iuor(this)
        }
        ,
        $.prototype.iuand = function(V) {
            var W;
            this.length > V.length ? W = V : W = this;
            for (var D = 0; D < W.length; D++)
                this.words[D] = this.words[D] & V.words[D];
            return this.length = W.length,
            this.strip()
        }
        ,
        $.prototype.iand = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuand(V)
        }
        ,
        $.prototype.and = function(V) {
            return this.length > V.length ? this.clone().iand(V) : V.clone().iand(this)
        }
        ,
        $.prototype.uand = function(V) {
            return this.length > V.length ? this.clone().iuand(V) : V.clone().iuand(this)
        }
        ,
        $.prototype.iuxor = function(V) {
            var W, D;
            this.length > V.length ? (W = this,
            D = V) : (W = V,
            D = this);
            for (var I = 0; I < D.length; I++)
                this.words[I] = W.words[I] ^ D.words[I];
            if (this !== W)
                for (; I < W.length; I++)
                    this.words[I] = W.words[I];
            return this.length = W.length,
            this.strip()
        }
        ,
        $.prototype.ixor = function(V) {
            return M((this.negative | V.negative) === 0),
            this.iuxor(V)
        }
        ,
        $.prototype.xor = function(V) {
            return this.length > V.length ? this.clone().ixor(V) : V.clone().ixor(this)
        }
        ,
        $.prototype.uxor = function(V) {
            return this.length > V.length ? this.clone().iuxor(V) : V.clone().iuxor(this)
        }
        ,
        $.prototype.inotn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = Math.ceil(V / 26) | 0
              , D = V % 26;
            this._expand(W),
            D > 0 && W--;
            for (var I = 0; I < W; I++)
                this.words[I] = ~this.words[I] & 67108863;
            return D > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - D),
            this.strip()
        }
        ,
        $.prototype.notn = function(V) {
            return this.clone().inotn(V)
        }
        ,
        $.prototype.setn = function(V, W) {
            M(typeof V == "number" && V >= 0);
            var D = V / 26 | 0
              , I = V % 26;
            return this._expand(D + 1),
            W ? this.words[D] = this.words[D] | 1 << I : this.words[D] = this.words[D] & ~(1 << I),
            this.strip()
        }
        ,
        $.prototype.iadd = function(V) {
            var W;
            if (this.negative !== 0 && V.negative === 0)
                return this.negative = 0,
                W = this.isub(V),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && V.negative !== 0)
                return V.negative = 0,
                W = this.isub(V),
                V.negative = 1,
                W._normSign();
            var D, I;
            this.length > V.length ? (D = this,
            I = V) : (D = V,
            I = this);
            for (var L = 0, K = 0; K < I.length; K++)
                W = (D.words[K] | 0) + (I.words[K] | 0) + L,
                this.words[K] = W & 67108863,
                L = W >>> 26;
            for (; L !== 0 && K < D.length; K++)
                W = (D.words[K] | 0) + L,
                this.words[K] = W & 67108863,
                L = W >>> 26;
            if (this.length = D.length,
            L !== 0)
                this.words[this.length] = L,
                this.length++;
            else if (D !== this)
                for (; K < D.length; K++)
                    this.words[K] = D.words[K];
            return this
        }
        ,
        $.prototype.add = function(V) {
            var W;
            return V.negative !== 0 && this.negative === 0 ? (V.negative = 0,
            W = this.sub(V),
            V.negative ^= 1,
            W) : V.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            W = V.sub(this),
            this.negative = 1,
            W) : this.length > V.length ? this.clone().iadd(V) : V.clone().iadd(this)
        }
        ,
        $.prototype.isub = function(V) {
            if (V.negative !== 0) {
                V.negative = 0;
                var W = this.iadd(V);
                return V.negative = 1,
                W._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(V),
                this.negative = 1,
                this._normSign();
            var D = this.cmp(V);
            if (D === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var I, L;
            D > 0 ? (I = this,
            L = V) : (I = V,
            L = this);
            for (var K = 0, X = 0; X < L.length; X++)
                W = (I.words[X] | 0) - (L.words[X] | 0) + K,
                K = W >> 26,
                this.words[X] = W & 67108863;
            for (; K !== 0 && X < I.length; X++)
                W = (I.words[X] | 0) + K,
                K = W >> 26,
                this.words[X] = W & 67108863;
            if (K === 0 && X < I.length && I !== this)
                for (; X < I.length; X++)
                    this.words[X] = I.words[X];
            return this.length = Math.max(this.length, X),
            I !== this && (this.negative = 1),
            this.strip()
        }
        ,
        $.prototype.sub = function(V) {
            return this.clone().isub(V)
        }
        ;
        function J(ue, V, W) {
            W.negative = V.negative ^ ue.negative;
            var D = ue.length + V.length | 0;
            W.length = D,
            D = D - 1 | 0;
            var I = ue.words[0] | 0
              , L = V.words[0] | 0
              , K = I * L
              , X = K & 67108863
              , Y = K / 67108864 | 0;
            W.words[0] = X;
            for (var j = 1; j < D; j++) {
                for (var G = Y >>> 26, ne = Y & 67108863, te = Math.min(j, V.length - 1), ce = Math.max(0, j - ue.length + 1); ce <= te; ce++) {
                    var Ee = j - ce | 0;
                    I = ue.words[Ee] | 0,
                    L = V.words[ce] | 0,
                    K = I * L + ne,
                    G += K / 67108864 | 0,
                    ne = K & 67108863
                }
                W.words[j] = ne | 0,
                Y = G | 0
            }
            return Y !== 0 ? W.words[j] = Y | 0 : W.length--,
            W.strip()
        }
        var ie = function(V, W, D) {
            var I = V.words, L = W.words, K = D.words, X = 0, Y, j, G, ne = I[0] | 0, te = ne & 8191, ce = ne >>> 13, Ee = I[1] | 0, Re = Ee & 8191, Te = Ee >>> 13, xe = I[2] | 0, ve = xe & 8191, Me = xe >>> 13, Fe = I[3] | 0, be = Fe & 8191, Ce = Fe >>> 13, ze = I[4] | 0, Ge = ze & 8191, nt = ze >>> 13, bt = I[5] | 0, ct = bt & 8191, De = bt >>> 13, Ue = I[6] | 0, We = Ue & 8191, Xe = Ue >>> 13, ht = I[7] | 0, Je = ht & 8191, ot = ht >>> 13, je = I[8] | 0, $e = je & 8191, Ie = je >>> 13, He = I[9] | 0, qe = He & 8191, Ne = He >>> 13, at = L[0] | 0, Ye = at & 8191, it = at >>> 13, At = L[1] | 0, pt = At & 8191, ut = At >>> 13, Rt = L[2] | 0, yt = Rt & 8191, st = Rt >>> 13, Wt = L[3] | 0, Ct = Wt & 8191, Mt = Wt >>> 13, Kt = L[4] | 0, Pt = Kt & 8191, St = Kt >>> 13, Zt = L[5] | 0, Nt = Zt & 8191, $t = Zt >>> 13, Gt = L[6] | 0, Ot = Gt & 8191, Bt = Gt >>> 13, Yt = L[7] | 0, ye = Yt & 8191, Be = Yt >>> 13, Oe = L[8] | 0, he = Oe & 8191, Pe = Oe >>> 13, rt = L[9] | 0, Ze = rt & 8191, tt = rt >>> 13;
            D.negative = V.negative ^ W.negative,
            D.length = 19,
            Y = Math.imul(te, Ye),
            j = Math.imul(te, it),
            j = j + Math.imul(ce, Ye) | 0,
            G = Math.imul(ce, it);
            var Et = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Et >>> 26) | 0,
            Et &= 67108863,
            Y = Math.imul(Re, Ye),
            j = Math.imul(Re, it),
            j = j + Math.imul(Te, Ye) | 0,
            G = Math.imul(Te, it),
            Y = Y + Math.imul(te, pt) | 0,
            j = j + Math.imul(te, ut) | 0,
            j = j + Math.imul(ce, pt) | 0,
            G = G + Math.imul(ce, ut) | 0;
            var Tt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Tt >>> 26) | 0,
            Tt &= 67108863,
            Y = Math.imul(ve, Ye),
            j = Math.imul(ve, it),
            j = j + Math.imul(Me, Ye) | 0,
            G = Math.imul(Me, it),
            Y = Y + Math.imul(Re, pt) | 0,
            j = j + Math.imul(Re, ut) | 0,
            j = j + Math.imul(Te, pt) | 0,
            G = G + Math.imul(Te, ut) | 0,
            Y = Y + Math.imul(te, yt) | 0,
            j = j + Math.imul(te, st) | 0,
            j = j + Math.imul(ce, yt) | 0,
            G = G + Math.imul(ce, st) | 0;
            var kt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (kt >>> 26) | 0,
            kt &= 67108863,
            Y = Math.imul(be, Ye),
            j = Math.imul(be, it),
            j = j + Math.imul(Ce, Ye) | 0,
            G = Math.imul(Ce, it),
            Y = Y + Math.imul(ve, pt) | 0,
            j = j + Math.imul(ve, ut) | 0,
            j = j + Math.imul(Me, pt) | 0,
            G = G + Math.imul(Me, ut) | 0,
            Y = Y + Math.imul(Re, yt) | 0,
            j = j + Math.imul(Re, st) | 0,
            j = j + Math.imul(Te, yt) | 0,
            G = G + Math.imul(Te, st) | 0,
            Y = Y + Math.imul(te, Ct) | 0,
            j = j + Math.imul(te, Mt) | 0,
            j = j + Math.imul(ce, Ct) | 0,
            G = G + Math.imul(ce, Mt) | 0;
            var Qt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Qt >>> 26) | 0,
            Qt &= 67108863,
            Y = Math.imul(Ge, Ye),
            j = Math.imul(Ge, it),
            j = j + Math.imul(nt, Ye) | 0,
            G = Math.imul(nt, it),
            Y = Y + Math.imul(be, pt) | 0,
            j = j + Math.imul(be, ut) | 0,
            j = j + Math.imul(Ce, pt) | 0,
            G = G + Math.imul(Ce, ut) | 0,
            Y = Y + Math.imul(ve, yt) | 0,
            j = j + Math.imul(ve, st) | 0,
            j = j + Math.imul(Me, yt) | 0,
            G = G + Math.imul(Me, st) | 0,
            Y = Y + Math.imul(Re, Ct) | 0,
            j = j + Math.imul(Re, Mt) | 0,
            j = j + Math.imul(Te, Ct) | 0,
            G = G + Math.imul(Te, Mt) | 0,
            Y = Y + Math.imul(te, Pt) | 0,
            j = j + Math.imul(te, St) | 0,
            j = j + Math.imul(ce, Pt) | 0,
            G = G + Math.imul(ce, St) | 0;
            var Vt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Vt >>> 26) | 0,
            Vt &= 67108863,
            Y = Math.imul(ct, Ye),
            j = Math.imul(ct, it),
            j = j + Math.imul(De, Ye) | 0,
            G = Math.imul(De, it),
            Y = Y + Math.imul(Ge, pt) | 0,
            j = j + Math.imul(Ge, ut) | 0,
            j = j + Math.imul(nt, pt) | 0,
            G = G + Math.imul(nt, ut) | 0,
            Y = Y + Math.imul(be, yt) | 0,
            j = j + Math.imul(be, st) | 0,
            j = j + Math.imul(Ce, yt) | 0,
            G = G + Math.imul(Ce, st) | 0,
            Y = Y + Math.imul(ve, Ct) | 0,
            j = j + Math.imul(ve, Mt) | 0,
            j = j + Math.imul(Me, Ct) | 0,
            G = G + Math.imul(Me, Mt) | 0,
            Y = Y + Math.imul(Re, Pt) | 0,
            j = j + Math.imul(Re, St) | 0,
            j = j + Math.imul(Te, Pt) | 0,
            G = G + Math.imul(Te, St) | 0,
            Y = Y + Math.imul(te, Nt) | 0,
            j = j + Math.imul(te, $t) | 0,
            j = j + Math.imul(ce, Nt) | 0,
            G = G + Math.imul(ce, $t) | 0;
            var Ve = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Ve >>> 26) | 0,
            Ve &= 67108863,
            Y = Math.imul(We, Ye),
            j = Math.imul(We, it),
            j = j + Math.imul(Xe, Ye) | 0,
            G = Math.imul(Xe, it),
            Y = Y + Math.imul(ct, pt) | 0,
            j = j + Math.imul(ct, ut) | 0,
            j = j + Math.imul(De, pt) | 0,
            G = G + Math.imul(De, ut) | 0,
            Y = Y + Math.imul(Ge, yt) | 0,
            j = j + Math.imul(Ge, st) | 0,
            j = j + Math.imul(nt, yt) | 0,
            G = G + Math.imul(nt, st) | 0,
            Y = Y + Math.imul(be, Ct) | 0,
            j = j + Math.imul(be, Mt) | 0,
            j = j + Math.imul(Ce, Ct) | 0,
            G = G + Math.imul(Ce, Mt) | 0,
            Y = Y + Math.imul(ve, Pt) | 0,
            j = j + Math.imul(ve, St) | 0,
            j = j + Math.imul(Me, Pt) | 0,
            G = G + Math.imul(Me, St) | 0,
            Y = Y + Math.imul(Re, Nt) | 0,
            j = j + Math.imul(Re, $t) | 0,
            j = j + Math.imul(Te, Nt) | 0,
            G = G + Math.imul(Te, $t) | 0,
            Y = Y + Math.imul(te, Ot) | 0,
            j = j + Math.imul(te, Bt) | 0,
            j = j + Math.imul(ce, Ot) | 0,
            G = G + Math.imul(ce, Bt) | 0;
            var me = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (me >>> 26) | 0,
            me &= 67108863,
            Y = Math.imul(Je, Ye),
            j = Math.imul(Je, it),
            j = j + Math.imul(ot, Ye) | 0,
            G = Math.imul(ot, it),
            Y = Y + Math.imul(We, pt) | 0,
            j = j + Math.imul(We, ut) | 0,
            j = j + Math.imul(Xe, pt) | 0,
            G = G + Math.imul(Xe, ut) | 0,
            Y = Y + Math.imul(ct, yt) | 0,
            j = j + Math.imul(ct, st) | 0,
            j = j + Math.imul(De, yt) | 0,
            G = G + Math.imul(De, st) | 0,
            Y = Y + Math.imul(Ge, Ct) | 0,
            j = j + Math.imul(Ge, Mt) | 0,
            j = j + Math.imul(nt, Ct) | 0,
            G = G + Math.imul(nt, Mt) | 0,
            Y = Y + Math.imul(be, Pt) | 0,
            j = j + Math.imul(be, St) | 0,
            j = j + Math.imul(Ce, Pt) | 0,
            G = G + Math.imul(Ce, St) | 0,
            Y = Y + Math.imul(ve, Nt) | 0,
            j = j + Math.imul(ve, $t) | 0,
            j = j + Math.imul(Me, Nt) | 0,
            G = G + Math.imul(Me, $t) | 0,
            Y = Y + Math.imul(Re, Ot) | 0,
            j = j + Math.imul(Re, Bt) | 0,
            j = j + Math.imul(Te, Ot) | 0,
            G = G + Math.imul(Te, Bt) | 0,
            Y = Y + Math.imul(te, ye) | 0,
            j = j + Math.imul(te, Be) | 0,
            j = j + Math.imul(ce, ye) | 0,
            G = G + Math.imul(ce, Be) | 0;
            var ke = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (ke >>> 26) | 0,
            ke &= 67108863,
            Y = Math.imul($e, Ye),
            j = Math.imul($e, it),
            j = j + Math.imul(Ie, Ye) | 0,
            G = Math.imul(Ie, it),
            Y = Y + Math.imul(Je, pt) | 0,
            j = j + Math.imul(Je, ut) | 0,
            j = j + Math.imul(ot, pt) | 0,
            G = G + Math.imul(ot, ut) | 0,
            Y = Y + Math.imul(We, yt) | 0,
            j = j + Math.imul(We, st) | 0,
            j = j + Math.imul(Xe, yt) | 0,
            G = G + Math.imul(Xe, st) | 0,
            Y = Y + Math.imul(ct, Ct) | 0,
            j = j + Math.imul(ct, Mt) | 0,
            j = j + Math.imul(De, Ct) | 0,
            G = G + Math.imul(De, Mt) | 0,
            Y = Y + Math.imul(Ge, Pt) | 0,
            j = j + Math.imul(Ge, St) | 0,
            j = j + Math.imul(nt, Pt) | 0,
            G = G + Math.imul(nt, St) | 0,
            Y = Y + Math.imul(be, Nt) | 0,
            j = j + Math.imul(be, $t) | 0,
            j = j + Math.imul(Ce, Nt) | 0,
            G = G + Math.imul(Ce, $t) | 0,
            Y = Y + Math.imul(ve, Ot) | 0,
            j = j + Math.imul(ve, Bt) | 0,
            j = j + Math.imul(Me, Ot) | 0,
            G = G + Math.imul(Me, Bt) | 0,
            Y = Y + Math.imul(Re, ye) | 0,
            j = j + Math.imul(Re, Be) | 0,
            j = j + Math.imul(Te, ye) | 0,
            G = G + Math.imul(Te, Be) | 0,
            Y = Y + Math.imul(te, he) | 0,
            j = j + Math.imul(te, Pe) | 0,
            j = j + Math.imul(ce, he) | 0,
            G = G + Math.imul(ce, Pe) | 0;
            var Le = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Le >>> 26) | 0,
            Le &= 67108863,
            Y = Math.imul(qe, Ye),
            j = Math.imul(qe, it),
            j = j + Math.imul(Ne, Ye) | 0,
            G = Math.imul(Ne, it),
            Y = Y + Math.imul($e, pt) | 0,
            j = j + Math.imul($e, ut) | 0,
            j = j + Math.imul(Ie, pt) | 0,
            G = G + Math.imul(Ie, ut) | 0,
            Y = Y + Math.imul(Je, yt) | 0,
            j = j + Math.imul(Je, st) | 0,
            j = j + Math.imul(ot, yt) | 0,
            G = G + Math.imul(ot, st) | 0,
            Y = Y + Math.imul(We, Ct) | 0,
            j = j + Math.imul(We, Mt) | 0,
            j = j + Math.imul(Xe, Ct) | 0,
            G = G + Math.imul(Xe, Mt) | 0,
            Y = Y + Math.imul(ct, Pt) | 0,
            j = j + Math.imul(ct, St) | 0,
            j = j + Math.imul(De, Pt) | 0,
            G = G + Math.imul(De, St) | 0,
            Y = Y + Math.imul(Ge, Nt) | 0,
            j = j + Math.imul(Ge, $t) | 0,
            j = j + Math.imul(nt, Nt) | 0,
            G = G + Math.imul(nt, $t) | 0,
            Y = Y + Math.imul(be, Ot) | 0,
            j = j + Math.imul(be, Bt) | 0,
            j = j + Math.imul(Ce, Ot) | 0,
            G = G + Math.imul(Ce, Bt) | 0,
            Y = Y + Math.imul(ve, ye) | 0,
            j = j + Math.imul(ve, Be) | 0,
            j = j + Math.imul(Me, ye) | 0,
            G = G + Math.imul(Me, Be) | 0,
            Y = Y + Math.imul(Re, he) | 0,
            j = j + Math.imul(Re, Pe) | 0,
            j = j + Math.imul(Te, he) | 0,
            G = G + Math.imul(Te, Pe) | 0,
            Y = Y + Math.imul(te, Ze) | 0,
            j = j + Math.imul(te, tt) | 0,
            j = j + Math.imul(ce, Ze) | 0,
            G = G + Math.imul(ce, tt) | 0;
            var Qe = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Qe >>> 26) | 0,
            Qe &= 67108863,
            Y = Math.imul(qe, pt),
            j = Math.imul(qe, ut),
            j = j + Math.imul(Ne, pt) | 0,
            G = Math.imul(Ne, ut),
            Y = Y + Math.imul($e, yt) | 0,
            j = j + Math.imul($e, st) | 0,
            j = j + Math.imul(Ie, yt) | 0,
            G = G + Math.imul(Ie, st) | 0,
            Y = Y + Math.imul(Je, Ct) | 0,
            j = j + Math.imul(Je, Mt) | 0,
            j = j + Math.imul(ot, Ct) | 0,
            G = G + Math.imul(ot, Mt) | 0,
            Y = Y + Math.imul(We, Pt) | 0,
            j = j + Math.imul(We, St) | 0,
            j = j + Math.imul(Xe, Pt) | 0,
            G = G + Math.imul(Xe, St) | 0,
            Y = Y + Math.imul(ct, Nt) | 0,
            j = j + Math.imul(ct, $t) | 0,
            j = j + Math.imul(De, Nt) | 0,
            G = G + Math.imul(De, $t) | 0,
            Y = Y + Math.imul(Ge, Ot) | 0,
            j = j + Math.imul(Ge, Bt) | 0,
            j = j + Math.imul(nt, Ot) | 0,
            G = G + Math.imul(nt, Bt) | 0,
            Y = Y + Math.imul(be, ye) | 0,
            j = j + Math.imul(be, Be) | 0,
            j = j + Math.imul(Ce, ye) | 0,
            G = G + Math.imul(Ce, Be) | 0,
            Y = Y + Math.imul(ve, he) | 0,
            j = j + Math.imul(ve, Pe) | 0,
            j = j + Math.imul(Me, he) | 0,
            G = G + Math.imul(Me, Pe) | 0,
            Y = Y + Math.imul(Re, Ze) | 0,
            j = j + Math.imul(Re, tt) | 0,
            j = j + Math.imul(Te, Ze) | 0,
            G = G + Math.imul(Te, tt) | 0;
            var Ke = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Ke >>> 26) | 0,
            Ke &= 67108863,
            Y = Math.imul(qe, yt),
            j = Math.imul(qe, st),
            j = j + Math.imul(Ne, yt) | 0,
            G = Math.imul(Ne, st),
            Y = Y + Math.imul($e, Ct) | 0,
            j = j + Math.imul($e, Mt) | 0,
            j = j + Math.imul(Ie, Ct) | 0,
            G = G + Math.imul(Ie, Mt) | 0,
            Y = Y + Math.imul(Je, Pt) | 0,
            j = j + Math.imul(Je, St) | 0,
            j = j + Math.imul(ot, Pt) | 0,
            G = G + Math.imul(ot, St) | 0,
            Y = Y + Math.imul(We, Nt) | 0,
            j = j + Math.imul(We, $t) | 0,
            j = j + Math.imul(Xe, Nt) | 0,
            G = G + Math.imul(Xe, $t) | 0,
            Y = Y + Math.imul(ct, Ot) | 0,
            j = j + Math.imul(ct, Bt) | 0,
            j = j + Math.imul(De, Ot) | 0,
            G = G + Math.imul(De, Bt) | 0,
            Y = Y + Math.imul(Ge, ye) | 0,
            j = j + Math.imul(Ge, Be) | 0,
            j = j + Math.imul(nt, ye) | 0,
            G = G + Math.imul(nt, Be) | 0,
            Y = Y + Math.imul(be, he) | 0,
            j = j + Math.imul(be, Pe) | 0,
            j = j + Math.imul(Ce, he) | 0,
            G = G + Math.imul(Ce, Pe) | 0,
            Y = Y + Math.imul(ve, Ze) | 0,
            j = j + Math.imul(ve, tt) | 0,
            j = j + Math.imul(Me, Ze) | 0,
            G = G + Math.imul(Me, tt) | 0;
            var vt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (vt >>> 26) | 0,
            vt &= 67108863,
            Y = Math.imul(qe, Ct),
            j = Math.imul(qe, Mt),
            j = j + Math.imul(Ne, Ct) | 0,
            G = Math.imul(Ne, Mt),
            Y = Y + Math.imul($e, Pt) | 0,
            j = j + Math.imul($e, St) | 0,
            j = j + Math.imul(Ie, Pt) | 0,
            G = G + Math.imul(Ie, St) | 0,
            Y = Y + Math.imul(Je, Nt) | 0,
            j = j + Math.imul(Je, $t) | 0,
            j = j + Math.imul(ot, Nt) | 0,
            G = G + Math.imul(ot, $t) | 0,
            Y = Y + Math.imul(We, Ot) | 0,
            j = j + Math.imul(We, Bt) | 0,
            j = j + Math.imul(Xe, Ot) | 0,
            G = G + Math.imul(Xe, Bt) | 0,
            Y = Y + Math.imul(ct, ye) | 0,
            j = j + Math.imul(ct, Be) | 0,
            j = j + Math.imul(De, ye) | 0,
            G = G + Math.imul(De, Be) | 0,
            Y = Y + Math.imul(Ge, he) | 0,
            j = j + Math.imul(Ge, Pe) | 0,
            j = j + Math.imul(nt, he) | 0,
            G = G + Math.imul(nt, Pe) | 0,
            Y = Y + Math.imul(be, Ze) | 0,
            j = j + Math.imul(be, tt) | 0,
            j = j + Math.imul(Ce, Ze) | 0,
            G = G + Math.imul(Ce, tt) | 0;
            var dt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (dt >>> 26) | 0,
            dt &= 67108863,
            Y = Math.imul(qe, Pt),
            j = Math.imul(qe, St),
            j = j + Math.imul(Ne, Pt) | 0,
            G = Math.imul(Ne, St),
            Y = Y + Math.imul($e, Nt) | 0,
            j = j + Math.imul($e, $t) | 0,
            j = j + Math.imul(Ie, Nt) | 0,
            G = G + Math.imul(Ie, $t) | 0,
            Y = Y + Math.imul(Je, Ot) | 0,
            j = j + Math.imul(Je, Bt) | 0,
            j = j + Math.imul(ot, Ot) | 0,
            G = G + Math.imul(ot, Bt) | 0,
            Y = Y + Math.imul(We, ye) | 0,
            j = j + Math.imul(We, Be) | 0,
            j = j + Math.imul(Xe, ye) | 0,
            G = G + Math.imul(Xe, Be) | 0,
            Y = Y + Math.imul(ct, he) | 0,
            j = j + Math.imul(ct, Pe) | 0,
            j = j + Math.imul(De, he) | 0,
            G = G + Math.imul(De, Pe) | 0,
            Y = Y + Math.imul(Ge, Ze) | 0,
            j = j + Math.imul(Ge, tt) | 0,
            j = j + Math.imul(nt, Ze) | 0,
            G = G + Math.imul(nt, tt) | 0;
            var It = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (It >>> 26) | 0,
            It &= 67108863,
            Y = Math.imul(qe, Nt),
            j = Math.imul(qe, $t),
            j = j + Math.imul(Ne, Nt) | 0,
            G = Math.imul(Ne, $t),
            Y = Y + Math.imul($e, Ot) | 0,
            j = j + Math.imul($e, Bt) | 0,
            j = j + Math.imul(Ie, Ot) | 0,
            G = G + Math.imul(Ie, Bt) | 0,
            Y = Y + Math.imul(Je, ye) | 0,
            j = j + Math.imul(Je, Be) | 0,
            j = j + Math.imul(ot, ye) | 0,
            G = G + Math.imul(ot, Be) | 0,
            Y = Y + Math.imul(We, he) | 0,
            j = j + Math.imul(We, Pe) | 0,
            j = j + Math.imul(Xe, he) | 0,
            G = G + Math.imul(Xe, Pe) | 0,
            Y = Y + Math.imul(ct, Ze) | 0,
            j = j + Math.imul(ct, tt) | 0,
            j = j + Math.imul(De, Ze) | 0,
            G = G + Math.imul(De, tt) | 0;
            var xt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (xt >>> 26) | 0,
            xt &= 67108863,
            Y = Math.imul(qe, Ot),
            j = Math.imul(qe, Bt),
            j = j + Math.imul(Ne, Ot) | 0,
            G = Math.imul(Ne, Bt),
            Y = Y + Math.imul($e, ye) | 0,
            j = j + Math.imul($e, Be) | 0,
            j = j + Math.imul(Ie, ye) | 0,
            G = G + Math.imul(Ie, Be) | 0,
            Y = Y + Math.imul(Je, he) | 0,
            j = j + Math.imul(Je, Pe) | 0,
            j = j + Math.imul(ot, he) | 0,
            G = G + Math.imul(ot, Pe) | 0,
            Y = Y + Math.imul(We, Ze) | 0,
            j = j + Math.imul(We, tt) | 0,
            j = j + Math.imul(Xe, Ze) | 0,
            G = G + Math.imul(Xe, tt) | 0;
            var Dt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (Dt >>> 26) | 0,
            Dt &= 67108863,
            Y = Math.imul(qe, ye),
            j = Math.imul(qe, Be),
            j = j + Math.imul(Ne, ye) | 0,
            G = Math.imul(Ne, Be),
            Y = Y + Math.imul($e, he) | 0,
            j = j + Math.imul($e, Pe) | 0,
            j = j + Math.imul(Ie, he) | 0,
            G = G + Math.imul(Ie, Pe) | 0,
            Y = Y + Math.imul(Je, Ze) | 0,
            j = j + Math.imul(Je, tt) | 0,
            j = j + Math.imul(ot, Ze) | 0,
            G = G + Math.imul(ot, tt) | 0;
            var qt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (qt >>> 26) | 0,
            qt &= 67108863,
            Y = Math.imul(qe, he),
            j = Math.imul(qe, Pe),
            j = j + Math.imul(Ne, he) | 0,
            G = Math.imul(Ne, Pe),
            Y = Y + Math.imul($e, Ze) | 0,
            j = j + Math.imul($e, tt) | 0,
            j = j + Math.imul(Ie, Ze) | 0,
            G = G + Math.imul(Ie, tt) | 0;
            var zt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            X = (G + (j >>> 13) | 0) + (zt >>> 26) | 0,
            zt &= 67108863,
            Y = Math.imul(qe, Ze),
            j = Math.imul(qe, tt),
            j = j + Math.imul(Ne, Ze) | 0,
            G = Math.imul(Ne, tt);
            var mt = (X + Y | 0) + ((j & 8191) << 13) | 0;
            return X = (G + (j >>> 13) | 0) + (mt >>> 26) | 0,
            mt &= 67108863,
            K[0] = Et,
            K[1] = Tt,
            K[2] = kt,
            K[3] = Qt,
            K[4] = Vt,
            K[5] = Ve,
            K[6] = me,
            K[7] = ke,
            K[8] = Le,
            K[9] = Qe,
            K[10] = Ke,
            K[11] = vt,
            K[12] = dt,
            K[13] = It,
            K[14] = xt,
            K[15] = Dt,
            K[16] = qt,
            K[17] = zt,
            K[18] = mt,
            X !== 0 && (K[19] = X,
            D.length++),
            D
        };
        Math.imul || (ie = J);
        function oe(ue, V, W) {
            W.negative = V.negative ^ ue.negative,
            W.length = ue.length + V.length;
            for (var D = 0, I = 0, L = 0; L < W.length - 1; L++) {
                var K = I;
                I = 0;
                for (var X = D & 67108863, Y = Math.min(L, V.length - 1), j = Math.max(0, L - ue.length + 1); j <= Y; j++) {
                    var G = L - j
                      , ne = ue.words[G] | 0
                      , te = V.words[j] | 0
                      , ce = ne * te
                      , Ee = ce & 67108863;
                    K = K + (ce / 67108864 | 0) | 0,
                    Ee = Ee + X | 0,
                    X = Ee & 67108863,
                    K = K + (Ee >>> 26) | 0,
                    I += K >>> 26,
                    K &= 67108863
                }
                W.words[L] = X,
                D = K,
                K = I
            }
            return D !== 0 ? W.words[L] = D : W.length--,
            W.strip()
        }
        function ae(ue, V, W) {
            var D = new se;
            return D.mulp(ue, V, W)
        }
        $.prototype.mulTo = function(V, W) {
            var D, I = this.length + V.length;
            return this.length === 10 && V.length === 10 ? D = ie(this, V, W) : I < 63 ? D = J(this, V, W) : I < 1024 ? D = oe(this, V, W) : D = ae(this, V, W),
            D
        }
        ;
        function se(ue, V) {
            this.x = ue,
            this.y = V
        }
        se.prototype.makeRBT = function(V) {
            for (var W = new Array(V), D = $.prototype._countBits(V) - 1, I = 0; I < V; I++)
                W[I] = this.revBin(I, D, V);
            return W
        }
        ,
        se.prototype.revBin = function(V, W, D) {
            if (V === 0 || V === D - 1)
                return V;
            for (var I = 0, L = 0; L < W; L++)
                I |= (V & 1) << W - L - 1,
                V >>= 1;
            return I
        }
        ,
        se.prototype.permute = function(V, W, D, I, L, K) {
            for (var X = 0; X < K; X++)
                I[X] = W[V[X]],
                L[X] = D[V[X]]
        }
        ,
        se.prototype.transform = function(V, W, D, I, L, K) {
            this.permute(K, V, W, D, I, L);
            for (var X = 1; X < L; X <<= 1)
                for (var Y = X << 1, j = Math.cos(2 * Math.PI / Y), G = Math.sin(2 * Math.PI / Y), ne = 0; ne < L; ne += Y)
                    for (var te = j, ce = G, Ee = 0; Ee < X; Ee++) {
                        var Re = D[ne + Ee]
                          , Te = I[ne + Ee]
                          , xe = D[ne + Ee + X]
                          , ve = I[ne + Ee + X]
                          , Me = te * xe - ce * ve;
                        ve = te * ve + ce * xe,
                        xe = Me,
                        D[ne + Ee] = Re + xe,
                        I[ne + Ee] = Te + ve,
                        D[ne + Ee + X] = Re - xe,
                        I[ne + Ee + X] = Te - ve,
                        Ee !== Y && (Me = j * te - G * ce,
                        ce = j * ce + G * te,
                        te = Me)
                    }
        }
        ,
        se.prototype.guessLen13b = function(V, W) {
            var D = Math.max(W, V) | 1
              , I = D & 1
              , L = 0;
            for (D = D / 2 | 0; D; D = D >>> 1)
                L++;
            return 1 << L + 1 + I
        }
        ,
        se.prototype.conjugate = function(V, W, D) {
            if (!(D <= 1))
                for (var I = 0; I < D / 2; I++) {
                    var L = V[I];
                    V[I] = V[D - I - 1],
                    V[D - I - 1] = L,
                    L = W[I],
                    W[I] = -W[D - I - 1],
                    W[D - I - 1] = -L
                }
        }
        ,
        se.prototype.normalize13b = function(V, W) {
            for (var D = 0, I = 0; I < W / 2; I++) {
                var L = Math.round(V[2 * I + 1] / W) * 8192 + Math.round(V[2 * I] / W) + D;
                V[I] = L & 67108863,
                L < 67108864 ? D = 0 : D = L / 67108864 | 0
            }
            return V
        }
        ,
        se.prototype.convert13b = function(V, W, D, I) {
            for (var L = 0, K = 0; K < W; K++)
                L = L + (V[K] | 0),
                D[2 * K] = L & 8191,
                L = L >>> 13,
                D[2 * K + 1] = L & 8191,
                L = L >>> 13;
            for (K = 2 * W; K < I; ++K)
                D[K] = 0;
            M(L === 0),
            M((L & -8192) === 0)
        }
        ,
        se.prototype.stub = function(V) {
            for (var W = new Array(V), D = 0; D < V; D++)
                W[D] = 0;
            return W
        }
        ,
        se.prototype.mulp = function(V, W, D) {
            var I = 2 * this.guessLen13b(V.length, W.length)
              , L = this.makeRBT(I)
              , K = this.stub(I)
              , X = new Array(I)
              , Y = new Array(I)
              , j = new Array(I)
              , G = new Array(I)
              , ne = new Array(I)
              , te = new Array(I)
              , ce = D.words;
            ce.length = I,
            this.convert13b(V.words, V.length, X, I),
            this.convert13b(W.words, W.length, G, I),
            this.transform(X, K, Y, j, I, L),
            this.transform(G, K, ne, te, I, L);
            for (var Ee = 0; Ee < I; Ee++) {
                var Re = Y[Ee] * ne[Ee] - j[Ee] * te[Ee];
                j[Ee] = Y[Ee] * te[Ee] + j[Ee] * ne[Ee],
                Y[Ee] = Re
            }
            return this.conjugate(Y, j, I),
            this.transform(Y, j, ce, K, I, L),
            this.conjugate(ce, K, I),
            this.normalize13b(ce, I),
            D.negative = V.negative ^ W.negative,
            D.length = V.length + W.length,
            D.strip()
        }
        ,
        $.prototype.mul = function(V) {
            var W = new $(null);
            return W.words = new Array(this.length + V.length),
            this.mulTo(V, W)
        }
        ,
        $.prototype.mulf = function(V) {
            var W = new $(null);
            return W.words = new Array(this.length + V.length),
            ae(this, V, W)
        }
        ,
        $.prototype.imul = function(V) {
            return this.clone().mulTo(V, this)
        }
        ,
        $.prototype.imuln = function(V) {
            M(typeof V == "number"),
            M(V < 67108864);
            for (var W = 0, D = 0; D < this.length; D++) {
                var I = (this.words[D] | 0) * V
                  , L = (I & 67108863) + (W & 67108863);
                W >>= 26,
                W += I / 67108864 | 0,
                W += L >>> 26,
                this.words[D] = L & 67108863
            }
            return W !== 0 && (this.words[D] = W,
            this.length++),
            this
        }
        ,
        $.prototype.muln = function(V) {
            return this.clone().imuln(V)
        }
        ,
        $.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        $.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        $.prototype.pow = function(V) {
            var W = Z(V);
            if (W.length === 0)
                return new $(1);
            for (var D = this, I = 0; I < W.length && W[I] === 0; I++,
            D = D.sqr())
                ;
            if (++I < W.length)
                for (var L = D.sqr(); I < W.length; I++,
                L = L.sqr())
                    W[I] !== 0 && (D = D.mul(L));
            return D
        }
        ,
        $.prototype.iushln = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26, D = (V - W) / 26, I = 67108863 >>> 26 - W << 26 - W, L;
            if (W !== 0) {
                var K = 0;
                for (L = 0; L < this.length; L++) {
                    var X = this.words[L] & I
                      , Y = (this.words[L] | 0) - X << W;
                    this.words[L] = Y | K,
                    K = X >>> 26 - W
                }
                K && (this.words[L] = K,
                this.length++)
            }
            if (D !== 0) {
                for (L = this.length - 1; L >= 0; L--)
                    this.words[L + D] = this.words[L];
                for (L = 0; L < D; L++)
                    this.words[L] = 0;
                this.length += D
            }
            return this.strip()
        }
        ,
        $.prototype.ishln = function(V) {
            return M(this.negative === 0),
            this.iushln(V)
        }
        ,
        $.prototype.iushrn = function(V, W, D) {
            M(typeof V == "number" && V >= 0);
            var I;
            W ? I = (W - W % 26) / 26 : I = 0;
            var L = V % 26
              , K = Math.min((V - L) / 26, this.length)
              , X = 67108863 ^ 67108863 >>> L << L
              , Y = D;
            if (I -= K,
            I = Math.max(0, I),
            Y) {
                for (var j = 0; j < K; j++)
                    Y.words[j] = this.words[j];
                Y.length = K
            }
            if (K !== 0)
                if (this.length > K)
                    for (this.length -= K,
                    j = 0; j < this.length; j++)
                        this.words[j] = this.words[j + K];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var G = 0;
            for (j = this.length - 1; j >= 0 && (G !== 0 || j >= I); j--) {
                var ne = this.words[j] | 0;
                this.words[j] = G << 26 - L | ne >>> L,
                G = ne & X
            }
            return Y && G !== 0 && (Y.words[Y.length++] = G),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this.strip()
        }
        ,
        $.prototype.ishrn = function(V, W, D) {
            return M(this.negative === 0),
            this.iushrn(V, W, D)
        }
        ,
        $.prototype.shln = function(V) {
            return this.clone().ishln(V)
        }
        ,
        $.prototype.ushln = function(V) {
            return this.clone().iushln(V)
        }
        ,
        $.prototype.shrn = function(V) {
            return this.clone().ishrn(V)
        }
        ,
        $.prototype.ushrn = function(V) {
            return this.clone().iushrn(V)
        }
        ,
        $.prototype.testn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26
              , D = (V - W) / 26
              , I = 1 << W;
            if (this.length <= D)
                return !1;
            var L = this.words[D];
            return !!(L & I)
        }
        ,
        $.prototype.imaskn = function(V) {
            M(typeof V == "number" && V >= 0);
            var W = V % 26
              , D = (V - W) / 26;
            if (M(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= D)
                return this;
            if (W !== 0 && D++,
            this.length = Math.min(D, this.length),
            W !== 0) {
                var I = 67108863 ^ 67108863 >>> W << W;
                this.words[this.length - 1] &= I
            }
            return this.strip()
        }
        ,
        $.prototype.maskn = function(V) {
            return this.clone().imaskn(V)
        }
        ,
        $.prototype.iaddn = function(V) {
            return M(typeof V == "number"),
            M(V < 67108864),
            V < 0 ? this.isubn(-V) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < V ? (this.words[0] = V - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(V),
            this.negative = 1,
            this) : this._iaddn(V)
        }
        ,
        $.prototype._iaddn = function(V) {
            this.words[0] += V;
            for (var W = 0; W < this.length && this.words[W] >= 67108864; W++)
                this.words[W] -= 67108864,
                W === this.length - 1 ? this.words[W + 1] = 1 : this.words[W + 1]++;
            return this.length = Math.max(this.length, W + 1),
            this
        }
        ,
        $.prototype.isubn = function(V) {
            if (M(typeof V == "number"),
            M(V < 67108864),
            V < 0)
                return this.iaddn(-V);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(V),
                this.negative = 1,
                this;
            if (this.words[0] -= V,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var W = 0; W < this.length && this.words[W] < 0; W++)
                    this.words[W] += 67108864,
                    this.words[W + 1] -= 1;
            return this.strip()
        }
        ,
        $.prototype.addn = function(V) {
            return this.clone().iaddn(V)
        }
        ,
        $.prototype.subn = function(V) {
            return this.clone().isubn(V)
        }
        ,
        $.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        $.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        $.prototype._ishlnsubmul = function(V, W, D) {
            var I = V.length + D, L;
            this._expand(I);
            var K, X = 0;
            for (L = 0; L < V.length; L++) {
                K = (this.words[L + D] | 0) + X;
                var Y = (V.words[L] | 0) * W;
                K -= Y & 67108863,
                X = (K >> 26) - (Y / 67108864 | 0),
                this.words[L + D] = K & 67108863
            }
            for (; L < this.length - D; L++)
                K = (this.words[L + D] | 0) + X,
                X = K >> 26,
                this.words[L + D] = K & 67108863;
            if (X === 0)
                return this.strip();
            for (M(X === -1),
            X = 0,
            L = 0; L < this.length; L++)
                K = -(this.words[L] | 0) + X,
                X = K >> 26,
                this.words[L] = K & 67108863;
            return this.negative = 1,
            this.strip()
        }
        ,
        $.prototype._wordDiv = function(V, W) {
            var D = this.length - V.length
              , I = this.clone()
              , L = V
              , K = L.words[L.length - 1] | 0
              , X = this._countBits(K);
            D = 26 - X,
            D !== 0 && (L = L.ushln(D),
            I.iushln(D),
            K = L.words[L.length - 1] | 0);
            var Y = I.length - L.length, j;
            if (W !== "mod") {
                j = new $(null),
                j.length = Y + 1,
                j.words = new Array(j.length);
                for (var G = 0; G < j.length; G++)
                    j.words[G] = 0
            }
            var ne = I.clone()._ishlnsubmul(L, 1, Y);
            ne.negative === 0 && (I = ne,
            j && (j.words[Y] = 1));
            for (var te = Y - 1; te >= 0; te--) {
                var ce = (I.words[L.length + te] | 0) * 67108864 + (I.words[L.length + te - 1] | 0);
                for (ce = Math.min(ce / K | 0, 67108863),
                I._ishlnsubmul(L, ce, te); I.negative !== 0; )
                    ce--,
                    I.negative = 0,
                    I._ishlnsubmul(L, 1, te),
                    I.isZero() || (I.negative ^= 1);
                j && (j.words[te] = ce)
            }
            return j && j.strip(),
            I.strip(),
            W !== "div" && D !== 0 && I.iushrn(D),
            {
                div: j || null,
                mod: I
            }
        }
        ,
        $.prototype.divmod = function(V, W, D) {
            if (M(!V.isZero()),
            this.isZero())
                return {
                    div: new $(0),
                    mod: new $(0)
                };
            var I, L, K;
            return this.negative !== 0 && V.negative === 0 ? (K = this.neg().divmod(V, W),
            W !== "mod" && (I = K.div.neg()),
            W !== "div" && (L = K.mod.neg(),
            D && L.negative !== 0 && L.iadd(V)),
            {
                div: I,
                mod: L
            }) : this.negative === 0 && V.negative !== 0 ? (K = this.divmod(V.neg(), W),
            W !== "mod" && (I = K.div.neg()),
            {
                div: I,
                mod: K.mod
            }) : this.negative & V.negative ? (K = this.neg().divmod(V.neg(), W),
            W !== "div" && (L = K.mod.neg(),
            D && L.negative !== 0 && L.isub(V)),
            {
                div: K.div,
                mod: L
            }) : V.length > this.length || this.cmp(V) < 0 ? {
                div: new $(0),
                mod: this
            } : V.length === 1 ? W === "div" ? {
                div: this.divn(V.words[0]),
                mod: null
            } : W === "mod" ? {
                div: null,
                mod: new $(this.modn(V.words[0]))
            } : {
                div: this.divn(V.words[0]),
                mod: new $(this.modn(V.words[0]))
            } : this._wordDiv(V, W)
        }
        ,
        $.prototype.div = function(V) {
            return this.divmod(V, "div", !1).div
        }
        ,
        $.prototype.mod = function(V) {
            return this.divmod(V, "mod", !1).mod
        }
        ,
        $.prototype.umod = function(V) {
            return this.divmod(V, "mod", !0).mod
        }
        ,
        $.prototype.divRound = function(V) {
            var W = this.divmod(V);
            if (W.mod.isZero())
                return W.div;
            var D = W.div.negative !== 0 ? W.mod.isub(V) : W.mod
              , I = V.ushrn(1)
              , L = V.andln(1)
              , K = D.cmp(I);
            return K < 0 || L === 1 && K === 0 ? W.div : W.div.negative !== 0 ? W.div.isubn(1) : W.div.iaddn(1)
        }
        ,
        $.prototype.modn = function(V) {
            M(V <= 67108863);
            for (var W = (1 << 26) % V, D = 0, I = this.length - 1; I >= 0; I--)
                D = (W * D + (this.words[I] | 0)) % V;
            return D
        }
        ,
        $.prototype.idivn = function(V) {
            M(V <= 67108863);
            for (var W = 0, D = this.length - 1; D >= 0; D--) {
                var I = (this.words[D] | 0) + W * 67108864;
                this.words[D] = I / V | 0,
                W = I % V
            }
            return this.strip()
        }
        ,
        $.prototype.divn = function(V) {
            return this.clone().idivn(V)
        }
        ,
        $.prototype.egcd = function(V) {
            M(V.negative === 0),
            M(!V.isZero());
            var W = this
              , D = V.clone();
            W.negative !== 0 ? W = W.umod(V) : W = W.clone();
            for (var I = new $(1), L = new $(0), K = new $(0), X = new $(1), Y = 0; W.isEven() && D.isEven(); )
                W.iushrn(1),
                D.iushrn(1),
                ++Y;
            for (var j = D.clone(), G = W.clone(); !W.isZero(); ) {
                for (var ne = 0, te = 1; !(W.words[0] & te) && ne < 26; ++ne,
                te <<= 1)
                    ;
                if (ne > 0)
                    for (W.iushrn(ne); ne-- > 0; )
                        (I.isOdd() || L.isOdd()) && (I.iadd(j),
                        L.isub(G)),
                        I.iushrn(1),
                        L.iushrn(1);
                for (var ce = 0, Ee = 1; !(D.words[0] & Ee) && ce < 26; ++ce,
                Ee <<= 1)
                    ;
                if (ce > 0)
                    for (D.iushrn(ce); ce-- > 0; )
                        (K.isOdd() || X.isOdd()) && (K.iadd(j),
                        X.isub(G)),
                        K.iushrn(1),
                        X.iushrn(1);
                W.cmp(D) >= 0 ? (W.isub(D),
                I.isub(K),
                L.isub(X)) : (D.isub(W),
                K.isub(I),
                X.isub(L))
            }
            return {
                a: K,
                b: X,
                gcd: D.iushln(Y)
            }
        }
        ,
        $.prototype._invmp = function(V) {
            M(V.negative === 0),
            M(!V.isZero());
            var W = this
              , D = V.clone();
            W.negative !== 0 ? W = W.umod(V) : W = W.clone();
            for (var I = new $(1), L = new $(0), K = D.clone(); W.cmpn(1) > 0 && D.cmpn(1) > 0; ) {
                for (var X = 0, Y = 1; !(W.words[0] & Y) && X < 26; ++X,
                Y <<= 1)
                    ;
                if (X > 0)
                    for (W.iushrn(X); X-- > 0; )
                        I.isOdd() && I.iadd(K),
                        I.iushrn(1);
                for (var j = 0, G = 1; !(D.words[0] & G) && j < 26; ++j,
                G <<= 1)
                    ;
                if (j > 0)
                    for (D.iushrn(j); j-- > 0; )
                        L.isOdd() && L.iadd(K),
                        L.iushrn(1);
                W.cmp(D) >= 0 ? (W.isub(D),
                I.isub(L)) : (D.isub(W),
                L.isub(I))
            }
            var ne;
            return W.cmpn(1) === 0 ? ne = I : ne = L,
            ne.cmpn(0) < 0 && ne.iadd(V),
            ne
        }
        ,
        $.prototype.gcd = function(V) {
            if (this.isZero())
                return V.abs();
            if (V.isZero())
                return this.abs();
            var W = this.clone()
              , D = V.clone();
            W.negative = 0,
            D.negative = 0;
            for (var I = 0; W.isEven() && D.isEven(); I++)
                W.iushrn(1),
                D.iushrn(1);
            do {
                for (; W.isEven(); )
                    W.iushrn(1);
                for (; D.isEven(); )
                    D.iushrn(1);
                var L = W.cmp(D);
                if (L < 0) {
                    var K = W;
                    W = D,
                    D = K
                } else if (L === 0 || D.cmpn(1) === 0)
                    break;
                W.isub(D)
            } while (!0);
            return D.iushln(I)
        }
        ,
        $.prototype.invm = function(V) {
            return this.egcd(V).a.umod(V)
        }
        ,
        $.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        $.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        $.prototype.andln = function(V) {
            return this.words[0] & V
        }
        ,
        $.prototype.bincn = function(V) {
            M(typeof V == "number");
            var W = V % 26
              , D = (V - W) / 26
              , I = 1 << W;
            if (this.length <= D)
                return this._expand(D + 1),
                this.words[D] |= I,
                this;
            for (var L = I, K = D; L !== 0 && K < this.length; K++) {
                var X = this.words[K] | 0;
                X += L,
                L = X >>> 26,
                X &= 67108863,
                this.words[K] = X
            }
            return L !== 0 && (this.words[K] = L,
            this.length++),
            this
        }
        ,
        $.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        $.prototype.cmpn = function(V) {
            var W = V < 0;
            if (this.negative !== 0 && !W)
                return -1;
            if (this.negative === 0 && W)
                return 1;
            this.strip();
            var D;
            if (this.length > 1)
                D = 1;
            else {
                W && (V = -V),
                M(V <= 67108863, "Number is too big");
                var I = this.words[0] | 0;
                D = I === V ? 0 : I < V ? -1 : 1
            }
            return this.negative !== 0 ? -D | 0 : D
        }
        ,
        $.prototype.cmp = function(V) {
            if (this.negative !== 0 && V.negative === 0)
                return -1;
            if (this.negative === 0 && V.negative !== 0)
                return 1;
            var W = this.ucmp(V);
            return this.negative !== 0 ? -W | 0 : W
        }
        ,
        $.prototype.ucmp = function(V) {
            if (this.length > V.length)
                return 1;
            if (this.length < V.length)
                return -1;
            for (var W = 0, D = this.length - 1; D >= 0; D--) {
                var I = this.words[D] | 0
                  , L = V.words[D] | 0;
                if (I !== L) {
                    I < L ? W = -1 : I > L && (W = 1);
                    break
                }
            }
            return W
        }
        ,
        $.prototype.gtn = function(V) {
            return this.cmpn(V) === 1
        }
        ,
        $.prototype.gt = function(V) {
            return this.cmp(V) === 1
        }
        ,
        $.prototype.gten = function(V) {
            return this.cmpn(V) >= 0
        }
        ,
        $.prototype.gte = function(V) {
            return this.cmp(V) >= 0
        }
        ,
        $.prototype.ltn = function(V) {
            return this.cmpn(V) === -1
        }
        ,
        $.prototype.lt = function(V) {
            return this.cmp(V) === -1
        }
        ,
        $.prototype.lten = function(V) {
            return this.cmpn(V) <= 0
        }
        ,
        $.prototype.lte = function(V) {
            return this.cmp(V) <= 0
        }
        ,
        $.prototype.eqn = function(V) {
            return this.cmpn(V) === 0
        }
        ,
        $.prototype.eq = function(V) {
            return this.cmp(V) === 0
        }
        ,
        $.red = function(V) {
            return new Ae(V)
        }
        ,
        $.prototype.toRed = function(V) {
            return M(!this.red, "Already a number in reduction context"),
            M(this.negative === 0, "red works only with positives"),
            V.convertTo(this)._forceRed(V)
        }
        ,
        $.prototype.fromRed = function() {
            return M(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        $.prototype._forceRed = function(V) {
            return this.red = V,
            this
        }
        ,
        $.prototype.forceRed = function(V) {
            return M(!this.red, "Already a number in reduction context"),
            this._forceRed(V)
        }
        ,
        $.prototype.redAdd = function(V) {
            return M(this.red, "redAdd works only with red numbers"),
            this.red.add(this, V)
        }
        ,
        $.prototype.redIAdd = function(V) {
            return M(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, V)
        }
        ,
        $.prototype.redSub = function(V) {
            return M(this.red, "redSub works only with red numbers"),
            this.red.sub(this, V)
        }
        ,
        $.prototype.redISub = function(V) {
            return M(this.red, "redISub works only with red numbers"),
            this.red.isub(this, V)
        }
        ,
        $.prototype.redShl = function(V) {
            return M(this.red, "redShl works only with red numbers"),
            this.red.shl(this, V)
        }
        ,
        $.prototype.redMul = function(V) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, V),
            this.red.mul(this, V)
        }
        ,
        $.prototype.redIMul = function(V) {
            return M(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, V),
            this.red.imul(this, V)
        }
        ,
        $.prototype.redSqr = function() {
            return M(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        $.prototype.redISqr = function() {
            return M(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        $.prototype.redSqrt = function() {
            return M(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        $.prototype.redInvm = function() {
            return M(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        $.prototype.redNeg = function() {
            return M(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        $.prototype.redPow = function(V) {
            return M(this.red && !V.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, V)
        }
        ;
        var le = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function de(ue, V) {
            this.name = ue,
            this.p = new $(V,16),
            this.n = this.p.bitLength(),
            this.k = new $(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        de.prototype._tmp = function() {
            var V = new $(null);
            return V.words = new Array(Math.ceil(this.n / 13)),
            V
        }
        ,
        de.prototype.ireduce = function(V) {
            var W = V, D;
            do
                this.split(W, this.tmp),
                W = this.imulK(W),
                W = W.iadd(this.tmp),
                D = W.bitLength();
            while (D > this.n);
            var I = D < this.n ? -1 : W.ucmp(this.p);
            return I === 0 ? (W.words[0] = 0,
            W.length = 1) : I > 0 ? W.isub(this.p) : W.strip(),
            W
        }
        ,
        de.prototype.split = function(V, W) {
            V.iushrn(this.n, 0, W)
        }
        ,
        de.prototype.imulK = function(V) {
            return V.imul(this.k)
        }
        ;
        function fe() {
            de.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        T(fe, de),
        fe.prototype.split = function(V, W) {
            for (var D = 4194303, I = Math.min(V.length, 9), L = 0; L < I; L++)
                W.words[L] = V.words[L];
            if (W.length = I,
            V.length <= 9) {
                V.words[0] = 0,
                V.length = 1;
                return
            }
            var K = V.words[9];
            for (W.words[W.length++] = K & D,
            L = 10; L < V.length; L++) {
                var X = V.words[L] | 0;
                V.words[L - 10] = (X & D) << 4 | K >>> 22,
                K = X
            }
            K >>>= 22,
            V.words[L - 10] = K,
            K === 0 && V.length > 10 ? V.length -= 10 : V.length -= 9
        }
        ,
        fe.prototype.imulK = function(V) {
            V.words[V.length] = 0,
            V.words[V.length + 1] = 0,
            V.length += 2;
            for (var W = 0, D = 0; D < V.length; D++) {
                var I = V.words[D] | 0;
                W += I * 977,
                V.words[D] = W & 67108863,
                W = I * 64 + (W / 67108864 | 0)
            }
            return V.words[V.length - 1] === 0 && (V.length--,
            V.words[V.length - 1] === 0 && V.length--),
            V
        }
        ;
        function pe() {
            de.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        T(pe, de);
        function ge() {
            de.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        T(ge, de);
        function we() {
            de.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        T(we, de),
        we.prototype.imulK = function(V) {
            for (var W = 0, D = 0; D < V.length; D++) {
                var I = (V.words[D] | 0) * 19 + W
                  , L = I & 67108863;
                I >>>= 26,
                V.words[D] = L,
                W = I
            }
            return W !== 0 && (V.words[V.length++] = W),
            V
        }
        ,
        $._prime = function(V) {
            if (le[V])
                return le[V];
            var W;
            if (V === "k256")
                W = new fe;
            else if (V === "p224")
                W = new pe;
            else if (V === "p192")
                W = new ge;
            else if (V === "p25519")
                W = new we;
            else
                throw new Error("Unknown prime " + V);
            return le[V] = W,
            W
        }
        ;
        function Ae(ue) {
            if (typeof ue == "string") {
                var V = $._prime(ue);
                this.m = V.p,
                this.prime = V
            } else
                M(ue.gtn(1), "modulus must be greater than 1"),
                this.m = ue,
                this.prime = null
        }
        Ae.prototype._verify1 = function(V) {
            M(V.negative === 0, "red works only with positives"),
            M(V.red, "red works only with red numbers")
        }
        ,
        Ae.prototype._verify2 = function(V, W) {
            M((V.negative | W.negative) === 0, "red works only with positives"),
            M(V.red && V.red === W.red, "red works only with red numbers")
        }
        ,
        Ae.prototype.imod = function(V) {
            return this.prime ? this.prime.ireduce(V)._forceRed(this) : V.umod(this.m)._forceRed(this)
        }
        ,
        Ae.prototype.neg = function(V) {
            return V.isZero() ? V.clone() : this.m.sub(V)._forceRed(this)
        }
        ,
        Ae.prototype.add = function(V, W) {
            this._verify2(V, W);
            var D = V.add(W);
            return D.cmp(this.m) >= 0 && D.isub(this.m),
            D._forceRed(this)
        }
        ,
        Ae.prototype.iadd = function(V, W) {
            this._verify2(V, W);
            var D = V.iadd(W);
            return D.cmp(this.m) >= 0 && D.isub(this.m),
            D
        }
        ,
        Ae.prototype.sub = function(V, W) {
            this._verify2(V, W);
            var D = V.sub(W);
            return D.cmpn(0) < 0 && D.iadd(this.m),
            D._forceRed(this)
        }
        ,
        Ae.prototype.isub = function(V, W) {
            this._verify2(V, W);
            var D = V.isub(W);
            return D.cmpn(0) < 0 && D.iadd(this.m),
            D
        }
        ,
        Ae.prototype.shl = function(V, W) {
            return this._verify1(V),
            this.imod(V.ushln(W))
        }
        ,
        Ae.prototype.imul = function(V, W) {
            return this._verify2(V, W),
            this.imod(V.imul(W))
        }
        ,
        Ae.prototype.mul = function(V, W) {
            return this._verify2(V, W),
            this.imod(V.mul(W))
        }
        ,
        Ae.prototype.isqr = function(V) {
            return this.imul(V, V.clone())
        }
        ,
        Ae.prototype.sqr = function(V) {
            return this.mul(V, V)
        }
        ,
        Ae.prototype.sqrt = function(V) {
            if (V.isZero())
                return V.clone();
            var W = this.m.andln(3);
            if (M(W % 2 === 1),
            W === 3) {
                var D = this.m.add(new $(1)).iushrn(2);
                return this.pow(V, D)
            }
            for (var I = this.m.subn(1), L = 0; !I.isZero() && I.andln(1) === 0; )
                L++,
                I.iushrn(1);
            M(!I.isZero());
            var K = new $(1).toRed(this)
              , X = K.redNeg()
              , Y = this.m.subn(1).iushrn(1)
              , j = this.m.bitLength();
            for (j = new $(2 * j * j).toRed(this); this.pow(j, Y).cmp(X) !== 0; )
                j.redIAdd(X);
            for (var G = this.pow(j, I), ne = this.pow(V, I.addn(1).iushrn(1)), te = this.pow(V, I), ce = L; te.cmp(K) !== 0; ) {
                for (var Ee = te, Re = 0; Ee.cmp(K) !== 0; Re++)
                    Ee = Ee.redSqr();
                M(Re < ce);
                var Te = this.pow(G, new $(1).iushln(ce - Re - 1));
                ne = ne.redMul(Te),
                G = Te.redSqr(),
                te = te.redMul(G),
                ce = Re
            }
            return ne
        }
        ,
        Ae.prototype.invm = function(V) {
            var W = V._invmp(this.m);
            return W.negative !== 0 ? (W.negative = 0,
            this.imod(W).redNeg()) : this.imod(W)
        }
        ,
        Ae.prototype.pow = function(V, W) {
            if (W.isZero())
                return new $(1);
            if (W.cmpn(1) === 0)
                return V.clone();
            var D = 4
              , I = new Array(1 << D);
            I[0] = new $(1).toRed(this),
            I[1] = V;
            for (var L = 2; L < I.length; L++)
                I[L] = this.mul(I[L - 1], V);
            var K = I[0]
              , X = 0
              , Y = 0
              , j = W.bitLength() % 26;
            for (j === 0 && (j = 26),
            L = W.length - 1; L >= 0; L--) {
                for (var G = W.words[L], ne = j - 1; ne >= 0; ne--) {
                    var te = G >> ne & 1;
                    if (K !== I[0] && (K = this.sqr(K)),
                    te === 0 && X === 0) {
                        Y = 0;
                        continue
                    }
                    X <<= 1,
                    X |= te,
                    Y++,
                    !(Y !== D && (L !== 0 || ne !== 0)) && (K = this.mul(K, I[X]),
                    Y = 0,
                    X = 0)
                }
                j = 26
            }
            return K
        }
        ,
        Ae.prototype.convertTo = function(V) {
            var W = V.umod(this.m);
            return W === V ? W.clone() : W
        }
        ,
        Ae.prototype.convertFrom = function(V) {
            var W = V.clone();
            return W.red = null,
            W
        }
        ,
        $.mont = function(V) {
            return new Se(V)
        }
        ;
        function Se(ue) {
            Ae.call(this, ue),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new $(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        T(Se, Ae),
        Se.prototype.convertTo = function(V) {
            return this.imod(V.ushln(this.shift))
        }
        ,
        Se.prototype.convertFrom = function(V) {
            var W = this.imod(V.mul(this.rinv));
            return W.red = null,
            W
        }
        ,
        Se.prototype.imul = function(V, W) {
            if (V.isZero() || W.isZero())
                return V.words[0] = 0,
                V.length = 1,
                V;
            var D = V.imul(W)
              , I = D.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , L = D.isub(I).iushrn(this.shift)
              , K = L;
            return L.cmp(this.m) >= 0 ? K = L.isub(this.m) : L.cmpn(0) < 0 && (K = L.iadd(this.m)),
            K._forceRed(this)
        }
        ,
        Se.prototype.mul = function(V, W) {
            if (V.isZero() || W.isZero())
                return new $(0)._forceRed(this);
            var D = V.mul(W)
              , I = D.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , L = D.isub(I).iushrn(this.shift)
              , K = L;
            return L.cmp(this.m) >= 0 ? K = L.isub(this.m) : L.cmpn(0) < 0 && (K = L.iadd(this.m)),
            K._forceRed(this)
        }
        ,
        Se.prototype.invm = function(V) {
            var W = this.imod(V._invmp(this.m).mul(this.r2));
            return W._forceRed(this)
        }
    }
    )(C, commonjsGlobal)
}
)(bn);
var bnExports = bn.exports
  , src$3 = function C(S) {
    if (typeof S != "string")
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof S + ", while checking isHexPrefixed.");
    return S.slice(0, 2) === "0x"
}
  , isHexPrefixed = src$3
  , src$2 = function C(S) {
    return typeof S != "string" ? S : isHexPrefixed(S) ? S.slice(2) : S
}
  , BN$l = bnExports
  , stripHexPrefix = src$2
  , src$1 = function C(S) {
    if (typeof S == "string" || typeof S == "number") {
        var E = new BN$l(1)
          , M = String(S).toLowerCase().trim()
          , T = M.substr(0, 2) === "0x" || M.substr(0, 3) === "-0x"
          , $ = stripHexPrefix(M);
        if ($.substr(0, 1) === "-" && ($ = stripHexPrefix($.slice(1)),
        E = new BN$l(-1,10)),
        $ = $ === "" ? "0" : $,
        !$.match(/^-?[0-9]+$/) && $.match(/^[0-9A-Fa-f]+$/) || $.match(/^[a-fA-F]+$/) || T === !0 && $.match(/^[0-9A-Fa-f]+$/))
            return new BN$l($,16).mul(E);
        if (($.match(/^-?[0-9]+$/) || $ === "") && T === !1)
            return new BN$l($,10).mul(E)
    } else if (typeof S == "object" && S.toString && !S.pop && !S.push && S.toString(10).match(/^-?[0-9]+$/) && (S.mul || S.dividedToIntegerBy))
        return new BN$l(S.toString(10),10);
    throw new Error("[number-to-bn] while converting number " + JSON.stringify(S) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.")
}
  , BN$k = bnExports$1
  , numberToBN = src$1
  , zero = new BN$k(0)
  , negative1 = new BN$k(-1)
  , unitMap = {
    noether: "0",
    wei: "1",
    kwei: "1000",
    Kwei: "1000",
    babbage: "1000",
    femtoether: "1000",
    mwei: "1000000",
    Mwei: "1000000",
    lovelace: "1000000",
    picoether: "1000000",
    gwei: "1000000000",
    Gwei: "1000000000",
    shannon: "1000000000",
    nanoether: "1000000000",
    nano: "1000000000",
    szabo: "1000000000000",
    microether: "1000000000000",
    micro: "1000000000000",
    finney: "1000000000000000",
    milliether: "1000000000000000",
    milli: "1000000000000000",
    ether: "1000000000000000000",
    kether: "1000000000000000000000",
    grand: "1000000000000000000000",
    mether: "1000000000000000000000000",
    gether: "1000000000000000000000000000",
    tether: "1000000000000000000000000000000"
};
function getValueOfUnit(C) {
    var S = C ? C.toLowerCase() : "ether"
      , E = unitMap[S];
    if (typeof E != "string")
        throw new Error("[ethjs-unit] the unit provided " + C + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
    return new BN$k(E,10)
}
function numberToString(C) {
    if (typeof C == "string") {
        if (!C.match(/^-?[0-9.]+$/))
            throw new Error("while converting number to string, invalid number value '" + C + "', should be a number matching (^-?[0-9.]+).");
        return C
    } else {
        if (typeof C == "number")
            return String(C);
        if (typeof C == "object" && C.toString && (C.toTwos || C.dividedToIntegerBy))
            return C.toPrecision ? String(C.toPrecision()) : C.toString(10)
    }
    throw new Error("while converting number to string, invalid number value '" + C + "' type " + typeof C + ".")
}
function fromWei(C, S, E) {
    var M = numberToBN(C)
      , T = M.lt(zero)
      , $ = getValueOfUnit(S)
      , B = unitMap[S].length - 1 || 1
      , O = E || {};
    T && (M = M.mul(negative1));
    for (var F = M.mod($).toString(10); F.length < B; )
        F = "0" + F;
    O.pad || (F = F.match(/^([0-9]*[1-9]|0)(0*)/)[1]);
    var N = M.div($).toString(10);
    O.commify && (N = N.replace(/\B(?=(\d{3})+(?!\d))/g, ","));
    var U = "" + N + (F == "0" ? "" : "." + F);
    return T && (U = "-" + U),
    U
}
function toWei(C, S) {
    var E = numberToString(C)
      , M = getValueOfUnit(S)
      , T = unitMap[S].length - 1 || 1
      , $ = E.substring(0, 1) === "-";
    if ($ && (E = E.substring(1)),
    E === ".")
        throw new Error("[ethjs-unit] while converting number " + C + " to wei, invalid value");
    var B = E.split(".");
    if (B.length > 2)
        throw new Error("[ethjs-unit] while converting number " + C + " to wei,  too many decimal points");
    var O = B[0]
      , F = B[1];
    if (O || (O = "0"),
    F || (F = "0"),
    F.length > T)
        throw new Error("[ethjs-unit] while converting number " + C + " to wei, too many decimal places");
    for (; F.length < T; )
        F += "0";
    O = new BN$k(O),
    F = new BN$k(F);
    var N = O.mul(M).add(F);
    return $ && (N = N.mul(negative1)),
    new BN$k(N.toString(10),10)
}
var lib = {
    unitMap,
    numberToString,
    getValueOfUnit,
    fromWei,
    toWei
};
/**
 * @file Web Cryptography API shim
 * @author Artem S Vybornov <vybornov@gmail.com>
 * @license MIT
 */
(function(C, S) {
    typeof define == "function" && define.amd ? define([], function() {
        return S(C)
    }) : typeof module == "object" && module.exports ? module.exports = S(C) : S(C)
}
)(typeof self < "u" ? self : void 0, function(C) {
    if (typeof Promise != "function")
        throw "Promise support required";
    var S = C.crypto || C.msCrypto;
    if (!S)
        return;
    var E = S.subtle || S.webkitSubtle;
    if (!E)
        return;
    var M = C.Crypto || S.constructor || Object
      , T = C.SubtleCrypto || E.constructor || Object;
    C.CryptoKey || C.Key;
    var $ = C.navigator.userAgent.indexOf("Edge/") > -1
      , B = !!C.msCrypto && !$
      , O = !S.subtle && !!S.webkitSubtle;
    if (!B && !O)
        return;
    function F(ue) {
        return btoa(ue).replace(/\=+$/, "").replace(/\+/g, "-").replace(/\//g, "_")
    }
    function N(ue) {
        return ue += "===",
        ue = ue.slice(0, -ue.length % 4),
        atob(ue.replace(/-/g, "+").replace(/_/g, "/"))
    }
    function U(ue) {
        for (var V = new Uint8Array(ue.length), W = 0; W < ue.length; W++)
            V[W] = ue.charCodeAt(W);
        return V
    }
    function H(ue) {
        return ue instanceof ArrayBuffer && (ue = new Uint8Array(ue)),
        String.fromCharCode.apply(String, ue)
    }
    function Z(ue) {
        var V = {
            name: (ue.name || ue || "").toUpperCase().replace("V", "v")
        };
        switch (V.name) {
        case "SHA-1":
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
            break;
        case "AES-CBC":
        case "AES-GCM":
        case "AES-KW":
            ue.length && (V.length = ue.length);
            break;
        case "HMAC":
            ue.hash && (V.hash = Z(ue.hash)),
            ue.length && (V.length = ue.length);
            break;
        case "RSAES-PKCS1-v1_5":
            ue.publicExponent && (V.publicExponent = new Uint8Array(ue.publicExponent)),
            ue.modulusLength && (V.modulusLength = ue.modulusLength);
            break;
        case "RSASSA-PKCS1-v1_5":
        case "RSA-OAEP":
            ue.hash && (V.hash = Z(ue.hash)),
            ue.publicExponent && (V.publicExponent = new Uint8Array(ue.publicExponent)),
            ue.modulusLength && (V.modulusLength = ue.modulusLength);
            break;
        default:
            throw new SyntaxError("Bad algorithm name")
        }
        return V
    }
    function J(ue) {
        return {
            HMAC: {
                "SHA-1": "HS1",
                "SHA-256": "HS256",
                "SHA-384": "HS384",
                "SHA-512": "HS512"
            },
            "RSASSA-PKCS1-v1_5": {
                "SHA-1": "RS1",
                "SHA-256": "RS256",
                "SHA-384": "RS384",
                "SHA-512": "RS512"
            },
            "RSAES-PKCS1-v1_5": {
                "": "RSA1_5"
            },
            "RSA-OAEP": {
                "SHA-1": "RSA-OAEP",
                "SHA-256": "RSA-OAEP-256"
            },
            "AES-KW": {
                128: "A128KW",
                192: "A192KW",
                256: "A256KW"
            },
            "AES-GCM": {
                128: "A128GCM",
                192: "A192GCM",
                256: "A256GCM"
            },
            "AES-CBC": {
                128: "A128CBC",
                192: "A192CBC",
                256: "A256CBC"
            }
        }[ue.name][(ue.hash || {}).name || ue.length || ""]
    }
    function ie(ue) {
        (ue instanceof ArrayBuffer || ue instanceof Uint8Array) && (ue = JSON.parse(decodeURIComponent(escape(H(ue)))));
        var V = {
            kty: ue.kty,
            alg: ue.alg,
            ext: ue.ext || ue.extractable
        };
        switch (V.kty) {
        case "oct":
            V.k = ue.k;
        case "RSA":
            ["n", "e", "d", "p", "q", "dp", "dq", "qi", "oth"].forEach(function(W) {
                W in ue && (V[W] = ue[W])
            });
            break;
        default:
            throw new TypeError("Unsupported key type")
        }
        return V
    }
    function oe(ue) {
        var V = ie(ue);
        return B && (V.extractable = V.ext,
        delete V.ext),
        U(unescape(encodeURIComponent(JSON.stringify(V)))).buffer
    }
    function ae(ue) {
        var V = fe(ue)
          , W = !1;
        V.length > 2 && (W = !0,
        V.shift());
        var D = {
            ext: !0
        };
        switch (V[0][0]) {
        case "1.2.840.113549.1.1.1":
            var I = ["n", "e", "d", "p", "q", "dp", "dq", "qi"]
              , L = fe(V[1]);
            W && L.shift();
            for (var K = 0; K < L.length; K++)
                L[K][0] || (L[K] = L[K].subarray(1)),
                D[I[K]] = F(H(L[K]));
            D.kty = "RSA";
            break;
        default:
            throw new TypeError("Unsupported key type")
        }
        return D
    }
    function se(ue) {
        var V, W = [["", null]], D = !1;
        switch (ue.kty) {
        case "RSA":
            for (var I = ["n", "e", "d", "p", "q", "dp", "dq", "qi"], L = [], K = 0; K < I.length && I[K]in ue; K++) {
                var X = L[K] = U(N(ue[I[K]]));
                X[0] & 128 && (L[K] = new Uint8Array(X.length + 1),
                L[K].set(X, 1))
            }
            L.length > 2 && (D = !0,
            L.unshift(new Uint8Array([0]))),
            W[0][0] = "1.2.840.113549.1.1.1",
            V = L;
            break;
        default:
            throw new TypeError("Unsupported key type")
        }
        return W.push(new Uint8Array(pe(V)).buffer),
        D ? W.unshift(new Uint8Array([0])) : W[1] = {
            tag: 3,
            value: W[1]
        },
        new Uint8Array(pe(W)).buffer
    }
    var le = {
        KoZIhvcNAQEB: "1.2.840.113549.1.1.1"
    }
      , de = {
        "1.2.840.113549.1.1.1": "KoZIhvcNAQEB"
    };
    function fe(ue, V) {
        if (ue instanceof ArrayBuffer && (ue = new Uint8Array(ue)),
        V || (V = {
            pos: 0,
            end: ue.length
        }),
        V.end - V.pos < 2 || V.end > ue.length)
            throw new RangeError("Malformed DER");
        var W = ue[V.pos++]
          , D = ue[V.pos++];
        if (D >= 128) {
            if (D &= 127,
            V.end - V.pos < D)
                throw new RangeError("Malformed DER");
            for (var I = 0; D--; )
                I <<= 8,
                I |= ue[V.pos++];
            D = I
        }
        if (V.end - V.pos < D)
            throw new RangeError("Malformed DER");
        var L;
        switch (W) {
        case 2:
            L = ue.subarray(V.pos, V.pos += D);
            break;
        case 3:
            if (ue[V.pos++])
                throw new Error("Unsupported bit string");
            D--;
        case 4:
            L = new Uint8Array(ue.subarray(V.pos, V.pos += D)).buffer;
            break;
        case 5:
            L = null;
            break;
        case 6:
            var K = btoa(H(ue.subarray(V.pos, V.pos += D)));
            if (!(K in le))
                throw new Error("Unsupported OBJECT ID " + K);
            L = le[K];
            break;
        case 48:
            L = [];
            for (var X = V.pos + D; V.pos < X; )
                L.push(fe(ue, V));
            break;
        default:
            throw new Error("Unsupported DER tag 0x" + W.toString(16))
        }
        return L
    }
    function pe(ue, V) {
        V || (V = []);
        var W = 0
          , D = 0
          , I = V.length + 2;
        if (V.push(0, 0),
        ue instanceof Uint8Array) {
            W = 2,
            D = ue.length;
            for (var L = 0; L < D; L++)
                V.push(ue[L])
        } else if (ue instanceof ArrayBuffer) {
            W = 4,
            D = ue.byteLength,
            ue = new Uint8Array(ue);
            for (var L = 0; L < D; L++)
                V.push(ue[L])
        } else if (ue === null)
            W = 5,
            D = 0;
        else if (typeof ue == "string" && ue in de) {
            var K = U(atob(de[ue]));
            W = 6,
            D = K.length;
            for (var L = 0; L < D; L++)
                V.push(K[L])
        } else if (ue instanceof Array) {
            for (var L = 0; L < ue.length; L++)
                pe(ue[L], V);
            W = 48,
            D = V.length - I
        } else if (typeof ue == "object" && ue.tag === 3 && ue.value instanceof ArrayBuffer) {
            ue = new Uint8Array(ue.value),
            W = 3,
            D = ue.byteLength,
            V.push(0);
            for (var L = 0; L < D; L++)
                V.push(ue[L]);
            D++
        } else
            throw new Error("Unsupported DER value " + ue);
        if (D >= 128) {
            var X = D
              , D = 4;
            for (V.splice(I, 0, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, X & 255); D > 1 && !(X >> 24); )
                X <<= 8,
                D--;
            D < 4 && V.splice(I, 4 - D),
            D |= 128
        }
        return V.splice(I - 2, 2, W, D),
        V
    }
    function ge(ue, V, W, D) {
        Object.defineProperties(this, {
            _key: {
                value: ue
            },
            type: {
                value: ue.type,
                enumerable: !0
            },
            extractable: {
                value: W === void 0 ? ue.extractable : W,
                enumerable: !0
            },
            algorithm: {
                value: V === void 0 ? ue.algorithm : V,
                enumerable: !0
            },
            usages: {
                value: D === void 0 ? ue.usages : D,
                enumerable: !0
            }
        })
    }
    function we(ue) {
        return ue === "verify" || ue === "encrypt" || ue === "wrapKey"
    }
    function Ae(ue) {
        return ue === "sign" || ue === "decrypt" || ue === "unwrapKey"
    }
    if (["generateKey", "importKey", "unwrapKey"].forEach(function(ue) {
        var V = E[ue];
        E[ue] = function(W, D, I) {
            var L = [].slice.call(arguments), K, X, Y;
            switch (ue) {
            case "generateKey":
                K = Z(W),
                X = D,
                Y = I;
                break;
            case "importKey":
                K = Z(I),
                X = L[3],
                Y = L[4],
                W === "jwk" && (D = ie(D),
                D.alg || (D.alg = J(K)),
                D.key_ops || (D.key_ops = D.kty !== "oct" ? "d"in D ? Y.filter(Ae) : Y.filter(we) : Y.slice()),
                L[1] = oe(D));
                break;
            case "unwrapKey":
                K = L[4],
                X = L[5],
                Y = L[6],
                L[2] = I._key;
                break
            }
            if (ue === "generateKey" && K.name === "HMAC" && K.hash)
                return K.length = K.length || {
                    "SHA-1": 512,
                    "SHA-256": 512,
                    "SHA-384": 1024,
                    "SHA-512": 1024
                }[K.hash.name],
                E.importKey("raw", S.getRandomValues(new Uint8Array(K.length + 7 >> 3)), K, X, Y);
            if (O && ue === "generateKey" && K.name === "RSASSA-PKCS1-v1_5" && (!K.modulusLength || K.modulusLength >= 2048))
                return W = Z(W),
                W.name = "RSAES-PKCS1-v1_5",
                delete W.hash,
                E.generateKey(W, !0, ["encrypt", "decrypt"]).then(function(G) {
                    return Promise.all([E.exportKey("jwk", G.publicKey), E.exportKey("jwk", G.privateKey)])
                }).then(function(G) {
                    return G[0].alg = G[1].alg = J(K),
                    G[0].key_ops = Y.filter(we),
                    G[1].key_ops = Y.filter(Ae),
                    Promise.all([E.importKey("jwk", G[0], K, !0, G[0].key_ops), E.importKey("jwk", G[1], K, X, G[1].key_ops)])
                }).then(function(G) {
                    return {
                        publicKey: G[0],
                        privateKey: G[1]
                    }
                });
            if ((O || B && (K.hash || {}).name === "SHA-1") && ue === "importKey" && W === "jwk" && K.name === "HMAC" && D.kty === "oct")
                return E.importKey("raw", U(N(D.k)), I, L[3], L[4]);
            if (O && ue === "importKey" && (W === "spki" || W === "pkcs8"))
                return E.importKey("jwk", ae(D), I, L[3], L[4]);
            if (B && ue === "unwrapKey")
                return E.decrypt(L[3], I, D).then(function(G) {
                    return E.importKey(W, G, L[4], L[5], L[6])
                });
            var j;
            try {
                j = V.apply(E, L)
            } catch (G) {
                return Promise.reject(G)
            }
            return B && (j = new Promise(function(G, ne) {
                j.onabort = j.onerror = function(te) {
                    ne(te)
                }
                ,
                j.oncomplete = function(te) {
                    G(te.target.result)
                }
            }
            )),
            j = j.then(function(G) {
                return K.name === "HMAC" && (K.length || (K.length = 8 * G.algorithm.length)),
                K.name.search("RSA") == 0 && (K.modulusLength || (K.modulusLength = (G.publicKey || G).algorithm.modulusLength),
                K.publicExponent || (K.publicExponent = (G.publicKey || G).algorithm.publicExponent)),
                G.publicKey && G.privateKey ? G = {
                    publicKey: new ge(G.publicKey,K,X,Y.filter(we)),
                    privateKey: new ge(G.privateKey,K,X,Y.filter(Ae))
                } : G = new ge(G,K,X,Y),
                G
            }),
            j
        }
    }),
    ["exportKey", "wrapKey"].forEach(function(ue) {
        var V = E[ue];
        E[ue] = function(W, D, I) {
            var L = [].slice.call(arguments);
            switch (ue) {
            case "exportKey":
                L[1] = D._key;
                break;
            case "wrapKey":
                L[1] = D._key,
                L[2] = I._key;
                break
            }
            if ((O || B && (D.algorithm.hash || {}).name === "SHA-1") && ue === "exportKey" && W === "jwk" && D.algorithm.name === "HMAC" && (L[0] = "raw"),
            O && ue === "exportKey" && (W === "spki" || W === "pkcs8") && (L[0] = "jwk"),
            B && ue === "wrapKey")
                return E.exportKey(W, D).then(function(X) {
                    return W === "jwk" && (X = U(unescape(encodeURIComponent(JSON.stringify(ie(X)))))),
                    E.encrypt(L[3], I, X)
                });
            var K;
            try {
                K = V.apply(E, L)
            } catch (X) {
                return Promise.reject(X)
            }
            return B && (K = new Promise(function(X, Y) {
                K.onabort = K.onerror = function(j) {
                    Y(j)
                }
                ,
                K.oncomplete = function(j) {
                    X(j.target.result)
                }
            }
            )),
            ue === "exportKey" && W === "jwk" && (K = K.then(function(X) {
                return (O || B && (D.algorithm.hash || {}).name === "SHA-1") && D.algorithm.name === "HMAC" ? {
                    kty: "oct",
                    alg: J(D.algorithm),
                    key_ops: D.usages.slice(),
                    ext: !0,
                    k: F(H(X))
                } : (X = ie(X),
                X.alg || (X.alg = J(D.algorithm)),
                X.key_ops || (X.key_ops = D.type === "public" ? D.usages.filter(we) : D.type === "private" ? D.usages.filter(Ae) : D.usages.slice()),
                X)
            })),
            O && ue === "exportKey" && (W === "spki" || W === "pkcs8") && (K = K.then(function(X) {
                return X = se(ie(X)),
                X
            })),
            K
        }
    }),
    ["encrypt", "decrypt", "sign", "verify"].forEach(function(ue) {
        var V = E[ue];
        E[ue] = function(W, D, I, L) {
            if (B && (!I.byteLength || L && !L.byteLength))
                throw new Error("Empy input is not allowed");
            var K = [].slice.call(arguments)
              , X = Z(W);
            if (B && ue === "decrypt" && X.name === "AES-GCM") {
                var Y = W.tagLength >> 3;
                K[2] = (I.buffer || I).slice(0, I.byteLength - Y),
                W.tag = (I.buffer || I).slice(I.byteLength - Y)
            }
            K[1] = D._key;
            var j;
            try {
                j = V.apply(E, K)
            } catch (G) {
                return Promise.reject(G)
            }
            return B && (j = new Promise(function(G, ne) {
                j.onabort = j.onerror = function(te) {
                    ne(te)
                }
                ,
                j.oncomplete = function(ce) {
                    var ce = ce.target.result;
                    if (ue === "encrypt" && ce instanceof AesGcmEncryptResult) {
                        var Ee = ce.ciphertext
                          , Re = ce.tag;
                        ce = new Uint8Array(Ee.byteLength + Re.byteLength),
                        ce.set(new Uint8Array(Ee), 0),
                        ce.set(new Uint8Array(Re), Ee.byteLength),
                        ce = ce.buffer
                    }
                    G(ce)
                }
            }
            )),
            j
        }
    }),
    B) {
        var Se = E.digest;
        E.digest = function(ue, V) {
            if (!V.byteLength)
                throw new Error("Empy input is not allowed");
            var W;
            try {
                W = Se.call(E, ue, V)
            } catch (D) {
                return Promise.reject(D)
            }
            return W = new Promise(function(D, I) {
                W.onabort = W.onerror = function(L) {
                    I(L)
                }
                ,
                W.oncomplete = function(L) {
                    D(L.target.result)
                }
            }
            ),
            W
        }
        ,
        C.crypto = Object.create(S, {
            getRandomValues: {
                value: function(ue) {
                    return S.getRandomValues(ue)
                }
            },
            subtle: {
                value: E
            }
        }),
        C.CryptoKey = ge
    }
    O && (S.subtle = E,
    C.Crypto = M,
    C.SubtleCrypto = T,
    C.CryptoKey = ge)
});
const browser = window.crypto
  , browser$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: browser
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$3$1 = getAugmentedNamespace(browser$1)
  , BN$j = bnExports$2
  , nacl$4 = naclFastExports
  , ethunit = lib
  , isCryptoAvailable = typeof self < "u" && self.crypto && self.crypto.subtle;
let myCrypto = null;
isCryptoAvailable || (myCrypto = require$$3$1);
function sha256$3(C) {
    return isCryptoAvailable ? crypto.subtle.digest("SHA-256", C) : myCrypto.subtle.digest({
        name: "SHA-256"
    }, C)
}
function toNano$2(C) {
    if (!BN$j.isBN(C) && typeof C != "string")
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
    return ethunit.toWei(C, "gwei")
}
function fromNano$1(C) {
    if (!BN$j.isBN(C) && typeof C != "string")
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
    return ethunit.fromWei(C, "gwei")
}
const to_hex_array = []
  , to_byte_map = {};
for (let C = 0; C <= 255; C++) {
    let S = C.toString(16);
    S.length < 2 && (S = "0" + S),
    to_hex_array.push(S),
    to_byte_map[S] = C
}
function bytesToHex$d(C) {
    const S = [];
    for (let E = 0; E < C.byteLength; E++)
        S.push(to_hex_array[C[E]]);
    return S.join("")
}
function hexToBytes$7(C) {
    C = C.toLowerCase();
    const S = C.length;
    if (S % 2 !== 0)
        throw "hex string must have length a multiple of 2";
    const E = S / 2
      , M = new Uint8Array(E);
    for (let T = 0; T < E; T++) {
        const $ = T * 2
          , B = C.substring($, $ + 2);
        if (!to_byte_map.hasOwnProperty(B))
            throw new Error("invalid hex character " + B);
        M[T] = to_byte_map[B]
    }
    return M
}
function stringToBytes$3(C, S=1) {
    let E, M;
    S === 1 && (E = new ArrayBuffer(C.length),
    M = new Uint8Array(E)),
    S === 2 && (E = new ArrayBuffer(C.length * 2),
    M = new Uint16Array(E)),
    S === 4 && (E = new ArrayBuffer(C.length * 4),
    M = new Uint32Array(E));
    for (let T = 0, $ = C.length; T < $; T++)
        M[T] = C.charCodeAt(T);
    return new Uint8Array(M.buffer)
}
function _crc32c(C, S) {
    C ^= 4294967295;
    for (let M = 0; M < S.length; M++)
        C ^= S[M],
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1,
        C = C & 1 ? C >>> 1 ^ 2197175160 : C >>> 1;
    return C ^ 4294967295
}
function crc32c$2(C) {
    const S = _crc32c(0, C)
      , E = new ArrayBuffer(4);
    return new DataView(E).setUint32(0, S, !1),
    new Uint8Array(E).reverse()
}
function crc16$2(C) {
    let E = 0;
    const M = new Uint8Array(C.length + 2);
    M.set(C);
    for (let T of M) {
        let $ = 128;
        for (; $ > 0; )
            E <<= 1,
            T & $ && (E += 1),
            $ >>= 1,
            E > 65535 && (E &= 65535,
            E ^= 4129)
    }
    return new Uint8Array([Math.floor(E / 256), E % 256])
}
function concatBytes$2(C, S) {
    const E = new Uint8Array(C.length + S.length);
    return E.set(C),
    E.set(S, C.length),
    E
}
function compareBytes$2(C, S) {
    return C.toString() === S.toString()
}
const base64abc = (()=>{
    const C = [];
    for (let T = 0; T < 26; ++T)
        C.push(String.fromCharCode(65 + T));
    for (let T = 0; T < 26; ++T)
        C.push(String.fromCharCode(97 + T));
    for (let T = 0; T < 10; ++T)
        C.push(String.fromCharCode(48 + T));
    return C.push("+"),
    C.push("/"),
    C
}
)();
function bytesToBase64$7(C) {
    let S = "", E;
    const M = C.length;
    for (E = 2; E < M; E += 3)
        S += base64abc[C[E - 2] >> 2],
        S += base64abc[(C[E - 2] & 3) << 4 | C[E - 1] >> 4],
        S += base64abc[(C[E - 1] & 15) << 2 | C[E] >> 6],
        S += base64abc[C[E] & 63];
    return E === M + 1 && (S += base64abc[C[E - 2] >> 2],
    S += base64abc[(C[E - 2] & 3) << 4],
    S += "=="),
    E === M && (S += base64abc[C[E - 2] >> 2],
    S += base64abc[(C[E - 2] & 3) << 4 | C[E - 1] >> 4],
    S += base64abc[(C[E - 1] & 15) << 2],
    S += "="),
    S
}
function base64toString$2(C) {
    return typeof self > "u" ? Buffer.from(C, "base64").toString("binary") : atob(C)
}
function stringToBase64$2(C) {
    return typeof self > "u" ? Buffer.from(C, "binary").toString("base64") : btoa(C)
}
function base64ToBytes$4(C) {
    const S = base64toString$2(C)
      , E = S.length
      , M = new Uint8Array(E);
    for (let T = 0; T < E; T++)
        M[T] = S.charCodeAt(T);
    return M
}
function readNBytesUIntFromArray$2(C, S) {
    let E = 0;
    for (let M = 0; M < C; M++)
        E *= 256,
        E += S[M];
    return E
}
function keyPairFromSeed$1(C) {
    return nacl$4.sign.keyPair.fromSeed(C)
}
function newKeyPair$1() {
    return nacl$4.sign.keyPair()
}
function newSeed$1() {
    return nacl$4.sign.keyPair().secretKey.slice(0, 32)
}
var Utils = {
    BN: BN$j,
    nacl: nacl$4,
    sha256: sha256$3,
    fromNano: fromNano$1,
    toNano: toNano$2,
    bytesToHex: bytesToHex$d,
    hexToBytes: hexToBytes$7,
    stringToBytes: stringToBytes$3,
    crc32c: crc32c$2,
    crc16: crc16$2,
    concatBytes: concatBytes$2,
    bytesToBase64: bytesToBase64$7,
    base64ToBytes: base64ToBytes$4,
    base64toString: base64toString$2,
    stringToBase64: stringToBase64$2,
    compareBytes: compareBytes$2,
    readNBytesUIntFromArray: readNBytesUIntFromArray$2,
    keyPairFromSeed: keyPairFromSeed$1,
    newKeyPair: newKeyPair$1,
    newSeed: newSeed$1
}
  , Address$g = {};
const {crc16: crc16$1, hexToBytes: hexToBytes$6, bytesToHex: bytesToHex$c, stringToBytes: stringToBytes$2, base64toString: base64toString$1, stringToBase64: stringToBase64$1} = Utils
  , bounceable_tag = 17
  , non_bounceable_tag = 81
  , test_flag = 128;
function parseFriendlyAddress(C) {
    if (C.length !== 48)
        throw new Error("User-friendly address should contain strictly 48 characters");
    const S = stringToBytes$2(base64toString$1(C));
    if (S.length !== 36)
        throw "Unknown address type: byte length is not equal to 36";
    const E = S.slice(0, 34)
      , M = S.slice(34, 36)
      , T = crc16$1(E);
    if (!(T[0] === M[0] && T[1] === M[1]))
        throw "Wrong crc16 hashsum";
    let $ = E[0]
      , B = !1
      , O = !1;
    if ($ & test_flag && (B = !0,
    $ = $ ^ test_flag),
    $ !== bounceable_tag && $ !== non_bounceable_tag)
        throw "Unknown address tag";
    O = $ === bounceable_tag;
    let F = null;
    if (E[1] === 255 ? F = -1 : F = E[1],
    F !== 0 && F !== -1)
        throw new Error("Invalid address wc " + F);
    const N = E.slice(2, 34);
    return {
        isTestOnly: B,
        isBounceable: O,
        workchain: F,
        hashPart: N
    }
}
let Address$f = class Mr {
    static isValid(S) {
        try {
            return new Mr(S),
            !0
        } catch {
            return !1
        }
    }
    constructor(S) {
        if (S == null)
            throw "Invalid address";
        if (S instanceof Mr) {
            this.wc = S.wc,
            this.hashPart = S.hashPart,
            this.isTestOnly = S.isTestOnly,
            this.isUserFriendly = S.isUserFriendly,
            this.isBounceable = S.isBounceable,
            this.isUrlSafe = S.isUrlSafe;
            return
        }
        if (this.isUrlSafe = !0,
        S.search(/\-/) > 0 || S.search(/_/) > 0 ? S = S.replace(/\-/g, "+").replace(/_/g, "/") : this.isUrlSafe = !1,
        S.indexOf(":") > -1) {
            const E = S.split(":");
            if (E.length !== 2)
                throw new Error("Invalid address " + S);
            const M = parseInt(E[0]);
            if (M !== 0 && M !== -1)
                throw new Error("Invalid address wc " + S);
            const T = E[1];
            if (T.length !== 64)
                throw new Error("Invalid address hex " + S);
            this.isUserFriendly = !1,
            this.wc = M,
            this.hashPart = hexToBytes$6(T),
            this.isTestOnly = !1,
            this.isBounceable = !1
        } else {
            this.isUserFriendly = !0;
            const E = parseFriendlyAddress(S);
            this.wc = E.workchain,
            this.hashPart = E.hashPart,
            this.isTestOnly = E.isTestOnly,
            this.isBounceable = E.isBounceable
        }
    }
    toString(S, E, M, T) {
        if (S === void 0 && (S = this.isUserFriendly),
        E === void 0 && (E = this.isUrlSafe),
        M === void 0 && (M = this.isBounceable),
        T === void 0 && (T = this.isTestOnly),
        S) {
            let $ = M ? bounceable_tag : non_bounceable_tag;
            T && ($ |= test_flag);
            const B = new Int8Array(34);
            B[0] = $,
            B[1] = this.wc,
            B.set(this.hashPart, 2);
            const O = new Uint8Array(36);
            O.set(B),
            O.set(crc16$1(B), 34);
            let F = stringToBase64$1(String.fromCharCode.apply(null, new Uint8Array(O)));
            return E && (F = F.replace(/\+/g, "-").replace(/\//g, "_")),
            F
        } else
            return this.wc + ":" + bytesToHex$c(this.hashPart)
    }
}
;
Address$g.default = Address$f;
var AdnlAddress$3 = {};
const {hexToBytes: hexToBytes$5, bytesToHex: bytesToHex$b} = Utils;
let AdnlAddress$2 = class $r {
    static isValid(S) {
        try {
            return new $r(S),
            !0
        } catch {
            return !1
        }
    }
    constructor(S) {
        if (S == null)
            throw "Invalid address";
        if (S instanceof $r)
            this.bytes = S.bytes;
        else if (S instanceof Uint8Array) {
            if (S.length !== 32)
                throw new Error("invalid adnl bytes length");
            this.bytes = S
        } else if (typeof S == "string") {
            if (S.length !== 64)
                throw new Error("invalid adnl hex length");
            this.bytes = hexToBytes$5(S)
        } else
            throw new Error("unsupported type")
    }
    toHex() {
        let S = bytesToHex$b(this.bytes);
        for (; S.length < 64; )
            S = "0" + S;
        return S
    }
}
;
AdnlAddress$3.default = AdnlAddress$2;
var StorageBagId$3 = {};
const {hexToBytes: hexToBytes$4, bytesToHex: bytesToHex$a} = Utils;
let StorageBagId$2 = class Tr {
    static isValid(S) {
        try {
            return new Tr(S),
            !0
        } catch {
            return !1
        }
    }
    constructor(S) {
        if (S == null)
            throw "Invalid address";
        if (S instanceof Tr)
            this.bytes = S.bytes;
        else if (S instanceof Uint8Array) {
            if (S.length !== 32)
                throw new Error("invalid bag id bytes length");
            this.bytes = S
        } else if (typeof S == "string") {
            if (S.length !== 64)
                throw new Error("invalid bag id hex length");
            this.bytes = hexToBytes$4(S)
        } else
            throw new Error("unsupported type")
    }
    toHex() {
        let S = bytesToHex$a(this.bytes);
        for (; S.length < 64; )
            S = "0" + S;
        return S
    }
}
;
StorageBagId$3.default = StorageBagId$2;
const {BN: BN$i, nacl: nacl$3, sha256: sha256$2, fromNano, toNano: toNano$1, bytesToHex: bytesToHex$9, hexToBytes: hexToBytes$3, stringToBytes: stringToBytes$1, crc32c: crc32c$1, crc16, concatBytes: concatBytes$1, bytesToBase64: bytesToBase64$6, base64ToBytes: base64ToBytes$3, base64toString, stringToBase64, compareBytes: compareBytes$1, readNBytesUIntFromArray: readNBytesUIntFromArray$1, keyPairFromSeed, newKeyPair, newSeed} = Utils
  , Address$e = Address$g.default
  , AdnlAddress$1 = AdnlAddress$3.default
  , StorageBagId$1 = StorageBagId$3.default;
function parseTransferUrl(C) {
    const S = "ton://transfer/";
    if (!C.startsWith(S))
        throw new Error("must starts with " + S);
    const E = C.substring(S.length).split("?");
    if (E.length > 2)
        throw new Error('multiple "?"');
    const M = E[0];
    if (!Address$e.isValid(M))
        throw new Error("invalid address format " + M);
    const T = {
        address: M
    }
      , $ = E[1];
    if ($ && $.length) {
        const B = $.split("&").map(O=>O.split("="));
        for (const O of B) {
            if (O.length !== 2)
                throw new Error("invalid url pair");
            const F = O[0]
              , N = O[1];
            if (F === "amount") {
                if (T.amount)
                    throw new Error("amount already set");
                if (new BN$i(N).isNeg())
                    throw new Error("negative amount");
                T.amount = N
            } else if (F === "text") {
                if (T.text)
                    throw new Error("text already set");
                T.text = decodeURIComponent(N)
            } else
                throw new Error("unknown url var " + F)
        }
    }
    return T
}
function formatTransferUrl(C, S, E) {
    let M = "ton://transfer/" + C;
    const T = [];
    return S && T.push("amount=" + S),
    E && T.push("text=" + encodeURIComponent(E)),
    T.length === 0 ? M : M + "?" + T.join("&")
}
var utils$1 = {
    Address: Address$e,
    AdnlAddress: AdnlAddress$1,
    StorageBagId: StorageBagId$1,
    BN: BN$i,
    nacl: nacl$3,
    sha256: sha256$2,
    fromNano,
    toNano: toNano$1,
    bytesToHex: bytesToHex$9,
    hexToBytes: hexToBytes$3,
    stringToBytes: stringToBytes$1,
    crc32c: crc32c$1,
    crc16,
    concatBytes: concatBytes$1,
    bytesToBase64: bytesToBase64$6,
    base64ToBytes: base64ToBytes$3,
    base64toString,
    stringToBase64,
    compareBytes: compareBytes$1,
    readNBytesUIntFromArray: readNBytesUIntFromArray$1,
    parseTransferUrl,
    formatTransferUrl,
    keyPairFromSeed,
    newKeyPair,
    newSeed
};
const {BN: BN$h, bytesToHex: bytesToHex$8} = utils$1;
let BitString$3 = class kr {
    constructor(S) {
        this.array = Uint8Array.from({
            length: Math.ceil(S / 8)
        }, ()=>0),
        this.cursor = 0,
        this.length = S
    }
    getFreeBits() {
        return this.length - this.cursor
    }
    getUsedBits() {
        return this.cursor
    }
    getUsedBytes() {
        return Math.ceil(this.cursor / 8)
    }
    get(S) {
        return (this.array[S / 8 | 0] & 1 << 7 - S % 8) > 0
    }
    checkRange(S) {
        if (S > this.length)
            throw Error("BitString overflow")
    }
    on(S) {
        this.checkRange(S),
        this.array[S / 8 | 0] |= 1 << 7 - S % 8
    }
    off(S) {
        this.checkRange(S),
        this.array[S / 8 | 0] &= ~(1 << 7 - S % 8)
    }
    toggle(S) {
        this.checkRange(S),
        this.array[S / 8 | 0] ^= 1 << 7 - S % 8
    }
    forEach(S) {
        const E = this.cursor;
        for (let M = 0; M < E; M++)
            S(this.get(M))
    }
    writeBit(S) {
        S && S > 0 ? this.on(this.cursor) : this.off(this.cursor),
        this.cursor = this.cursor + 1
    }
    writeBitArray(S) {
        for (let E = 0; E < S.length; E++)
            this.writeBit(S[E])
    }
    writeUint(S, E) {
        if (isNaN(S))
            throw new Error("writeUint: value is NaN");
        if (S === null)
            throw new Error("writeUint: value is null");
        if (S === void 0)
            throw new Error("writeUint: value is undefined");
        if (!E)
            throw new Error("writeUint: no bitLength");
        if (S = new BN$h(S),
        E == 0 || S.toString(2).length > E) {
            if (S == 0)
                return;
            throw Error("bitLength is too small for number, got number=" + S + ",bitLength=" + E)
        }
        const M = S.toString(2, E);
        for (let T = 0; T < E; T++)
            this.writeBit(M[T] == 1)
    }
    writeInt(S, E) {
        if (isNaN(S))
            throw new Error("writeInt: value is NaN");
        if (S === null)
            throw new Error("writeInt: value is null");
        if (S === void 0)
            throw new Error("writeInt: value is undefined");
        if (!E)
            throw new Error("writeInt: no bitLength");
        if (S = new BN$h(S),
        E == 1) {
            if (S == -1) {
                this.writeBit(!0);
                return
            }
            if (S == 0) {
                this.writeBit(!1);
                return
            }
            throw Error("Bitlength is too small for number")
        } else if (S.isNeg()) {
            this.writeBit(!0);
            const T = new BN$h(2).pow(new BN$h(E - 1));
            this.writeUint(T.add(S), E - 1)
        } else
            this.writeBit(!1),
            this.writeUint(S, E - 1)
    }
    writeUint8(S) {
        this.writeUint(S, 8)
    }
    writeBytes(S) {
        for (let E = 0; E < S.length; E++)
            this.writeUint8(S[E])
    }
    writeString(S) {
        this.writeBytes(new TextEncoder().encode(S))
    }
    writeGrams(S) {
        if (S == 0)
            this.writeUint(0, 4);
        else {
            S = new BN$h(S);
            const E = Math.ceil(S.toString(16).length / 2);
            this.writeUint(E, 4),
            this.writeUint(S, E * 8)
        }
    }
    writeCoins(S) {
        this.writeGrams(S)
    }
    writeAddress(S) {
        S == null ? this.writeUint(0, 2) : (this.writeUint(2, 2),
        this.writeUint(0, 1),
        this.writeInt(S.wc, 8),
        this.writeBytes(S.hashPart))
    }
    writeBitString(S) {
        S.forEach(E=>{
            this.writeBit(E)
        }
        )
    }
    clone() {
        const S = new kr(0);
        return S.array = this.array.slice(0),
        S.length = this.length,
        S.cursor = this.cursor,
        S
    }
    toString() {
        return this.toHex()
    }
    getTopUppedArray() {
        const S = this.clone();
        let E = Math.ceil(S.cursor / 8) * 8 - S.cursor;
        if (E > 0)
            for (E = E - 1,
            S.writeBit(!0); E > 0; )
                E = E - 1,
                S.writeBit(!1);
        return S.array = S.array.slice(0, Math.ceil(S.cursor / 8)),
        S.array
    }
    toHex() {
        if (this.cursor % 4 === 0) {
            const S = bytesToHex$8(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();
            return this.cursor % 8 === 0 ? S : S.substr(0, S.length - 1)
        } else {
            const S = this.clone();
            for (S.writeBit(1); S.cursor % 4 !== 0; )
                S.writeBit(0);
            return S.toHex().toUpperCase() + "_"
        }
    }
    setTopUppedArray(S, E=!0) {
        if (this.length = S.length * 8,
        this.array = S,
        this.cursor = this.length,
        !(E || !this.length)) {
            let M = !1;
            for (let T = 0; T < 7; T++)
                if (this.cursor -= 1,
                this.get(this.cursor)) {
                    M = !0,
                    this.off(this.cursor);
                    break
                }
            if (!M)
                throw console.log(S, E),
                new Error("Incorrect TopUppedArray")
        }
    }
}
;
var BitString_1 = {
    BitString: BitString$3
};
const {BN: BN$g, Address: Address$d, bytesToHex: bytesToHex$7} = utils$1
  , {BitString: BitString$2} = BitString_1;
let Slice$2 = class {
    constructor(S, E, M) {
        this.array = S,
        this.length = E,
        this.readCursor = 0,
        this.refs = M,
        this.refCursor = 0
    }
    getFreeBits() {
        return this.length - this.readCursor
    }
    checkRange(S) {
        if (S > this.length)
            throw Error("BitString overflow")
    }
    get(S) {
        return this.checkRange(S),
        (this.array[S / 8 | 0] & 1 << 7 - S % 8) > 0
    }
    loadBit() {
        const S = this.get(this.readCursor);
        return this.readCursor++,
        S
    }
    loadBits(S) {
        const E = new BitString$2(S);
        for (let M = 0; M < S; M++)
            E.writeBit(this.loadBit());
        return E.array
    }
    loadUint(S) {
        if (S < 1)
            throw "Incorrect bitLength";
        let E = "";
        for (let M = 0; M < S; M++)
            E += this.loadBit() ? "1" : "0";
        return new BN$g(E,2)
    }
    loadInt(S) {
        if (S < 1)
            throw "Incorrect bitLength";
        const E = this.loadBit();
        if (S === 1)
            return E ? new BN$g(-1) : new BN$g(0);
        let M = this.loadUint(S - 1);
        if (E) {
            const $ = new BN$g(2).pow(new BN$g(S - 1));
            M = M.sub($)
        }
        return M
    }
    loadVarUint(S) {
        const E = this.loadUint(new BN$g(S).toString(2).length - 1);
        return E.toNumber() === 0 ? new BN$g(0) : this.loadUint(E * 8)
    }
    loadCoins() {
        return this.loadVarUint(16)
    }
    loadAddress() {
        const S = this.loadUint(2);
        if (S.toNumber() === 0)
            return null;
        if (S.toNumber() !== 2)
            throw new Error("unsupported address type");
        if (this.loadBit())
            throw new Error("unsupported address type");
        const E = this.loadInt(8).toNumber()
          , M = this.loadBits(256);
        return new Address$d(E + ":" + bytesToHex$7(M))
    }
    loadRef() {
        if (this.refCursor >= 4)
            throw new Error("refs overflow");
        const S = this.refs[this.refCursor];
        return this.refCursor++,
        S
    }
}
;
var Slice_1 = {
    Slice: Slice$2
};
const {BitString: BitString$1} = BitString_1
  , {bytesToBase64: bytesToBase64$5, compareBytes, concatBytes, crc32c, hexToBytes: hexToBytes$2, readNBytesUIntFromArray, sha256: sha256$1, bytesToHex: bytesToHex$6} = utils$1
  , {Slice: Slice$1} = Slice_1
  , reachBocMagicPrefix = hexToBytes$2("B5EE9C72")
  , leanBocMagicPrefix = hexToBytes$2("68ff65f3")
  , leanBocMagicPrefixCRC = hexToBytes$2("acc3a728");
let Cell$q = class {
    constructor() {
        this.bits = new BitString$1(1023),
        this.refs = [],
        this.isExotic = !1
    }
    static fromBoc(S) {
        return deserializeBoc(S)
    }
    static oneFromBoc(S) {
        const E = deserializeBoc(S);
        if (E.length !== 1)
            throw new Error("expected 1 root cell but have " + E.length);
        return E[0]
    }
    writeCell(S) {
        this.bits.writeBitString(S.bits),
        this.refs = this.refs.concat(S.refs)
    }
    getMaxLevel() {
        let S = 0;
        for (let E in this.refs) {
            const M = this.refs[E];
            M.getMaxLevel() > S && (S = M.getMaxLevel())
        }
        return S
    }
    isExplicitlyStoredHashes() {
        return 0
    }
    getMaxDepth() {
        let S = 0;
        if (this.refs.length > 0) {
            for (let E = 0; E < this.refs.length; E++) {
                let T = this.refs[E].getMaxDepth();
                T > S && (S = T)
            }
            S = S + 1
        }
        return S
    }
    getMaxDepthAsArray() {
        const S = this.getMaxDepth()
          , E = Uint8Array.from({
            length: 2
        }, ()=>0);
        return E[1] = S % 256,
        E[0] = Math.floor(S / 256),
        E
    }
    getRefsDescriptor() {
        const S = Uint8Array.from({
            length: 1
        }, ()=>0);
        return S[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32,
        S
    }
    getBitsDescriptor() {
        const S = Uint8Array.from({
            length: 1
        }, ()=>0);
        return S[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8),
        S
    }
    getDataWithDescriptors() {
        const S = this.getRefsDescriptor()
          , E = this.getBitsDescriptor()
          , M = this.bits.getTopUppedArray();
        return concatBytes(concatBytes(S, E), M)
    }
    async getRepr() {
        const S = [];
        S.push(this.getDataWithDescriptors());
        for (let M in this.refs) {
            const T = this.refs[M];
            S.push(T.getMaxDepthAsArray())
        }
        for (let M in this.refs) {
            const T = this.refs[M];
            S.push(await T.hash())
        }
        let E = new Uint8Array;
        for (let M in S) {
            const T = S[M];
            E = concatBytes(E, T)
        }
        return E
    }
    async hash() {
        return new Uint8Array(await sha256$1(await this.getRepr()))
    }
    beginParse() {
        const S = this.refs.map(E=>E.beginParse());
        return new Slice$1(this.bits.array.slice(),this.bits.length,S)
    }
    print(S) {
        S = S || "";
        let E = S + "x{" + this.bits.toHex() + `}
`;
        for (let M in this.refs) {
            const T = this.refs[M];
            E += T.print(S + " ")
        }
        return E
    }
    async toBoc(S=!0, E=!0, M=!1, T=0) {
        const B = await this.treeWalk()
          , O = B[0]
          , F = B[1]
          , N = O.length
          , U = N.toString(2).length
          , H = Math.min(Math.ceil(U / 8), 1);
        let Z = 0
          , J = [];
        for (let le of O)
            J.push(Z),
            Z = Z + await le[1].bocSerializationSize(F, H);
        const ie = Z.toString(2).length
          , oe = Math.max(Math.ceil(ie / 8), 1)
          , ae = new BitString$1((1023 + 32 * 4 + 32 * 3) * O.length);
        ae.writeBytes(reachBocMagicPrefix),
        ae.writeBitArray([S, E, M]),
        ae.writeUint(T, 2),
        ae.writeUint(H, 3),
        ae.writeUint8(oe),
        ae.writeUint(N, H * 8),
        ae.writeUint(1, H * 8),
        ae.writeUint(0, H * 8),
        ae.writeUint(Z, oe * 8),
        ae.writeUint(0, H * 8),
        S && O.forEach((le,de)=>ae.writeUint(J[de], oe * 8));
        for (let le of O) {
            const de = await le[1].serializeForBoc(F, H);
            ae.writeBytes(de)
        }
        let se = ae.getTopUppedArray();
        return E && (se = concatBytes(se, crc32c(se))),
        se
    }
    async serializeForBoc(S, E) {
        const M = [];
        if (M.push(this.getDataWithDescriptors()),
        this.isExplicitlyStoredHashes())
            throw new Error("Cell hashes explicit storing is not implemented");
        for (let $ in this.refs) {
            const O = await this.refs[$].hash();
            let N = S[O].toString(16);
            N.length % 2 && (N = "0" + N);
            const U = hexToBytes$2(N);
            M.push(U)
        }
        let T = new Uint8Array;
        for (let $ in M) {
            const B = M[$];
            T = concatBytes(T, B)
        }
        return T
    }
    async bocSerializationSize(S, E) {
        return (await this.serializeForBoc(S, E)).length
    }
    async treeWalk() {
        return treeWalk(this, [], {})
    }
}
;
async function moveToTheEnd(C, S, E) {
    const M = C[E];
    for (let $ in C)
        C[$] > M && (C[$] = C[$] - 1);
    C[E] = S.length - 1;
    const T = S.splice(M, 1)[0];
    S.push(T);
    for (let $ of T[1].refs)
        await moveToTheEnd(C, S, await $.hash())
}
async function treeWalk(C, S, E, M=null) {
    const T = await C.hash();
    if (T in E)
        return M && E[M] > E[T] && await moveToTheEnd(E, S, T),
        [S, E];
    E[T] = S.length,
    S.push([T, C]);
    for (let $ of C.refs) {
        const B = await treeWalk($, S, E, T);
        S = B[0],
        E = B[1]
    }
    return [S, E]
}
function parseBocHeader(C) {
    if (C.length < 5)
        throw "Not enough bytes for magic prefix";
    const S = C
      , E = C.slice(0, 4);
    C = C.slice(4);
    let M, T, $, B, O;
    if (compareBytes(E, reachBocMagicPrefix)) {
        const ae = C[0];
        M = ae & 128,
        T = ae & 64,
        $ = ae & 32,
        B = (ae & 16) * 2 + (ae & 8),
        O = ae % 8
    }
    if (compareBytes(E, leanBocMagicPrefix) && (M = 1,
    T = 0,
    $ = 0,
    B = 0,
    O = C[0]),
    compareBytes(E, leanBocMagicPrefixCRC) && (M = 1,
    T = 1,
    $ = 0,
    B = 0,
    O = C[0]),
    C = C.slice(1),
    C.length < 1 + 5 * O)
        throw "Not enough bytes for encoding cells counters";
    const F = C[0];
    C = C.slice(1);
    const N = readNBytesUIntFromArray(O, C);
    C = C.slice(O);
    const U = readNBytesUIntFromArray(O, C);
    C = C.slice(O);
    const H = readNBytesUIntFromArray(O, C);
    C = C.slice(O);
    const Z = readNBytesUIntFromArray(F, C);
    if (C = C.slice(F),
    C.length < U * O)
        throw "Not enough bytes for encoding root cells hashes";
    let J = [];
    for (let ae = 0; ae < U; ae++)
        J.push(readNBytesUIntFromArray(O, C)),
        C = C.slice(O);
    let ie = !1;
    if (M) {
        if (ie = [],
        C.length < F * N)
            throw "Not enough bytes for index encoding";
        for (let ae = 0; ae < N; ae++)
            ie.push(readNBytesUIntFromArray(F, C)),
            C = C.slice(F)
    }
    if (C.length < Z)
        throw "Not enough bytes for cells data";
    const oe = C.slice(0, Z);
    if (C = C.slice(Z),
    T) {
        if (C.length < 4)
            throw "Not enough bytes for crc32c hashsum";
        const ae = S.length;
        if (!compareBytes(crc32c(S.slice(0, ae - 4)), C.slice(0, 4)))
            throw "Crc32c hashsum mismatch";
        C = C.slice(4)
    }
    if (C.length)
        throw "Too much bytes in BoC serialization";
    return {
        has_idx: M,
        hash_crc32: T,
        has_cache_bits: $,
        flags: B,
        size_bytes: O,
        off_bytes: F,
        cells_num: N,
        roots_num: U,
        absent_num: H,
        tot_cells_size: Z,
        root_list: J,
        index: ie,
        cells_data: oe
    }
}
function deserializeCellData(C, S) {
    if (C.length < 2)
        throw "Not enough bytes to encode cell descriptors";
    const E = C[0]
      , M = C[1];
    C = C.slice(2);
    const T = E & 8
      , $ = E % 8
      , B = Math.ceil(M / 2)
      , O = !(M % 2);
    let F = new Cell$q;
    if (F.isExotic = T,
    C.length < B + S * $)
        throw "Not enough bytes to encode cell data";
    F.bits.setTopUppedArray(C.slice(0, B), O),
    C = C.slice(B);
    for (let N = 0; N < $; N++)
        F.refs.push(readNBytesUIntFromArray(S, C)),
        C = C.slice(S);
    return {
        cell: F,
        residue: C
    }
}
function deserializeBoc(C) {
    typeof C == "string" && (C = hexToBytes$2(C));
    const S = parseBocHeader(C);
    let E = S.cells_data
      , M = [];
    for (let $ = 0; $ < S.cells_num; $++) {
        let B = deserializeCellData(E, S.size_bytes);
        E = B.residue,
        M.push(B.cell)
    }
    for (let $ = S.cells_num - 1; $ >= 0; $--) {
        let B = M[$];
        for (let O = 0; O < B.refs.length; O++) {
            const F = B.refs[O];
            if (F < $)
                throw "Topological order is broken";
            B.refs[O] = M[F]
        }
    }
    let T = [];
    for (let $ of S.root_list)
        T.push(M[$]);
    return T
}
var Cell_1 = {
    Cell: Cell$q
};
const {BitString} = BitString_1
  , {Cell: Cell$p} = Cell_1
  , {Slice} = Slice_1;
var boc$1 = {
    BitString,
    Cell: Cell$p,
    Slice
};
const {Cell: Cell$o} = boc$1
  , {Address: Address$c, bytesToBase64: bytesToBase64$4, bytesToHex: bytesToHex$5, BN: BN$f} = utils$1;
let Contract$f = class Ar {
    constructor(S, E) {
        this.provider = S,
        this.options = E,
        this.address = E.address ? new Address$c(E.address) : null,
        E.wc || (E.wc = this.address ? this.address.wc : 0),
        this.methods = {}
    }
    async getAddress() {
        return this.address || (this.address = (await this.createStateInit()).address),
        this.address
    }
    createCodeCell() {
        if (!this.options.code)
            throw new Error("Contract: options.code is not defined");
        return this.options.code
    }
    createDataCell() {
        return new Cell$o
    }
    async createStateInit() {
        const S = this.createCodeCell()
          , E = this.createDataCell()
          , M = Ar.createStateInit(S, E)
          , T = await M.hash()
          , $ = new Address$c(this.options.wc + ":" + bytesToHex$5(T));
        return {
            stateInit: M,
            address: $,
            code: S,
            data: E
        }
    }
    static createStateInit(S, E, M=null, T=null, $=null) {
        if (M)
            throw "Library in state init is not implemented";
        if (T)
            throw "Split depth in state init is not implemented";
        if ($)
            throw "Ticktock in state init is not implemented";
        const B = new Cell$o;
        return B.bits.writeBitArray([!!T, !!$, !!S, !!E, !!M]),
        S && B.refs.push(S),
        E && B.refs.push(E),
        M && B.refs.push(M),
        B
    }
    static createInternalMessageHeader(S, E=0, M=!0, T=null, $=!1, B=null, O=null, F=0, N=0, U=0, H=0) {
        const Z = new Cell$o;
        if (Z.bits.writeBit(!1),
        Z.bits.writeBit(M),
        T !== null ? Z.bits.writeBit(T) : Z.bits.writeBit(new Address$c(S).isBounceable),
        Z.bits.writeBit($),
        Z.bits.writeAddress(B ? new Address$c(B) : null),
        Z.bits.writeAddress(new Address$c(S)),
        Z.bits.writeGrams(E),
        O)
            throw "Currency collections are not implemented yet";
        return Z.bits.writeBit(!!O),
        Z.bits.writeGrams(F),
        Z.bits.writeGrams(N),
        Z.bits.writeUint(U, 64),
        Z.bits.writeUint(H, 32),
        Z
    }
    static createExternalMessageHeader(S, E=null, M=0) {
        const T = new Cell$o;
        return T.bits.writeUint(2, 2),
        T.bits.writeAddress(E ? new Address$c(E) : null),
        T.bits.writeAddress(new Address$c(S)),
        T.bits.writeGrams(M),
        T
    }
    static createOutMsg(S, E, M, T=null) {
        let $ = new Cell$o;
        M && (M.refs ? $ = M : typeof M == "string" ? M.length > 0 && ($.bits.writeUint(0, 32),
        $.bits.writeString(M)) : $.bits.writeBytes(M));
        const B = Ar.createInternalMessageHeader(new Address$c(S), new BN$f(E));
        return Ar.createCommonMsgInfo(B, T, $)
    }
    static createCommonMsgInfo(S, E=null, M=null) {
        const T = new Cell$o;
        return T.writeCell(S),
        E ? (T.bits.writeBit(!0),
        T.bits.writeBit(!0),
        T.refs.push(E)) : T.bits.writeBit(!1),
        M ? T.bits.getFreeBits() >= M.bits.getUsedBits() && T.refs.length + M.refs.length <= 4 ? (T.bits.writeBit(!1),
        T.writeCell(M)) : (T.bits.writeBit(!0),
        T.refs.push(M)) : T.bits.writeBit(!1),
        T
    }
    static createMethod(S, E) {
        return {
            getBody: async()=>(await E).body,
            getQuery: async()=>(await E).message,
            send: async()=>{
                const M = await E
                  , T = bytesToBase64$4(await M.message.toBoc(!1));
                return S.sendBoc(T)
            }
            ,
            estimateFee: async()=>{
                const M = await E
                  , T = M.code ? {
                    address: M.address.toString(!0, !0, !1),
                    body: bytesToBase64$4(await M.body.toBoc(!1)),
                    init_code: bytesToBase64$4(await M.code.toBoc(!1)),
                    init_data: bytesToBase64$4(await M.data.toBoc(!1))
                } : {
                    address: M.address.toString(!0, !0, !0),
                    body: bytesToBase64$4(await M.body.toBoc(!1))
                };
                return S.getEstimateFee(T)
            }
        }
    }
}
;
var contract = {
    Contract: Contract$f
};
const {Cell: Cell$n} = boc$1
  , {Address: Address$b, BN: BN$e, bytesToHex: bytesToHex$4} = utils$1
  , {Contract: Contract$e} = contract;
let AppTon$1 = class {
    constructor(S, E) {
        this.transport = S,
        this.ton = E,
        this.ADDRESS_FORMAT_HEX = 0,
        this.ADDRESS_FORMAT_USER_FRIENDLY = 1,
        this.ADDRESS_FORMAT_URL_SAFE = 2,
        this.ADDRESS_FORMAT_BOUNCEABLE = 4,
        this.ADDRESS_FORMAT_TEST_ONLY = 8
    }
    async getAppConfiguration() {
        const S = await this.transport.send(224, 1, 0, 0);
        return {
            version: "" + S[0] + "." + S[1] + "." + S[2]
        }
    }
    async getPublicKey(S, E) {
        const M = Buffer.alloc(4);
        M.writeInt32BE(S);
        const T = await this.transport.send(224, 2, E ? 1 : 0, 0, M)
          , $ = T[0];
        return {
            publicKey: new Uint8Array(T.slice(1, 1 + $))
        }
    }
    async getAddress(S, E, M) {
        const T = Buffer.alloc(4);
        T.writeInt32BE(S);
        const $ = await this.transport.send(224, 5, E ? 1 : 0, M, T)
          , B = $[0]
          , O = new Uint8Array($.slice(1, 1 + B));
        return {
            address: new Address$b("0:" + bytesToHex$4(O))
        }
    }
    async sign(S, E) {
        const M = Buffer.alloc(4);
        M.writeInt32BE(S);
        const T = Buffer.concat([M, Buffer.from(E)])
          , $ = await this.transport.send(224, 3, 0, 0, T)
          , B = $[0];
        return {
            signature: $.slice(1, 1 + B)
        }
    }
    async transfer(S, E, M, T, $, B) {
        const F = await E.createTransferMessage(null, M, T, $, null, 3, !0)
          , N = Buffer.alloc(4);
        N.writeInt32BE(S);
        const U = Buffer.concat([N, Buffer.from(await F.signingMessage.toBoc())])
          , H = await this.transport.send(224, 4, B, 0, U)
          , Z = H[0]
          , J = H.slice(1, 1 + Z)
          , ie = new Uint8Array(J)
          , oe = new Cell$n;
        oe.bits.writeBytes(ie),
        oe.writeCell(F.signingMessage);
        let ae = null
          , se = null
          , le = null;
        if ($ === 0) {
            const we = await E.createStateInit();
            ae = we.stateInit,
            se = we.code,
            le = we.data
        }
        const de = await E.getAddress()
          , fe = Contract$e.createExternalMessageHeader(de)
          , pe = Contract$e.createCommonMsgInfo(fe, ae, oe)
          , ge = new Promise(we=>{
            we({
                address: de,
                message: pe,
                body: oe,
                signature: ie,
                signingMessage: F.signingMessage,
                stateInit: ae,
                code: se,
                data: le
            })
        }
        );
        return Contract$e.createMethod(this.ton.provider, ge)
    }
}
;
var AppTon_1 = AppTon$1
  , providers = {}
  , HttpProviderUtils$2 = {};
const {BN: BN$d, base64ToBytes: base64ToBytes$2} = utils$1
  , {Cell: Cell$m} = boc$1;
let HttpProviderUtils$1 = class Cr {
    static parseObject(S) {
        const E = S["@type"];
        switch (E) {
        case "tvm.list":
        case "tvm.tuple":
            return S.elements.map(Cr.parseObject);
        case "tvm.cell":
            return Cell$m.oneFromBoc(base64ToBytes$2(S.bytes));
        case "tvm.stackEntryCell":
            return Cr.parseObject(S.cell);
        case "tvm.stackEntryTuple":
            return Cr.parseObject(S.tuple);
        case "tvm.stackEntryNumber":
            return Cr.parseObject(S.number);
        case "tvm.numberDecimal":
            return new BN$d(S.number,10);
        default:
            throw new Error("unknown type " + E)
        }
    }
    static parseResponseStack(S) {
        const E = S[0]
          , M = S[1];
        switch (E) {
        case "num":
            return new BN$d(M.replace(/0x/, ""),16);
        case "list":
        case "tuple":
            return Cr.parseObject(M);
        case "cell":
            const T = base64ToBytes$2(M.bytes);
            return Cell$m.oneFromBoc(T);
        default:
            throw new Error("unknown type " + E)
        }
    }
    static parseResponse(S) {
        if (S.exit_code !== 0) {
            const M = new Error("http provider parse response error");
            throw M.result = S,
            M
        }
        const E = S.stack.map(Cr.parseResponseStack);
        return E.length === 1 ? E[0] : E
    }
    static makeArg(S) {
        if (S instanceof BN$d || S instanceof Number)
            return ["num", S];
        throw new Error("unknown arg type " + S)
    }
    static makeArgs(S) {
        return S.map(this.makeArg)
    }
}
;
HttpProviderUtils$2.default = HttpProviderUtils$1;
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$3 = getAugmentedNamespace(__viteBrowserExternal$1)
  , {Cell: Cell$l} = boc$1
  , {base64ToBytes: base64ToBytes$1} = utils$1
  , HttpProviderUtils = HttpProviderUtils$2.default;
typeof fetch > "u" && (fetch = require$$3);
const SHARD_ID_ALL = "-9223372036854775808";
let HttpProvider$1 = class {
    constructor(S, E) {
        this.host = S || "https://toncenter.com/api/v2/jsonRPC",
        this.options = E || {}
    }
    sendImpl(S, E) {
        const M = {
            "Content-Type": "application/json"
        };
        return this.options.apiKey && (M["X-API-Key"] = this.options.apiKey),
        fetch(S, {
            method: "POST",
            headers: M,
            body: JSON.stringify(E)
        }).then(T=>T.json()).then(({result: T, error: $})=>T || Promise.reject($))
    }
    send(S, E) {
        return this.sendImpl(this.host, {
            id: 1,
            jsonrpc: "2.0",
            method: S,
            params: E
        })
    }
    async getAddressInfo(S) {
        return this.send("getAddressInformation", {
            address: S
        })
    }
    async getExtendedAddressInfo(S) {
        return this.send("getExtendedAddressInformation", {
            address: S
        })
    }
    async getWalletInfo(S) {
        return this.send("getWalletInformation", {
            address: S
        })
    }
    async getTransactions(S, E=20, M=void 0, T=void 0, $=void 0, B=void 0) {
        return this.send("getTransactions", {
            address: S,
            limit: E,
            lt: M,
            hash: T,
            to_lt: $,
            archival: B
        })
    }
    async getBalance(S) {
        return this.send("getAddressBalance", {
            address: S
        })
    }
    async sendBoc(S) {
        return this.send("sendBoc", {
            boc: S
        })
    }
    async sendQuery(S) {
        return this.send("sendQuerySimple", S)
    }
    async getEstimateFee(S) {
        return this.send("estimateFee", S)
    }
    async call(S, E, M=[]) {
        return this.send("runGetMethod", {
            address: S,
            method: E,
            stack: M
        })
    }
    async call2(S, E, M=[]) {
        const T = await this.send("runGetMethod", {
            address: S,
            method: E,
            stack: M
        });
        return HttpProviderUtils.parseResponse(T)
    }
    async getConfigParam(S) {
        const E = await this.send("getConfigParam", {
            config_id: S
        });
        if (E["@type"] !== "configInfo")
            throw new Error("getConfigParam expected type configInfo");
        if (!E.config)
            throw new Error("getConfigParam expected config");
        if (E.config["@type"] !== "tvm.cell")
            throw new Error("getConfigParam expected type tvm.cell");
        if (!E.config.bytes)
            throw new Error("getConfigParam expected bytes");
        return Cell$l.oneFromBoc(base64ToBytes$1(E.config.bytes))
    }
    async getMasterchainInfo() {
        return this.send("getMasterchainInfo", {})
    }
    async getBlockShards(S) {
        return this.send("shards", {
            seqno: S
        })
    }
    async getBlockTransactions(S, E, M, T, $, B) {
        return this.send("getBlockTransactions", {
            workchain: S,
            shard: E,
            seqno: M,
            count: T,
            after_lt: $,
            after_hash: B
        })
    }
    async getMasterchainBlockTransactions(S, E, M, T) {
        return this.getBlockTransactions(-1, SHARD_ID_ALL, S, E, M, T)
    }
    async getBlockHeader(S, E, M) {
        return this.send("getBlockHeader", {
            workchain: S,
            shard: E,
            seqno: M
        })
    }
    async getMasterchainBlockHeader(S) {
        return this.getBlockHeader(-1, SHARD_ID_ALL, S)
    }
}
;
HttpProvider$1.SHARD_ID_ALL = SHARD_ID_ALL;
providers.default = HttpProvider$1;
var wallet = {};
const {Contract: Contract$d} = contract
  , {Cell: Cell$k} = boc$1
  , {nacl: nacl$2, stringToBytes, Address: Address$a, BN: BN$c} = utils$1;
let WalletContract$7 = class extends Contract$d {
    constructor(S, E) {
        if (!E.publicKey && !E.address)
            throw new Error("WalletContract required publicKey or address in options");
        super(S, E),
        this.methods = {
            transfer: M=>Contract$d.createMethod(S, this.createTransferMessage(M.secretKey, M.toAddress, M.amount, M.seqno, M.payload, M.sendMode, !M.secretKey, M.stateInit, M.expireAt)),
            transfers: M=>Contract$d.createMethod(S, this.createTransferMessages(M.secretKey, M.seqno, M.messages, !M.secretKey, M.expireAt)),
            seqno: ()=>({
                call: async()=>{
                    const M = await this.getAddress();
                    let T = null;
                    try {
                        T = (await S.call2(M.toString(), "seqno")).toNumber()
                    } catch {}
                    return T
                }
            })
        },
        this.deploy = M=>Contract$d.createMethod(S, this.createInitExternalMessage(M))
    }
    getName() {
        throw new Error("override me")
    }
    createDataCell() {
        const S = new Cell$k;
        return S.bits.writeUint(0, 32),
        S.bits.writeBytes(this.options.publicKey),
        S
    }
    createSigningMessage(S) {
        S = S || 0;
        const E = new Cell$k;
        return E.bits.writeUint(S, 32),
        E
    }
    async createInitExternalMessage(S) {
        if (!this.options.publicKey) {
            const H = nacl$2.sign.keyPair.fromSecretKey(S);
            this.options.publicKey = H.publicKey
        }
        const {stateInit: E, address: M, code: T, data: $} = await this.createStateInit()
          , B = this.createSigningMessage()
          , O = nacl$2.sign.detached(await B.hash(), S)
          , F = new Cell$k;
        F.bits.writeBytes(O),
        F.writeCell(B);
        const N = Contract$d.createExternalMessageHeader(M)
          , U = Contract$d.createCommonMsgInfo(N, E, F);
        return {
            address: M,
            message: U,
            body: F,
            signingMessage: B,
            stateInit: E,
            code: T,
            data: $
        }
    }
    async createExternalMessage(S, E, M, T=!1) {
        const $ = T ? new Uint8Array(64) : nacl$2.sign.detached(await S.hash(), E)
          , B = new Cell$k;
        B.bits.writeBytes($),
        B.writeCell(S);
        let O = null
          , F = null
          , N = null;
        if (M === 0) {
            if (!this.options.publicKey) {
                const ie = nacl$2.sign.keyPair.fromSecretKey(E);
                this.options.publicKey = ie.publicKey
            }
            const J = await this.createStateInit();
            O = J.stateInit,
            F = J.code,
            N = J.data
        }
        const U = await this.getAddress()
          , H = Contract$d.createExternalMessageHeader(U)
          , Z = Contract$d.createCommonMsgInfo(H, O, B);
        return {
            address: U,
            message: Z,
            body: B,
            signature: $,
            signingMessage: S,
            stateInit: O,
            code: F,
            data: N
        }
    }
    async createTransferMessage(S, E, M, T, $="", B=3, O=!1, F=null, N=void 0) {
        if (T == null || T < 0)
            throw new Error("seqno must be number >= 0");
        const U = this.createSigningMessage(T, N);
        return B == null && (B = 3),
        U.bits.writeUint8(B),
        U.refs.push(Contract$d.createOutMsg(E, M, $, F)),
        this.createExternalMessage(U, S, T, O)
    }
    async createTransferMessages(S, E, M, T=!1, $=void 0) {
        if (E == null || E < 0)
            throw new Error("seqno must be number >= 0");
        const B = this.createSigningMessage(E, $);
        if (M.length < 1 || M.length > 4)
            throw new Error("put 1-4 messages");
        for (const O of M) {
            let F = O.sendMode;
            F == null && (F = 3),
            B.bits.writeUint8(F),
            B.refs.push(Contract$d.createOutMsg(O.toAddress, O.amount, O.payload, O.stateInit))
        }
        return this.createExternalMessage(B, S, E, T)
    }
}
;
var WalletContract_1 = {
    WalletContract: WalletContract$7
};
const {Cell: Cell$j} = boc$1
  , {WalletContract: WalletContract$6} = WalletContract_1;
let SimpleWalletContractR1$1 = class extends WalletContract$6 {
    constructor(S, E) {
        E.code = Cell$j.oneFromBoc("B5EE9C72410101010044000084FF0020DDA4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED5441FDF089"),
        super(S, E)
    }
    getName() {
        return "simpleR1"
    }
}
  , SimpleWalletContractR2$1 = class extends WalletContract$6 {
    constructor(S, E) {
        E.code = Cell$j.oneFromBoc("B5EE9C724101010100530000A2FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54D0E2786F"),
        super(S, E)
    }
    getName() {
        return "simpleR2"
    }
}
  , SimpleWalletContractR3$1 = class extends WalletContract$6 {
    constructor(S, E) {
        E.code = Cell$j.oneFromBoc("B5EE9C7241010101005F0000BAFF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54B5B86E42"),
        super(S, E)
    }
    getName() {
        return "simpleR3"
    }
}
;
var WalletContractSimple = {
    SimpleWalletContractR1: SimpleWalletContractR1$1,
    SimpleWalletContractR2: SimpleWalletContractR2$1,
    SimpleWalletContractR3: SimpleWalletContractR3$1
};
const {Cell: Cell$i} = boc$1
  , {WalletContract: WalletContract$5} = WalletContract_1;
class WalletV2ContractBase extends WalletContract$5 {
    createSigningMessage(S, E) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const M = new Cell$i;
        if (M.bits.writeUint(S, 32),
        S === 0)
            for (let T = 0; T < 32; T++)
                M.bits.writeBit(1);
        else
            M.bits.writeUint(E, 32);
        return M
    }
}
let WalletV2ContractR1$1 = class extends WalletV2ContractBase {
    constructor(S, E) {
        E.code = Cell$i.oneFromBoc("B5EE9C724101010100570000AAFF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54A1370BB6"),
        super(S, E)
    }
    getName() {
        return "v2R1"
    }
}
  , WalletV2ContractR2$1 = class extends WalletV2ContractBase {
    constructor(S, E) {
        E.code = Cell$i.oneFromBoc("B5EE9C724101010100630000C2FF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54044CD7A1"),
        super(S, E)
    }
    getName() {
        return "v2R2"
    }
}
;
var WalletContractV2 = {
    WalletV2ContractR1: WalletV2ContractR1$1,
    WalletV2ContractR2: WalletV2ContractR2$1
};
const {BN: BN$b} = utils$1;
function parseWalletV3TransferBody$3(C) {
    if (C.loadBits(512),
    C.loadUint(32).toNumber() !== 698983191)
        throw new Error("invalid walletId");
    const E = C.loadUint(32).toNumber()
      , M = C.loadUint(32).toNumber();
    if (C.loadUint(8).toNumber() !== 3)
        throw new Error("invalid sendMode");
    let $ = C.loadRef();
    if ($.loadBit())
        throw Error("invalid internal header");
    if (!$.loadBit())
        throw Error("invalid ihrDisabled");
    const B = $.loadBit();
    if ($.loadBit())
        throw Error("invalid bounced");
    if ($.loadAddress() !== null)
        throw Error("invalid externalSourceAddress");
    const F = $.loadAddress()
      , N = $.loadCoins();
    if ($.loadBit())
        throw Error("invalid currencyCollection");
    if (!$.loadCoins().eq(new BN$b(0)))
        throw new Error("invalid ihrFees");
    if (!$.loadCoins().eq(new BN$b(0)))
        throw new Error("invalid fwdFees");
    if (!$.loadUint(64).eq(new BN$b(0)))
        throw new Error("invalid createdLt");
    if (!$.loadUint(32).eq(new BN$b(0)))
        throw new Error("invalid createdAt");
    $.loadBit() && $.loadRef();
    let ie = null;
    if ($.getFreeBits() > 0 && ($.loadBit() && ($ = $.loadRef()),
    $.getFreeBits() > 32)) {
        const oe = $.loadUint(32)
          , ae = $.loadBits($.getFreeBits());
        ie = oe.eq(new BN$b(0)) ? new TextDecoder().decode(ae) : ""
    }
    return {
        toAddress: F,
        value: N,
        bounce: B,
        seqno: M,
        expireAt: E,
        payload: ie
    }
}
function parseWalletV3TransferQuery$3(C) {
    const S = C.beginParse();
    if (S.loadUint(2).toNumber() !== 2)
        throw Error("invalid header");
    if (S.loadAddress() !== null)
        throw Error("invalid externalSourceAddress");
    const M = S.loadAddress();
    if (!S.loadCoins().eq(new BN$b(0)))
        throw new Error("invalid externalImportFee");
    S.loadBit() && S.loadBit() && S.loadRef();
    const $ = S.loadBit() ? S.loadRef() : S;
    return {
        fromAddress: M,
        ...parseWalletV3TransferBody$3($)
    }
}
var WalletQueryParser = {
    parseWalletV3TransferQuery: parseWalletV3TransferQuery$3,
    parseWalletV3TransferBody: parseWalletV3TransferBody$3
};
const {Cell: Cell$h} = boc$1
  , {WalletContract: WalletContract$4} = WalletContract_1
  , {parseWalletV3TransferQuery: parseWalletV3TransferQuery$2, parseWalletV3TransferBody: parseWalletV3TransferBody$2} = WalletQueryParser;
class WalletV3ContractBase extends WalletContract$4 {
    createSigningMessage(S, E) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const M = new Cell$h;
        if (M.bits.writeUint(this.options.walletId, 32),
        S === 0)
            for (let T = 0; T < 32; T++)
                M.bits.writeBit(1);
        else
            M.bits.writeUint(E, 32);
        return M.bits.writeUint(S, 32),
        M
    }
    createDataCell() {
        const S = new Cell$h;
        return S.bits.writeUint(0, 32),
        S.bits.writeUint(this.options.walletId, 32),
        S.bits.writeBytes(this.options.publicKey),
        S
    }
}
let WalletV3ContractR1$1 = class extends WalletV3ContractBase {
    constructor(S, E) {
        E.code = Cell$h.oneFromBoc("B5EE9C724101010100620000C0FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED543FBE6EE0"),
        super(S, E),
        this.options.walletId || (this.options.walletId = 698983191 + this.options.wc)
    }
    getName() {
        return "v3R1"
    }
}
;
WalletV3ContractR1$1.parseTransferQuery = parseWalletV3TransferQuery$2;
WalletV3ContractR1$1.parseTransferBody = parseWalletV3TransferBody$2;
let WalletV3ContractR2$1 = class extends WalletV3ContractBase {
    constructor(S, E) {
        E.code = Cell$h.oneFromBoc("B5EE9C724101010100710000DEFF0020DD2082014C97BA218201339CBAB19F71B0ED44D0D31FD31F31D70BFFE304E0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED5410BD6DAD"),
        super(S, E),
        this.options.walletId || (this.options.walletId = 698983191 + this.options.wc)
    }
    getName() {
        return "v3R2"
    }
}
;
WalletV3ContractR2$1.parseTransferQuery = parseWalletV3TransferQuery$2;
WalletV3ContractR2$1.parseTransferBody = parseWalletV3TransferBody$2;
var WalletContractV3 = {
    WalletV3ContractR1: WalletV3ContractR1$1,
    WalletV3ContractR2: WalletV3ContractR2$1
};
const {Cell: Cell$g} = boc$1
  , {WalletContract: WalletContract$3} = WalletContract_1
  , {parseWalletV3TransferQuery: parseWalletV3TransferQuery$1, parseWalletV3TransferBody: parseWalletV3TransferBody$1} = WalletQueryParser;
let WalletV4ContractR1$1 = class extends WalletContract$3 {
    constructor(S, E) {
        E.code = Cell$g.oneFromBoc("B5EE9C72410215010002F5000114FF00F4A413F4BCF2C80B010201200203020148040504F8F28308D71820D31FD31FD31F02F823BBF263ED44D0D31FD31FD3FFF404D15143BAF2A15151BAF2A205F901541064F910F2A3F80024A4C8CB1F5240CB1F5230CBFF5210F400C9ED54F80F01D30721C0009F6C519320D74A96D307D402FB00E830E021C001E30021C002E30001C0039130E30D03A4C8CB1F12CB1FCBFF1112131403EED001D0D3030171B0915BE021D749C120915BE001D31F218210706C7567BD228210626C6E63BDB022821064737472BDB0925F03E002FA403020FA4401C8CA07CBFFC9D0ED44D0810140D721F404305C810108F40A6FA131B3925F05E004D33FC8258210706C7567BA9131E30D248210626C6E63BAE30004060708020120090A005001FA00F404308210706C7567831EB17080185005CB0527CF165003FA02F40012CB69CB1F5210CB3F0052F8276F228210626C6E63831EB17080185005CB0527CF1624FA0214CB6A13CB1F5230CB3F01FA02F4000092821064737472BA8E3504810108F45930ED44D0810140D720C801CF16F400C9ED54821064737472831EB17080185004CB0558CF1622FA0212CB6ACB1FCB3F9410345F04E2C98040FB000201200B0C0059BD242B6F6A2684080A06B90FA0218470D4080847A4937D29910CE6903E9FF9837812801B7810148987159F31840201580D0E0011B8C97ED44D0D70B1F8003DB29DFB513420405035C87D010C00B23281F2FFF274006040423D029BE84C600201200F100019ADCE76A26840206B90EB85FFC00019AF1DF6A26840106B90EB858FC0006ED207FA00D4D422F90005C8CA0715CBFFC9D077748018C8CB05CB0222CF165005FA0214CB6B12CCCCC971FB00C84014810108F451F2A702006C810108D718C8542025810108F451F2A782106E6F746570748018C8CB05CB025004CF16821005F5E100FA0213CB6A12CB1FC971FB00020072810108D718305202810108F459F2A7F82582106473747270748018C8CB05CB025005CF16821005F5E100FA0214CB6A13CB1F12CB3FC973FB00000AF400C9ED5446A9F34F"),
        super(S, E),
        this.options.walletId || (this.options.walletId = 698983191 + this.options.wc),
        this.methods.getPublicKey = this.getPublicKey.bind(this)
    }
    getName() {
        return "v4R1"
    }
    createSigningMessage(S, E, M) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const T = new Cell$g;
        if (T.bits.writeUint(this.options.walletId, 32),
        S === 0)
            for (let $ = 0; $ < 32; $++)
                T.bits.writeBit(1);
        else
            T.bits.writeUint(E, 32);
        return T.bits.writeUint(S, 32),
        M || T.bits.writeUint(0, 8),
        T
    }
    createDataCell() {
        const S = new Cell$g;
        return S.bits.writeUint(0, 32),
        S.bits.writeUint(this.options.walletId, 32),
        S.bits.writeBytes(this.options.publicKey),
        S.bits.writeUint(0, 1),
        S
    }
    async getPublicKey() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_public_key")
    }
}
;
WalletV4ContractR1$1.parseTransferQuery = parseWalletV3TransferQuery$1;
WalletV4ContractR1$1.parseTransferBody = parseWalletV3TransferBody$1;
var WalletContractV4 = {
    WalletV4ContractR1: WalletV4ContractR1$1
};
const {Cell: Cell$f} = boc$1
  , {Contract: Contract$c} = contract
  , {Address: Address$9, bytesToHex: bytesToHex$3, BN: BN$a, toNano} = utils$1
  , {WalletContract: WalletContract$2} = WalletContract_1
  , {parseWalletV3TransferQuery, parseWalletV3TransferBody} = WalletQueryParser;
let WalletV4ContractR2$1 = class extends WalletContract$2 {
    constructor(S, E) {
        E.code = Cell$f.oneFromBoc("B5EE9C72410214010002D4000114FF00F4A413F4BCF2C80B010201200203020148040504F8F28308D71820D31FD31FD31F02F823BBF264ED44D0D31FD31FD3FFF404D15143BAF2A15151BAF2A205F901541064F910F2A3F80024A4C8CB1F5240CB1F5230CBFF5210F400C9ED54F80F01D30721C0009F6C519320D74A96D307D402FB00E830E021C001E30021C002E30001C0039130E30D03A4C8CB1F12CB1FCBFF1011121302E6D001D0D3032171B0925F04E022D749C120925F04E002D31F218210706C7567BD22821064737472BDB0925F05E003FA403020FA4401C8CA07CBFFC9D0ED44D0810140D721F404305C810108F40A6FA131B3925F07E005D33FC8258210706C7567BA923830E30D03821064737472BA925F06E30D06070201200809007801FA00F40430F8276F2230500AA121BEF2E0508210706C7567831EB17080185004CB0526CF1658FA0219F400CB6917CB1F5260CB3F20C98040FB0006008A5004810108F45930ED44D0810140D720C801CF16F400C9ED540172B08E23821064737472831EB17080185005CB055003CF1623FA0213CB6ACB1FCB3FC98040FB00925F03E20201200A0B0059BD242B6F6A2684080A06B90FA0218470D4080847A4937D29910CE6903E9FF9837812801B7810148987159F31840201580C0D0011B8C97ED44D0D70B1F8003DB29DFB513420405035C87D010C00B23281F2FFF274006040423D029BE84C600201200E0F0019ADCE76A26840206B90EB85FFC00019AF1DF6A26840106B90EB858FC0006ED207FA00D4D422F90005C8CA0715CBFFC9D077748018C8CB05CB0222CF165005FA0214CB6B12CCCCC973FB00C84014810108F451F2A7020070810108D718FA00D33FC8542047810108F451F2A782106E6F746570748018C8CB05CB025006CF165004FA0214CB6A12CB1FCB3FC973FB0002006C810108D718FA00D33F305224810108F459F2A782106473747270748018C8CB05CB025005CF165003FA0213CB6ACB1F12CB3FC973FB00000AF400C9ED54696225E5"),
        super(S, E),
        this.options.walletId || (this.options.walletId = 698983191 + this.options.wc),
        this.methods.deployAndInstallPlugin = M=>Contract$c.createMethod(S, this.deployAndInstallPlugin(M)),
        this.methods.installPlugin = M=>Contract$c.createMethod(S, this.installPlugin(M)),
        this.methods.removePlugin = M=>Contract$c.createMethod(S, this.removePlugin(M)),
        this.methods.getPublicKey = this.getPublicKey.bind(this),
        this.methods.getWalletId = this.getWalletId.bind(this),
        this.methods.isPluginInstalled = this.isPluginInstalled.bind(this),
        this.methods.getPluginsList = this.getPluginsList.bind(this)
    }
    getName() {
        return "v4R2"
    }
    createSigningMessage(S, E, M) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const T = new Cell$f;
        if (T.bits.writeUint(this.options.walletId, 32),
        S === 0)
            for (let $ = 0; $ < 32; $++)
                T.bits.writeBit(1);
        else
            T.bits.writeUint(E, 32);
        return T.bits.writeUint(S, 32),
        M || T.bits.writeUint(0, 8),
        T
    }
    createDataCell() {
        const S = new Cell$f;
        return S.bits.writeUint(0, 32),
        S.bits.writeUint(this.options.walletId, 32),
        S.bits.writeBytes(this.options.publicKey),
        S.bits.writeUint(0, 1),
        S
    }
    async deployAndInstallPlugin(S) {
        const {secretKey: E, seqno: M, pluginWc: T, amount: $, stateInit: B, body: O, expireAt: F} = S
          , N = this.createSigningMessage(M, F, !0);
        return N.bits.writeUint(1, 8),
        N.bits.writeInt(T, 8),
        N.bits.writeGrams($),
        N.refs.push(B),
        N.refs.push(O),
        this.createExternalMessage(N, E, M, !1)
    }
    async _setPlugin(S, E) {
        const {secretKey: M, seqno: T, amount: $, queryId: B, expireAt: O} = S
          , F = new Address$9(S.pluginAddress)
          , N = this.createSigningMessage(T, O, !0);
        return N.bits.writeUint(E ? 2 : 3, 8),
        N.bits.writeInt(F.wc, 8),
        N.bits.writeBytes(F.hashPart),
        N.bits.writeGrams($ || toNano("0.1")),
        N.bits.writeUint(B || 0, 64),
        this.createExternalMessage(N, M, T, !1)
    }
    async installPlugin(S) {
        return this._setPlugin(S, !0)
    }
    async removePlugin(S) {
        return this._setPlugin(S, !1)
    }
    async getWalletId() {
        const S = await this.getAddress();
        return (await this.provider.call2(S.toString(), "get_subwallet_id")).toNumber()
    }
    async getPublicKey() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_public_key")
    }
    async isPluginInstalled(S) {
        S = new Address$9(S);
        const E = "0x" + bytesToHex$3(S.hashPart)
          , M = await this.getAddress();
        return !(await this.provider.call2(M.toString(), "is_plugin_installed", [["num", S.wc], ["num", E]])).isZero()
    }
    async getPluginsList() {
        const S = T=>T[0].toNumber() + ":" + T[1].toString(16)
          , E = await this.getAddress();
        return (await this.provider.call2(E.toString(), "get_plugin_list")).map(S)
    }
}
;
WalletV4ContractR2$1.parseTransferQuery = parseWalletV3TransferQuery;
WalletV4ContractR2$1.parseTransferBody = parseWalletV3TransferBody;
var WalletContractV4R2 = {
    WalletV4ContractR2: WalletV4ContractR2$1
};
const {SimpleWalletContractR1, SimpleWalletContractR2, SimpleWalletContractR3} = WalletContractSimple
  , {WalletV2ContractR1, WalletV2ContractR2} = WalletContractV2
  , {WalletV3ContractR1, WalletV3ContractR2} = WalletContractV3
  , {WalletV4ContractR1} = WalletContractV4
  , {WalletV4ContractR2} = WalletContractV4R2
  , ALL = {
    simpleR1: SimpleWalletContractR1,
    simpleR2: SimpleWalletContractR2,
    simpleR3: SimpleWalletContractR3,
    v2R1: WalletV2ContractR1,
    v2R2: WalletV2ContractR2,
    v3R1: WalletV3ContractR1,
    v3R2: WalletV3ContractR2,
    v4R1: WalletV4ContractR1,
    v4R2: WalletV4ContractR2
}
  , LIST = [SimpleWalletContractR1, SimpleWalletContractR2, SimpleWalletContractR3, WalletV2ContractR1, WalletV2ContractR2, WalletV3ContractR1, WalletV3ContractR2, WalletV4ContractR1, WalletV4ContractR2];
let Wallets$1 = class {
    constructor(S) {
        this.provider = S,
        this.all = ALL,
        this.list = LIST,
        this.defaultVersion = "v3R1",
        this.default = this.all[this.defaultVersion]
    }
    create(S) {
        return new this.default(this.provider,S)
    }
}
;
Wallets$1.all = ALL;
Wallets$1.list = LIST;
wallet.default = Wallets$1;
var lockup = {};
const {Cell: Cell$e} = boc$1
  , {Address: Address$8, BN: BN$9, base64ToBytes} = utils$1
  , {WalletContract: WalletContract$1} = WalletContract_1
  , WALLET_ID_BASE$1 = 698983191;
let LockupWalletV1$1 = class extends WalletContract$1 {
    constructor(S, E) {
        E.code = Cell$e.oneFromBoc("B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4"),
        super(S, E),
        this.options.walletId || (this.options.walletId = WALLET_ID_BASE$1 + this.options.wc),
        this.methods.getPublicKey = this.getPublicKey.bind(this),
        this.methods.getWalletId = this.getWalletId.bind(this),
        this.methods.getLiquidBalance = this.getLiquidBalance.bind(this),
        this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this),
        this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this)
    }
    getName() {
        return "lockup-0.1"
    }
    createSigningMessage(S, E, M) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const T = new Cell$e;
        if (T.bits.writeUint(this.options.walletId, 32),
        S === 0)
            for (let $ = 0; $ < 32; $++)
                T.bits.writeBit(1);
        else
            T.bits.writeUint(E, 32);
        return T.bits.writeUint(S, 32),
        T
    }
    createDataCell() {
        const S = new Cell$e;
        return S.bits.writeUint(0, 32),
        S.bits.writeUint(this.options.walletId, 32),
        S.bits.writeBytes(this.options.publicKey),
        S.bits.writeBytes(base64ToBytes(this.options.config.config_public_key)),
        this.options.config.allowed_destinations ? (S.bits.writeUint(1, 1),
        S.refs.push(Cell$e.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)))) : S.bits.writeUint(0, 1),
        S.bits.writeGrams(0),
        S.bits.writeUint(0, 1),
        S.bits.writeGrams(0),
        S.bits.writeUint(0, 1),
        S
    }
    async getWalletId() {
        const S = await this.getAddress();
        return (await this.provider.call2(S.toString(), "get_subwallet_id")).toNumber()
    }
    async getPublicKey() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_public_key")
    }
    async getLiquidBalance() {
        const S = await this.getBalances();
        return S[0] - S[1] - S[2]
    }
    async getNominalRestrictedBalance() {
        return await this.getBalances()[1]
    }
    async getNominalLockedBalance() {
        return await this.getBalances()[2]
    }
    async getBalances() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_balances")
    }
}
;
LockupWalletV1$1.WALLET_ID_BASE = WALLET_ID_BASE$1;
var LockupWalletV1_1 = {
    LockupWalletV1: LockupWalletV1$1
};
const {Address: Address$7} = utils$1
  , {Cell: Cell$d} = boc$1
  , SNAKE_DATA_PREFIX = 0
  , CHUNK_DATA_PREFIX = 1
  , ONCHAIN_CONTENT_PREFIX = 0
  , OFFCHAIN_CONTENT_PREFIX = 1
  , serializeUri$1 = C=>new TextEncoder().encode(encodeURI(C))
  , parseUri = C=>new TextDecoder().decode(C)
  , createOffchainUriCell$2 = C=>{
    const S = new Cell$d;
    return S.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8),
    S.bits.writeBytes(serializeUri$1(C)),
    S
}
  , parseOffchainUriCell$4 = C=>{
    if (C.bits.array[0] !== OFFCHAIN_CONTENT_PREFIX)
        throw new Error("no OFFCHAIN_CONTENT_PREFIX");
    let S = 0
      , E = C;
    for (; E; )
        S += E.bits.array.length,
        E = E.refs[0];
    const M = new Uint8Array(S);
    for (S = 0,
    E = C; E; )
        M.set(E.bits.array, S),
        S += E.bits.array.length,
        E = E.refs[0];
    return parseUri(M.slice(1))
}
  , readIntFromBitString = (C,S,E)=>{
    let M = BigInt(0);
    for (let T = 0; T < E; T++)
        M *= BigInt(2),
        M += BigInt(C.get(S + T));
    return M
}
  , parseAddress$a = C=>{
    let S = readIntFromBitString(C.bits, 3, 8);
    S > BigInt(127) && (S = S - BigInt(256));
    const E = readIntFromBitString(C.bits, 11, 256);
    if (S.toString(10) + ":" + E.toString(16) == "0:0")
        return null;
    const M = S.toString(10) + ":" + E.toString(16).padStart(64, "0");
    return new Address$7(M)
}
  , getRoyaltyParams$2 = async(C,S)=>{
    const E = await C.call2(S, "royalty_params")
      , M = E[0].toNumber()
      , T = E[1].toNumber()
      , $ = M / T
      , B = parseAddress$a(E[2]);
    return {
        royalty: $,
        royaltyBase: T,
        royaltyFactor: M,
        royaltyAddress: B
    }
}
;
var NftUtils = {
    SNAKE_DATA_PREFIX,
    CHUNK_DATA_PREFIX,
    ONCHAIN_CONTENT_PREFIX,
    OFFCHAIN_CONTENT_PREFIX,
    parseAddress: parseAddress$a,
    serializeUri: serializeUri$1,
    parseUri,
    createOffchainUriCell: createOffchainUriCell$2,
    parseOffchainUriCell: parseOffchainUriCell$4,
    getRoyaltyParams: getRoyaltyParams$2
};
const {Cell: Cell$c} = boc$1
  , {Address: Address$6, BN: BN$8, bytesToHex: bytesToHex$2} = utils$1
  , {WalletContract} = WalletContract_1
  , {parseAddress: parseAddress$9} = NftUtils
  , {Contract: Contract$b} = contract
  , WALLET_ID_BASE = 268
  , CODE_HEX = "b5ee9c7241021c010003fb000114ff00f4a413f4bcf2c80b01020120030203b8f28308d71820d31fd31fd31f02f823bbf264ed44d0d31fd31fd3ff305abaf2a15033baf2a202f9014033f910f2a3f800db3c20d74ac0018e99ed44ed45ed47915bed67ed65ed648e82db3ced41edf101f2ff9130e2f841a4f861db3c1b1413020148110402012008050201200706020db9846db3cdb3c81b1a0129ba462db3cf845f846f847f848f849f84af84bf84481b0201200e090201620d0a02016a0c0b012fa2c76cf3e9100723281f2fff2743e112040423d029be84c61b000fa25fb513435c2c7e014bad346d9e36fc22470d4080847a4937d29910ce6903e9ff9837812801b7810148987159f318401b02016e100f0019af1df6a26840106b90eb858fc00019adce76a26840206b90eb85ffc003acd06c2220d749c160915be001d0d3030171b0915be0fa4030db3c01d31fd33ff84b5240c705238210a7733acdbab08ea46c12db3c8210f7733acd01708018c8cb055004cf1623fa0213cb6acb1fcb3fc98040fb00e30e1b141201cef84a5240c7050382107258a69bba13b08ed18e2c01fa407fc8ca0002fa4401c8ca07cbffc9d0f8441023810108f441f86420d74ac200209501d430d001deb312e68210f258a69b32708018c8cb055004cf1623fa0213cb6acb1fcb3fc98040fb00db3c925f03e2130066f848f847f846f845c8cb3fcb1fcb1fcb1ff849fa02f84acf16f84bcf16c9f844f843f842f841c8cb1fcb1fcbfff400ccc9ed54025cd307d4d1f823db3c20c2008e9b22c003f2e06421d0d303fa4031fa40f84a5220c705b3925f04e30d9130e201fb001a1503fa21fa4401c8ca07cbffc9d0f844810108f40a6fa1318f5f330172b0c002f2e06501fa003171d721fa0031fa0031d33f31d31f31d30001c000f2e066d3000193d430d0de2171db3c8e2a31d31f302082104e73744bba21821047657424bab121821056744370bab1018210566f7465bab1f2e067e30e70925f03e220c200191716000e9372fb029130e202ea0170db3c8e6d20d749c2008e63d31f21c00022830bbab122811001bab122821047d54391bab1228210595f07bcbab122821069fb306cbab1228210566f7465bab122821056744370bab1f2e06701c00021d749c200b08e15d3073020c06421c077b121c044b101c057b1f2e0689130e29130e2e30d1918001ad31f308210566f7465baf2e067004401fa4401c3ff925b70e001f833206e925b70e0d020d7498307b9925b70e0d70bffba0060f845f846a05210bc923070e0f845f848a05210b99330f849e0f849f849f84513a1f847a904f846f847a9041023a984a1007eed44d0d31f01f861d31f01f862d3ff01f863f40401f864d401d0d33f01f865d31f01f866d31f01f867d31f01f868fa0001f869fa4001f86afa4001f86bd1d10a20c6a7";
let VestingWalletV1$1 = class extends WalletContract {
    constructor(S, E) {
        E.code = Cell$c.oneFromBoc(CODE_HEX),
        super(S, E),
        this.options.walletId || (this.options.walletId = WALLET_ID_BASE + this.options.wc),
        this.methods.getPublicKey = this.getPublicKey.bind(this),
        this.methods.getWalletId = this.getWalletId.bind(this),
        this.methods.getLockedAmount = this.getLockedAmount.bind(this),
        this.methods.getVestingData = this.getVestingData.bind(this),
        this.methods.getWhitelist = this.getWhitelist.bind(this)
    }
    getName() {
        return "vesting-1"
    }
    createSigningMessage(S, E, M) {
        S = S || 0,
        E = E || Math.floor(Date.now() / 1e3) + 60;
        const T = new Cell$c;
        if (T.bits.writeUint(this.options.walletId, 32),
        S === 0)
            for (let $ = 0; $ < 32; $++)
                T.bits.writeBit(1);
        else
            T.bits.writeUint(E, 32);
        return T.bits.writeUint(S, 32),
        T
    }
    createDataCell() {
        if (this.options.walletId !== 0 && !this.options.walletId)
            throw new Error("no walletId");
        if (!this.options.publicKey)
            throw new Error("no publicKey");
        if (!(this.options.publicKey instanceof Uint8Array))
            throw new Error("publicKey not Uint8Array");
        if (this.options.vestingStartTime !== 0 && !this.options.vestingStartTime)
            throw new Error("no vestingStartTime");
        if (this.options.vestingTotalDuration <= 0)
            throw new Error("vestingTotalDuration cant be zero or negative");
        if (!this.options.vestingTotalDuration)
            throw new Error("no vestingTotalDuration");
        if (this.options.vestingTotalDuration > 2 ** 32 - 1)
            throw new Error("vestingTotalDuration > 2^32 - 1");
        if (this.options.unlockPeriod <= 0)
            throw new Error("unlockPeriod cant be zero or negative");
        if (!this.options.unlockPeriod)
            throw new Error("no unlockPeriod");
        if (this.options.unlockPeriod > this.options.vestingTotalDuration)
            throw new Error("unlockPeriod > vestingTotalDuration");
        if (this.options.cliffDuration !== 0 && !this.options.cliffDuration)
            throw new Error("no cliffDuration");
        if (this.options.cliffDuration < 0)
            throw new Error("cliffDuration cant be negative");
        if (this.options.cliffDuration >= this.options.vestingTotalDuration)
            throw new Error("cliffDuration >= vestingTotalDuration");
        if (!new BN$8(this.options.vestingTotalDuration).div(new BN$8(this.options.unlockPeriod)).mul(new BN$8(this.options.unlockPeriod)).eq(new BN$8(this.options.vestingTotalDuration)))
            throw new Error("vestingTotalDuration mod unlockPeriod != 0");
        if (!new BN$8(this.options.cliffDuration).div(new BN$8(this.options.unlockPeriod)).mul(new BN$8(this.options.unlockPeriod)).eq(new BN$8(this.options.cliffDuration)))
            throw new Error("cliffDuration mod unlockPeriod != 0");
        if (!this.options.vestingTotalAmount)
            throw new Error("no vestingTotalAmount");
        if (!this.options.vestingTotalAmount.gt(new BN$8(0)))
            throw new Error("vestingTotalAmount cant be zero");
        if (!this.options.vestingSenderAddress)
            throw new Error("no vestingSenderAddress");
        if (!(this.options.vestingSenderAddress instanceof Address$6))
            throw new Error("vestingSenderAddress not Address");
        if (!this.options.ownerAddress)
            throw new Error("no ownerAddress");
        if (!(this.options.ownerAddress instanceof Address$6))
            throw new Error("ownerAddress not Address");
        const M = new Cell$c;
        M.bits.writeUint(0, 32),
        M.bits.writeUint(this.options.walletId, 32),
        M.bits.writeUint(new BN$8(bytesToHex$2(this.options.publicKey),16), 256),
        M.bits.writeBit(!1);
        const T = new Cell$c;
        return T.bits.writeUint(this.options.vestingStartTime, 64),
        T.bits.writeUint(this.options.vestingTotalDuration, 32),
        T.bits.writeUint(this.options.unlockPeriod, 32),
        T.bits.writeUint(this.options.cliffDuration, 32),
        T.bits.writeCoins(this.options.vestingTotalAmount),
        T.bits.writeAddress(new Address$6(this.options.vestingSenderAddress)),
        T.bits.writeAddress(new Address$6(this.options.ownerAddress)),
        M.refs[0] = T,
        M
    }
    createAddWhitelistBody(S) {
        const {addresses: E, queryId: M} = S
          , T = new Cell$c;
        T.bits.writeUint(1918412443, 32),
        T.bits.writeUint(M || 0, 64),
        T.bits.writeAddress(E[0]);
        let $ = null;
        for (let B = E.length - 1; B >= 1; B--) {
            const O = new Cell$c;
            O.bits.writeAddress(E[B]),
            $ && (O.refs[0] = $),
            $ = O
        }
        return $ && (T.refs[0] = $),
        T
    }
    createInternalTransfer(S) {
        const E = new Cell$c;
        return E.bits.writeUint(2809346765, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeUint8(S.sendMode || 3),
        E.refs.push(Contract$b.createOutMsg(S.address, S.amount, S.payload)),
        E
    }
    async getPublicKey() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_public_key")
    }
    async getWalletId() {
        const S = await this.getAddress();
        return this.provider.call2(S.toString(), "get_subwallet_id")
    }
    async getLockedAmount(S) {
        const E = await this.getAddress();
        return this.provider.call2(E.toString(), "get_locked_amount", [["num", S]])
    }
    async getVestingData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_vesting_data")
          , M = E[0].toNumber()
          , T = E[1].toNumber()
          , $ = E[2].toNumber()
          , B = E[3].toNumber()
          , O = E[4]
          , F = parseAddress$9(E[5])
          , N = parseAddress$9(E[6])
          , U = E[7];
        return {
            vestingStartTime: M,
            vestingTotalDuration: T,
            unlockPeriod: $,
            cliffDuration: B,
            vestingTotalAmount: O,
            vestingSenderAddress: F,
            ownerAddress: N,
            whitelistCell: U
        }
    }
    async getWhitelist() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_whitelist")
          , M = [];
        for (const T of E) {
            if (T.length !== 2)
                throw new Error("invalid whitelist result");
            const $ = T[0]
              , B = T[1]
              , O = new Address$6($.toString(10) + ":" + B.toString(16).padStart(64, "0"));
            M.push(O)
        }
        return M
    }
}
;
VestingWalletV1$1.WALLET_ID_BASE = WALLET_ID_BASE;
VestingWalletV1$1.codeHex = CODE_HEX;
var VestingWalletV1_1 = {
    VestingWalletV1: VestingWalletV1$1
};
const {LockupWalletV1} = LockupWalletV1_1
  , {VestingWalletV1} = VestingWalletV1_1;
lockup.default = {
    LockupWalletV1,
    VestingWalletV1,
    all: {
        "lockup-0.1": LockupWalletV1,
        "vesting-1": VestingWalletV1
    },
    list: [LockupWalletV1, VestingWalletV1]
};
var nft = {};
const {Contract: Contract$a} = contract
  , {Cell: Cell$b} = boc$1
  , {Address: Address$5, bytesToBase64: bytesToBase64$3, BN: BN$7} = utils$1
  , {parseAddress: parseAddress$8} = NftUtils
  , {createOffchainUriCell: createOffchainUriCell$1, serializeUri, parseOffchainUriCell: parseOffchainUriCell$3, getRoyaltyParams: getRoyaltyParams$1} = NftUtils;
let NftCollection$1 = class extends Contract$a {
    constructor(S, E) {
        if (E.wc = 0,
        E.code = E.code || Cell$b.oneFromBoc("B5EE9C724102140100021F000114FF00F4A413F4BCF2C80B0102016202030202CD04050201200E0F04E7D10638048ADF000E8698180B8D848ADF07D201800E98FE99FF6A2687D20699FEA6A6A184108349E9CA829405D47141BAF8280E8410854658056B84008646582A802E78B127D010A65B509E58FE59F80E78B64C0207D80701B28B9E382F970C892E000F18112E001718112E001F181181981E0024060708090201200A0B00603502D33F5313BBF2E1925313BA01FA00D43028103459F0068E1201A44343C85005CF1613CB3FCCCCCCC9ED54925F05E200A6357003D4308E378040F4966FA5208E2906A4208100FABE93F2C18FDE81019321A05325BBF2F402FA00D43022544B30F00623BA9302A402DE04926C21E2B3E6303250444313C85005CF1613CB3FCCCCCCC9ED54002C323401FA40304144C85005CF1613CB3FCCCCCCC9ED54003C8E15D4D43010344130C85005CF1613CB3FCCCCCCC9ED54E05F04840FF2F00201200C0D003D45AF0047021F005778018C8CB0558CF165004FA0213CB6B12CCCCC971FB008002D007232CFFE0A33C5B25C083232C044FD003D0032C03260001B3E401D3232C084B281F2FFF2742002012010110025BC82DF6A2687D20699FEA6A6A182DE86A182C40043B8B5D31ED44D0FA40D33FD4D4D43010245F04D0D431D430D071C8CB0701CF16CCC980201201213002FB5DAFDA89A1F481A67FA9A9A860D883A1A61FA61FF480610002DB4F47DA89A1F481A67FA9A9A86028BE09E008E003E00B01A500C6E"),
        E.royalty > 1)
            throw new Error("royalty > 1");
        E.royaltyBase = 1e3,
        E.royaltyFactor = Math.floor(E.royalty * E.royaltyBase),
        super(S, E),
        this.methods.getCollectionData = this.getCollectionData.bind(this),
        this.methods.getNftItemAddressByIndex = this.getNftItemAddressByIndex.bind(this),
        this.methods.getNftItemContent = this.getNftItemContent.bind(this),
        this.methods.getRoyaltyParams = this.getRoyaltyParams.bind(this)
    }
    createContentCell(S) {
        const E = createOffchainUriCell$1(S.collectionContentUri)
          , M = new Cell$b;
        M.bits.writeBytes(serializeUri(S.nftItemContentBaseUri));
        const T = new Cell$b;
        return T.refs[0] = E,
        T.refs[1] = M,
        T
    }
    createRoyaltyCell(S) {
        const E = new Cell$b;
        return E.bits.writeUint(S.royaltyFactor, 16),
        E.bits.writeUint(S.royaltyBase, 16),
        E.bits.writeAddress(S.royaltyAddress),
        E
    }
    createDataCell() {
        const S = new Cell$b;
        return S.bits.writeAddress(this.options.ownerAddress),
        S.bits.writeUint(0, 64),
        S.refs[0] = this.createContentCell(this.options),
        S.refs[1] = Cell$b.oneFromBoc(this.options.nftItemCodeHex),
        S.refs[2] = this.createRoyaltyCell(this.options),
        S
    }
    createMintBody(S) {
        const E = new Cell$b;
        E.bits.writeUint(1, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeUint(S.itemIndex, 64),
        E.bits.writeCoins(S.amount);
        const M = new Cell$b;
        M.bits.writeAddress(S.itemOwnerAddress);
        const T = new Cell$b;
        return T.bits.writeBytes(serializeUri(S.itemContentUri)),
        M.refs[0] = T,
        E.refs[0] = M,
        E
    }
    createGetRoyaltyParamsBody(S) {
        const E = new Cell$b;
        return E.bits.writeUint(1765620048, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E
    }
    createChangeOwnerBody(S) {
        if (S.newOwnerAddress === void 0)
            throw new Error("Specify newOwnerAddress");
        const E = new Cell$b;
        return E.bits.writeUint(3, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeAddress(S.newOwnerAddress),
        E
    }
    createEditContentBody(S) {
        if (S.royalty > 1)
            throw new Error("royalty > 1");
        S.royaltyBase = 1e3,
        S.royaltyFactor = Math.floor(S.royalty * S.royaltyBase);
        const E = new Cell$b;
        return E.bits.writeUint(4, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.refs[0] = this.createContentCell(S),
        E.refs[1] = this.createRoyaltyCell(S),
        E
    }
    async getCollectionData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_collection_data")
          , M = E[0];
        let T = NaN;
        try {
            T = M.toNumber()
        } catch {}
        const $ = E[1];
        let B = null;
        try {
            B = parseOffchainUriCell$3($)
        } catch {}
        const O = parseAddress$8(E[2]);
        return {
            nextItemIndex: T,
            itemsCount: M,
            ownerAddress: O,
            collectionContentCell: $,
            collectionContentUri: B
        }
    }
    async getNftItemContent(S) {
        const E = await this.getAddress()
          , M = await S.getData();
        if (M.isInitialized) {
            const T = await this.provider.call2(E.toString(), "get_nft_content", [["num", M.itemIndex.toString(10)], ["tvm.Cell", bytesToBase64$3(await M.contentCell.toBoc(!1))]]);
            M.contentUri = null;
            try {
                M.contentUri = parseOffchainUriCell$3(T)
            } catch {}
        }
        return M
    }
    async getNftItemAddressByIndex(S) {
        S = new BN$7(S);
        const E = await this.getAddress()
          , M = await this.provider.call2(E.toString(), "get_nft_address_by_index", [["num", S.toString(10)]]);
        return parseAddress$8(M)
    }
    async getRoyaltyParams() {
        const S = await this.getAddress();
        return getRoyaltyParams$1(this.provider, S.toString())
    }
}
;
var NftCollection_1 = {
    NftCollection: NftCollection$1
};
const {Contract: Contract$9} = contract
  , {Cell: Cell$a} = boc$1
  , {Address: Address$4, BN: BN$6} = utils$1
  , {parseAddress: parseAddress$7, getRoyaltyParams} = NftUtils
  , {parseOffchainUriCell: parseOffchainUriCell$2} = NftUtils
  , NFT_ITEM_CODE_HEX = "B5EE9C7241020D010001D0000114FF00F4A413F4BCF2C80B0102016202030202CE04050009A11F9FE00502012006070201200B0C02D70C8871C02497C0F83434C0C05C6C2497C0F83E903E900C7E800C5C75C87E800C7E800C3C00812CE3850C1B088D148CB1C17CB865407E90350C0408FC00F801B4C7F4CFE08417F30F45148C2EA3A1CC840DD78C9004F80C0D0D0D4D60840BF2C9A884AEB8C097C12103FCBC20080900113E910C1C2EBCB8536001F65135C705F2E191FA4021F001FA40D20031FA00820AFAF0801BA121945315A0A1DE22D70B01C300209206A19136E220C2FFF2E192218E3E821005138D91C85009CF16500BCF16712449145446A0708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00104794102A375BE20A00727082108B77173505C8CBFF5004CF1610248040708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB000082028E3526F0018210D53276DB103744006D71708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB0093303234E25502F003003B3B513434CFFE900835D27080269FC07E90350C04090408F80C1C165B5B60001D00F232CFD633C58073C5B3327B5520BF75041B";
let NftItem$1 = class extends Contract$9 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code || Cell$a.oneFromBoc(NFT_ITEM_CODE_HEX),
        super(S, E),
        this.methods.getData = this.getData.bind(this)
    }
    createDataCell() {
        const S = new Cell$a;
        return S.bits.writeUint(this.options.index, 64),
        S.bits.writeAddress(this.options.collectionAddress),
        S
    }
    async getData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_nft_data")
          , M = E[0].toNumber() === -1
          , T = E[1];
        let $ = NaN;
        try {
            $ = T.toNumber()
        } catch {}
        const B = parseAddress$7(E[2])
          , O = M ? parseAddress$7(E[3]) : null
          , F = E[4];
        let N = null;
        try {
            N = M && B === null ? parseOffchainUriCell$2(F) : null
        } catch {}
        return {
            isInitialized: M,
            index: $,
            itemIndex: T,
            collectionAddress: B,
            ownerAddress: O,
            contentCell: F,
            contentUri: N
        }
    }
    async createTransferBody(S) {
        const E = new Cell$a;
        return E.bits.writeUint(1607220500, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeAddress(S.newOwnerAddress),
        E.bits.writeAddress(S.responseAddress),
        E.bits.writeBit(!1),
        E.bits.writeCoins(S.forwardAmount || new BN$6(0)),
        S.forwardPayload ? S.forwardPayload.refs ? (E.bits.writeBit(!0),
        E.refs.push(S.forwardPayload)) : (E.bits.writeBit(!1),
        E.bits.writeBytes(S.forwardPayload)) : E.bits.writeBit(!1),
        E
    }
    createGetStaticDataBody(S) {
        const E = new Cell$a;
        return E.bits.writeUint(801842850, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E
    }
    async getRoyaltyParams() {
        const S = await this.getAddress();
        return getRoyaltyParams(this.provider, S.toString())
    }
}
;
NftItem$1.codeHex = NFT_ITEM_CODE_HEX;
var NftItem_1 = {
    NftItem: NftItem$1
};
const {Contract: Contract$8} = contract
  , {Cell: Cell$9} = boc$1;
let NftMarketplace$1 = class extends Contract$8 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code || Cell$9.oneFromBoc("B5EE9C7241010401006D000114FF00F4A413F4BCF2C80B01020120020300AAD23221C700915BE0D0D3030171B0915BE0FA40ED44D0FA403012C705F2E19101D31F01C0018E2BFA003001D4D43021F90070C8CA07CBFFC9D077748018C8CB05CB0258CF165004FA0213CB6BCCCCC971FB00915BE20004F2308EF7CCE7"),
        super(S, E)
    }
    createDataCell() {
        const S = new Cell$9;
        return S.bits.writeAddress(this.options.ownerAddress),
        S
    }
}
;
var NftMarketplace_1 = {
    NftMarketplace: NftMarketplace$1
};
const {Contract: Contract$7} = contract
  , {Cell: Cell$8} = boc$1
  , {parseAddress: parseAddress$6} = NftUtils
  , NFT_SALE_HEX_CODE = "B5EE9C7241020A010001B4000114FF00F4A413F4BCF2C80B01020120020302014804050004F2300202CD0607002FA03859DA89A1F481F481F481F401A861A1F401F481F4006101F7D00E8698180B8D8492F82707D201876A2687D207D207D207D006A18116BA4E10159C71D991B1B2990E382C92F837028916382F970FA01698FC1080289C6C8895D7970FAE99F98FD2018201A642802E78B2801E78B00E78B00FD016664F6AA701363804C9B081B2299823878027003698FE99F9810E000C92F857010C0801F5D41081DCD650029285029185F7970E101E87D007D207D0018384008646582A804E78B28B9D090D0A85AD08A500AFD010AE5B564B8FD80384008646582AC678B2803FD010B65B564B8FD80384008646582A802E78B00FD0109E5B564B8FD80381041082FE61E8A10C00C646582A802E78B117D010A65B509E58F8A40900C8C0029A3110471036454012F004E032363704C0038E4782103B9ACA0015BEF2E1C95312C70559C705B1F2E1CA702082105FCC3D14218010C8CB055006CF1622FA0215CB6A14CB1F14CB3F21CF1601CF16CA0021FA02CA00C98100A0FB00E05F06840FF2F0002ACB3F22CF1658CF16CA0021FA02CA00C98100A0FB00AECABAD1";
let NftSale$1 = class extends Contract$7 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code || Cell$8.oneFromBoc(NFT_SALE_HEX_CODE),
        super(S, E),
        this.methods.getData = this.getData.bind(this)
    }
    createDataCell() {
        const S = new Cell$8;
        S.bits.writeAddress(this.options.marketplaceAddress),
        S.bits.writeAddress(this.options.nftAddress),
        S.bits.writeAddress(null),
        S.bits.writeCoins(this.options.fullPrice);
        const E = new Cell$8;
        return E.bits.writeCoins(this.options.marketplaceFee),
        E.bits.writeAddress(this.options.royaltyAddress),
        E.bits.writeCoins(this.options.royaltyAmount),
        S.refs[0] = E,
        S
    }
    async getData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_sale_data")
          , M = parseAddress$6(E[0])
          , T = parseAddress$6(E[1])
          , $ = parseAddress$6(E[2])
          , B = E[3]
          , O = E[4]
          , F = parseAddress$6(E[5])
          , N = E[6];
        return {
            marketplaceAddress: M,
            nftAddress: T,
            nftOwnerAddress: $,
            fullPrice: B,
            marketplaceFee: O,
            royaltyAddress: F,
            royaltyAmount: N
        }
    }
    async createCancelBody(S) {
        const E = new Cell$8;
        return E.bits.writeUint(3, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E
    }
}
;
NftSale$1.codeHex = NFT_SALE_HEX_CODE;
var NftSale_1 = {
    NftSale: NftSale$1
};
const {NftCollection} = NftCollection_1
  , {NftItem} = NftItem_1
  , {NftMarketplace} = NftMarketplace_1
  , {NftSale} = NftSale_1;
nft.default = {
    NftCollection,
    NftItem,
    NftMarketplace,
    NftSale
};
var ft = {};
const {Contract: Contract$6} = contract
  , {Cell: Cell$7} = boc$1
  , {createOffchainUriCell, parseOffchainUriCell: parseOffchainUriCell$1, parseAddress: parseAddress$5} = NftUtils
  , {Address: Address$3, BN: BN$5, bytesToBase64: bytesToBase64$2} = utils$1;
let JettonMinter$1 = class extends Contract$6 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code || Cell$7.oneFromBoc("B5EE9C7241020B010001ED000114FF00F4A413F4BCF2C80B0102016202030202CC040502037A60090A03EFD9910E38048ADF068698180B8D848ADF07D201800E98FE99FF6A2687D007D206A6A18400AA9385D47181A9AA8AAE382F9702480FD207D006A18106840306B90FD001812881A28217804502A906428027D012C678B666664F6AA7041083DEECBEF29385D71811A92E001F1811802600271812F82C207F97840607080093DFC142201B82A1009AA0A01E428027D012C678B00E78B666491646580897A007A00658064907C80383A6465816503E5FFE4E83BC00C646582AC678B28027D0109E5B589666664B8FD80400FE3603FA00FA40F82854120870542013541403C85004FA0258CF1601CF16CCC922C8CB0112F400F400CB00C9F9007074C8CB02CA07CBFFC9D05008C705F2E04A12A1035024C85004FA0258CF16CCCCC9ED5401FA403020D70B01C3008E1F8210D53276DB708010C8CB055003CF1622FA0212CB6ACB1FCB3FC98042FB00915BE200303515C705F2E049FA403059C85004FA0258CF16CCCCC9ED54002E5143C705F2E049D43001C85004FA0258CF16CCCCC9ED54007DADBCF6A2687D007D206A6A183618FC1400B82A1009AA0A01E428027D012C678B00E78B666491646580897A007A00658064FC80383A6465816503E5FFE4E840001FAF16F6A2687D007D206A6A183FAA904051007F09"),
        super(S, E)
    }
    createDataCell() {
        const S = new Cell$7;
        return S.bits.writeCoins(0),
        S.bits.writeAddress(this.options.adminAddress),
        S.refs[0] = createOffchainUriCell(this.options.jettonContentUri),
        S.refs[1] = Cell$7.oneFromBoc(this.options.jettonWalletCodeHex),
        S
    }
    createMintBody(S) {
        const E = new Cell$7;
        E.bits.writeUint(21, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeAddress(S.destination),
        E.bits.writeCoins(S.amount);
        const M = new Cell$7;
        return M.bits.writeUint(395134233, 32),
        M.bits.writeUint(S.queryId || 0, 64),
        M.bits.writeCoins(S.jettonAmount),
        M.bits.writeAddress(null),
        M.bits.writeAddress(null),
        M.bits.writeCoins(new BN$5(0)),
        M.bits.writeBit(!1),
        E.refs[0] = M,
        E
    }
    createChangeAdminBody(S) {
        if (S.newAdminAddress === void 0)
            throw new Error("Specify newAdminAddress");
        const E = new Cell$7;
        return E.bits.writeUint(3, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeAddress(S.newAdminAddress),
        E
    }
    createEditContentBody(S) {
        const E = new Cell$7;
        return E.bits.writeUint(4, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.refs[0] = createOffchainUriCell(S.jettonContentUri),
        E
    }
    async getJettonData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_jetton_data")
          , M = E[0]
          , T = E[1].toNumber() === -1
          , $ = parseAddress$5(E[2])
          , B = E[3];
        let O = null;
        try {
            O = parseOffchainUriCell$1(B)
        } catch {}
        const F = E[4];
        return {
            totalSupply: M,
            isMutable: T,
            adminAddress: $,
            jettonContentCell: B,
            jettonContentUri: O,
            jettonWalletCode: F
        }
    }
    async getJettonWalletAddress(S) {
        const E = await this.getAddress()
          , M = new Cell$7;
        M.bits.writeAddress(S);
        const T = await this.provider.call2(E.toString(), "get_wallet_address", [["tvm.Slice", bytesToBase64$2(await M.toBoc(!1))]]);
        return parseAddress$5(T)
    }
}
;
var JettonMinter_1 = {
    JettonMinter: JettonMinter$1
};
const {Contract: Contract$5} = contract
  , {Cell: Cell$6} = boc$1
  , {parseAddress: parseAddress$4} = NftUtils
  , {BN: BN$4} = utils$1
  , JETTON_WALLET_CODE_HEX = "B5EE9C7241021201000328000114FF00F4A413F4BCF2C80B0102016202030202CC0405001BA0F605DA89A1F401F481F481A8610201D40607020148080900BB0831C02497C138007434C0C05C6C2544D7C0FC02F83E903E900C7E800C5C75C87E800C7E800C00B4C7E08403E29FA954882EA54C4D167C0238208405E3514654882EA58C511100FC02780D60841657C1EF2EA4D67C02B817C12103FCBC2000113E910C1C2EBCB853600201200A0B020120101101F500F4CFFE803E90087C007B51343E803E903E90350C144DA8548AB1C17CB8B04A30BFFCB8B0950D109C150804D50500F214013E809633C58073C5B33248B232C044BD003D0032C032483E401C1D3232C0B281F2FFF274013E903D010C7E801DE0063232C1540233C59C3E8085F2DAC4F3208405E351467232C7C6600C03F73B51343E803E903E90350C0234CFFE80145468017E903E9014D6F1C1551CDB5C150804D50500F214013E809633C58073C5B33248B232C044BD003D0032C0327E401C1D3232C0B281F2FFF274140371C1472C7CB8B0C2BE80146A2860822625A020822625A004AD822860822625A028062849F8C3C975C2C070C008E00D0E0F009ACB3F5007FA0222CF165006CF1625FA025003CF16C95005CC2391729171E25008A813A08208989680AA008208989680A0A014BCF2E2C504C98040FB001023C85004FA0258CF1601CF16CCC9ED5400705279A018A182107362D09CC8CB1F5230CB3F58FA025007CF165007CF16C9718018C8CB0524CF165006FA0215CB6A14CCC971FB0010241023000E10491038375F040076C200B08E218210D53276DB708010C8CB055008CF165004FA0216CB6A12CB1F12CB3FC972FB0093356C21E203C85004FA0258CF1601CF16CCC9ED5400DB3B51343E803E903E90350C01F4CFFE803E900C145468549271C17CB8B049F0BFFCB8B0A0822625A02A8005A805AF3CB8B0E0841EF765F7B232C7C572CFD400FE8088B3C58073C5B25C60063232C14933C59C3E80B2DAB33260103EC01004F214013E809633C58073C5B3327B55200083200835C87B51343E803E903E90350C0134C7E08405E3514654882EA0841EF765F784EE84AC7CB8B174CFCC7E800C04E81408F214013E809633C58073C5B3327B55205ECCF23D";
let JettonWallet$1 = class extends Contract$5 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code || Cell$6.oneFromBoc(JETTON_WALLET_CODE_HEX),
        super(S, E)
    }
    async createTransferBody(S) {
        const E = new Cell$6;
        return E.bits.writeUint(260734629, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeCoins(S.jettonAmount),
        E.bits.writeAddress(S.toAddress),
        E.bits.writeAddress(S.responseAddress),
        E.bits.writeBit(!1),
        E.bits.writeCoins(S.forwardAmount || new BN$4(0)),
        S.forwardPayload ? S.forwardPayload.refs ? (E.bits.writeBit(!0),
        E.refs.push(S.forwardPayload)) : (E.bits.writeBit(!1),
        E.bits.writeBytes(S.forwardPayload)) : E.bits.writeBit(!1),
        E
    }
    async createBurnBody(S) {
        const E = new Cell$6;
        return E.bits.writeUint(1499400124, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeCoins(S.jettonAmount),
        E.bits.writeAddress(S.responseAddress),
        E
    }
    async getData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_wallet_data")
          , M = E[0]
          , T = parseAddress$4(E[1])
          , $ = parseAddress$4(E[2])
          , B = E[3];
        return {
            balance: M,
            ownerAddress: T,
            jettonMinterAddress: $,
            jettonWalletCode: B
        }
    }
}
;
JettonWallet$1.codeHex = JETTON_WALLET_CODE_HEX;
var JettonWallet_1 = {
    JettonWallet: JettonWallet$1
};
const {JettonMinter} = JettonMinter_1
  , {JettonWallet} = JettonWallet_1;
ft.default = {
    JettonMinter,
    JettonWallet
};
const MC_INTERVAL = 10 * 1e3
  , SHARDS_INTERVAL = 1 * 1e3
  , parseShardBlockNumber = C=>({
    workchain: C.workchain,
    shardId: C.shard,
    shardBlockNumber: C.seqno
});
let BlockSubscription$2 = class {
    constructor(S, E, M, T) {
        this.provider = S,
        this.storage = E,
        this.onBlock = M,
        this.startMcBlockNumber = T ? T.startMcBlockNumber : void 0,
        this.mcInterval = (T ? T.mcInterval : void 0) || MC_INTERVAL,
        this.shardsInterval = (T ? T.shardsInterval : void 0) || SHARDS_INTERVAL
    }
    async start() {
        if (this.stop(),
        !this.startMcBlockNumber && (this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno,
        !this.startMcBlockNumber))
            throw new Error("Cannot get start mc block number from provider");
        const S = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);
        if (this.startLT = S.end_lt,
        !this.startLT)
            throw new Error("Cannot get startLT from provider");
        let E = !1;
        const M = async()=>{
            if (!E) {
                E = !0;
                try {
                    const B = await this.storage.getLastMasterchainBlockNumber() || this.startMcBlockNumber;
                    if (!B)
                        throw new Error("no init masterchain block in storage");
                    const O = (await this.provider.getMasterchainInfo()).last.seqno;
                    if (!O)
                        throw new Error("invalid last masterchain block from provider");
                    for (let F = B + 1; F < O; F++) {
                        const N = await this.provider.getBlockShards(F)
                          , U = await this.provider.getMasterchainBlockHeader(F);
                        await this.onBlock(U, N),
                        await this.storage.insertBlocks(F, N.shards.map(parseShardBlockNumber))
                    }
                } catch (B) {
                    console.error(B)
                }
                E = !1
            }
        }
        ;
        this.mcIntervalId = setInterval(()=>M(), this.mcInterval),
        M();
        let T = !1;
        const $ = async()=>{
            if (!T) {
                T = !0;
                try {
                    const B = await this.storage.getUnprocessedShardBlock();
                    if (B) {
                        const {workchain: O, shardId: F, shardBlockNumber: N} = B
                          , U = await this.provider.getBlockHeader(O, F, N);
                        if (U.end_lt < this.startLT)
                            await this.storage.setBlockProcessed(O, F, N, []);
                        else {
                            await this.onBlock(U);
                            const H = U.prev_blocks.map(parseShardBlockNumber);
                            await this.storage.setBlockProcessed(O, F, N, H)
                        }
                    }
                } catch (B) {
                    console.log(B)
                }
                T = !1
            }
        }
        ;
        this.shardsIntervalId = setInterval(()=>$(), this.shardsInterval)
    }
    stop() {
        clearInterval(this.mcIntervalId),
        clearInterval(this.shardsIntervalId)
    }
}
;
var BlockSubscription_1 = {
    BlockSubscription: BlockSubscription$2
};
let InMemoryBlockStorage$2 = class {
    constructor(S) {
        this.masterchainBlocks = {},
        this.shardchainBlocks = {},
        this.logFunction = S
    }
    async insertShardBlocks(S) {
        for (const {workchain: E, shardId: M, shardBlockNumber: T} of S)
            this.shardchainBlocks[E + "_" + M + "_" + T] === void 0 && (this.logFunction && this.logFunction("insert shard " + E + " " + M + " " + T),
            this.shardchainBlocks[E + "_" + M + "_" + T] = !1)
    }
    async insertBlocks(S, E) {
        if (this.logFunction && this.logFunction("mc processed " + S),
        this.masterchainBlocks[S] !== void 0)
            throw new Error("mc already exists " + S);
        this.masterchainBlocks[S] = !0,
        await this.insertShardBlocks(E)
    }
    async getLastMasterchainBlockNumber() {
        return Object.keys(this.masterchainBlocks).map(E=>Number(E)).sort((E,M)=>M - E)[0]
    }
    async setBlockProcessed(S, E, M, T) {
        if (this.logFunction && this.logFunction("shard processed " + S + " " + E + " " + M),
        this.shardchainBlocks[S + "_" + E + "_" + M] === void 0)
            throw new Error("shard not exists " + S + "_" + E + "_" + M);
        this.shardchainBlocks[S + "_" + E + "_" + M] = !0,
        await this.insertShardBlocks(T)
    }
    async getUnprocessedShardBlock() {
        for (let S in this.shardchainBlocks)
            if (this.shardchainBlocks[S] === !1) {
                const E = S.split("_");
                return {
                    workchain: Number(E[0]),
                    shardId: E[1],
                    shardBlockNumber: Number(E[2])
                }
            }
    }
}
;
var InMemoryBlockStorage_1 = {
    InMemoryBlockStorage: InMemoryBlockStorage$2
};
const {BlockSubscription: BlockSubscription$1} = BlockSubscription_1
  , {InMemoryBlockStorage: InMemoryBlockStorage$1} = InMemoryBlockStorage_1;
var blockSubscription = {
    BlockSubscription: BlockSubscription$1,
    InMemoryBlockStorage: InMemoryBlockStorage$1
};
const {Contract: Contract$4} = contract
  , {Cell: Cell$5} = boc$1
  , {hexToBytes: hexToBytes$1, BN: BN$3, nacl: nacl$1, bytesToBase64: bytesToBase64$1} = utils$1;
let SubscriptionContract$1 = class extends Contract$4 {
    constructor(S, E) {
        E.code = Cell$5.oneFromBoc("B5EE9C7241020F01000262000114FF00F4A413F4BCF2C80B0102012002030201480405036AF230DB3C5335A127A904F82327A128A90401BC5135A0F823B913B0F29EF800725210BE945387F0078E855386DB3CA4E2F82302DB3C0B0C0D0202CD06070121A0D0C9B67813F488DE0411F488DE0410130B048FD6D9E05E8698198FD201829846382C74E2F841999E98F9841083239BA395D497803F018B841083AB735BBED9E702984E382D9C74688462F863841083AB735BBED9E70156BA4E09040B0A0A080269F10FD22184093886D9E7C12C1083239BA39384008646582A803678B2801FD010A65B5658F89659FE4B9FD803FC1083239BA396D9E40E0A04F08E8D108C5F0C708210756E6B77DB3CE00AD31F308210706C7567831EB15210BA8F48305324A126A904F82326A127A904BEF27109FA4430A619F833D078D721D70B3F5260A11BBE8E923036F82370708210737562732759DB3C5077DE106910581047103645135042DB3CE0395F076C2232821064737472BA0A0A0D09011A8E897F821064737472DB3CE0300A006821B39982100400000072FB02DE70F8276F118010C8CB055005CF1621FA0214F40013CB6912CB1F830602948100A032DEC901FB000030ED44D0FA40FA40FA00D31FD31FD31FD31FD31FD307D31F30018021FA443020813A98DB3C01A619F833D078D721D70B3FA070F8258210706C7567228018C8CB055007CF165004FA0215CB6A12CB1F13CB3F01FA02CB00C973FB000E0040C8500ACF165008CF165006FA0214CB1F12CB1FCB1FCB1FCB1FCB07CB1FC9ED54005801A615F833D020D70B078100D1BA95810088D721DED307218100DDBA028100DEBA12B1F2E047D33F30A8AB0FE5855AB4"),
        super(S, E),
        this.methods.pay = ()=>Contract$4.createMethod(S, this.createPayExternalMessage()),
        this.methods.getSubscriptionData = this.getSubscriptionData.bind(this)
    }
    createDataCell() {
        const S = new Cell$5;
        return S.bits.writeAddress(this.options.wallet),
        S.bits.writeAddress(this.options.beneficiary),
        S.bits.writeGrams(this.options.amount),
        S.bits.writeUint(this.options.period, 32),
        S.bits.writeUint(this.options.startAt, 32),
        S.bits.writeUint(this.options.timeout, 32),
        S.bits.writeUint(0, 32),
        S.bits.writeUint(0, 32),
        S.bits.writeUint(0, 8),
        S.bits.writeUint(this.options.subscriptionId, 32),
        S
    }
    createBody() {
        const S = new Cell$5;
        return S.bits.writeUint(new BN$3(1886156135).add(new BN$3(2147483648)), 32),
        S
    }
    createSelfDestructBody() {
        const S = new Cell$5;
        return S.bits.writeUint(1685288050, 32),
        S
    }
    async getSubscriptionData() {
        const S = ie=>ie[0].toNumber() + ":" + ie[1].toString(16)
          , E = await this.getAddress()
          , M = await this.provider.call2(E.toString(), "get_subscription_data")
          , T = S(M[0])
          , $ = S(M[1])
          , B = M[2]
          , O = M[3].toNumber()
          , F = M[4].toNumber()
          , N = M[5].toNumber()
          , U = M[6].toNumber()
          , H = M[7].toNumber()
          , Z = M[8].toNumber()
          , J = M[9].toNumber();
        return {
            wallet: T,
            beneficiary: $,
            amount: B,
            period: O,
            startAt: F,
            timeout: N,
            lastPayment: U,
            lastRequest: H,
            failedAttempts: Z,
            subscriptionId: J
        }
    }
    async createPayExternalMessage() {
        const S = await this.getAddress()
          , E = Contract$4.createExternalMessageHeader(S)
          , M = Contract$4.createCommonMsgInfo(E, null, null)
          , T = new Cell$5;
        return T.bits.writeUint(Math.floor(Date.now() / 1e3), 64),
        {
            address: S,
            message: M,
            body: T
        }
    }
}
;
var subscription = {
    SubscriptionContract: SubscriptionContract$1
};
const {Cell: Cell$4} = boc$1
  , writePublicKey$1 = (C,S)=>{
    if (S.length !== 256 / 8)
        throw new Error("invalid publicKey length");
    C.bits.writeBytes(S)
}
  , writeSignature$1 = (C,S)=>{
    if (S.length !== 512 / 8)
        throw new Error("invalid signature length");
    C.bits.writeBytes(S)
}
  , createSignatureCell$1 = C=>{
    const S = new Cell$4;
    return writeSignature$1(S, C),
    S
}
  , writeMayBe = (C,S)=>{
    if (S) {
        if (C.bits.writeBit(1),
        C.refs.length >= 4)
            throw new Error("refs overflow");
        C.refs.push(S)
    } else
        C.bits.writeBit(0)
}
  , writeDict = writeMayBe
  , tag_init$1 = 1768843636
  , tag_cooperative_close$1 = 1131179891
  , tag_cooperative_commit$1 = 1128492404
  , tag_start_uncooperative_close$1 = 1433289580
  , tag_challenge_state$1 = 1130915665
  , tag_settle_conditionals$1 = 1131168622
  , tag_state$1 = 1130910580
  , op_top_up_balance$1 = 1741148801
  , op_init_channel$1 = 235282626
  , op_cooperative_close$1 = 1433884798
  , op_cooperative_commit$1 = 2040604399
  , op_start_uncooperative_close$1 = 521476815
  , op_challenge_quarantined_state$1 = 143567410
  , op_settle_conditionals$1 = 1727459433
  , op_finish_uncooperative_close$1 = 625158801
  , op_channel_closed$1 = -572749638
  , createTopUpBalance$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(op_top_up_balance$1, 32),
    S.bits.writeCoins(C.coinsA),
    S.bits.writeCoins(C.coinsB),
    S
}
  , createInitChannelBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_init$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.bits.writeCoins(C.balanceA),
    S.bits.writeCoins(C.balanceB),
    S
}
  , createCooperativeCloseChannelBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_cooperative_close$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.bits.writeCoins(C.balanceA),
    S.bits.writeCoins(C.balanceB),
    S.bits.writeUint(C.seqnoA, 64),
    S.bits.writeUint(C.seqnoB, 64),
    S
}
  , createCooperativeCommitBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_cooperative_commit$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.bits.writeUint(C.seqnoA, 64),
    S.bits.writeUint(C.seqnoB, 64),
    S
}
  , createConditionalPayment$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeCoins(C.amount),
    S.writeCell(C.condition),
    S
}
  , createSemiChannelBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(C.seqno, 64),
    S.bits.writeCoins(C.sentCoins),
    writeDict(S, C.conditionals),
    S
}
  , createSemiChannelState$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_state$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.writeCell(C.semiChannelBody),
    writeMayBe(S, C.counterpartySemiChannelBody),
    S
}
  , createSignedSemiChannelState$1 = C=>{
    const S = new Cell$4;
    return writeSignature$1(S, C.signature),
    S.writeCell(C.state),
    S
}
  , createStartUncooperativeCloseBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_start_uncooperative_close$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.refs[0] = C.signedSemiChannelStateA,
    S.refs[1] = C.signedSemiChannelStateB,
    S
}
  , createChallengeQuarantinedStateBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_challenge_state$1, 32),
    S.bits.writeUint(C.channelId, 128),
    S.refs[0] = C.signedSemiChannelStateA,
    S.refs[1] = C.signedSemiChannelStateB,
    S
}
  , createSettleConditionalsBody$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(tag_settle_conditionals$1, 32),
    S.bits.writeUint(C.channelId, 128),
    writeDict(S, C.conditionalsToSettle),
    S
}
  , createFinishUncooperativeClose$1 = ()=>{
    const C = new Cell$4;
    return C.bits.writeUint(op_finish_uncooperative_close$1, 32),
    C
}
  , createOneSignature$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(C.op, 32),
    S.bits.writeBit(C.isA),
    writeSignature$1(S, C.signature),
    S.writeCell(C.cell),
    S
}
  , createTwoSignature$1 = C=>{
    const S = new Cell$4;
    return S.bits.writeUint(C.op, 32),
    S.refs[0] = createSignatureCell$1(C.signatureA),
    S.refs[1] = createSignatureCell$1(C.signatureB),
    S.writeCell(C.cell),
    S
}
;
var PaymentUtils = {
    writePublicKey: writePublicKey$1,
    writeSignature: writeSignature$1,
    createSignatureCell: createSignatureCell$1,
    tag_init: tag_init$1,
    tag_cooperative_close: tag_cooperative_close$1,
    tag_cooperative_commit: tag_cooperative_commit$1,
    tag_start_uncooperative_close: tag_start_uncooperative_close$1,
    tag_challenge_state: tag_challenge_state$1,
    tag_settle_conditionals: tag_settle_conditionals$1,
    tag_state: tag_state$1,
    op_top_up_balance: op_top_up_balance$1,
    op_init_channel: op_init_channel$1,
    op_cooperative_close: op_cooperative_close$1,
    op_cooperative_commit: op_cooperative_commit$1,
    op_start_uncooperative_close: op_start_uncooperative_close$1,
    op_challenge_quarantined_state: op_challenge_quarantined_state$1,
    op_settle_conditionals: op_settle_conditionals$1,
    op_finish_uncooperative_close: op_finish_uncooperative_close$1,
    op_channel_closed: op_channel_closed$1,
    createTopUpBalance: createTopUpBalance$1,
    createInitChannelBody: createInitChannelBody$1,
    createCooperativeCloseChannelBody: createCooperativeCloseChannelBody$1,
    createCooperativeCommitBody: createCooperativeCommitBody$1,
    createConditionalPayment: createConditionalPayment$1,
    createSemiChannelBody: createSemiChannelBody$1,
    createSemiChannelState: createSemiChannelState$1,
    createSignedSemiChannelState: createSignedSemiChannelState$1,
    createStartUncooperativeCloseBody: createStartUncooperativeCloseBody$1,
    createChallengeQuarantinedStateBody: createChallengeQuarantinedStateBody$1,
    createSettleConditionalsBody: createSettleConditionalsBody$1,
    createFinishUncooperativeClose: createFinishUncooperativeClose$1,
    createOneSignature: createOneSignature$1,
    createTwoSignature: createTwoSignature$1
};
const {Contract: Contract$3} = contract
  , {Cell: Cell$3} = boc$1
  , {nacl, hexToBytes, BN: BN$2} = utils$1
  , {parseAddress: parseAddress$3} = NftUtils
  , {writePublicKey, writeSignature, createSignatureCell, tag_init, tag_cooperative_close, tag_cooperative_commit, tag_start_uncooperative_close, tag_challenge_state, tag_settle_conditionals, tag_state, op_top_up_balance, op_init_channel, op_cooperative_close, op_cooperative_commit, op_start_uncooperative_close, op_challenge_quarantined_state, op_settle_conditionals, op_finish_uncooperative_close, op_channel_closed, createTopUpBalance, createInitChannelBody, createCooperativeCloseChannelBody, createCooperativeCommitBody, createConditionalPayment, createSemiChannelBody, createSemiChannelState, createSignedSemiChannelState, createStartUncooperativeCloseBody, createChallengeQuarantinedStateBody, createSettleConditionalsBody, createFinishUncooperativeClose, createOneSignature, createTwoSignature} = PaymentUtils
  , PAYMENT_CHANNEL_CODE_HEX = "B5EE9C72410230010007FB000114FF00F4A413F4BCF2C80B0102012002030201480405000AF26C21F0190202CB06070201202E2F020120080902012016170201200A0B0201200C0D0009D3610F80CC001D6B5007434C7FE8034C7CC1BC0FE19E0201580E0F0201201011002D3E11DBC4BE11DBC43232C7FE11DBC47E80B2C7F2407320008B083E1B7B51343480007E187E80007E18BE80007E18F4FFC07E1934FFC07E1974DFC07E19BC01887080A7F4C7C07E1A34C7C07E1A7D01007E1AB7807080E535007E1AF7BE1B2002012012130201201415008D3E13723E11BE117E113E10540132803E10BE80BE10FE8084F2FFC4B2FFF2DFFC02887080A7FE12BE127E121400F2C7C4B2C7FD0037807080E53E12C073253E1333C5B8B27B5520004D1C3C02FE106CFCB8193E803E800C3E1096283E18BE10C0683E18FE10BE10E8006EFCB819BC032000CF1D3C02FE106CFCB819348020C235C6083E4040E4BE1124BE117890CC3E443CB81974C7C060841A5B9A5D2EBCB81A3E118074DFD66EBCB81CBE803E800C3E1094882FBE10D4882FAC3CB819807E18BE18FE12F43E800C3E10BE10E80068006E7CB8199FFE187C0320004120843777222E9C20043232C15401B3C594013E808532DA84B2C7F2DFF2407EC02002012018190201D42B2C0201201A1B0201201E1F0201201C1D00E5473F00BD401D001D401D021F90102D31F01821043436D74BAF2E068F84601D37F59BAF2E072F844544355F910F8454330F910B0F2E065D33FD33F30F84822B9F84922B9B0F2E06C21F86820F869F84A6E915B8E19F84AD0D33FFA003171D721D33F305033BC02BCB1936DF86ADEE2F800F00C8006F3E12F43E800C7E903E900C3E09DBC41CBE10D62F24CC20C1B7BE10FE11963C03FE10BE11A04020BC03DC3E185C3E189C3E18DB7E1ABC032000B51D3C02F5007400750074087E4040B4C7C0608410DB1BDCEEBCB81A3E118074DFD66EBCB81CBE111510D57E443E1150CC3E442C3CB8197E80007E18BE80007E18F4CFF4CFCC3E1208AE7E1248AE6C3CB81B007E1A3E1A7E003C042001C1573F00BF84A6EF2E06AD2008308D71820F9012392F84492F845E24130F910F2E065D31F018210556E436CBAF2E068F84601D37F59BAF2E072D401D08308D71820F901F8444130F910F2E06501D430D08308D71820F901F8454130F910F2E06501820020120222301FED31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE2303205D31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE23032F8485280BEF8495250BEB0524BBE1AB0527ABE19210064B05215BE14B05248BE17B0F2E06970F82305C8CB3F5004FA0215F40015CB3F5004FA0212F400CB1F12CA00CA00C9F86AF00C01C31CFC02FE129BACFCB81AF48020C235C6083E4048E4BE1124BE1178904C3E443CB81974C7C0608410DA19D46EBCB81A3E118074DFD66EBCB81CB5007420C235C6083E407E11104C3E443CB81940750C3420C235C6083E407E11504C3E443CB81940602403F71CFC02FE129BACFCB81AF48020C235C6083E4048E4BE1124BE1178904C3E443CB81974C7C0608410DB10DBAEBCB81A3E118074DFD66EBCB81CBD010C3E12B434CFFE803D0134CFFE803D0134C7FE11DBC4148828083E08EE7CB81BBE11DBC4A83E08EF3CB81C34800C151D5A64D6D4C8F7A2B98E82A49B08B8C3816028292A01FCD31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE2303205D31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE230325339BE5381BEB0F8495250BEB0F8485290BEB02502FE5237BE16B05262BEB0F2E06927C20097F84918BEF2E0699137E222C20097F84813BEF2E0699132E2F84AD0D33FFA00F404D33FFA00F404D31FF8476F105220A0F823BCF2E06FD200D20030B3F2E073209C3537373A5274BC5263BC12B18E11323939395250BC5299BC18B14650134440E25319BAB3F2E06D9130E30D7F05C82627002496F8476F1114A098F8476F1117A00603E203003ECB3F5004FA0215F40012CB3F5004FA0213F400CB1F12CA00CA00C9F86AF00C00620A8020F4966FA5208E213050038020F4666FA1208E1001FA00ED1E15DA119450C3A00B9133E2923430E202926C21E2B31B000C3535075063140038C8CB3F5004FA0212F400CB3F5003FA0213F400CB1FCA00C9F86AF00C00D51D3C02FE129BACFCB81AFE12B434CFFE803D010C74CFFE803D010C74C7CC3E11DBC4283E11DBC4A83E08EE7CB81C7E003E10886808E87E18BE10D400E816287E18FE10F04026BE10BE10E83E189C3E18F7BE10B04026BE10FE10A83E18DC3E18F780693E1A293E1A7C042001F53B7EF4C7C8608419F1F4A06EA4CC7C037808608403818830AEA54C7C03B6CC780C882084155DD61FAEA54C3C0476CC780820841E6849BBEEA54C3C04B6CC7808208407C546B3EEA54C3C0576CC780820840223AA8CAEA54C3C05B6CC7808208419BDBC1A6EA54C3C05F6CC780C60840950CAA46EA53C0636CC78202D0008840FF2F00075BC7FE3A7805FC25E87D007D207D20184100D0CAF6A1EC7C217C21B7817C227C22B7817C237C23FC247C24B7817C2524C3B7818823881B22A021984008DBD0CABA7805FC20C8B870FC253748B8F07C256840206B90FD0018C020EB90FD0018B8EB90E98F987C23B7882908507C11DE491839707C23B788507C23B789507C11DE48B9F03A4331C4966";
var xr;
let PaymentChannel$2 = (xr = class extends Contract$3 {
    constructor(S, E) {
        E.publicKeyA = E.isA ? E.myKeyPair.publicKey : E.hisPublicKey,
        E.publicKeyB = E.isA ? E.hisPublicKey : E.myKeyPair.publicKey,
        E.wc = E.wc || 0,
        E.code = E.code || Cell$3.oneFromBoc(PAYMENT_CHANNEL_CODE_HEX),
        super(S, E)
    }
    createDataCell() {
        var T, $, B;
        const S = new Cell$3;
        S.bits.writeBit(0),
        S.bits.writeCoins(0),
        S.bits.writeCoins(0),
        writePublicKey(S, this.options.publicKeyA),
        writePublicKey(S, this.options.publicKeyB),
        S.bits.writeUint(this.options.channelId, 128);
        const E = new Cell$3;
        E.bits.writeUint(((T = this.options.closingConfig) == null ? void 0 : T.quarantineDuration) || 0, 32),
        E.bits.writeCoins((($ = this.options.closingConfig) == null ? void 0 : $.misbehaviorFine) || new BN$2(0)),
        E.bits.writeUint(((B = this.options.closingConfig) == null ? void 0 : B.conditionalCloseDuration) || 0, 32),
        S.refs[0] = E,
        S.bits.writeUint(0, 32),
        S.bits.writeUint(0, 32),
        S.bits.writeBit(!1);
        const M = new Cell$3;
        return M.bits.writeCoins(this.options.excessFee || new BN$2(0)),
        M.bits.writeAddress(this.options.addressA),
        M.bits.writeAddress(this.options.addressB),
        S.refs[1] = M,
        S
    }
    async createOneSignature(S, E) {
        const M = nacl.sign.detached(await E.hash(), this.options.myKeyPair.secretKey);
        return {
            cell: createOneSignature({
                op: S,
                isA: this.options.isA,
                signature: M,
                cell: E
            }),
            signature: M
        }
    }
    async createTwoSignature(S, E, M) {
        const T = nacl.sign.detached(await M.hash(), this.options.myKeyPair.secretKey)
          , $ = this.options.isA ? T : E
          , B = this.options.isA ? E : T;
        return {
            cell: createTwoSignature({
                op: S,
                signatureA: $,
                signatureB: B,
                cell: M
            }),
            signature: T
        }
    }
    async createTopUpBalance(S) {
        return createTopUpBalance(S)
    }
    async createInitChannel(S) {
        return this.createOneSignature(op_init_channel, createInitChannelBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createCooperativeCloseChannel(S) {
        return S.hisSignature || (S.hisSignature = new Uint8Array(512 / 8)),
        this.createTwoSignature(op_cooperative_close, S.hisSignature, createCooperativeCloseChannelBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createCooperativeCommit(S) {
        return S.hisSignature || (S.hisSignature = new Uint8Array(512 / 8)),
        this.createTwoSignature(op_cooperative_commit, S.hisSignature, createCooperativeCommitBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createSignedSemiChannelState(S) {
        const E = createSemiChannelState({
            channelId: this.options.channelId,
            semiChannelBody: createSemiChannelBody({
                seqno: S.mySeqno,
                sentCoins: S.mySentCoins,
                conditionals: null
            }),
            counterpartySemiChannelBody: S.hisSeqno === void 0 ? null : createSemiChannelBody({
                seqno: S.hisSeqno,
                sentCoins: S.hisSentCoins,
                conditionals: null
            })
        })
          , M = nacl.sign.detached(await E.hash(), this.options.myKeyPair.secretKey);
        return {
            cell: createSignedSemiChannelState({
                signature: M,
                state: E
            }),
            signature: M
        }
    }
    async signState(S) {
        const E = this.options.isA ? S.seqnoA : S.seqnoB
          , M = this.options.isA ? S.seqnoB : S.seqnoA
          , T = this.options.initBalanceA.gt(S.balanceA) ? this.options.initBalanceA.sub(S.balanceA) : new BN$2(0)
          , $ = this.options.initBalanceB.gt(S.balanceB) ? this.options.initBalanceB.sub(S.balanceB) : new BN$2(0)
          , B = this.options.isA ? T : $
          , O = this.options.isA ? $ : T
          , {cell: F, signature: N} = await this.createSignedSemiChannelState({
            mySeqno: E,
            mySentCoins: B,
            hisSeqno: M,
            hisSentCoins: O
        });
        return N
    }
    async verifyState(S, E) {
        const M = this.options.isA ? S.seqnoB : S.seqnoA
          , T = this.options.isA ? S.seqnoA : S.seqnoB
          , $ = this.options.initBalanceA.gt(S.balanceA) ? this.options.initBalanceA.sub(S.balanceA) : new BN$2(0)
          , B = this.options.initBalanceB.gt(S.balanceB) ? this.options.initBalanceB.sub(S.balanceB) : new BN$2(0)
          , O = this.options.isA ? B : $
          , F = this.options.isA ? $ : B
          , U = await createSemiChannelState({
            channelId: this.options.channelId,
            semiChannelBody: createSemiChannelBody({
                seqno: M,
                sentCoins: O,
                conditionals: null
            }),
            counterpartySemiChannelBody: T === void 0 ? null : createSemiChannelBody({
                seqno: T,
                sentCoins: F,
                conditionals: null
            })
        }).hash();
        return nacl.sign.detached.verify(U, E, this.options.isA ? this.options.publicKeyB : this.options.publicKeyA)
    }
    async signClose(S) {
        const {cell: E, signature: M} = await this.createCooperativeCloseChannel(S);
        return M
    }
    async verifyClose(S, E) {
        const T = await (await createCooperativeCloseChannelBody({
            ...S,
            channelId: this.options.channelId
        })).hash();
        return nacl.sign.detached.verify(T, E, this.options.isA ? this.options.publicKeyB : this.options.publicKeyA)
    }
    async createStartUncooperativeClose(S) {
        return this.createOneSignature(op_start_uncooperative_close, createStartUncooperativeCloseBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createChallengeQuarantinedState(S) {
        return this.createOneSignature(op_challenge_quarantined_state, createChallengeQuarantinedStateBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createSettleConditionals(S) {
        return this.createOneSignature(op_settle_conditionals, createSettleConditionalsBody({
            ...S,
            channelId: this.options.channelId
        }))
    }
    async createFinishUncooperativeClose() {
        return createFinishUncooperativeClose()
    }
    async getChannelState() {
        const S = await this.getAddress();
        return (await this.provider.call2(S.toString(), "get_channel_state", [])).toNumber()
    }
    async getData() {
        const S = de=>{
            let fe = de.toString(16);
            return fe.length % 2 !== 0 && (fe = "0" + fe),
            hexToBytes(fe)
        }
          , E = await this.getAddress()
          , M = await this.provider.call2(E.toString(), "get_channel_data", [])
          , T = M[0].toNumber()
          , $ = M[1][0]
          , B = M[1][1]
          , O = S(M[2][0])
          , F = S(M[2][1])
          , N = M[3]
          , U = M[4][0].toNumber()
          , H = M[4][1]
          , Z = M[4][2].toNumber()
          , J = M[5][0]
          , ie = M[5][1]
          , oe = M[6]
          , ae = M[7][0]
          , se = parseAddress$3(M[7][1])
          , le = parseAddress$3(M[7][2]);
        return {
            state: T,
            balanceA: $,
            balanceB: B,
            publicKeyA: O,
            publicKeyB: F,
            channelId: N,
            quarantineDuration: U,
            misbehaviorFine: H,
            conditionalCloseDuration: Z,
            seqnoA: J,
            seqnoB: ie,
            quarantine: oe,
            excessFee: ae,
            addressA: se,
            addressB: le
        }
    }
    fromWallet(S) {
        const {wallet: E, secretKey: M} = S
          , T = ($,B)=>{
            const O = async F=>{
                const N = B ? (await this.createStateInit()).stateInit : null
                  , U = await this.getAddress()
                  , H = await E.methods.seqno().call() || 0
                  , Z = await $;
                return E.methods.transfer({
                    secretKey: M,
                    toAddress: U.toString(!0, !0, !0),
                    amount: F,
                    seqno: H,
                    payload: Z,
                    stateInit: N,
                    sendMode: 3
                })
            }
            ;
            return {
                send: F=>O(F).then(N=>N.send()),
                estimateFee: F=>O(F).then(N=>N.estimateFee())
            }
        }
        ;
        return {
            deploy: ()=>T(null, !0),
            init: $=>T(this.createInitChannel($).then(B=>B.cell)),
            topUp: $=>T(this.createTopUpBalance($)),
            close: $=>T(this.createCooperativeCloseChannel($).then(B=>B.cell)),
            commit: $=>T(this.createCooperativeCommit($).then(B=>B.cell)),
            startUncooperativeClose: $=>T(this.createStartUncooperativeClose($).then(B=>B.cell)),
            challengeQuarantinedState: $=>T(this.createChallengeQuarantinedState($).then(B=>B.cell)),
            settleConditionals: $=>T(this.createSettleConditionals($).then(B=>B.cell)),
            finishUncooperativeClose: ()=>T(this.createFinishUncooperativeClose())
        }
    }
}
,
jt(xr, "STATE_UNINITED", 0),
jt(xr, "STATE_OPEN", 1),
jt(xr, "STATE_CLOSURE_STARTED", 2),
jt(xr, "STATE_SETTLING_CONDITIONALS", 3),
jt(xr, "STATE_AWAITING_FINALIZATION", 4),
xr);
PaymentChannel$2.codeHex = PAYMENT_CHANNEL_CODE_HEX;
var PaymentChannel_1 = {
    PaymentChannel: PaymentChannel$2
};
const {PaymentChannel: PaymentChannel$1} = PaymentChannel_1;
let Payments$1 = class {
    constructor(S) {
        this.provider = S
    }
    createChannel(S) {
        return new PaymentChannel$1(this.provider,S)
    }
}
;
var payments = {
    Payments: Payments$1,
    PaymentChannel: PaymentChannel$1
}
  , errorClasses = {}
  , deserializers = {}
  , addCustomErrorDeserializer = function(C, S) {
    deserializers[C] = S
}
  , createCustomErrorClass = function(C) {
    var S = function(M, T) {
        Object.assign(this, T),
        this.name = C,
        this.message = M || C,
        this.stack = new Error().stack
    };
    return S.prototype = new Error,
    errorClasses[C] = S,
    S
}
  , deserializeError = function(C) {
    if (typeof C == "object" && C) {
        try {
            var S = JSON.parse(C.message);
            S.message && S.name && (C = S)
        } catch {}
        var E = void 0;
        if (typeof C.name == "string") {
            var M = C.name
              , T = deserializers[M];
            if (T)
                E = T(C);
            else {
                var $ = M === "Error" ? Error : errorClasses[M];
                $ || (console.warn("deserializing an unknown class '" + M + "'"),
                $ = createCustomErrorClass(M)),
                E = Object.create($.prototype);
                try {
                    for (var B in C)
                        C.hasOwnProperty(B) && (E[B] = C[B])
                } catch {}
            }
        } else
            E = new Error(C.message);
        return !E.stack && Error.captureStackTrace && Error.captureStackTrace(E, deserializeError),
        E
    }
    return new Error(String(C))
}
  , serializeError = function(C) {
    return C && (typeof C == "object" ? destroyCircular(C, []) : typeof C == "function" ? "[Function: " + (C.name || "anonymous") + "]" : C)
};
function destroyCircular(C, S) {
    var E = {};
    S.push(C);
    for (var M = 0, T = Object.keys(C); M < T.length; M++) {
        var $ = T[M]
          , B = C[$];
        if (typeof B != "function") {
            if (!B || typeof B != "object") {
                E[$] = B;
                continue
            }
            if (S.indexOf(C[$]) === -1) {
                E[$] = destroyCircular(C[$], S.slice(0));
                continue
            }
            E[$] = "[Circular]"
        }
    }
    return typeof C.name == "string" && (E.name = C.name),
    typeof C.message == "string" && (E.message = C.message),
    typeof C.stack == "string" && (E.stack = C.stack),
    E
}
var AccountNameRequiredError = createCustomErrorClass("AccountNameRequired")
  , AccountNotSupported = createCustomErrorClass("AccountNotSupported")
  , AmountRequired = createCustomErrorClass("AmountRequired")
  , BluetoothRequired = createCustomErrorClass("BluetoothRequired")
  , BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp")
  , CantOpenDevice = createCustomErrorClass("CantOpenDevice")
  , CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported")
  , CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported")
  , DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported")
  , DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose")
  , DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine")
  , DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected")
  , DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected")
  , DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected")
  , DeviceHalted = createCustomErrorClass("DeviceHalted")
  , DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid")
  , DeviceSocketFail = createCustomErrorClass("DeviceSocketFail")
  , DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus")
  , DisconnectedDevice = createCustomErrorClass("DisconnectedDevice")
  , DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation")
  , EnpointConfigError = createCustomErrorClass("EnpointConfig")
  , EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData")
  , FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed")
  , FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized")
  , HardResetFail = createCustomErrorClass("HardResetFail")
  , InvalidXRPTag = createCustomErrorClass("InvalidXRPTag")
  , InvalidAddress = createCustomErrorClass("InvalidAddress")
  , InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource")
  , LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError")
  , UnknownMCU = createCustomErrorClass("UnknownMCU")
  , LedgerAPIError = createCustomErrorClass("LedgerAPIError")
  , LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage")
  , LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable")
  , ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled")
  , ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC")
  , ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired")
  , ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired")
  , ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked")
  , ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace")
  , ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace")
  , ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep")
  , NetworkDown = createCustomErrorClass("NetworkDown")
  , NoAddressesFound = createCustomErrorClass("NoAddressesFound")
  , NotEnoughBalance = createCustomErrorClass("NotEnoughBalance")
  , NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate")
  , NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount")
  , NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance")
  , NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated")
  , NoAccessToCamera = createCustomErrorClass("NoAccessToCamera")
  , NotEnoughGas = createCustomErrorClass("NotEnoughGas")
  , NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress")
  , GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate")
  , PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch")
  , PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect")
  , RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty")
  , RecommendUndelegation = createCustomErrorClass("RecommendUndelegation")
  , TimeoutTagged = createCustomErrorClass("TimeoutTagged")
  , UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader")
  , MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard")
  , RecipientRequired = createCustomErrorClass("RecipientRequired")
  , UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive")
  , UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend")
  , UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail")
  , UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash")
  , UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig")
  , UpdateYourApp = createCustomErrorClass("UpdateYourApp")
  , UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange")
  , UserRefusedAddress = createCustomErrorClass("UserRefusedAddress")
  , UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate")
  , UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager")
  , UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice")
  , TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled")
  , TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable")
  , TransportRaceCondition = createCustomErrorClass("TransportRaceCondition")
  , TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired")
  , DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp")
  , WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError")
  , WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed")
  , WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount")
  , WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency")
  , ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP")
  , CantScanQRCode = createCustomErrorClass("CantScanQRCode")
  , FeeNotLoaded = createCustomErrorClass("FeeNotLoaded")
  , FeeRequired = createCustomErrorClass("FeeRequired")
  , FeeTooHigh = createCustomErrorClass("FeeTooHigh")
  , SyncError = createCustomErrorClass("SyncError")
  , PairingFailed = createCustomErrorClass("PairingFailed")
  , GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed")
  , LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx")
  , LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx")
  , FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired")
  , NoDBPathGiven = createCustomErrorClass("NoDBPathGiven")
  , DBWrongPassword = createCustomErrorClass("DBWrongPassword")
  , DBNotReset = createCustomErrorClass("DBNotReset");
function TransportError(C, S) {
    this.name = "TransportError",
    this.message = C,
    this.stack = new Error().stack,
    this.id = S
}
TransportError.prototype = new Error;
addCustomErrorDeserializer("TransportError", function(C) {
    return new TransportError(C.message,C.id)
});
var StatusCodes = {
    PIN_REMAINING_ATTEMPTS: 25536,
    INCORRECT_LENGTH: 26368,
    MISSING_CRITICAL_PARAMETER: 26624,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
    SECURITY_STATUS_NOT_SATISFIED: 27010,
    CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
    INCORRECT_DATA: 27264,
    NOT_ENOUGH_MEMORY_SPACE: 27268,
    REFERENCED_DATA_NOT_FOUND: 27272,
    FILE_ALREADY_EXISTS: 27273,
    INCORRECT_P1_P2: 27392,
    INS_NOT_SUPPORTED: 27904,
    CLA_NOT_SUPPORTED: 28160,
    TECHNICAL_PROBLEM: 28416,
    OK: 36864,
    MEMORY_PROBLEM: 37440,
    NO_EF_SELECTED: 37888,
    INVALID_OFFSET: 37890,
    FILE_NOT_FOUND: 37892,
    INCONSISTENT_FILE: 37896,
    ALGORITHM_NOT_SUPPORTED: 38020,
    INVALID_KCV: 38021,
    CODE_NOT_INITIALIZED: 38914,
    ACCESS_CONDITION_NOT_FULFILLED: 38916,
    CONTRADICTION_SECRET_CODE_STATUS: 38920,
    CONTRADICTION_INVALIDATION: 38928,
    CODE_BLOCKED: 38976,
    MAX_VALUE_REACHED: 38992,
    GP_AUTH_FAILED: 25344,
    LICENSING: 28482,
    HALTED: 28586
};
function getAltStatusMessage(C) {
    switch (C) {
    case 26368:
        return "Incorrect length";
    case 26624:
        return "Missing critical parameter";
    case 27010:
        return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
        return "Condition of use not satisfied (denied by the user?)";
    case 27264:
        return "Invalid data received";
    case 27392:
        return "Invalid parameter received"
    }
    if (28416 <= C && C <= 28671)
        return "Internal error, please report"
}
function TransportStatusError(C) {
    this.name = "TransportStatusError";
    var S = Object.keys(StatusCodes).find(function(T) {
        return StatusCodes[T] === C
    }) || "UNKNOWN_ERROR"
      , E = getAltStatusMessage(C) || S
      , M = C.toString(16);
    this.message = "Ledger device: " + E + " (0x" + M + ")",
    this.stack = new Error().stack,
    this.statusCode = C,
    this.statusText = S
}
TransportStatusError.prototype = new Error;
addCustomErrorDeserializer("TransportStatusError", function(C) {
    return new TransportStatusError(C.statusCode)
});
const dist = Object.freeze(Object.defineProperty({
    __proto__: null,
    AccountNameRequiredError,
    AccountNotSupported,
    AmountRequired,
    BluetoothRequired,
    BtcUnmatchedApp,
    CantOpenDevice,
    CantScanQRCode,
    CashAddrNotSupported,
    CurrencyNotSupported,
    DBNotReset,
    DBWrongPassword,
    DeviceAppVerifyNotSupported,
    DeviceGenuineSocketEarlyClose,
    DeviceHalted,
    DeviceInOSUExpected,
    DeviceNameInvalid,
    DeviceNotGenuineError,
    DeviceOnDashboardExpected,
    DeviceOnDashboardUnexpected,
    DeviceShouldStayInApp,
    DeviceSocketFail,
    DeviceSocketNoBulkStatus,
    DisconnectedDevice,
    DisconnectedDeviceDuringOperation,
    ETHAddressNonEIP,
    EnpointConfigError,
    EthAppPleaseEnableContractData,
    FeeEstimationFailed,
    FeeNotLoaded,
    FeeRequired,
    FeeTooHigh,
    FirmwareNotRecognized,
    FirmwareOrAppUpdateRequired,
    GasLessThanEstimate,
    GenuineCheckFailed,
    HardResetFail,
    InvalidAddress,
    InvalidAddressBecauseDestinationIsAlsoSource,
    InvalidXRPTag,
    LatestMCUInstalledError,
    LedgerAPI4xx,
    LedgerAPI5xx,
    LedgerAPIError,
    LedgerAPIErrorWithMessage,
    LedgerAPINotAvailable,
    MCUNotGenuineToDashboard,
    ManagerAppAlreadyInstalledError,
    ManagerAppDepInstallRequired,
    ManagerAppDepUninstallRequired,
    ManagerAppRelyOnBTCError,
    ManagerDeviceLockedError,
    ManagerFirmwareNotEnoughSpaceError,
    ManagerNotEnoughSpaceError,
    ManagerUninstallBTCDep,
    NetworkDown,
    NoAccessToCamera,
    NoAddressesFound,
    NoDBPathGiven,
    NotEnoughBalance,
    NotEnoughBalanceBecauseDestinationNotCreated,
    NotEnoughBalanceInParentAccount,
    NotEnoughBalanceToDelegate,
    NotEnoughGas,
    NotEnoughSpendableBalance,
    NotSupportedLegacyAddress,
    PairingFailed,
    PasswordIncorrectError,
    PasswordsDontMatchError,
    RecipientRequired,
    RecommendSubAccountsToEmpty,
    RecommendUndelegation,
    StatusCodes,
    SyncError,
    TimeoutTagged,
    TransportError,
    TransportInterfaceNotAvailable,
    TransportOpenUserCancelled,
    TransportRaceCondition,
    TransportStatusError,
    TransportWebUSBGestureRequired,
    UnavailableTezosOriginatedAccountReceive,
    UnavailableTezosOriginatedAccountSend,
    UnexpectedBootloader,
    UnknownMCU,
    UpdateFetchFileFail,
    UpdateIncorrectHash,
    UpdateIncorrectSig,
    UpdateYourApp,
    UserRefusedAddress,
    UserRefusedAllowManager,
    UserRefusedDeviceNameChange,
    UserRefusedFirmwareUpdate,
    UserRefusedOnDevice,
    WebsocketConnectionError,
    WebsocketConnectionFailed,
    WrongAppForCurrency,
    WrongDeviceForAccount,
    addCustomErrorDeserializer,
    createCustomErrorClass,
    deserializeError,
    getAltStatusMessage,
    serializeError
}, Symbol.toStringTag, {
    value: "Module"
}));
class Transport {
    constructor() {
        this.exchangeTimeout = 3e4,
        this.unresponsiveTimeout = 15e3,
        this.deviceModel = null,
        this._events = new EventEmitter$1,
        this.send = async(S,E,M,T,$=Buffer.alloc(0),B=[StatusCodes.OK])=>{
            if ($.length >= 256)
                throw new TransportError("data.length exceed 256 bytes limit. Got: " + $.length,"DataLengthTooBig");
            const O = await this.exchange(Buffer.concat([Buffer.from([S, E, M, T]), Buffer.from([$.length]), $]))
              , F = O.readUInt16BE(O.length - 2);
            if (!B.some(N=>N === F))
                throw new TransportStatusError(F);
            return O
        }
        ,
        this.exchangeBusyPromise = void 0,
        this.exchangeAtomicImpl = async S=>{
            if (this.exchangeBusyPromise)
                throw new TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
            let E;
            const M = new Promise(B=>{
                E = B
            }
            );
            this.exchangeBusyPromise = M;
            let T = !1;
            const $ = setTimeout(()=>{
                T = !0,
                this.emit("unresponsive")
            }
            , this.unresponsiveTimeout);
            try {
                const B = await S();
                return T && this.emit("responsive"),
                B
            } finally {
                clearTimeout($),
                E && E(),
                this.exchangeBusyPromise = null
            }
        }
        ,
        this._appAPIlock = null
    }
    exchange(S) {
        throw new Error("exchange not implemented")
    }
    setScrambleKey(S) {}
    close() {
        return Promise.resolve()
    }
    on(S, E) {
        this._events.on(S, E)
    }
    off(S, E) {
        this._events.removeListener(S, E)
    }
    emit(S, ...E) {
        this._events.emit(S, ...E)
    }
    setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.")
    }
    setExchangeTimeout(S) {
        this.exchangeTimeout = S
    }
    setExchangeUnresponsiveTimeout(S) {
        this.unresponsiveTimeout = S
    }
    static create(S=3e3, E) {
        return new Promise((M,T)=>{
            let $ = !1;
            const B = this.listen({
                next: F=>{
                    $ = !0,
                    B && B.unsubscribe(),
                    O && clearTimeout(O),
                    this.open(F.descriptor, S).then(M, T)
                }
                ,
                error: F=>{
                    O && clearTimeout(O),
                    T(F)
                }
                ,
                complete: ()=>{
                    O && clearTimeout(O),
                    $ || T(new TransportError(this.ErrorMessage_NoDeviceFound,"NoDeviceFound"))
                }
            })
              , O = E ? setTimeout(()=>{
                B.unsubscribe(),
                T(new TransportError(this.ErrorMessage_ListenTimeout,"ListenTimeout"))
            }
            , E) : null
        }
        )
    }
    decorateAppAPIMethods(S, E, M) {
        for (let T of E)
            S[T] = this.decorateAppAPIMethod(T, S[T], S, M)
    }
    decorateAppAPIMethod(S, E, M, T) {
        return async(...$)=>{
            const {_appAPIlock: B} = this;
            if (B)
                return Promise.reject(new TransportError("Ledger Device is busy (lock " + B + ")","TransportLocked"));
            try {
                return this._appAPIlock = S,
                this.setScrambleKey(T),
                await E.apply(M, $)
            } finally {
                this._appAPIlock = null
            }
        }
    }
}
Transport.isSupported = void 0;
Transport.list = void 0;
Transport.listen = void 0;
Transport.open = void 0;
Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
var hidFraming = {};
const require$$0 = getAugmentedNamespace(dist);
Object.defineProperty(hidFraming, "__esModule", {
    value: !0
});
var default_1 = hidFraming.default = void 0
  , _errors$1 = require$$0;
const Tag = 5;
function asUInt16BE(C) {
    const S = Buffer.alloc(2);
    return S.writeUInt16BE(C, 0),
    S
}
const initialAcc = {
    data: Buffer.alloc(0),
    dataLength: 0,
    sequence: 0
}
  , createHIDframing = (C,S)=>({
    makeBlocks(E) {
        let M = Buffer.concat([asUInt16BE(E.length), E]);
        const T = S - 5
          , $ = Math.ceil(M.length / T);
        M = Buffer.concat([M, Buffer.alloc($ * T - M.length + 1).fill(0)]);
        const B = [];
        for (let O = 0; O < $; O++) {
            const F = Buffer.alloc(5);
            F.writeUInt16BE(C, 0),
            F.writeUInt8(Tag, 2),
            F.writeUInt16BE(O, 3);
            const N = M.slice(O * T, (O + 1) * T);
            B.push(Buffer.concat([F, N]))
        }
        return B
    },
    reduceResponse(E, M) {
        let {data: T, dataLength: $, sequence: B} = E || initialAcc;
        if (M.readUInt16BE(0) !== C)
            throw new _errors$1.TransportError("Invalid channel","InvalidChannel");
        if (M.readUInt8(2) !== Tag)
            throw new _errors$1.TransportError("Invalid tag","InvalidTag");
        if (M.readUInt16BE(3) !== B)
            throw new _errors$1.TransportError("Invalid sequence","InvalidSequence");
        E || ($ = M.readUInt16BE(5)),
        B++;
        const O = M.slice(E ? 5 : 7);
        return T = Buffer.concat([T, O]),
        T.length > $ && (T = T.slice(0, $)),
        {
            data: T,
            dataLength: $,
            sequence: B
        }
    },
    getReducedResult(E) {
        if (E && E.dataLength === E.data.length)
            return E.data
    }
});
var _default = createHIDframing;
default_1 = hidFraming.default = _default;
var re$2 = {
    exports: {}
};
const SEMVER_SPEC_VERSION = "2.0.0"
  , MAX_LENGTH$1 = 256
  , MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991
  , MAX_SAFE_COMPONENT_LENGTH = 16
  , MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6
  , RELEASE_TYPES = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var constants$1 = {
    MAX_LENGTH: MAX_LENGTH$1,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
}
  , define_process_env_default = {};
const debug$1 = typeof process$1 == "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...C)=>console.error("SEMVER", ...C) : ()=>{}
;
var debug_1 = debug$1;
(function(C, S) {
    const {MAX_SAFE_COMPONENT_LENGTH: E, MAX_SAFE_BUILD_LENGTH: M, MAX_LENGTH: T} = constants$1
      , $ = debug_1;
    S = C.exports = {};
    const B = S.re = []
      , O = S.safeRe = []
      , F = S.src = []
      , N = S.t = {};
    let U = 0;
    const H = "[a-zA-Z0-9-]"
      , Z = [["\\s", 1], ["\\d", T], [H, M]]
      , J = oe=>{
        for (const [ae,se] of Z)
            oe = oe.split(`${ae}*`).join(`${ae}{0,${se}}`).split(`${ae}+`).join(`${ae}{1,${se}}`);
        return oe
    }
      , ie = (oe,ae,se)=>{
        const le = J(ae)
          , de = U++;
        $(oe, de, ae),
        N[oe] = de,
        F[de] = ae,
        B[de] = new RegExp(ae,se ? "g" : void 0),
        O[de] = new RegExp(le,se ? "g" : void 0)
    }
    ;
    ie("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    ie("NUMERICIDENTIFIERLOOSE", "\\d+"),
    ie("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${H}*`),
    ie("MAINVERSION", `(${F[N.NUMERICIDENTIFIER]})\\.(${F[N.NUMERICIDENTIFIER]})\\.(${F[N.NUMERICIDENTIFIER]})`),
    ie("MAINVERSIONLOOSE", `(${F[N.NUMERICIDENTIFIERLOOSE]})\\.(${F[N.NUMERICIDENTIFIERLOOSE]})\\.(${F[N.NUMERICIDENTIFIERLOOSE]})`),
    ie("PRERELEASEIDENTIFIER", `(?:${F[N.NUMERICIDENTIFIER]}|${F[N.NONNUMERICIDENTIFIER]})`),
    ie("PRERELEASEIDENTIFIERLOOSE", `(?:${F[N.NUMERICIDENTIFIERLOOSE]}|${F[N.NONNUMERICIDENTIFIER]})`),
    ie("PRERELEASE", `(?:-(${F[N.PRERELEASEIDENTIFIER]}(?:\\.${F[N.PRERELEASEIDENTIFIER]})*))`),
    ie("PRERELEASELOOSE", `(?:-?(${F[N.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${F[N.PRERELEASEIDENTIFIERLOOSE]})*))`),
    ie("BUILDIDENTIFIER", `${H}+`),
    ie("BUILD", `(?:\\+(${F[N.BUILDIDENTIFIER]}(?:\\.${F[N.BUILDIDENTIFIER]})*))`),
    ie("FULLPLAIN", `v?${F[N.MAINVERSION]}${F[N.PRERELEASE]}?${F[N.BUILD]}?`),
    ie("FULL", `^${F[N.FULLPLAIN]}$`),
    ie("LOOSEPLAIN", `[v=\\s]*${F[N.MAINVERSIONLOOSE]}${F[N.PRERELEASELOOSE]}?${F[N.BUILD]}?`),
    ie("LOOSE", `^${F[N.LOOSEPLAIN]}$`),
    ie("GTLT", "((?:<|>)?=?)"),
    ie("XRANGEIDENTIFIERLOOSE", `${F[N.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    ie("XRANGEIDENTIFIER", `${F[N.NUMERICIDENTIFIER]}|x|X|\\*`),
    ie("XRANGEPLAIN", `[v=\\s]*(${F[N.XRANGEIDENTIFIER]})(?:\\.(${F[N.XRANGEIDENTIFIER]})(?:\\.(${F[N.XRANGEIDENTIFIER]})(?:${F[N.PRERELEASE]})?${F[N.BUILD]}?)?)?`),
    ie("XRANGEPLAINLOOSE", `[v=\\s]*(${F[N.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F[N.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F[N.XRANGEIDENTIFIERLOOSE]})(?:${F[N.PRERELEASELOOSE]})?${F[N.BUILD]}?)?)?`),
    ie("XRANGE", `^${F[N.GTLT]}\\s*${F[N.XRANGEPLAIN]}$`),
    ie("XRANGELOOSE", `^${F[N.GTLT]}\\s*${F[N.XRANGEPLAINLOOSE]}$`),
    ie("COERCEPLAIN", `(^|[^\\d])(\\d{1,${E}})(?:\\.(\\d{1,${E}}))?(?:\\.(\\d{1,${E}}))?`),
    ie("COERCE", `${F[N.COERCEPLAIN]}(?:$|[^\\d])`),
    ie("COERCEFULL", F[N.COERCEPLAIN] + `(?:${F[N.PRERELEASE]})?(?:${F[N.BUILD]})?(?:$|[^\\d])`),
    ie("COERCERTL", F[N.COERCE], !0),
    ie("COERCERTLFULL", F[N.COERCEFULL], !0),
    ie("LONETILDE", "(?:~>?)"),
    ie("TILDETRIM", `(\\s*)${F[N.LONETILDE]}\\s+`, !0),
    S.tildeTrimReplace = "$1~",
    ie("TILDE", `^${F[N.LONETILDE]}${F[N.XRANGEPLAIN]}$`),
    ie("TILDELOOSE", `^${F[N.LONETILDE]}${F[N.XRANGEPLAINLOOSE]}$`),
    ie("LONECARET", "(?:\\^)"),
    ie("CARETTRIM", `(\\s*)${F[N.LONECARET]}\\s+`, !0),
    S.caretTrimReplace = "$1^",
    ie("CARET", `^${F[N.LONECARET]}${F[N.XRANGEPLAIN]}$`),
    ie("CARETLOOSE", `^${F[N.LONECARET]}${F[N.XRANGEPLAINLOOSE]}$`),
    ie("COMPARATORLOOSE", `^${F[N.GTLT]}\\s*(${F[N.LOOSEPLAIN]})$|^$`),
    ie("COMPARATOR", `^${F[N.GTLT]}\\s*(${F[N.FULLPLAIN]})$|^$`),
    ie("COMPARATORTRIM", `(\\s*)${F[N.GTLT]}\\s*(${F[N.LOOSEPLAIN]}|${F[N.XRANGEPLAIN]})`, !0),
    S.comparatorTrimReplace = "$1$2$3",
    ie("HYPHENRANGE", `^\\s*(${F[N.XRANGEPLAIN]})\\s+-\\s+(${F[N.XRANGEPLAIN]})\\s*$`),
    ie("HYPHENRANGELOOSE", `^\\s*(${F[N.XRANGEPLAINLOOSE]})\\s+-\\s+(${F[N.XRANGEPLAINLOOSE]})\\s*$`),
    ie("STAR", "(<|>)?=?\\s*\\*"),
    ie("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    ie("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
}
)(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({
    loose: !0
})
  , emptyOpts = Object.freeze({})
  , parseOptions$1 = C=>C ? typeof C != "object" ? looseOption : C : emptyOpts;
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/
  , compareIdentifiers$1 = (C,S)=>{
    const E = numeric.test(C)
      , M = numeric.test(S);
    return E && M && (C = +C,
    S = +S),
    C === S ? 0 : E && !M ? -1 : M && !E ? 1 : C < S ? -1 : 1
}
  , rcompareIdentifiers = (C,S)=>compareIdentifiers$1(S, C);
var identifiers$1 = {
    compareIdentifiers: compareIdentifiers$1,
    rcompareIdentifiers
};
const debug = debug_1
  , {MAX_LENGTH, MAX_SAFE_INTEGER} = constants$1
  , {safeRe: re$1, t: t$1} = reExports
  , parseOptions = parseOptions_1
  , {compareIdentifiers} = identifiers$1;
let SemVer$d = class yr {
    constructor(S, E) {
        if (E = parseOptions(E),
        S instanceof yr) {
            if (S.loose === !!E.loose && S.includePrerelease === !!E.includePrerelease)
                return S;
            S = S.version
        } else if (typeof S != "string")
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof S}".`);
        if (S.length > MAX_LENGTH)
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        debug("SemVer", S, E),
        this.options = E,
        this.loose = !!E.loose,
        this.includePrerelease = !!E.includePrerelease;
        const M = S.trim().match(E.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
        if (!M)
            throw new TypeError(`Invalid Version: ${S}`);
        if (this.raw = S,
        this.major = +M[1],
        this.minor = +M[2],
        this.patch = +M[3],
        this.major > MAX_SAFE_INTEGER || this.major < 0)
            throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
            throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
            throw new TypeError("Invalid patch version");
        M[4] ? this.prerelease = M[4].split(".").map(T=>{
            if (/^[0-9]+$/.test(T)) {
                const $ = +T;
                if ($ >= 0 && $ < MAX_SAFE_INTEGER)
                    return $
            }
            return T
        }
        ) : this.prerelease = [],
        this.build = M[5] ? M[5].split(".") : [],
        this.format()
    }
    format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`,
        this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
        this.version
    }
    toString() {
        return this.version
    }
    compare(S) {
        if (debug("SemVer.compare", this.version, this.options, S),
        !(S instanceof yr)) {
            if (typeof S == "string" && S === this.version)
                return 0;
            S = new yr(S,this.options)
        }
        return S.version === this.version ? 0 : this.compareMain(S) || this.comparePre(S)
    }
    compareMain(S) {
        return S instanceof yr || (S = new yr(S,this.options)),
        compareIdentifiers(this.major, S.major) || compareIdentifiers(this.minor, S.minor) || compareIdentifiers(this.patch, S.patch)
    }
    comparePre(S) {
        if (S instanceof yr || (S = new yr(S,this.options)),
        this.prerelease.length && !S.prerelease.length)
            return -1;
        if (!this.prerelease.length && S.prerelease.length)
            return 1;
        if (!this.prerelease.length && !S.prerelease.length)
            return 0;
        let E = 0;
        do {
            const M = this.prerelease[E]
              , T = S.prerelease[E];
            if (debug("prerelease compare", E, M, T),
            M === void 0 && T === void 0)
                return 0;
            if (T === void 0)
                return 1;
            if (M === void 0)
                return -1;
            if (M === T)
                continue;
            return compareIdentifiers(M, T)
        } while (++E)
    }
    compareBuild(S) {
        S instanceof yr || (S = new yr(S,this.options));
        let E = 0;
        do {
            const M = this.build[E]
              , T = S.build[E];
            if (debug("prerelease compare", E, M, T),
            M === void 0 && T === void 0)
                return 0;
            if (T === void 0)
                return 1;
            if (M === void 0)
                return -1;
            if (M === T)
                continue;
            return compareIdentifiers(M, T)
        } while (++E)
    }
    inc(S, E, M) {
        switch (S) {
        case "premajor":
            this.prerelease.length = 0,
            this.patch = 0,
            this.minor = 0,
            this.major++,
            this.inc("pre", E, M);
            break;
        case "preminor":
            this.prerelease.length = 0,
            this.patch = 0,
            this.minor++,
            this.inc("pre", E, M);
            break;
        case "prepatch":
            this.prerelease.length = 0,
            this.inc("patch", E, M),
            this.inc("pre", E, M);
            break;
        case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", E, M),
            this.inc("pre", E, M);
            break;
        case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
            this.minor = 0,
            this.patch = 0,
            this.prerelease = [];
            break;
        case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
            this.patch = 0,
            this.prerelease = [];
            break;
        case "patch":
            this.prerelease.length === 0 && this.patch++,
            this.prerelease = [];
            break;
        case "pre":
            {
                const T = Number(M) ? 1 : 0;
                if (!E && M === !1)
                    throw new Error("invalid increment argument: identifier is empty");
                if (this.prerelease.length === 0)
                    this.prerelease = [T];
                else {
                    let $ = this.prerelease.length;
                    for (; --$ >= 0; )
                        typeof this.prerelease[$] == "number" && (this.prerelease[$]++,
                        $ = -2);
                    if ($ === -1) {
                        if (E === this.prerelease.join(".") && M === !1)
                            throw new Error("invalid increment argument: identifier already exists");
                        this.prerelease.push(T)
                    }
                }
                if (E) {
                    let $ = [E, T];
                    M === !1 && ($ = [E]),
                    compareIdentifiers(this.prerelease[0], E) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = $) : this.prerelease = $
                }
                break
            }
        default:
            throw new Error(`invalid increment argument: ${S}`)
        }
        return this.raw = this.format(),
        this.build.length && (this.raw += `+${this.build.join(".")}`),
        this
    }
}
;
var semver$2 = SemVer$d;
const SemVer$c = semver$2
  , parse$7 = (C,S,E=!1)=>{
    if (C instanceof SemVer$c)
        return C;
    try {
        return new SemVer$c(C,S)
    } catch (M) {
        if (!E)
            return null;
        throw M
    }
}
;
var parse_1 = parse$7;
const parse$6 = parse_1
  , valid$2 = (C,S)=>{
    const E = parse$6(C, S);
    return E ? E.version : null
}
;
var valid_1 = valid$2;
const parse$5 = parse_1
  , clean$1 = (C,S)=>{
    const E = parse$5(C.trim().replace(/^[=v]+/, ""), S);
    return E ? E.version : null
}
;
var clean_1 = clean$1;
const SemVer$b = semver$2
  , inc$1 = (C,S,E,M,T)=>{
    typeof E == "string" && (T = M,
    M = E,
    E = void 0);
    try {
        return new SemVer$b(C instanceof SemVer$b ? C.version : C,E).inc(S, M, T).version
    } catch {
        return null
    }
}
;
var inc_1 = inc$1;
const parse$4 = parse_1
  , diff$2 = (C,S)=>{
    const E = parse$4(C, null, !0)
      , M = parse$4(S, null, !0)
      , T = E.compare(M);
    if (T === 0)
        return null;
    const $ = T > 0
      , B = $ ? E : M
      , O = $ ? M : E
      , F = !!B.prerelease.length;
    if (!!O.prerelease.length && !F)
        return !O.patch && !O.minor ? "major" : B.patch ? "patch" : B.minor ? "minor" : "major";
    const U = F ? "pre" : "";
    return E.major !== M.major ? U + "major" : E.minor !== M.minor ? U + "minor" : E.patch !== M.patch ? U + "patch" : "prerelease"
}
;
var diff_1 = diff$2;
const SemVer$a = semver$2
  , major$1 = (C,S)=>new SemVer$a(C,S).major;
var major_1 = major$1;
const SemVer$9 = semver$2
  , minor$1 = (C,S)=>new SemVer$9(C,S).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2
  , patch$1 = (C,S)=>new SemVer$8(C,S).patch;
var patch_1 = patch$1;
const parse$3 = parse_1
  , prerelease$1 = (C,S)=>{
    const E = parse$3(C, S);
    return E && E.prerelease.length ? E.prerelease : null
}
;
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2
  , compare$b = (C,S,E)=>new SemVer$7(C,E).compare(new SemVer$7(S,E));
var compare_1 = compare$b;
const compare$a = compare_1
  , rcompare$1 = (C,S,E)=>compare$a(S, C, E);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1
  , compareLoose$1 = (C,S)=>compare$9(C, S, !0);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2
  , compareBuild$3 = (C,S,E)=>{
    const M = new SemVer$6(C,E)
      , T = new SemVer$6(S,E);
    return M.compare(T) || M.compareBuild(T)
}
;
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1
  , sort$1 = (C,S)=>C.sort((E,M)=>compareBuild$2(E, M, S));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1
  , rsort$1 = (C,S)=>C.sort((E,M)=>compareBuild$1(M, E, S));
var rsort_1 = rsort$1;
const compare$8 = compare_1
  , gt$4 = (C,S,E)=>compare$8(C, S, E) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1
  , lt$3 = (C,S,E)=>compare$7(C, S, E) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1
  , eq$2 = (C,S,E)=>compare$6(C, S, E) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1
  , neq$2 = (C,S,E)=>compare$5(C, S, E) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1
  , gte$3 = (C,S,E)=>compare$4(C, S, E) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1
  , lte$3 = (C,S,E)=>compare$3(C, S, E) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1
  , neq$1 = neq_1
  , gt$3 = gt_1
  , gte$2 = gte_1
  , lt$2 = lt_1
  , lte$2 = lte_1
  , cmp$1 = (C,S,E,M)=>{
    switch (S) {
    case "===":
        return typeof C == "object" && (C = C.version),
        typeof E == "object" && (E = E.version),
        C === E;
    case "!==":
        return typeof C == "object" && (C = C.version),
        typeof E == "object" && (E = E.version),
        C !== E;
    case "":
    case "=":
    case "==":
        return eq$1(C, E, M);
    case "!=":
        return neq$1(C, E, M);
    case ">":
        return gt$3(C, E, M);
    case ">=":
        return gte$2(C, E, M);
    case "<":
        return lt$2(C, E, M);
    case "<=":
        return lte$2(C, E, M);
    default:
        throw new TypeError(`Invalid operator: ${S}`)
    }
}
;
var cmp_1 = cmp$1;
const SemVer$5 = semver$2
  , parse$2 = parse_1
  , {safeRe: re, t} = reExports
  , coerce$1 = (C,S)=>{
    if (C instanceof SemVer$5)
        return C;
    if (typeof C == "number" && (C = String(C)),
    typeof C != "string")
        return null;
    S = S || {};
    let E = null;
    if (!S.rtl)
        E = C.match(S.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    else {
        const F = S.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let N;
        for (; (N = F.exec(C)) && (!E || E.index + E[0].length !== C.length); )
            (!E || N.index + N[0].length !== E.index + E[0].length) && (E = N),
            F.lastIndex = N.index + N[1].length + N[2].length;
        F.lastIndex = -1
    }
    if (E === null)
        return null;
    const M = E[2]
      , T = E[3] || "0"
      , $ = E[4] || "0"
      , B = S.includePrerelease && E[5] ? `-${E[5]}` : ""
      , O = S.includePrerelease && E[6] ? `+${E[6]}` : "";
    return parse$2(`${M}.${T}.${$}${B}${O}`, S)
}
;
var coerce_1 = coerce$1, iterator$1, hasRequiredIterator;
function requireIterator() {
    return hasRequiredIterator || (hasRequiredIterator = 1,
    iterator$1 = function(C) {
        C.prototype[Symbol.iterator] = function*() {
            for (let S = this.head; S; S = S.next)
                yield S.value
        }
    }
    ),
    iterator$1
}
var yallist = Yallist$1;
Yallist$1.Node = Node$1;
Yallist$1.create = Yallist$1;
function Yallist$1(C) {
    var S = this;
    if (S instanceof Yallist$1 || (S = new Yallist$1),
    S.tail = null,
    S.head = null,
    S.length = 0,
    C && typeof C.forEach == "function")
        C.forEach(function(T) {
            S.push(T)
        });
    else if (arguments.length > 0)
        for (var E = 0, M = arguments.length; E < M; E++)
            S.push(arguments[E]);
    return S
}
Yallist$1.prototype.removeNode = function(C) {
    if (C.list !== this)
        throw new Error("removing node which does not belong to this list");
    var S = C.next
      , E = C.prev;
    return S && (S.prev = E),
    E && (E.next = S),
    C === this.head && (this.head = S),
    C === this.tail && (this.tail = E),
    C.list.length--,
    C.next = null,
    C.prev = null,
    C.list = null,
    S
}
;
Yallist$1.prototype.unshiftNode = function(C) {
    if (C !== this.head) {
        C.list && C.list.removeNode(C);
        var S = this.head;
        C.list = this,
        C.next = S,
        S && (S.prev = C),
        this.head = C,
        this.tail || (this.tail = C),
        this.length++
    }
}
;
Yallist$1.prototype.pushNode = function(C) {
    if (C !== this.tail) {
        C.list && C.list.removeNode(C);
        var S = this.tail;
        C.list = this,
        C.prev = S,
        S && (S.next = C),
        this.tail = C,
        this.head || (this.head = C),
        this.length++
    }
}
;
Yallist$1.prototype.push = function() {
    for (var C = 0, S = arguments.length; C < S; C++)
        push(this, arguments[C]);
    return this.length
}
;
Yallist$1.prototype.unshift = function() {
    for (var C = 0, S = arguments.length; C < S; C++)
        unshift(this, arguments[C]);
    return this.length
}
;
Yallist$1.prototype.pop = function() {
    if (this.tail) {
        var C = this.tail.value;
        return this.tail = this.tail.prev,
        this.tail ? this.tail.next = null : this.head = null,
        this.length--,
        C
    }
}
;
Yallist$1.prototype.shift = function() {
    if (this.head) {
        var C = this.head.value;
        return this.head = this.head.next,
        this.head ? this.head.prev = null : this.tail = null,
        this.length--,
        C
    }
}
;
Yallist$1.prototype.forEach = function(C, S) {
    S = S || this;
    for (var E = this.head, M = 0; E !== null; M++)
        C.call(S, E.value, M, this),
        E = E.next
}
;
Yallist$1.prototype.forEachReverse = function(C, S) {
    S = S || this;
    for (var E = this.tail, M = this.length - 1; E !== null; M--)
        C.call(S, E.value, M, this),
        E = E.prev
}
;
Yallist$1.prototype.get = function(C) {
    for (var S = 0, E = this.head; E !== null && S < C; S++)
        E = E.next;
    if (S === C && E !== null)
        return E.value
}
;
Yallist$1.prototype.getReverse = function(C) {
    for (var S = 0, E = this.tail; E !== null && S < C; S++)
        E = E.prev;
    if (S === C && E !== null)
        return E.value
}
;
Yallist$1.prototype.map = function(C, S) {
    S = S || this;
    for (var E = new Yallist$1, M = this.head; M !== null; )
        E.push(C.call(S, M.value, this)),
        M = M.next;
    return E
}
;
Yallist$1.prototype.mapReverse = function(C, S) {
    S = S || this;
    for (var E = new Yallist$1, M = this.tail; M !== null; )
        E.push(C.call(S, M.value, this)),
        M = M.prev;
    return E
}
;
Yallist$1.prototype.reduce = function(C, S) {
    var E, M = this.head;
    if (arguments.length > 1)
        E = S;
    else if (this.head)
        M = this.head.next,
        E = this.head.value;
    else
        throw new TypeError("Reduce of empty list with no initial value");
    for (var T = 0; M !== null; T++)
        E = C(E, M.value, T),
        M = M.next;
    return E
}
;
Yallist$1.prototype.reduceReverse = function(C, S) {
    var E, M = this.tail;
    if (arguments.length > 1)
        E = S;
    else if (this.tail)
        M = this.tail.prev,
        E = this.tail.value;
    else
        throw new TypeError("Reduce of empty list with no initial value");
    for (var T = this.length - 1; M !== null; T--)
        E = C(E, M.value, T),
        M = M.prev;
    return E
}
;
Yallist$1.prototype.toArray = function() {
    for (var C = new Array(this.length), S = 0, E = this.head; E !== null; S++)
        C[S] = E.value,
        E = E.next;
    return C
}
;
Yallist$1.prototype.toArrayReverse = function() {
    for (var C = new Array(this.length), S = 0, E = this.tail; E !== null; S++)
        C[S] = E.value,
        E = E.prev;
    return C
}
;
Yallist$1.prototype.slice = function(C, S) {
    S = S || this.length,
    S < 0 && (S += this.length),
    C = C || 0,
    C < 0 && (C += this.length);
    var E = new Yallist$1;
    if (S < C || S < 0)
        return E;
    C < 0 && (C = 0),
    S > this.length && (S = this.length);
    for (var M = 0, T = this.head; T !== null && M < C; M++)
        T = T.next;
    for (; T !== null && M < S; M++,
    T = T.next)
        E.push(T.value);
    return E
}
;
Yallist$1.prototype.sliceReverse = function(C, S) {
    S = S || this.length,
    S < 0 && (S += this.length),
    C = C || 0,
    C < 0 && (C += this.length);
    var E = new Yallist$1;
    if (S < C || S < 0)
        return E;
    C < 0 && (C = 0),
    S > this.length && (S = this.length);
    for (var M = this.length, T = this.tail; T !== null && M > S; M--)
        T = T.prev;
    for (; T !== null && M > C; M--,
    T = T.prev)
        E.push(T.value);
    return E
}
;
Yallist$1.prototype.splice = function(C, S, ...E) {
    C > this.length && (C = this.length - 1),
    C < 0 && (C = this.length + C);
    for (var M = 0, T = this.head; T !== null && M < C; M++)
        T = T.next;
    for (var $ = [], M = 0; T && M < S; M++)
        $.push(T.value),
        T = this.removeNode(T);
    T === null && (T = this.tail),
    T !== this.head && T !== this.tail && (T = T.prev);
    for (var M = 0; M < E.length; M++)
        T = insert(this, T, E[M]);
    return $
}
;
Yallist$1.prototype.reverse = function() {
    for (var C = this.head, S = this.tail, E = C; E !== null; E = E.prev) {
        var M = E.prev;
        E.prev = E.next,
        E.next = M
    }
    return this.head = S,
    this.tail = C,
    this
}
;
function insert(C, S, E) {
    var M = S === C.head ? new Node$1(E,null,S,C) : new Node$1(E,S,S.next,C);
    return M.next === null && (C.tail = M),
    M.prev === null && (C.head = M),
    C.length++,
    M
}
function push(C, S) {
    C.tail = new Node$1(S,C.tail,null,C),
    C.head || (C.head = C.tail),
    C.length++
}
function unshift(C, S) {
    C.head = new Node$1(S,null,C.head,C),
    C.tail || (C.tail = C.head),
    C.length++
}
function Node$1(C, S, E, M) {
    if (!(this instanceof Node$1))
        return new Node$1(C,S,E,M);
    this.list = M,
    this.value = C,
    S ? (S.next = this,
    this.prev = S) : this.prev = null,
    E ? (E.prev = this,
    this.next = E) : this.next = null
}
try {
    requireIterator()(Yallist$1)
} catch (C) {}
const Yallist = yallist
  , MAX = Symbol("max")
  , LENGTH = Symbol("length")
  , LENGTH_CALCULATOR = Symbol("lengthCalculator")
  , ALLOW_STALE = Symbol("allowStale")
  , MAX_AGE = Symbol("maxAge")
  , DISPOSE = Symbol("dispose")
  , NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet")
  , LRU_LIST = Symbol("lruList")
  , CACHE = Symbol("cache")
  , UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet")
  , naiveLength = ()=>1;
class LRUCache {
    constructor(S) {
        if (typeof S == "number" && (S = {
            max: S
        }),
        S || (S = {}),
        S.max && (typeof S.max != "number" || S.max < 0))
            throw new TypeError("max must be a non-negative number");
        this[MAX] = S.max || 1 / 0;
        const E = S.length || naiveLength;
        if (this[LENGTH_CALCULATOR] = typeof E != "function" ? naiveLength : E,
        this[ALLOW_STALE] = S.stale || !1,
        S.maxAge && typeof S.maxAge != "number")
            throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = S.maxAge || 0,
        this[DISPOSE] = S.dispose,
        this[NO_DISPOSE_ON_SET] = S.noDisposeOnSet || !1,
        this[UPDATE_AGE_ON_GET] = S.updateAgeOnGet || !1,
        this.reset()
    }
    set max(S) {
        if (typeof S != "number" || S < 0)
            throw new TypeError("max must be a non-negative number");
        this[MAX] = S || 1 / 0,
        trim(this)
    }
    get max() {
        return this[MAX]
    }
    set allowStale(S) {
        this[ALLOW_STALE] = !!S
    }
    get allowStale() {
        return this[ALLOW_STALE]
    }
    set maxAge(S) {
        if (typeof S != "number")
            throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = S,
        trim(this)
    }
    get maxAge() {
        return this[MAX_AGE]
    }
    set lengthCalculator(S) {
        typeof S != "function" && (S = naiveLength),
        S !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = S,
        this[LENGTH] = 0,
        this[LRU_LIST].forEach(E=>{
            E.length = this[LENGTH_CALCULATOR](E.value, E.key),
            this[LENGTH] += E.length
        }
        )),
        trim(this)
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR]
    }
    get length() {
        return this[LENGTH]
    }
    get itemCount() {
        return this[LRU_LIST].length
    }
    rforEach(S, E) {
        E = E || this;
        for (let M = this[LRU_LIST].tail; M !== null; ) {
            const T = M.prev;
            forEachStep(this, S, M, E),
            M = T
        }
    }
    forEach(S, E) {
        E = E || this;
        for (let M = this[LRU_LIST].head; M !== null; ) {
            const T = M.next;
            forEachStep(this, S, M, E),
            M = T
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map(S=>S.key)
    }
    values() {
        return this[LRU_LIST].toArray().map(S=>S.value)
    }
    reset() {
        this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(S=>this[DISPOSE](S.key, S.value)),
        this[CACHE] = new Map,
        this[LRU_LIST] = new Yallist,
        this[LENGTH] = 0
    }
    dump() {
        return this[LRU_LIST].map(S=>isStale(this, S) ? !1 : {
            k: S.key,
            v: S.value,
            e: S.now + (S.maxAge || 0)
        }).toArray().filter(S=>S)
    }
    dumpLru() {
        return this[LRU_LIST]
    }
    set(S, E, M) {
        if (M = M || this[MAX_AGE],
        M && typeof M != "number")
            throw new TypeError("maxAge must be a number");
        const T = M ? Date.now() : 0
          , $ = this[LENGTH_CALCULATOR](E, S);
        if (this[CACHE].has(S)) {
            if ($ > this[MAX])
                return del(this, this[CACHE].get(S)),
                !1;
            const F = this[CACHE].get(S).value;
            return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](S, F.value)),
            F.now = T,
            F.maxAge = M,
            F.value = E,
            this[LENGTH] += $ - F.length,
            F.length = $,
            this.get(S),
            trim(this),
            !0
        }
        const B = new Entry(S,E,$,T,M);
        return B.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](S, E),
        !1) : (this[LENGTH] += B.length,
        this[LRU_LIST].unshift(B),
        this[CACHE].set(S, this[LRU_LIST].head),
        trim(this),
        !0)
    }
    has(S) {
        if (!this[CACHE].has(S))
            return !1;
        const E = this[CACHE].get(S).value;
        return !isStale(this, E)
    }
    get(S) {
        return get(this, S, !0)
    }
    peek(S) {
        return get(this, S, !1)
    }
    pop() {
        const S = this[LRU_LIST].tail;
        return S ? (del(this, S),
        S.value) : null
    }
    del(S) {
        del(this, this[CACHE].get(S))
    }
    load(S) {
        this.reset();
        const E = Date.now();
        for (let M = S.length - 1; M >= 0; M--) {
            const T = S[M]
              , $ = T.e || 0;
            if ($ === 0)
                this.set(T.k, T.v);
            else {
                const B = $ - E;
                B > 0 && this.set(T.k, T.v, B)
            }
        }
    }
    prune() {
        this[CACHE].forEach((S,E)=>get(this, E, !1))
    }
}
const get = (C,S,E)=>{
    const M = C[CACHE].get(S);
    if (M) {
        const T = M.value;
        if (isStale(C, T)) {
            if (del(C, M),
            !C[ALLOW_STALE])
                return
        } else
            E && (C[UPDATE_AGE_ON_GET] && (M.value.now = Date.now()),
            C[LRU_LIST].unshiftNode(M));
        return T.value
    }
}
  , isStale = (C,S)=>{
    if (!S || !S.maxAge && !C[MAX_AGE])
        return !1;
    const E = Date.now() - S.now;
    return S.maxAge ? E > S.maxAge : C[MAX_AGE] && E > C[MAX_AGE]
}
  , trim = C=>{
    if (C[LENGTH] > C[MAX])
        for (let S = C[LRU_LIST].tail; C[LENGTH] > C[MAX] && S !== null; ) {
            const E = S.prev;
            del(C, S),
            S = E
        }
}
  , del = (C,S)=>{
    if (S) {
        const E = S.value;
        C[DISPOSE] && C[DISPOSE](E.key, E.value),
        C[LENGTH] -= E.length,
        C[CACHE].delete(E.key),
        C[LRU_LIST].removeNode(S)
    }
}
;
class Entry {
    constructor(S, E, M, T, $) {
        this.key = S,
        this.value = E,
        this.length = M,
        this.now = T,
        this.maxAge = $ || 0
    }
}
const forEachStep = (C,S,E,M)=>{
    let T = E.value;
    isStale(C, T) && (del(C, E),
    C[ALLOW_STALE] || (T = void 0)),
    T && S.call(M, T.value, T.key, C)
}
;
var lruCache = LRUCache, range$1, hasRequiredRange;
function requireRange() {
    if (hasRequiredRange)
        return range$1;
    hasRequiredRange = 1;
    class C {
        constructor(I, L) {
            if (L = M(L),
            I instanceof C)
                return I.loose === !!L.loose && I.includePrerelease === !!L.includePrerelease ? I : new C(I.raw,L);
            if (I instanceof T)
                return this.raw = I.value,
                this.set = [[I]],
                this.format(),
                this;
            if (this.options = L,
            this.loose = !!L.loose,
            this.includePrerelease = !!L.includePrerelease,
            this.raw = I.trim().split(/\s+/).join(" "),
            this.set = this.raw.split("||").map(K=>this.parseRange(K.trim())).filter(K=>K.length),
            !this.set.length)
                throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
                const K = this.set[0];
                if (this.set = this.set.filter(X=>!ie(X[0])),
                this.set.length === 0)
                    this.set = [K];
                else if (this.set.length > 1) {
                    for (const X of this.set)
                        if (X.length === 1 && oe(X[0])) {
                            this.set = [X];
                            break
                        }
                }
            }
            this.format()
        }
        format() {
            return this.range = this.set.map(I=>I.join(" ").trim()).join("||").trim(),
            this.range
        }
        toString() {
            return this.range
        }
        parseRange(I) {
            const K = ((this.options.includePrerelease && Z) | (this.options.loose && J)) + ":" + I
              , X = E.get(K);
            if (X)
                return X;
            const Y = this.options.loose
              , j = Y ? O[F.HYPHENRANGELOOSE] : O[F.HYPHENRANGE];
            I = I.replace(j, V(this.options.includePrerelease)),
            $("hyphen replace", I),
            I = I.replace(O[F.COMPARATORTRIM], N),
            $("comparator trim", I),
            I = I.replace(O[F.TILDETRIM], U),
            $("tilde trim", I),
            I = I.replace(O[F.CARETTRIM], H),
            $("caret trim", I);
            let G = I.split(" ").map(Ee=>se(Ee, this.options)).join(" ").split(/\s+/).map(Ee=>ue(Ee, this.options));
            Y && (G = G.filter(Ee=>($("loose invalid filter", Ee, this.options),
            !!Ee.match(O[F.COMPARATORLOOSE])))),
            $("range list", G);
            const ne = new Map
              , te = G.map(Ee=>new T(Ee,this.options));
            for (const Ee of te) {
                if (ie(Ee))
                    return [Ee];
                ne.set(Ee.value, Ee)
            }
            ne.size > 1 && ne.has("") && ne.delete("");
            const ce = [...ne.values()];
            return E.set(K, ce),
            ce
        }
        intersects(I, L) {
            if (!(I instanceof C))
                throw new TypeError("a Range is required");
            return this.set.some(K=>ae(K, L) && I.set.some(X=>ae(X, L) && K.every(Y=>X.every(j=>Y.intersects(j, L)))))
        }
        test(I) {
            if (!I)
                return !1;
            if (typeof I == "string")
                try {
                    I = new B(I,this.options)
                } catch {
                    return !1
                }
            for (let L = 0; L < this.set.length; L++)
                if (W(this.set[L], I, this.options))
                    return !0;
            return !1
        }
    }
    range$1 = C;
    const S = lruCache
      , E = new S({
        max: 1e3
    })
      , M = parseOptions_1
      , T = requireComparator()
      , $ = debug_1
      , B = semver$2
      , {safeRe: O, t: F, comparatorTrimReplace: N, tildeTrimReplace: U, caretTrimReplace: H} = reExports
      , {FLAG_INCLUDE_PRERELEASE: Z, FLAG_LOOSE: J} = constants$1
      , ie = D=>D.value === "<0.0.0-0"
      , oe = D=>D.value === ""
      , ae = (D,I)=>{
        let L = !0;
        const K = D.slice();
        let X = K.pop();
        for (; L && K.length; )
            L = K.every(Y=>X.intersects(Y, I)),
            X = K.pop();
        return L
    }
      , se = (D,I)=>($("comp", D, I),
    D = pe(D, I),
    $("caret", D),
    D = de(D, I),
    $("tildes", D),
    D = we(D, I),
    $("xrange", D),
    D = Se(D, I),
    $("stars", D),
    D)
      , le = D=>!D || D.toLowerCase() === "x" || D === "*"
      , de = (D,I)=>D.trim().split(/\s+/).map(L=>fe(L, I)).join(" ")
      , fe = (D,I)=>{
        const L = I.loose ? O[F.TILDELOOSE] : O[F.TILDE];
        return D.replace(L, (K,X,Y,j,G)=>{
            $("tilde", D, K, X, Y, j, G);
            let ne;
            return le(X) ? ne = "" : le(Y) ? ne = `>=${X}.0.0 <${+X + 1}.0.0-0` : le(j) ? ne = `>=${X}.${Y}.0 <${X}.${+Y + 1}.0-0` : G ? ($("replaceTilde pr", G),
            ne = `>=${X}.${Y}.${j}-${G} <${X}.${+Y + 1}.0-0`) : ne = `>=${X}.${Y}.${j} <${X}.${+Y + 1}.0-0`,
            $("tilde return", ne),
            ne
        }
        )
    }
      , pe = (D,I)=>D.trim().split(/\s+/).map(L=>ge(L, I)).join(" ")
      , ge = (D,I)=>{
        $("caret", D, I);
        const L = I.loose ? O[F.CARETLOOSE] : O[F.CARET]
          , K = I.includePrerelease ? "-0" : "";
        return D.replace(L, (X,Y,j,G,ne)=>{
            $("caret", D, X, Y, j, G, ne);
            let te;
            return le(Y) ? te = "" : le(j) ? te = `>=${Y}.0.0${K} <${+Y + 1}.0.0-0` : le(G) ? Y === "0" ? te = `>=${Y}.${j}.0${K} <${Y}.${+j + 1}.0-0` : te = `>=${Y}.${j}.0${K} <${+Y + 1}.0.0-0` : ne ? ($("replaceCaret pr", ne),
            Y === "0" ? j === "0" ? te = `>=${Y}.${j}.${G}-${ne} <${Y}.${j}.${+G + 1}-0` : te = `>=${Y}.${j}.${G}-${ne} <${Y}.${+j + 1}.0-0` : te = `>=${Y}.${j}.${G}-${ne} <${+Y + 1}.0.0-0`) : ($("no pr"),
            Y === "0" ? j === "0" ? te = `>=${Y}.${j}.${G}${K} <${Y}.${j}.${+G + 1}-0` : te = `>=${Y}.${j}.${G}${K} <${Y}.${+j + 1}.0-0` : te = `>=${Y}.${j}.${G} <${+Y + 1}.0.0-0`),
            $("caret return", te),
            te
        }
        )
    }
      , we = (D,I)=>($("replaceXRanges", D, I),
    D.split(/\s+/).map(L=>Ae(L, I)).join(" "))
      , Ae = (D,I)=>{
        D = D.trim();
        const L = I.loose ? O[F.XRANGELOOSE] : O[F.XRANGE];
        return D.replace(L, (K,X,Y,j,G,ne)=>{
            $("xRange", D, K, X, Y, j, G, ne);
            const te = le(Y)
              , ce = te || le(j)
              , Ee = ce || le(G)
              , Re = Ee;
            return X === "=" && Re && (X = ""),
            ne = I.includePrerelease ? "-0" : "",
            te ? X === ">" || X === "<" ? K = "<0.0.0-0" : K = "*" : X && Re ? (ce && (j = 0),
            G = 0,
            X === ">" ? (X = ">=",
            ce ? (Y = +Y + 1,
            j = 0,
            G = 0) : (j = +j + 1,
            G = 0)) : X === "<=" && (X = "<",
            ce ? Y = +Y + 1 : j = +j + 1),
            X === "<" && (ne = "-0"),
            K = `${X + Y}.${j}.${G}${ne}`) : ce ? K = `>=${Y}.0.0${ne} <${+Y + 1}.0.0-0` : Ee && (K = `>=${Y}.${j}.0${ne} <${Y}.${+j + 1}.0-0`),
            $("xRange return", K),
            K
        }
        )
    }
      , Se = (D,I)=>($("replaceStars", D, I),
    D.trim().replace(O[F.STAR], ""))
      , ue = (D,I)=>($("replaceGTE0", D, I),
    D.trim().replace(O[I.includePrerelease ? F.GTE0PRE : F.GTE0], ""))
      , V = D=>(I,L,K,X,Y,j,G,ne,te,ce,Ee,Re,Te)=>(le(K) ? L = "" : le(X) ? L = `>=${K}.0.0${D ? "-0" : ""}` : le(Y) ? L = `>=${K}.${X}.0${D ? "-0" : ""}` : j ? L = `>=${L}` : L = `>=${L}${D ? "-0" : ""}`,
    le(te) ? ne = "" : le(ce) ? ne = `<${+te + 1}.0.0-0` : le(Ee) ? ne = `<${te}.${+ce + 1}.0-0` : Re ? ne = `<=${te}.${ce}.${Ee}-${Re}` : D ? ne = `<${te}.${ce}.${+Ee + 1}-0` : ne = `<=${ne}`,
    `${L} ${ne}`.trim())
      , W = (D,I,L)=>{
        for (let K = 0; K < D.length; K++)
            if (!D[K].test(I))
                return !1;
        if (I.prerelease.length && !L.includePrerelease) {
            for (let K = 0; K < D.length; K++)
                if ($(D[K].semver),
                D[K].semver !== T.ANY && D[K].semver.prerelease.length > 0) {
                    const X = D[K].semver;
                    if (X.major === I.major && X.minor === I.minor && X.patch === I.patch)
                        return !0
                }
            return !1
        }
        return !0
    }
    ;
    return range$1
}
var comparator, hasRequiredComparator;
function requireComparator() {
    if (hasRequiredComparator)
        return comparator;
    hasRequiredComparator = 1;
    const C = Symbol("SemVer ANY");
    class S {
        static get ANY() {
            return C
        }
        constructor(U, H) {
            if (H = E(H),
            U instanceof S) {
                if (U.loose === !!H.loose)
                    return U;
                U = U.value
            }
            U = U.trim().split(/\s+/).join(" "),
            B("comparator", U, H),
            this.options = H,
            this.loose = !!H.loose,
            this.parse(U),
            this.semver === C ? this.value = "" : this.value = this.operator + this.semver.version,
            B("comp", this)
        }
        parse(U) {
            const H = this.options.loose ? M[T.COMPARATORLOOSE] : M[T.COMPARATOR]
              , Z = U.match(H);
            if (!Z)
                throw new TypeError(`Invalid comparator: ${U}`);
            this.operator = Z[1] !== void 0 ? Z[1] : "",
            this.operator === "=" && (this.operator = ""),
            Z[2] ? this.semver = new O(Z[2],this.options.loose) : this.semver = C
        }
        toString() {
            return this.value
        }
        test(U) {
            if (B("Comparator.test", U, this.options.loose),
            this.semver === C || U === C)
                return !0;
            if (typeof U == "string")
                try {
                    U = new O(U,this.options)
                } catch {
                    return !1
                }
            return $(U, this.operator, this.semver, this.options)
        }
        intersects(U, H) {
            if (!(U instanceof S))
                throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" ? !0 : new F(U.value,H).test(this.value) : U.operator === "" ? U.value === "" ? !0 : new F(this.value,H).test(U.semver) : (H = E(H),
            H.includePrerelease && (this.value === "<0.0.0-0" || U.value === "<0.0.0-0") || !H.includePrerelease && (this.value.startsWith("<0.0.0") || U.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && U.operator.startsWith(">") || this.operator.startsWith("<") && U.operator.startsWith("<") || this.semver.version === U.semver.version && this.operator.includes("=") && U.operator.includes("=") || $(this.semver, "<", U.semver, H) && this.operator.startsWith(">") && U.operator.startsWith("<") || $(this.semver, ">", U.semver, H) && this.operator.startsWith("<") && U.operator.startsWith(">")))
        }
    }
    comparator = S;
    const E = parseOptions_1
      , {safeRe: M, t: T} = reExports
      , $ = cmp_1
      , B = debug_1
      , O = semver$2
      , F = requireRange();
    return comparator
}
const Range$9 = requireRange()
  , satisfies$4 = (C,S,E)=>{
    try {
        S = new Range$9(S,E)
    } catch {
        return !1
    }
    return S.test(C)
}
;
var satisfies_1 = satisfies$4;
const Range$8 = requireRange()
  , toComparators$1 = (C,S)=>new Range$8(C,S).set.map(E=>E.map(M=>M.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2
  , Range$7 = requireRange()
  , maxSatisfying$1 = (C,S,E)=>{
    let M = null
      , T = null
      , $ = null;
    try {
        $ = new Range$7(S,E)
    } catch {
        return null
    }
    return C.forEach(B=>{
        $.test(B) && (!M || T.compare(B) === -1) && (M = B,
        T = new SemVer$4(M,E))
    }
    ),
    M
}
;
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2
  , Range$6 = requireRange()
  , minSatisfying$1 = (C,S,E)=>{
    let M = null
      , T = null
      , $ = null;
    try {
        $ = new Range$6(S,E)
    } catch {
        return null
    }
    return C.forEach(B=>{
        $.test(B) && (!M || T.compare(B) === 1) && (M = B,
        T = new SemVer$3(M,E))
    }
    ),
    M
}
;
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2
  , Range$5 = requireRange()
  , gt$2 = gt_1
  , minVersion$1 = (C,S)=>{
    C = new Range$5(C,S);
    let E = new SemVer$2("0.0.0");
    if (C.test(E) || (E = new SemVer$2("0.0.0-0"),
    C.test(E)))
        return E;
    E = null;
    for (let M = 0; M < C.set.length; ++M) {
        const T = C.set[M];
        let $ = null;
        T.forEach(B=>{
            const O = new SemVer$2(B.semver.version);
            switch (B.operator) {
            case ">":
                O.prerelease.length === 0 ? O.patch++ : O.prerelease.push(0),
                O.raw = O.format();
            case "":
            case ">=":
                (!$ || gt$2(O, $)) && ($ = O);
                break;
            case "<":
            case "<=":
                break;
            default:
                throw new Error(`Unexpected operation: ${B.operator}`)
            }
        }
        ),
        $ && (!E || gt$2(E, $)) && (E = $)
    }
    return E && C.test(E) ? E : null
}
;
var minVersion_1 = minVersion$1;
const Range$4 = requireRange()
  , validRange$1 = (C,S)=>{
    try {
        return new Range$4(C,S).range || "*"
    } catch {
        return null
    }
}
;
var valid$1 = validRange$1;
const SemVer$1 = semver$2
  , Comparator$2 = requireComparator()
  , {ANY: ANY$1} = Comparator$2
  , Range$3 = requireRange()
  , satisfies$3 = satisfies_1
  , gt$1 = gt_1
  , lt$1 = lt_1
  , lte$1 = lte_1
  , gte$1 = gte_1
  , outside$3 = (C,S,E,M)=>{
    C = new SemVer$1(C,M),
    S = new Range$3(S,M);
    let T, $, B, O, F;
    switch (E) {
    case ">":
        T = gt$1,
        $ = lte$1,
        B = lt$1,
        O = ">",
        F = ">=";
        break;
    case "<":
        T = lt$1,
        $ = gte$1,
        B = gt$1,
        O = "<",
        F = "<=";
        break;
    default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }
    if (satisfies$3(C, S, M))
        return !1;
    for (let N = 0; N < S.set.length; ++N) {
        const U = S.set[N];
        let H = null
          , Z = null;
        if (U.forEach(J=>{
            J.semver === ANY$1 && (J = new Comparator$2(">=0.0.0")),
            H = H || J,
            Z = Z || J,
            T(J.semver, H.semver, M) ? H = J : B(J.semver, Z.semver, M) && (Z = J)
        }
        ),
        H.operator === O || H.operator === F || (!Z.operator || Z.operator === O) && $(C, Z.semver))
            return !1;
        if (Z.operator === F && B(C, Z.semver))
            return !1
    }
    return !0
}
;
var outside_1 = outside$3;
const outside$2 = outside_1
  , gtr$1 = (C,S,E)=>outside$2(C, S, ">", E);
var gtr_1 = gtr$1;
const outside$1 = outside_1
  , ltr$1 = (C,S,E)=>outside$1(C, S, "<", E);
var ltr_1 = ltr$1;
const Range$2 = requireRange()
  , intersects$1 = (C,S,E)=>(C = new Range$2(C,E),
S = new Range$2(S,E),
C.intersects(S, E));
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1
  , compare$2 = compare_1;
var simplify = (C,S,E)=>{
    const M = [];
    let T = null
      , $ = null;
    const B = C.sort((U,H)=>compare$2(U, H, E));
    for (const U of B)
        satisfies$2(U, S, E) ? ($ = U,
        T || (T = U)) : ($ && M.push([T, $]),
        $ = null,
        T = null);
    T && M.push([T, null]);
    const O = [];
    for (const [U,H] of M)
        U === H ? O.push(U) : !H && U === B[0] ? O.push("*") : H ? U === B[0] ? O.push(`<=${H}`) : O.push(`${U} - ${H}`) : O.push(`>=${U}`);
    const F = O.join(" || ")
      , N = typeof S.raw == "string" ? S.raw : String(S);
    return F.length < N.length ? F : S
}
;
const Range$1 = requireRange()
  , Comparator$1 = requireComparator()
  , {ANY} = Comparator$1
  , satisfies$1 = satisfies_1
  , compare$1 = compare_1
  , subset$1 = (C,S,E={})=>{
    if (C === S)
        return !0;
    C = new Range$1(C,E),
    S = new Range$1(S,E);
    let M = !1;
    e: for (const T of C.set) {
        for (const $ of S.set) {
            const B = simpleSubset(T, $, E);
            if (M = M || B !== null,
            B)
                continue e
        }
        if (M)
            return !1
    }
    return !0
}
  , minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")]
  , minimumVersion = [new Comparator$1(">=0.0.0")]
  , simpleSubset = (C,S,E)=>{
    if (C === S)
        return !0;
    if (C.length === 1 && C[0].semver === ANY) {
        if (S.length === 1 && S[0].semver === ANY)
            return !0;
        E.includePrerelease ? C = minimumVersionWithPreRelease : C = minimumVersion
    }
    if (S.length === 1 && S[0].semver === ANY) {
        if (E.includePrerelease)
            return !0;
        S = minimumVersion
    }
    const M = new Set;
    let T, $;
    for (const J of C)
        J.operator === ">" || J.operator === ">=" ? T = higherGT(T, J, E) : J.operator === "<" || J.operator === "<=" ? $ = lowerLT($, J, E) : M.add(J.semver);
    if (M.size > 1)
        return null;
    let B;
    if (T && $) {
        if (B = compare$1(T.semver, $.semver, E),
        B > 0)
            return null;
        if (B === 0 && (T.operator !== ">=" || $.operator !== "<="))
            return null
    }
    for (const J of M) {
        if (T && !satisfies$1(J, String(T), E) || $ && !satisfies$1(J, String($), E))
            return null;
        for (const ie of S)
            if (!satisfies$1(J, String(ie), E))
                return !1;
        return !0
    }
    let O, F, N, U, H = $ && !E.includePrerelease && $.semver.prerelease.length ? $.semver : !1, Z = T && !E.includePrerelease && T.semver.prerelease.length ? T.semver : !1;
    H && H.prerelease.length === 1 && $.operator === "<" && H.prerelease[0] === 0 && (H = !1);
    for (const J of S) {
        if (U = U || J.operator === ">" || J.operator === ">=",
        N = N || J.operator === "<" || J.operator === "<=",
        T) {
            if (Z && J.semver.prerelease && J.semver.prerelease.length && J.semver.major === Z.major && J.semver.minor === Z.minor && J.semver.patch === Z.patch && (Z = !1),
            J.operator === ">" || J.operator === ">=") {
                if (O = higherGT(T, J, E),
                O === J && O !== T)
                    return !1
            } else if (T.operator === ">=" && !satisfies$1(T.semver, String(J), E))
                return !1
        }
        if ($) {
            if (H && J.semver.prerelease && J.semver.prerelease.length && J.semver.major === H.major && J.semver.minor === H.minor && J.semver.patch === H.patch && (H = !1),
            J.operator === "<" || J.operator === "<=") {
                if (F = lowerLT($, J, E),
                F === J && F !== $)
                    return !1
            } else if ($.operator === "<=" && !satisfies$1($.semver, String(J), E))
                return !1
        }
        if (!J.operator && ($ || T) && B !== 0)
            return !1
    }
    return !(T && N && !$ && B !== 0 || $ && U && !T && B !== 0 || Z || H)
}
  , higherGT = (C,S,E)=>{
    if (!C)
        return S;
    const M = compare$1(C.semver, S.semver, E);
    return M > 0 ? C : M < 0 || S.operator === ">" && C.operator === ">=" ? S : C
}
  , lowerLT = (C,S,E)=>{
    if (!C)
        return S;
    const M = compare$1(C.semver, S.semver, E);
    return M < 0 ? C : M > 0 || S.operator === "<" && C.operator === "<=" ? S : C
}
;
var subset_1 = subset$1;
const internalRe = reExports
  , constants = constants$1
  , SemVer = semver$2
  , identifiers = identifiers$1
  , parse$1 = parse_1
  , valid = valid_1
  , clean = clean_1
  , inc = inc_1
  , diff$1 = diff_1
  , major = major_1
  , minor = minor_1
  , patch = patch_1
  , prerelease = prerelease_1
  , compare = compare_1
  , rcompare = rcompare_1
  , compareLoose = compareLoose_1
  , compareBuild = compareBuild_1
  , sort = sort_1
  , rsort = rsort_1
  , gt = gt_1
  , lt = lt_1
  , eq = eq_1
  , neq = neq_1
  , gte = gte_1
  , lte = lte_1
  , cmp = cmp_1
  , coerce = coerce_1
  , Comparator = requireComparator()
  , Range = requireRange()
  , satisfies = satisfies_1
  , toComparators = toComparators_1
  , maxSatisfying = maxSatisfying_1
  , minSatisfying = minSatisfying_1
  , minVersion = minVersion_1
  , validRange = valid$1
  , outside = outside_1
  , gtr = gtr_1
  , ltr = ltr_1
  , intersects = intersects_1
  , simplifyRange = simplify
  , subset = subset_1;
var semver = {
    parse: parse$1,
    valid,
    clean,
    inc,
    diff: diff$1,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$1 = getDefaultExportFromCjs$1(semver)
  , devices = {
    blue: {
        id: "blue",
        productName: "LedgerBlue",
        productIdMM: 0,
        legacyUsbProductId: 0,
        usbOnly: !0,
        memorySize: 480 * 1024,
        blockSize: 4 * 1024,
        getBlockSize: C=>4 * 1024
    },
    nanoS: {
        id: "nanoS",
        productName: "LedgerNanoS",
        productIdMM: 16,
        legacyUsbProductId: 1,
        usbOnly: !0,
        memorySize: 320 * 1024,
        blockSize: 4 * 1024,
        getBlockSize: C=>semver$1.lt(semver$1.coerce(C), "2.0.0") ? 4 * 1024 : 2 * 1024
    },
    nanoX: {
        id: "nanoX",
        productName: "LedgerNanoX",
        productIdMM: 64,
        legacyUsbProductId: 4,
        usbOnly: !1,
        memorySize: 2 * 1024 * 1024,
        blockSize: 4 * 1024,
        getBlockSize: C=>4 * 1024,
        bluetoothSpec: [{
            serviceUuid: "d973f2e0-b19e-11e2-9e96-0800200c9a66",
            notifyUuid: "d973f2e1-b19e-11e2-9e96-0800200c9a66",
            writeUuid: "d973f2e2-b19e-11e2-9e96-0800200c9a66"
        }, {
            serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
            notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
            writeUuid: "13d63400-2c97-0004-0002-4c6564676572"
        }]
    }
}
  , devicesList = Object.values(devices)
  , ledgerUSBVendorId = 11415
  , identifyUSBProductId = C=>{
    const S = devicesList.find(T=>T.legacyUsbProductId === C);
    if (S)
        return S;
    const E = C >> 8;
    return devicesList.find(T=>T.productIdMM === E)
}
  , bluetoothServices = []
  , serviceUuidToInfos = {};
for (let C in devices) {
    const S = devices[C]
      , {bluetoothSpec: E} = S;
    if (E)
        for (let M = 0; M < E.length; M++) {
            const T = E[M];
            bluetoothServices.push(T.serviceUuid),
            serviceUuidToInfos[T.serviceUuid] = serviceUuidToInfos[T.serviceUuid.replace(/-/g, "")] = {
                deviceModel: S,
                ...T
            }
        }
}
const getBluetoothServiceUuids = ()=>bluetoothServices
  , getInfosForServiceUuid = C=>serviceUuidToInfos[C.toLowerCase()];
let id = 0;
const subscribers = []
  , log = (C,S,E)=>{
    const M = {
        type: C,
        id: String(++id),
        date: new Date
    };
    S && (M.message = S),
    E && (M.data = E),
    dispatch$8(M)
}
  , listen = C=>(subscribers.push(C),
()=>{
    const S = subscribers.indexOf(C);
    S !== -1 && (subscribers[S] = subscribers[subscribers.length - 1],
    subscribers.pop())
}
);
function dispatch$8(C) {
    for (let S = 0; S < subscribers.length; S++)
        try {
            subscribers[S](C)
        } catch (E) {
            console.error(E)
        }
}
typeof window < "u" && (window.__ledgerLogsListen = listen);
const libEs = Object.freeze(Object.defineProperty({
    __proto__: null,
    listen,
    log
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ledgerDevices$1 = [{
    vendorId: ledgerUSBVendorId
}];
async function requestLedgerDevice() {
    return await navigator.usb.requestDevice({
        filters: ledgerDevices$1
    })
}
async function getLedgerDevices$1() {
    return (await navigator.usb.getDevices()).filter(S=>S.vendorId === ledgerUSBVendorId)
}
async function getFirstLedgerDevice$1() {
    const C = await getLedgerDevices$1();
    return C.length > 0 ? C[0] : requestLedgerDevice()
}
const isSupported$1 = ()=>Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices == "function")
  , configurationValue = 1
  , endpointNumber = 3;
let TransportWebUSB$1 = class Sr extends Transport {
    constructor(S, E) {
        super(),
        this.device = void 0,
        this.deviceModel = void 0,
        this.channel = Math.floor(Math.random() * 65535),
        this.packetSize = 64,
        this.interfaceNumber = void 0,
        this._disconnectEmitted = !1,
        this._emitDisconnect = M=>{
            this._disconnectEmitted || (this._disconnectEmitted = !0,
            this.emit("disconnect", M))
        }
        ,
        this.exchange = M=>this.exchangeAtomicImpl(async()=>{
            const {channel: T, packetSize: $} = this;
            log("apdu", "=> " + M.toString("hex"));
            const B = default_1(T, $)
              , O = B.makeBlocks(M);
            for (let U = 0; U < O.length; U++)
                await this.device.transferOut(endpointNumber, O[U]);
            let F, N;
            for (; !(F = B.getReducedResult(N)); ) {
                const U = await this.device.transferIn(endpointNumber, $)
                  , H = Buffer.from(U.data.buffer);
                N = B.reduceResponse(N, H)
            }
            return log("apdu", "<= " + F.toString("hex")),
            F
        }
        ).catch(T=>{
            throw T && T.message && T.message.includes("disconnected") ? (this._emitDisconnect(T),
            new DisconnectedDeviceDuringOperation(T.message)) : T
        }
        ),
        this.device = S,
        this.interfaceNumber = E,
        this.deviceModel = identifyUSBProductId(S.productId)
    }
    static async request() {
        const S = await requestLedgerDevice();
        return Sr.open(S)
    }
    static async openConnected() {
        const S = await getLedgerDevices$1();
        return S.length === 0 ? null : Sr.open(S[0])
    }
    static async open(S) {
        await S.open(),
        S.configuration === null && await S.selectConfiguration(configurationValue),
        await gracefullyResetDevice(S);
        const E = S.configurations[0].interfaces.find(({alternates: B})=>B.some(O=>O.interfaceClass === 255));
        if (!E)
            throw new TransportInterfaceNotAvailable("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
        const M = E.interfaceNumber;
        try {
            await S.claimInterface(M)
        } catch (B) {
            throw await S.close(),
            new TransportInterfaceNotAvailable(B.message)
        }
        const T = new Sr(S,M)
          , $ = B=>{
            S === B.device && (navigator.usb.removeEventListener("disconnect", $),
            T._emitDisconnect(new DisconnectedDevice))
        }
        ;
        return navigator.usb.addEventListener("disconnect", $),
        T
    }
    async close() {
        await this.exchangeBusyPromise,
        await this.device.releaseInterface(this.interfaceNumber),
        await gracefullyResetDevice(this.device),
        await this.device.close()
    }
    setScrambleKey() {}
}
;
TransportWebUSB$1.isSupported = isSupported$1;
TransportWebUSB$1.list = getLedgerDevices$1;
TransportWebUSB$1.listen = C=>{
    let S = !1;
    getFirstLedgerDevice$1().then(M=>{
        if (!S) {
            const T = identifyUSBProductId(M.productId);
            C.next({
                type: "add",
                descriptor: M,
                deviceModel: T
            }),
            C.complete()
        }
    }
    , M=>{
        window.DOMException && M instanceof window.DOMException && M.code === 18 ? C.error(new TransportWebUSBGestureRequired(M.message)) : C.error(new TransportOpenUserCancelled(M.message))
    }
    );
    function E() {
        S = !0
    }
    return {
        unsubscribe: E
    }
}
;
async function gracefullyResetDevice(C) {
    try {
        await C.reset()
    } catch (S) {
        console.warn(S)
    }
}
const TransportWebUSB$2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: TransportWebUSB$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$12 = getAugmentedNamespace(TransportWebUSB$2)
  , ledgerDevices = [{
    vendorId: ledgerUSBVendorId
}]
  , isSupported = ()=>Promise.resolve(!!(global.navigator && global.navigator.hid))
  , getHID = ()=>{
    const {hid: C} = navigator;
    if (!C)
        throw new TransportError("navigator.hid is not supported","HIDNotSupported");
    return C
}
;
async function requestLedgerDevices() {
    const C = await getHID().requestDevice({
        filters: ledgerDevices
    });
    return Array.isArray(C) ? C : [C]
}
async function getLedgerDevices() {
    return (await getHID().getDevices()).filter(S=>S.vendorId === ledgerUSBVendorId)
}
async function getFirstLedgerDevice() {
    const C = await getLedgerDevices();
    return C.length > 0 ? C[0] : (await requestLedgerDevices())[0]
}
let TransportWebHID$1 = class Er extends Transport {
    constructor(S) {
        super(),
        this.device = void 0,
        this.deviceModel = void 0,
        this.channel = Math.floor(Math.random() * 65535),
        this.packetSize = 64,
        this.inputs = [],
        this.inputCallback = void 0,
        this.read = ()=>this.inputs.length ? Promise.resolve(this.inputs.shift()) : new Promise(E=>{
            this.inputCallback = E
        }
        ),
        this.onInputReport = E=>{
            const M = Buffer.from(E.data.buffer);
            this.inputCallback ? (this.inputCallback(M),
            this.inputCallback = null) : this.inputs.push(M)
        }
        ,
        this._disconnectEmitted = !1,
        this._emitDisconnect = E=>{
            this._disconnectEmitted || (this._disconnectEmitted = !0,
            this.emit("disconnect", E))
        }
        ,
        this.exchange = E=>this.exchangeAtomicImpl(async()=>{
            const {channel: M, packetSize: T} = this;
            log("apdu", "=> " + E.toString("hex"));
            const $ = default_1(M, T)
              , B = $.makeBlocks(E);
            for (let N = 0; N < B.length; N++)
                await this.device.sendReport(0, B[N]);
            let O, F;
            for (; !(O = $.getReducedResult(F)); ) {
                const N = await this.read();
                F = $.reduceResponse(F, N)
            }
            return log("apdu", "<= " + O.toString("hex")),
            O
        }
        ).catch(M=>{
            throw M && M.message && M.message.includes("write") ? (this._emitDisconnect(M),
            new DisconnectedDeviceDuringOperation(M.message)) : M
        }
        ),
        this.device = S,
        this.deviceModel = identifyUSBProductId(S.productId),
        S.addEventListener("inputreport", this.onInputReport)
    }
    static async request() {
        const [S] = await requestLedgerDevices();
        return Er.open(S)
    }
    static async openConnected() {
        const S = await getLedgerDevices();
        return S.length === 0 ? null : Er.open(S[0])
    }
    static async open(S) {
        await S.open();
        const E = new Er(S)
          , M = T=>{
            S === T.device && (getHID().removeEventListener("disconnect", M),
            E._emitDisconnect(new DisconnectedDevice))
        }
        ;
        return getHID().addEventListener("disconnect", M),
        E
    }
    async close() {
        await this.exchangeBusyPromise,
        this.device.removeEventListener("inputreport", this.onInputReport),
        await this.device.close()
    }
    setScrambleKey() {}
}
;
TransportWebHID$1.isSupported = isSupported;
TransportWebHID$1.list = getLedgerDevices;
TransportWebHID$1.listen = C=>{
    let S = !1;
    getFirstLedgerDevice().then(M=>{
        if (!M)
            C.error(new TransportOpenUserCancelled("Access denied to use Ledger device"));
        else if (!S) {
            const T = identifyUSBProductId(M.productId);
            C.next({
                type: "add",
                descriptor: M,
                deviceModel: T
            }),
            C.complete()
        }
    }
    , M=>{
        C.error(new TransportOpenUserCancelled(M.message))
    }
    );
    function E() {
        S = !0
    }
    return {
        unsubscribe: E
    }
}
;
const TransportWebHID$2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: TransportWebHID$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$13 = getAugmentedNamespace(TransportWebHID$2);
var sendAPDU$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(C, S) {
    return extendStatics$1 = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(E, M) {
        E.__proto__ = M
    }
    || function(E, M) {
        for (var T in M)
            M.hasOwnProperty(T) && (E[T] = M[T])
    }
    ,
    extendStatics$1(C, S)
};
function __extends$1(C, S) {
    extendStatics$1(C, S);
    function E() {
        this.constructor = C
    }
    C.prototype = S === null ? Object.create(S) : (E.prototype = S.prototype,
    new E)
}
function isFunction(C) {
    return typeof C == "function"
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1
  , config = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(C) {
        if (C) {
            var S = new Error;
            "" + S.stack
        }
        _enable_super_gross_mode_that_will_cause_bad_things = C
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things
    }
};
function hostReportError(C) {
    setTimeout(function() {
        throw C
    }, 0)
}
var empty$1 = {
    closed: !0,
    next: function(C) {},
    error: function(C) {
        if (config.useDeprecatedSynchronousErrorHandling)
            throw C;
        hostReportError(C)
    },
    complete: function() {}
}
  , isArray = function() {
    return Array.isArray || function(C) {
        return C && typeof C.length == "number"
    }
}();
function isObject(C) {
    return C !== null && typeof C == "object"
}
var UnsubscriptionErrorImpl = function() {
    function C(S) {
        return Error.call(this),
        this.message = S ? S.length + ` errors occurred during unsubscription:
` + S.map(function(E, M) {
            return M + 1 + ") " + E.toString()
        }).join(`
  `) : "",
        this.name = "UnsubscriptionError",
        this.errors = S,
        this
    }
    return C.prototype = Object.create(Error.prototype),
    C
}()
  , UnsubscriptionError = UnsubscriptionErrorImpl
  , Subscription = function() {
    function C(S) {
        this.closed = !1,
        this._parentOrParents = null,
        this._subscriptions = null,
        S && (this._ctorUnsubscribe = !0,
        this._unsubscribe = S)
    }
    return C.prototype.unsubscribe = function() {
        var S;
        if (!this.closed) {
            var E = this
              , M = E._parentOrParents
              , T = E._ctorUnsubscribe
              , $ = E._unsubscribe
              , B = E._subscriptions;
            if (this.closed = !0,
            this._parentOrParents = null,
            this._subscriptions = null,
            M instanceof C)
                M.remove(this);
            else if (M !== null)
                for (var O = 0; O < M.length; ++O) {
                    var F = M[O];
                    F.remove(this)
                }
            if (isFunction($)) {
                T && (this._unsubscribe = void 0);
                try {
                    $.call(this)
                } catch (H) {
                    S = H instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(H.errors) : [H]
                }
            }
            if (isArray(B))
                for (var O = -1, N = B.length; ++O < N; ) {
                    var U = B[O];
                    if (isObject(U))
                        try {
                            U.unsubscribe()
                        } catch (Z) {
                            S = S || [],
                            Z instanceof UnsubscriptionError ? S = S.concat(flattenUnsubscriptionErrors(Z.errors)) : S.push(Z)
                        }
                }
            if (S)
                throw new UnsubscriptionError(S)
        }
    }
    ,
    C.prototype.add = function(S) {
        var E = S;
        if (!S)
            return C.EMPTY;
        switch (typeof S) {
        case "function":
            E = new C(S);
        case "object":
            if (E === this || E.closed || typeof E.unsubscribe != "function")
                return E;
            if (this.closed)
                return E.unsubscribe(),
                E;
            if (!(E instanceof C)) {
                var M = E;
                E = new C,
                E._subscriptions = [M]
            }
            break;
        default:
            throw new Error("unrecognized teardown " + S + " added to Subscription.")
        }
        var T = E._parentOrParents;
        if (T === null)
            E._parentOrParents = this;
        else if (T instanceof C) {
            if (T === this)
                return E;
            E._parentOrParents = [T, this]
        } else if (T.indexOf(this) === -1)
            T.push(this);
        else
            return E;
        var $ = this._subscriptions;
        return $ === null ? this._subscriptions = [E] : $.push(E),
        E
    }
    ,
    C.prototype.remove = function(S) {
        var E = this._subscriptions;
        if (E) {
            var M = E.indexOf(S);
            M !== -1 && E.splice(M, 1)
        }
    }
    ,
    C.EMPTY = function(S) {
        return S.closed = !0,
        S
    }(new C),
    C
}();
function flattenUnsubscriptionErrors(C) {
    return C.reduce(function(S, E) {
        return S.concat(E instanceof UnsubscriptionError ? E.errors : E)
    }, [])
}
var rxSubscriber = function() {
    return typeof Symbol == "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
}()
  , Subscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this) || this;
        switch ($.syncErrorValue = null,
        $.syncErrorThrown = !1,
        $.syncErrorThrowable = !1,
        $.isStopped = !1,
        arguments.length) {
        case 0:
            $.destination = empty$1;
            break;
        case 1:
            if (!E) {
                $.destination = empty$1;
                break
            }
            if (typeof E == "object") {
                E instanceof S ? ($.syncErrorThrowable = E.syncErrorThrowable,
                $.destination = E,
                E.add($)) : ($.syncErrorThrowable = !0,
                $.destination = new SafeSubscriber($,E));
                break
            }
        default:
            $.syncErrorThrowable = !0,
            $.destination = new SafeSubscriber($,E,M,T);
            break
        }
        return $
    }
    return S.prototype[rxSubscriber] = function() {
        return this
    }
    ,
    S.create = function(E, M, T) {
        var $ = new S(E,M,T);
        return $.syncErrorThrowable = !1,
        $
    }
    ,
    S.prototype.next = function(E) {
        this.isStopped || this._next(E)
    }
    ,
    S.prototype.error = function(E) {
        this.isStopped || (this.isStopped = !0,
        this._error(E))
    }
    ,
    S.prototype.complete = function() {
        this.isStopped || (this.isStopped = !0,
        this._complete())
    }
    ,
    S.prototype.unsubscribe = function() {
        this.closed || (this.isStopped = !0,
        C.prototype.unsubscribe.call(this))
    }
    ,
    S.prototype._next = function(E) {
        this.destination.next(E)
    }
    ,
    S.prototype._error = function(E) {
        this.destination.error(E),
        this.unsubscribe()
    }
    ,
    S.prototype._complete = function() {
        this.destination.complete(),
        this.unsubscribe()
    }
    ,
    S.prototype._unsubscribeAndRecycle = function() {
        var E = this._parentOrParents;
        return this._parentOrParents = null,
        this.unsubscribe(),
        this.closed = !1,
        this.isStopped = !1,
        this._parentOrParents = E,
        this
    }
    ,
    S
}(Subscription)
  , SafeSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T, $) {
        var B = C.call(this) || this;
        B._parentSubscriber = E;
        var O, F = B;
        return isFunction(M) ? O = M : M && (O = M.next,
        T = M.error,
        $ = M.complete,
        M !== empty$1 && (F = Object.create(M),
        isFunction(F.unsubscribe) && B.add(F.unsubscribe.bind(F)),
        F.unsubscribe = B.unsubscribe.bind(B))),
        B._context = F,
        B._next = O,
        B._error = T,
        B._complete = $,
        B
    }
    return S.prototype.next = function(E) {
        if (!this.isStopped && this._next) {
            var M = this._parentSubscriber;
            !config.useDeprecatedSynchronousErrorHandling || !M.syncErrorThrowable ? this.__tryOrUnsub(this._next, E) : this.__tryOrSetError(M, this._next, E) && this.unsubscribe()
        }
    }
    ,
    S.prototype.error = function(E) {
        if (!this.isStopped) {
            var M = this._parentSubscriber
              , T = config.useDeprecatedSynchronousErrorHandling;
            if (this._error)
                !T || !M.syncErrorThrowable ? (this.__tryOrUnsub(this._error, E),
                this.unsubscribe()) : (this.__tryOrSetError(M, this._error, E),
                this.unsubscribe());
            else if (M.syncErrorThrowable)
                T ? (M.syncErrorValue = E,
                M.syncErrorThrown = !0) : hostReportError(E),
                this.unsubscribe();
            else {
                if (this.unsubscribe(),
                T)
                    throw E;
                hostReportError(E)
            }
        }
    }
    ,
    S.prototype.complete = function() {
        var E = this;
        if (!this.isStopped) {
            var M = this._parentSubscriber;
            if (this._complete) {
                var T = function() {
                    return E._complete.call(E._context)
                };
                !config.useDeprecatedSynchronousErrorHandling || !M.syncErrorThrowable ? (this.__tryOrUnsub(T),
                this.unsubscribe()) : (this.__tryOrSetError(M, T),
                this.unsubscribe())
            } else
                this.unsubscribe()
        }
    }
    ,
    S.prototype.__tryOrUnsub = function(E, M) {
        try {
            E.call(this._context, M)
        } catch (T) {
            if (this.unsubscribe(),
            config.useDeprecatedSynchronousErrorHandling)
                throw T;
            hostReportError(T)
        }
    }
    ,
    S.prototype.__tryOrSetError = function(E, M, T) {
        if (!config.useDeprecatedSynchronousErrorHandling)
            throw new Error("bad call");
        try {
            M.call(this._context, T)
        } catch ($) {
            return config.useDeprecatedSynchronousErrorHandling ? (E.syncErrorValue = $,
            E.syncErrorThrown = !0,
            !0) : (hostReportError($),
            !0)
        }
        return !1
    }
    ,
    S.prototype._unsubscribe = function() {
        var E = this._parentSubscriber;
        this._context = null,
        this._parentSubscriber = null,
        E.unsubscribe()
    }
    ,
    S
}(Subscriber);
function canReportError(C) {
    for (; C; ) {
        var S = C
          , E = S.closed
          , M = S.destination
          , T = S.isStopped;
        if (E || T)
            return !1;
        M && M instanceof Subscriber ? C = M : C = null
    }
    return !0
}
function toSubscriber(C, S, E) {
    if (C) {
        if (C instanceof Subscriber)
            return C;
        if (C[rxSubscriber])
            return C[rxSubscriber]()
    }
    return !C && !S && !E ? new Subscriber(empty$1) : new Subscriber(C,S,E)
}
var observable = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable"
}();
function identity(C) {
    return C
}
function pipe() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    return pipeFromArray(C)
}
function pipeFromArray(C) {
    return C.length === 0 ? identity : C.length === 1 ? C[0] : function(E) {
        return C.reduce(function(M, T) {
            return T(M)
        }, E)
    }
}
var Observable = function() {
    function C(S) {
        this._isScalar = !1,
        S && (this._subscribe = S)
    }
    return C.prototype.lift = function(S) {
        var E = new C;
        return E.source = this,
        E.operator = S,
        E
    }
    ,
    C.prototype.subscribe = function(S, E, M) {
        var T = this.operator
          , $ = toSubscriber(S, E, M);
        if (T ? $.add(T.call($, this.source)) : $.add(this.source || config.useDeprecatedSynchronousErrorHandling && !$.syncErrorThrowable ? this._subscribe($) : this._trySubscribe($)),
        config.useDeprecatedSynchronousErrorHandling && $.syncErrorThrowable && ($.syncErrorThrowable = !1,
        $.syncErrorThrown))
            throw $.syncErrorValue;
        return $
    }
    ,
    C.prototype._trySubscribe = function(S) {
        try {
            return this._subscribe(S)
        } catch (E) {
            config.useDeprecatedSynchronousErrorHandling && (S.syncErrorThrown = !0,
            S.syncErrorValue = E),
            canReportError(S) ? S.error(E) : console.warn(E)
        }
    }
    ,
    C.prototype.forEach = function(S, E) {
        var M = this;
        return E = getPromiseCtor(E),
        new E(function(T, $) {
            var B;
            B = M.subscribe(function(O) {
                try {
                    S(O)
                } catch (F) {
                    $(F),
                    B && B.unsubscribe()
                }
            }, $, T)
        }
        )
    }
    ,
    C.prototype._subscribe = function(S) {
        var E = this.source;
        return E && E.subscribe(S)
    }
    ,
    C.prototype[observable] = function() {
        return this
    }
    ,
    C.prototype.pipe = function() {
        for (var S = [], E = 0; E < arguments.length; E++)
            S[E] = arguments[E];
        return S.length === 0 ? this : pipeFromArray(S)(this)
    }
    ,
    C.prototype.toPromise = function(S) {
        var E = this;
        return S = getPromiseCtor(S),
        new S(function(M, T) {
            var $;
            E.subscribe(function(B) {
                return $ = B
            }, function(B) {
                return T(B)
            }, function() {
                return M($)
            })
        }
        )
    }
    ,
    C.create = function(S) {
        return new C(S)
    }
    ,
    C
}();
function getPromiseCtor(C) {
    if (C || (C = config.Promise || Promise),
    !C)
        throw new Error("no Promise impl found");
    return C
}
var ObjectUnsubscribedErrorImpl = function() {
    function C() {
        return Error.call(this),
        this.message = "object unsubscribed",
        this.name = "ObjectUnsubscribedError",
        this
    }
    return C.prototype = Object.create(Error.prototype),
    C
}()
  , ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl
  , SubjectSubscription = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this) || this;
        return T.subject = E,
        T.subscriber = M,
        T.closed = !1,
        T
    }
    return S.prototype.unsubscribe = function() {
        if (!this.closed) {
            this.closed = !0;
            var E = this.subject
              , M = E.observers;
            if (this.subject = null,
            !(!M || M.length === 0 || E.isStopped || E.closed)) {
                var T = M.indexOf(this.subscriber);
                T !== -1 && M.splice(T, 1)
            }
        }
    }
    ,
    S
}(Subscription)
  , SubjectSubscriber = function(C) {
    __extends$1(S, C);
    function S(E) {
        var M = C.call(this, E) || this;
        return M.destination = E,
        M
    }
    return S
}(Subscriber)
  , Subject = function(C) {
    __extends$1(S, C);
    function S() {
        var E = C.call(this) || this;
        return E.observers = [],
        E.closed = !1,
        E.isStopped = !1,
        E.hasError = !1,
        E.thrownError = null,
        E
    }
    return S.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this)
    }
    ,
    S.prototype.lift = function(E) {
        var M = new AnonymousSubject(this,this);
        return M.operator = E,
        M
    }
    ,
    S.prototype.next = function(E) {
        if (this.closed)
            throw new ObjectUnsubscribedError;
        if (!this.isStopped)
            for (var M = this.observers, T = M.length, $ = M.slice(), B = 0; B < T; B++)
                $[B].next(E)
    }
    ,
    S.prototype.error = function(E) {
        if (this.closed)
            throw new ObjectUnsubscribedError;
        this.hasError = !0,
        this.thrownError = E,
        this.isStopped = !0;
        for (var M = this.observers, T = M.length, $ = M.slice(), B = 0; B < T; B++)
            $[B].error(E);
        this.observers.length = 0
    }
    ,
    S.prototype.complete = function() {
        if (this.closed)
            throw new ObjectUnsubscribedError;
        this.isStopped = !0;
        for (var E = this.observers, M = E.length, T = E.slice(), $ = 0; $ < M; $++)
            T[$].complete();
        this.observers.length = 0
    }
    ,
    S.prototype.unsubscribe = function() {
        this.isStopped = !0,
        this.closed = !0,
        this.observers = null
    }
    ,
    S.prototype._trySubscribe = function(E) {
        if (this.closed)
            throw new ObjectUnsubscribedError;
        return C.prototype._trySubscribe.call(this, E)
    }
    ,
    S.prototype._subscribe = function(E) {
        if (this.closed)
            throw new ObjectUnsubscribedError;
        return this.hasError ? (E.error(this.thrownError),
        Subscription.EMPTY) : this.isStopped ? (E.complete(),
        Subscription.EMPTY) : (this.observers.push(E),
        new SubjectSubscription(this,E))
    }
    ,
    S.prototype.asObservable = function() {
        var E = new Observable;
        return E.source = this,
        E
    }
    ,
    S.create = function(E, M) {
        return new AnonymousSubject(E,M)
    }
    ,
    S
}(Observable)
  , AnonymousSubject = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this) || this;
        return T.destination = E,
        T.source = M,
        T
    }
    return S.prototype.next = function(E) {
        var M = this.destination;
        M && M.next && M.next(E)
    }
    ,
    S.prototype.error = function(E) {
        var M = this.destination;
        M && M.error && this.destination.error(E)
    }
    ,
    S.prototype.complete = function() {
        var E = this.destination;
        E && E.complete && this.destination.complete()
    }
    ,
    S.prototype._subscribe = function(E) {
        var M = this.source;
        return M ? this.source.subscribe(E) : Subscription.EMPTY
    }
    ,
    S
}(Subject);
function refCount() {
    return function(S) {
        return S.lift(new RefCountOperator(S))
    }
}
var RefCountOperator = function() {
    function C(S) {
        this.connectable = S
    }
    return C.prototype.call = function(S, E) {
        var M = this.connectable;
        M._refCount++;
        var T = new RefCountSubscriber(S,M)
          , $ = E.subscribe(T);
        return T.closed || (T.connection = M.connect()),
        $
    }
    ,
    C
}()
  , RefCountSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.connectable = M,
        T
    }
    return S.prototype._unsubscribe = function() {
        var E = this.connectable;
        if (!E) {
            this.connection = null;
            return
        }
        this.connectable = null;
        var M = E._refCount;
        if (M <= 0) {
            this.connection = null;
            return
        }
        if (E._refCount = M - 1,
        M > 1) {
            this.connection = null;
            return
        }
        var T = this.connection
          , $ = E._connection;
        this.connection = null,
        $ && (!T || $ === T) && $.unsubscribe()
    }
    ,
    S
}(Subscriber)
  , ConnectableObservable = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this) || this;
        return T.source = E,
        T.subjectFactory = M,
        T._refCount = 0,
        T._isComplete = !1,
        T
    }
    return S.prototype._subscribe = function(E) {
        return this.getSubject().subscribe(E)
    }
    ,
    S.prototype.getSubject = function() {
        var E = this._subject;
        return (!E || E.isStopped) && (this._subject = this.subjectFactory()),
        this._subject
    }
    ,
    S.prototype.connect = function() {
        var E = this._connection;
        return E || (this._isComplete = !1,
        E = this._connection = new Subscription,
        E.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(),this))),
        E.closed && (this._connection = null,
        E = Subscription.EMPTY)),
        E
    }
    ,
    S.prototype.refCount = function() {
        return refCount()(this)
    }
    ,
    S
}(Observable)
  , connectableObservableDescriptor = function() {
    var C = ConnectableObservable.prototype;
    return {
        operator: {
            value: null
        },
        _refCount: {
            value: 0,
            writable: !0
        },
        _subject: {
            value: null,
            writable: !0
        },
        _connection: {
            value: null,
            writable: !0
        },
        _subscribe: {
            value: C._subscribe
        },
        _isComplete: {
            value: C._isComplete,
            writable: !0
        },
        getSubject: {
            value: C.getSubject
        },
        connect: {
            value: C.connect
        },
        refCount: {
            value: C.refCount
        }
    }
}()
  , ConnectableSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.connectable = M,
        T
    }
    return S.prototype._error = function(E) {
        this._unsubscribe(),
        C.prototype._error.call(this, E)
    }
    ,
    S.prototype._complete = function() {
        this.connectable._isComplete = !0,
        this._unsubscribe(),
        C.prototype._complete.call(this)
    }
    ,
    S.prototype._unsubscribe = function() {
        var E = this.connectable;
        if (E) {
            this.connectable = null;
            var M = E._connection;
            E._refCount = 0,
            E._subject = null,
            E._connection = null,
            M && M.unsubscribe()
        }
    }
    ,
    S
}(SubjectSubscriber)
  , GroupedObservable = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this) || this;
        return $.key = E,
        $.groupSubject = M,
        $.refCountSubscription = T,
        $
    }
    return S.prototype._subscribe = function(E) {
        var M = new Subscription
          , T = this
          , $ = T.refCountSubscription
          , B = T.groupSubject;
        return $ && !$.closed && M.add(new InnerRefCountSubscription($)),
        M.add(B.subscribe(E)),
        M
    }
    ,
    S
}(Observable)
  , InnerRefCountSubscription = function(C) {
    __extends$1(S, C);
    function S(E) {
        var M = C.call(this) || this;
        return M.parent = E,
        E.count++,
        M
    }
    return S.prototype.unsubscribe = function() {
        var E = this.parent;
        !E.closed && !this.closed && (C.prototype.unsubscribe.call(this),
        E.count -= 1,
        E.count === 0 && E.attemptedToUnsubscribe && E.unsubscribe())
    }
    ,
    S
}(Subscription)
  , BehaviorSubject = function(C) {
    __extends$1(S, C);
    function S(E) {
        var M = C.call(this) || this;
        return M._value = E,
        M
    }
    return Object.defineProperty(S.prototype, "value", {
        get: function() {
            return this.getValue()
        },
        enumerable: !0,
        configurable: !0
    }),
    S.prototype._subscribe = function(E) {
        var M = C.prototype._subscribe.call(this, E);
        return M && !M.closed && E.next(this._value),
        M
    }
    ,
    S.prototype.getValue = function() {
        if (this.hasError)
            throw this.thrownError;
        if (this.closed)
            throw new ObjectUnsubscribedError;
        return this._value
    }
    ,
    S.prototype.next = function(E) {
        C.prototype.next.call(this, this._value = E)
    }
    ,
    S
}(Subject)
  , Action = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        return C.call(this) || this
    }
    return S.prototype.schedule = function(E, M) {
        return this
    }
    ,
    S
}(Subscription)
  , AsyncAction = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E, M) || this;
        return T.scheduler = E,
        T.work = M,
        T.pending = !1,
        T
    }
    return S.prototype.schedule = function(E, M) {
        if (M === void 0 && (M = 0),
        this.closed)
            return this;
        this.state = E;
        var T = this.id
          , $ = this.scheduler;
        return T != null && (this.id = this.recycleAsyncId($, T, M)),
        this.pending = !0,
        this.delay = M,
        this.id = this.id || this.requestAsyncId($, this.id, M),
        this
    }
    ,
    S.prototype.requestAsyncId = function(E, M, T) {
        return T === void 0 && (T = 0),
        setInterval(E.flush.bind(E, this), T)
    }
    ,
    S.prototype.recycleAsyncId = function(E, M, T) {
        if (T === void 0 && (T = 0),
        T !== null && this.delay === T && this.pending === !1)
            return M;
        clearInterval(M)
    }
    ,
    S.prototype.execute = function(E, M) {
        if (this.closed)
            return new Error("executing a cancelled action");
        this.pending = !1;
        var T = this._execute(E, M);
        if (T)
            return T;
        this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
    }
    ,
    S.prototype._execute = function(E, M) {
        var T = !1
          , $ = void 0;
        try {
            this.work(E)
        } catch (B) {
            T = !0,
            $ = !!B && B || new Error(B)
        }
        if (T)
            return this.unsubscribe(),
            $
    }
    ,
    S.prototype._unsubscribe = function() {
        var E = this.id
          , M = this.scheduler
          , T = M.actions
          , $ = T.indexOf(this);
        this.work = null,
        this.state = null,
        this.pending = !1,
        this.scheduler = null,
        $ !== -1 && T.splice($, 1),
        E != null && (this.id = this.recycleAsyncId(M, E, null)),
        this.delay = null
    }
    ,
    S
}(Action)
  , QueueAction = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E, M) || this;
        return T.scheduler = E,
        T.work = M,
        T
    }
    return S.prototype.schedule = function(E, M) {
        return M === void 0 && (M = 0),
        M > 0 ? C.prototype.schedule.call(this, E, M) : (this.delay = M,
        this.state = E,
        this.scheduler.flush(this),
        this)
    }
    ,
    S.prototype.execute = function(E, M) {
        return M > 0 || this.closed ? C.prototype.execute.call(this, E, M) : this._execute(E, M)
    }
    ,
    S.prototype.requestAsyncId = function(E, M, T) {
        return T === void 0 && (T = 0),
        T !== null && T > 0 || T === null && this.delay > 0 ? C.prototype.requestAsyncId.call(this, E, M, T) : E.flush(this)
    }
    ,
    S
}(AsyncAction)
  , Scheduler = function() {
    function C(S, E) {
        E === void 0 && (E = C.now),
        this.SchedulerAction = S,
        this.now = E
    }
    return C.prototype.schedule = function(S, E, M) {
        return E === void 0 && (E = 0),
        new this.SchedulerAction(this,S).schedule(M, E)
    }
    ,
    C.now = function() {
        return Date.now()
    }
    ,
    C
}()
  , AsyncScheduler = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        M === void 0 && (M = Scheduler.now);
        var T = C.call(this, E, function() {
            return S.delegate && S.delegate !== T ? S.delegate.now() : M()
        }) || this;
        return T.actions = [],
        T.active = !1,
        T.scheduled = void 0,
        T
    }
    return S.prototype.schedule = function(E, M, T) {
        return M === void 0 && (M = 0),
        S.delegate && S.delegate !== this ? S.delegate.schedule(E, M, T) : C.prototype.schedule.call(this, E, M, T)
    }
    ,
    S.prototype.flush = function(E) {
        var M = this.actions;
        if (this.active) {
            M.push(E);
            return
        }
        var T;
        this.active = !0;
        do
            if (T = E.execute(E.state, E.delay))
                break;
        while (E = M.shift());
        if (this.active = !1,
        T) {
            for (; E = M.shift(); )
                E.unsubscribe();
            throw T
        }
    }
    ,
    S
}(Scheduler)
  , QueueScheduler = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S
}(AsyncScheduler)
  , queueScheduler = new QueueScheduler(QueueAction)
  , queue = queueScheduler
  , EMPTY = new Observable(function(C) {
    return C.complete()
}
);
function empty(C) {
    return C ? emptyScheduled(C) : EMPTY
}
function emptyScheduled(C) {
    return new Observable(function(S) {
        return C.schedule(function() {
            return S.complete()
        })
    }
    )
}
function isScheduler(C) {
    return C && typeof C.schedule == "function"
}
var subscribeToArray = function(C) {
    return function(S) {
        for (var E = 0, M = C.length; E < M && !S.closed; E++)
            S.next(C[E]);
        S.complete()
    }
};
function scheduleArray(C, S) {
    return new Observable(function(E) {
        var M = new Subscription
          , T = 0;
        return M.add(S.schedule(function() {
            if (T === C.length) {
                E.complete();
                return
            }
            E.next(C[T++]),
            E.closed || M.add(this.schedule())
        })),
        M
    }
    )
}
function fromArray(C, S) {
    return S ? scheduleArray(C, S) : new Observable(subscribeToArray(C))
}
function of() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    var E = C[C.length - 1];
    return isScheduler(E) ? (C.pop(),
    scheduleArray(C, E)) : fromArray(C)
}
function throwError(C, S) {
    return S ? new Observable(function(E) {
        return S.schedule(dispatch$7, 0, {
            error: C,
            subscriber: E
        })
    }
    ) : new Observable(function(E) {
        return E.error(C)
    }
    )
}
function dispatch$7(C) {
    var S = C.error
      , E = C.subscriber;
    E.error(S)
}
var NotificationKind;
NotificationKind || (NotificationKind = {});
var Notification = function() {
    function C(S, E, M) {
        this.kind = S,
        this.value = E,
        this.error = M,
        this.hasValue = S === "N"
    }
    return C.prototype.observe = function(S) {
        switch (this.kind) {
        case "N":
            return S.next && S.next(this.value);
        case "E":
            return S.error && S.error(this.error);
        case "C":
            return S.complete && S.complete()
        }
    }
    ,
    C.prototype.do = function(S, E, M) {
        var T = this.kind;
        switch (T) {
        case "N":
            return S && S(this.value);
        case "E":
            return E && E(this.error);
        case "C":
            return M && M()
        }
    }
    ,
    C.prototype.accept = function(S, E, M) {
        return S && typeof S.next == "function" ? this.observe(S) : this.do(S, E, M)
    }
    ,
    C.prototype.toObservable = function() {
        var S = this.kind;
        switch (S) {
        case "N":
            return of(this.value);
        case "E":
            return throwError(this.error);
        case "C":
            return empty()
        }
        throw new Error("unexpected notification kind value")
    }
    ,
    C.createNext = function(S) {
        return typeof S < "u" ? new C("N",S) : C.undefinedValueNotification
    }
    ,
    C.createError = function(S) {
        return new C("E",void 0,S)
    }
    ,
    C.createComplete = function() {
        return C.completeNotification
    }
    ,
    C.completeNotification = new C("C"),
    C.undefinedValueNotification = new C("N",void 0),
    C
}()
  , ObserveOnSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        T === void 0 && (T = 0);
        var $ = C.call(this, E) || this;
        return $.scheduler = M,
        $.delay = T,
        $
    }
    return S.dispatch = function(E) {
        var M = E.notification
          , T = E.destination;
        M.observe(T),
        this.unsubscribe()
    }
    ,
    S.prototype.scheduleMessage = function(E) {
        var M = this.destination;
        M.add(this.scheduler.schedule(S.dispatch, this.delay, new ObserveOnMessage(E,this.destination)))
    }
    ,
    S.prototype._next = function(E) {
        this.scheduleMessage(Notification.createNext(E))
    }
    ,
    S.prototype._error = function(E) {
        this.scheduleMessage(Notification.createError(E)),
        this.unsubscribe()
    }
    ,
    S.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete()),
        this.unsubscribe()
    }
    ,
    S
}(Subscriber)
  , ObserveOnMessage = function() {
    function C(S, E) {
        this.notification = S,
        this.destination = E
    }
    return C
}()
  , ReplaySubject = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        E === void 0 && (E = Number.POSITIVE_INFINITY),
        M === void 0 && (M = Number.POSITIVE_INFINITY);
        var $ = C.call(this) || this;
        return $.scheduler = T,
        $._events = [],
        $._infiniteTimeWindow = !1,
        $._bufferSize = E < 1 ? 1 : E,
        $._windowTime = M < 1 ? 1 : M,
        M === Number.POSITIVE_INFINITY ? ($._infiniteTimeWindow = !0,
        $.next = $.nextInfiniteTimeWindow) : $.next = $.nextTimeWindow,
        $
    }
    return S.prototype.nextInfiniteTimeWindow = function(E) {
        if (!this.isStopped) {
            var M = this._events;
            M.push(E),
            M.length > this._bufferSize && M.shift()
        }
        C.prototype.next.call(this, E)
    }
    ,
    S.prototype.nextTimeWindow = function(E) {
        this.isStopped || (this._events.push(new ReplayEvent(this._getNow(),E)),
        this._trimBufferThenGetEvents()),
        C.prototype.next.call(this, E)
    }
    ,
    S.prototype._subscribe = function(E) {
        var M = this._infiniteTimeWindow, T = M ? this._events : this._trimBufferThenGetEvents(), $ = this.scheduler, B = T.length, O;
        if (this.closed)
            throw new ObjectUnsubscribedError;
        if (this.isStopped || this.hasError ? O = Subscription.EMPTY : (this.observers.push(E),
        O = new SubjectSubscription(this,E)),
        $ && E.add(E = new ObserveOnSubscriber(E,$)),
        M)
            for (var F = 0; F < B && !E.closed; F++)
                E.next(T[F]);
        else
            for (var F = 0; F < B && !E.closed; F++)
                E.next(T[F].value);
        return this.hasError ? E.error(this.thrownError) : this.isStopped && E.complete(),
        O
    }
    ,
    S.prototype._getNow = function() {
        return (this.scheduler || queue).now()
    }
    ,
    S.prototype._trimBufferThenGetEvents = function() {
        for (var E = this._getNow(), M = this._bufferSize, T = this._windowTime, $ = this._events, B = $.length, O = 0; O < B && !(E - $[O].time < T); )
            O++;
        return B > M && (O = Math.max(O, B - M)),
        O > 0 && $.splice(0, O),
        $
    }
    ,
    S
}(Subject)
  , ReplayEvent = function() {
    function C(S, E) {
        this.time = S,
        this.value = E
    }
    return C
}()
  , AsyncSubject = function(C) {
    __extends$1(S, C);
    function S() {
        var E = C !== null && C.apply(this, arguments) || this;
        return E.value = null,
        E.hasNext = !1,
        E.hasCompleted = !1,
        E
    }
    return S.prototype._subscribe = function(E) {
        return this.hasError ? (E.error(this.thrownError),
        Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (E.next(this.value),
        E.complete(),
        Subscription.EMPTY) : C.prototype._subscribe.call(this, E)
    }
    ,
    S.prototype.next = function(E) {
        this.hasCompleted || (this.value = E,
        this.hasNext = !0)
    }
    ,
    S.prototype.error = function(E) {
        this.hasCompleted || C.prototype.error.call(this, E)
    }
    ,
    S.prototype.complete = function() {
        this.hasCompleted = !0,
        this.hasNext && C.prototype.next.call(this, this.value),
        C.prototype.complete.call(this)
    }
    ,
    S
}(Subject)
  , nextHandle = 1
  , RESOLVED = function() {
    return Promise.resolve()
}()
  , activeHandles = {};
function findAndClearHandle(C) {
    return C in activeHandles ? (delete activeHandles[C],
    !0) : !1
}
var Immediate = {
    setImmediate: function(C) {
        var S = nextHandle++;
        return activeHandles[S] = !0,
        RESOLVED.then(function() {
            return findAndClearHandle(S) && C()
        }),
        S
    },
    clearImmediate: function(C) {
        findAndClearHandle(C)
    }
}
  , AsapAction = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E, M) || this;
        return T.scheduler = E,
        T.work = M,
        T
    }
    return S.prototype.requestAsyncId = function(E, M, T) {
        return T === void 0 && (T = 0),
        T !== null && T > 0 ? C.prototype.requestAsyncId.call(this, E, M, T) : (E.actions.push(this),
        E.scheduled || (E.scheduled = Immediate.setImmediate(E.flush.bind(E, null))))
    }
    ,
    S.prototype.recycleAsyncId = function(E, M, T) {
        if (T === void 0 && (T = 0),
        T !== null && T > 0 || T === null && this.delay > 0)
            return C.prototype.recycleAsyncId.call(this, E, M, T);
        E.actions.length === 0 && (Immediate.clearImmediate(M),
        E.scheduled = void 0)
    }
    ,
    S
}(AsyncAction)
  , AsapScheduler = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S.prototype.flush = function(E) {
        this.active = !0,
        this.scheduled = void 0;
        var M = this.actions, T, $ = -1, B = M.length;
        E = E || M.shift();
        do
            if (T = E.execute(E.state, E.delay))
                break;
        while (++$ < B && (E = M.shift()));
        if (this.active = !1,
        T) {
            for (; ++$ < B && (E = M.shift()); )
                E.unsubscribe();
            throw T
        }
    }
    ,
    S
}(AsyncScheduler)
  , asapScheduler = new AsapScheduler(AsapAction)
  , asap = asapScheduler
  , asyncScheduler = new AsyncScheduler(AsyncAction)
  , async = asyncScheduler
  , AnimationFrameAction = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E, M) || this;
        return T.scheduler = E,
        T.work = M,
        T
    }
    return S.prototype.requestAsyncId = function(E, M, T) {
        return T === void 0 && (T = 0),
        T !== null && T > 0 ? C.prototype.requestAsyncId.call(this, E, M, T) : (E.actions.push(this),
        E.scheduled || (E.scheduled = requestAnimationFrame(function() {
            return E.flush(null)
        })))
    }
    ,
    S.prototype.recycleAsyncId = function(E, M, T) {
        if (T === void 0 && (T = 0),
        T !== null && T > 0 || T === null && this.delay > 0)
            return C.prototype.recycleAsyncId.call(this, E, M, T);
        E.actions.length === 0 && (cancelAnimationFrame(M),
        E.scheduled = void 0)
    }
    ,
    S
}(AsyncAction)
  , AnimationFrameScheduler = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S.prototype.flush = function(E) {
        this.active = !0,
        this.scheduled = void 0;
        var M = this.actions, T, $ = -1, B = M.length;
        E = E || M.shift();
        do
            if (T = E.execute(E.state, E.delay))
                break;
        while (++$ < B && (E = M.shift()));
        if (this.active = !1,
        T) {
            for (; ++$ < B && (E = M.shift()); )
                E.unsubscribe();
            throw T
        }
    }
    ,
    S
}(AsyncScheduler)
  , animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction)
  , animationFrame = animationFrameScheduler
  , VirtualTimeScheduler = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        E === void 0 && (E = VirtualAction),
        M === void 0 && (M = Number.POSITIVE_INFINITY);
        var T = C.call(this, E, function() {
            return T.frame
        }) || this;
        return T.maxFrames = M,
        T.frame = 0,
        T.index = -1,
        T
    }
    return S.prototype.flush = function() {
        for (var E = this, M = E.actions, T = E.maxFrames, $, B; (B = M[0]) && B.delay <= T && (M.shift(),
        this.frame = B.delay,
        !($ = B.execute(B.state, B.delay))); )
            ;
        if ($) {
            for (; B = M.shift(); )
                B.unsubscribe();
            throw $
        }
    }
    ,
    S.frameTimeFactor = 10,
    S
}(AsyncScheduler)
  , VirtualAction = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        T === void 0 && (T = E.index += 1);
        var $ = C.call(this, E, M) || this;
        return $.scheduler = E,
        $.work = M,
        $.index = T,
        $.active = !0,
        $.index = E.index = T,
        $
    }
    return S.prototype.schedule = function(E, M) {
        if (M === void 0 && (M = 0),
        !this.id)
            return C.prototype.schedule.call(this, E, M);
        this.active = !1;
        var T = new S(this.scheduler,this.work);
        return this.add(T),
        T.schedule(E, M)
    }
    ,
    S.prototype.requestAsyncId = function(E, M, T) {
        T === void 0 && (T = 0),
        this.delay = E.frame + T;
        var $ = E.actions;
        return $.push(this),
        $.sort(S.sortActions),
        !0
    }
    ,
    S.prototype.recycleAsyncId = function(E, M, T) {}
    ,
    S.prototype._execute = function(E, M) {
        if (this.active === !0)
            return C.prototype._execute.call(this, E, M)
    }
    ,
    S.sortActions = function(E, M) {
        return E.delay === M.delay ? E.index === M.index ? 0 : E.index > M.index ? 1 : -1 : E.delay > M.delay ? 1 : -1
    }
    ,
    S
}(AsyncAction);
function noop() {}
function isObservable(C) {
    return !!C && (C instanceof Observable || typeof C.lift == "function" && typeof C.subscribe == "function")
}
var ArgumentOutOfRangeErrorImpl = function() {
    function C() {
        return Error.call(this),
        this.message = "argument out of range",
        this.name = "ArgumentOutOfRangeError",
        this
    }
    return C.prototype = Object.create(Error.prototype),
    C
}()
  , ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl
  , EmptyErrorImpl = function() {
    function C() {
        return Error.call(this),
        this.message = "no elements in sequence",
        this.name = "EmptyError",
        this
    }
    return C.prototype = Object.create(Error.prototype),
    C
}()
  , EmptyError = EmptyErrorImpl
  , TimeoutErrorImpl = function() {
    function C() {
        return Error.call(this),
        this.message = "Timeout has occurred",
        this.name = "TimeoutError",
        this
    }
    return C.prototype = Object.create(Error.prototype),
    C
}()
  , TimeoutError = TimeoutErrorImpl;
function map(C, S) {
    return function(M) {
        if (typeof C != "function")
            throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
        return M.lift(new MapOperator(C,S))
    }
}
var MapOperator = function() {
    function C(S, E) {
        this.project = S,
        this.thisArg = E
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new MapSubscriber(S,this.project,this.thisArg))
    }
    ,
    C
}()
  , MapSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this, E) || this;
        return $.project = M,
        $.count = 0,
        $.thisArg = T || $,
        $
    }
    return S.prototype._next = function(E) {
        var M;
        try {
            M = this.project.call(this.thisArg, E, this.count++)
        } catch (T) {
            this.destination.error(T);
            return
        }
        this.destination.next(M)
    }
    ,
    S
}(Subscriber);
function bindCallback(C, S, E) {
    if (S)
        if (isScheduler(S))
            E = S;
        else
            return function() {
                for (var M = [], T = 0; T < arguments.length; T++)
                    M[T] = arguments[T];
                return bindCallback(C, E).apply(void 0, M).pipe(map(function($) {
                    return isArray($) ? S.apply(void 0, $) : S($)
                }))
            }
            ;
    return function() {
        for (var M = [], T = 0; T < arguments.length; T++)
            M[T] = arguments[T];
        var $ = this, B, O = {
            context: $,
            subject: B,
            callbackFunc: C,
            scheduler: E
        };
        return new Observable(function(F) {
            if (E) {
                var U = {
                    args: M,
                    subscriber: F,
                    params: O
                };
                return E.schedule(dispatch$6, 0, U)
            } else {
                if (!B) {
                    B = new AsyncSubject;
                    var N = function() {
                        for (var H = [], Z = 0; Z < arguments.length; Z++)
                            H[Z] = arguments[Z];
                        B.next(H.length <= 1 ? H[0] : H),
                        B.complete()
                    };
                    try {
                        C.apply($, M.concat([N]))
                    } catch (H) {
                        canReportError(B) ? B.error(H) : console.warn(H)
                    }
                }
                return B.subscribe(F)
            }
        }
        )
    }
}
function dispatch$6(C) {
    var S = this
      , E = C.args
      , M = C.subscriber
      , T = C.params
      , $ = T.callbackFunc
      , B = T.context
      , O = T.scheduler
      , F = T.subject;
    if (!F) {
        F = T.subject = new AsyncSubject;
        var N = function() {
            for (var U = [], H = 0; H < arguments.length; H++)
                U[H] = arguments[H];
            var Z = U.length <= 1 ? U[0] : U;
            S.add(O.schedule(dispatchNext$1, 0, {
                value: Z,
                subject: F
            }))
        };
        try {
            $.apply(B, E.concat([N]))
        } catch (U) {
            F.error(U)
        }
    }
    this.add(F.subscribe(M))
}
function dispatchNext$1(C) {
    var S = C.value
      , E = C.subject;
    E.next(S),
    E.complete()
}
function bindNodeCallback(C, S, E) {
    if (S)
        if (isScheduler(S))
            E = S;
        else
            return function() {
                for (var M = [], T = 0; T < arguments.length; T++)
                    M[T] = arguments[T];
                return bindNodeCallback(C, E).apply(void 0, M).pipe(map(function($) {
                    return isArray($) ? S.apply(void 0, $) : S($)
                }))
            }
            ;
    return function() {
        for (var M = [], T = 0; T < arguments.length; T++)
            M[T] = arguments[T];
        var $ = {
            subject: void 0,
            args: M,
            callbackFunc: C,
            scheduler: E,
            context: this
        };
        return new Observable(function(B) {
            var O = $.context
              , F = $.subject;
            if (E)
                return E.schedule(dispatch$5, 0, {
                    params: $,
                    subscriber: B,
                    context: O
                });
            if (!F) {
                F = $.subject = new AsyncSubject;
                var N = function() {
                    for (var U = [], H = 0; H < arguments.length; H++)
                        U[H] = arguments[H];
                    var Z = U.shift();
                    if (Z) {
                        F.error(Z);
                        return
                    }
                    F.next(U.length <= 1 ? U[0] : U),
                    F.complete()
                };
                try {
                    C.apply(O, M.concat([N]))
                } catch (U) {
                    canReportError(F) ? F.error(U) : console.warn(U)
                }
            }
            return F.subscribe(B)
        }
        )
    }
}
function dispatch$5(C) {
    var S = this
      , E = C.params
      , M = C.subscriber
      , T = C.context
      , $ = E.callbackFunc
      , B = E.args
      , O = E.scheduler
      , F = E.subject;
    if (!F) {
        F = E.subject = new AsyncSubject;
        var N = function() {
            for (var U = [], H = 0; H < arguments.length; H++)
                U[H] = arguments[H];
            var Z = U.shift();
            if (Z)
                S.add(O.schedule(dispatchError, 0, {
                    err: Z,
                    subject: F
                }));
            else {
                var J = U.length <= 1 ? U[0] : U;
                S.add(O.schedule(dispatchNext, 0, {
                    value: J,
                    subject: F
                }))
            }
        };
        try {
            $.apply(T, B.concat([N]))
        } catch (U) {
            this.add(O.schedule(dispatchError, 0, {
                err: U,
                subject: F
            }))
        }
    }
    this.add(F.subscribe(M))
}
function dispatchNext(C) {
    var S = C.value
      , E = C.subject;
    E.next(S),
    E.complete()
}
function dispatchError(C) {
    var S = C.err
      , E = C.subject;
    E.error(S)
}
var OuterSubscriber = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S.prototype.notifyNext = function(E, M, T, $, B) {
        this.destination.next(M)
    }
    ,
    S.prototype.notifyError = function(E, M) {
        this.destination.error(E)
    }
    ,
    S.prototype.notifyComplete = function(E) {
        this.destination.complete()
    }
    ,
    S
}(Subscriber)
  , InnerSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this) || this;
        return $.parent = E,
        $.outerValue = M,
        $.outerIndex = T,
        $.index = 0,
        $
    }
    return S.prototype._next = function(E) {
        this.parent.notifyNext(this.outerValue, E, this.outerIndex, this.index++, this)
    }
    ,
    S.prototype._error = function(E) {
        this.parent.notifyError(E, this),
        this.unsubscribe()
    }
    ,
    S.prototype._complete = function() {
        this.parent.notifyComplete(this),
        this.unsubscribe()
    }
    ,
    S
}(Subscriber)
  , subscribeToPromise = function(C) {
    return function(S) {
        return C.then(function(E) {
            S.closed || (S.next(E),
            S.complete())
        }, function(E) {
            return S.error(E)
        }).then(null, hostReportError),
        S
    }
};
function getSymbolIterator() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
}
var iterator = getSymbolIterator()
  , subscribeToIterable = function(C) {
    return function(S) {
        var E = C[iterator]();
        do {
            var M = void 0;
            try {
                M = E.next()
            } catch (T) {
                return S.error(T),
                S
            }
            if (M.done) {
                S.complete();
                break
            }
            if (S.next(M.value),
            S.closed)
                break
        } while (!0);
        return typeof E.return == "function" && S.add(function() {
            E.return && E.return()
        }),
        S
    }
}
  , subscribeToObservable = function(C) {
    return function(S) {
        var E = C[observable]();
        if (typeof E.subscribe != "function")
            throw new TypeError("Provided object does not correctly implement Symbol.observable");
        return E.subscribe(S)
    }
}
  , isArrayLike = function(C) {
    return C && typeof C.length == "number" && typeof C != "function"
};
function isPromise(C) {
    return !!C && typeof C.subscribe != "function" && typeof C.then == "function"
}
var subscribeTo = function(C) {
    if (C && typeof C[observable] == "function")
        return subscribeToObservable(C);
    if (isArrayLike(C))
        return subscribeToArray(C);
    if (isPromise(C))
        return subscribeToPromise(C);
    if (C && typeof C[iterator] == "function")
        return subscribeToIterable(C);
    var S = isObject(C) ? "an invalid object" : "'" + C + "'"
      , E = "You provided " + S + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(E)
};
function subscribeToResult(C, S, E, M, T) {
    if (T === void 0 && (T = new InnerSubscriber(C,E,M)),
    !T.closed)
        return S instanceof Observable ? S.subscribe(T) : subscribeTo(S)(T)
}
var NONE = {};
function combineLatest() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    var E = void 0
      , M = void 0;
    return isScheduler(C[C.length - 1]) && (M = C.pop()),
    typeof C[C.length - 1] == "function" && (E = C.pop()),
    C.length === 1 && isArray(C[0]) && (C = C[0]),
    fromArray(C, M).lift(new CombineLatestOperator(E))
}
var CombineLatestOperator = function() {
    function C(S) {
        this.resultSelector = S
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new CombineLatestSubscriber(S,this.resultSelector))
    }
    ,
    C
}()
  , CombineLatestSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.resultSelector = M,
        T.active = 0,
        T.values = [],
        T.observables = [],
        T
    }
    return S.prototype._next = function(E) {
        this.values.push(NONE),
        this.observables.push(E)
    }
    ,
    S.prototype._complete = function() {
        var E = this.observables
          , M = E.length;
        if (M === 0)
            this.destination.complete();
        else {
            this.active = M,
            this.toRespond = M;
            for (var T = 0; T < M; T++) {
                var $ = E[T];
                this.add(subscribeToResult(this, $, void 0, T))
            }
        }
    }
    ,
    S.prototype.notifyComplete = function(E) {
        (this.active -= 1) === 0 && this.destination.complete()
    }
    ,
    S.prototype.notifyNext = function(E, M, T) {
        var $ = this.values
          , B = $[T]
          , O = this.toRespond ? B === NONE ? --this.toRespond : this.toRespond : 0;
        $[T] = M,
        O === 0 && (this.resultSelector ? this._tryResultSelector($) : this.destination.next($.slice()))
    }
    ,
    S.prototype._tryResultSelector = function(E) {
        var M;
        try {
            M = this.resultSelector.apply(this, E)
        } catch (T) {
            this.destination.error(T);
            return
        }
        this.destination.next(M)
    }
    ,
    S
}(OuterSubscriber);
function scheduleObservable(C, S) {
    return new Observable(function(E) {
        var M = new Subscription;
        return M.add(S.schedule(function() {
            var T = C[observable]();
            M.add(T.subscribe({
                next: function($) {
                    M.add(S.schedule(function() {
                        return E.next($)
                    }))
                },
                error: function($) {
                    M.add(S.schedule(function() {
                        return E.error($)
                    }))
                },
                complete: function() {
                    M.add(S.schedule(function() {
                        return E.complete()
                    }))
                }
            }))
        })),
        M
    }
    )
}
function schedulePromise(C, S) {
    return new Observable(function(E) {
        var M = new Subscription;
        return M.add(S.schedule(function() {
            return C.then(function(T) {
                M.add(S.schedule(function() {
                    E.next(T),
                    M.add(S.schedule(function() {
                        return E.complete()
                    }))
                }))
            }, function(T) {
                M.add(S.schedule(function() {
                    return E.error(T)
                }))
            })
        })),
        M
    }
    )
}
function scheduleIterable(C, S) {
    if (!C)
        throw new Error("Iterable cannot be null");
    return new Observable(function(E) {
        var M = new Subscription, T;
        return M.add(function() {
            T && typeof T.return == "function" && T.return()
        }),
        M.add(S.schedule(function() {
            T = C[iterator](),
            M.add(S.schedule(function() {
                if (!E.closed) {
                    var $, B;
                    try {
                        var O = T.next();
                        $ = O.value,
                        B = O.done
                    } catch (F) {
                        E.error(F);
                        return
                    }
                    B ? E.complete() : (E.next($),
                    this.schedule())
                }
            }))
        })),
        M
    }
    )
}
function isInteropObservable(C) {
    return C && typeof C[observable] == "function"
}
function isIterable(C) {
    return C && typeof C[iterator] == "function"
}
function scheduled(C, S) {
    if (C != null) {
        if (isInteropObservable(C))
            return scheduleObservable(C, S);
        if (isPromise(C))
            return schedulePromise(C, S);
        if (isArrayLike(C))
            return scheduleArray(C, S);
        if (isIterable(C) || typeof C == "string")
            return scheduleIterable(C, S)
    }
    throw new TypeError((C !== null && typeof C || C) + " is not observable")
}
function from(C, S) {
    return S ? scheduled(C, S) : C instanceof Observable ? C : new Observable(subscribeTo(C))
}
var SimpleInnerSubscriber = function(C) {
    __extends$1(S, C);
    function S(E) {
        var M = C.call(this) || this;
        return M.parent = E,
        M
    }
    return S.prototype._next = function(E) {
        this.parent.notifyNext(E)
    }
    ,
    S.prototype._error = function(E) {
        this.parent.notifyError(E),
        this.unsubscribe()
    }
    ,
    S.prototype._complete = function() {
        this.parent.notifyComplete(),
        this.unsubscribe()
    }
    ,
    S
}(Subscriber)
  , SimpleOuterSubscriber = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S.prototype.notifyNext = function(E) {
        this.destination.next(E)
    }
    ,
    S.prototype.notifyError = function(E) {
        this.destination.error(E)
    }
    ,
    S.prototype.notifyComplete = function() {
        this.destination.complete()
    }
    ,
    S
}(Subscriber);
function innerSubscribe(C, S) {
    if (!S.closed) {
        if (C instanceof Observable)
            return C.subscribe(S);
        var E;
        try {
            E = subscribeTo(C)(S)
        } catch (M) {
            S.error(M)
        }
        return E
    }
}
function mergeMap(C, S, E) {
    return E === void 0 && (E = Number.POSITIVE_INFINITY),
    typeof S == "function" ? function(M) {
        return M.pipe(mergeMap(function(T, $) {
            return from(C(T, $)).pipe(map(function(B, O) {
                return S(T, B, $, O)
            }))
        }, E))
    }
    : (typeof S == "number" && (E = S),
    function(M) {
        return M.lift(new MergeMapOperator(C,E))
    }
    )
}
var MergeMapOperator = function() {
    function C(S, E) {
        E === void 0 && (E = Number.POSITIVE_INFINITY),
        this.project = S,
        this.concurrent = E
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new MergeMapSubscriber(S,this.project,this.concurrent))
    }
    ,
    C
}()
  , MergeMapSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        T === void 0 && (T = Number.POSITIVE_INFINITY);
        var $ = C.call(this, E) || this;
        return $.project = M,
        $.concurrent = T,
        $.hasCompleted = !1,
        $.buffer = [],
        $.active = 0,
        $.index = 0,
        $
    }
    return S.prototype._next = function(E) {
        this.active < this.concurrent ? this._tryNext(E) : this.buffer.push(E)
    }
    ,
    S.prototype._tryNext = function(E) {
        var M, T = this.index++;
        try {
            M = this.project(E, T)
        } catch ($) {
            this.destination.error($);
            return
        }
        this.active++,
        this._innerSub(M)
    }
    ,
    S.prototype._innerSub = function(E) {
        var M = new SimpleInnerSubscriber(this)
          , T = this.destination;
        T.add(M);
        var $ = innerSubscribe(E, M);
        $ !== M && T.add($)
    }
    ,
    S.prototype._complete = function() {
        this.hasCompleted = !0,
        this.active === 0 && this.buffer.length === 0 && this.destination.complete(),
        this.unsubscribe()
    }
    ,
    S.prototype.notifyNext = function(E) {
        this.destination.next(E)
    }
    ,
    S.prototype.notifyComplete = function() {
        var E = this.buffer;
        this.active--,
        E.length > 0 ? this._next(E.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete()
    }
    ,
    S
}(SimpleOuterSubscriber);
function mergeAll(C) {
    return C === void 0 && (C = Number.POSITIVE_INFINITY),
    mergeMap(identity, C)
}
function concatAll() {
    return mergeAll(1)
}
function concat() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    return concatAll()(of.apply(void 0, C))
}
function defer(C) {
    return new Observable(function(S) {
        var E;
        try {
            E = C()
        } catch (T) {
            S.error(T);
            return
        }
        var M = E ? from(E) : empty();
        return M.subscribe(S)
    }
    )
}
function forkJoin() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    if (C.length === 1) {
        var E = C[0];
        if (isArray(E))
            return forkJoinInternal(E, null);
        if (isObject(E) && Object.getPrototypeOf(E) === Object.prototype) {
            var M = Object.keys(E);
            return forkJoinInternal(M.map(function($) {
                return E[$]
            }), M)
        }
    }
    if (typeof C[C.length - 1] == "function") {
        var T = C.pop();
        return C = C.length === 1 && isArray(C[0]) ? C[0] : C,
        forkJoinInternal(C, null).pipe(map(function($) {
            return T.apply(void 0, $)
        }))
    }
    return forkJoinInternal(C, null)
}
function forkJoinInternal(C, S) {
    return new Observable(function(E) {
        var M = C.length;
        if (M === 0) {
            E.complete();
            return
        }
        for (var T = new Array(M), $ = 0, B = 0, O = function(N) {
            var U = from(C[N])
              , H = !1;
            E.add(U.subscribe({
                next: function(Z) {
                    H || (H = !0,
                    B++),
                    T[N] = Z
                },
                error: function(Z) {
                    return E.error(Z)
                },
                complete: function() {
                    $++,
                    ($ === M || !H) && (B === M && E.next(S ? S.reduce(function(Z, J, ie) {
                        return Z[J] = T[ie],
                        Z
                    }, {}) : T),
                    E.complete())
                }
            }))
        }, F = 0; F < M; F++)
            O(F)
    }
    )
}
function fromEvent(C, S, E, M) {
    return isFunction(E) && (M = E,
    E = void 0),
    M ? fromEvent(C, S, E).pipe(map(function(T) {
        return isArray(T) ? M.apply(void 0, T) : M(T)
    })) : new Observable(function(T) {
        function $(B) {
            arguments.length > 1 ? T.next(Array.prototype.slice.call(arguments)) : T.next(B)
        }
        setupSubscription(C, S, $, T, E)
    }
    )
}
function setupSubscription(C, S, E, M, T) {
    var $;
    if (isEventTarget(C)) {
        var B = C;
        C.addEventListener(S, E, T),
        $ = function() {
            return B.removeEventListener(S, E, T)
        }
    } else if (isJQueryStyleEventEmitter(C)) {
        var O = C;
        C.on(S, E),
        $ = function() {
            return O.off(S, E)
        }
    } else if (isNodeStyleEventEmitter(C)) {
        var F = C;
        C.addListener(S, E),
        $ = function() {
            return F.removeListener(S, E)
        }
    } else if (C && C.length)
        for (var N = 0, U = C.length; N < U; N++)
            setupSubscription(C[N], S, E, M, T);
    else
        throw new TypeError("Invalid event target");
    M.add($)
}
function isNodeStyleEventEmitter(C) {
    return C && typeof C.addListener == "function" && typeof C.removeListener == "function"
}
function isJQueryStyleEventEmitter(C) {
    return C && typeof C.on == "function" && typeof C.off == "function"
}
function isEventTarget(C) {
    return C && typeof C.addEventListener == "function" && typeof C.removeEventListener == "function"
}
function fromEventPattern(C, S, E) {
    return E ? fromEventPattern(C, S).pipe(map(function(M) {
        return isArray(M) ? E.apply(void 0, M) : E(M)
    })) : new Observable(function(M) {
        var T = function() {
            for (var B = [], O = 0; O < arguments.length; O++)
                B[O] = arguments[O];
            return M.next(B.length === 1 ? B[0] : B)
        }, $;
        try {
            $ = C(T)
        } catch (B) {
            M.error(B);
            return
        }
        if (isFunction(S))
            return function() {
                return S(T, $)
            }
    }
    )
}
function generate(C, S, E, M, T) {
    var $, B;
    if (arguments.length == 1) {
        var O = C;
        B = O.initialState,
        S = O.condition,
        E = O.iterate,
        $ = O.resultSelector || identity,
        T = O.scheduler
    } else
        M === void 0 || isScheduler(M) ? (B = C,
        $ = identity,
        T = M) : (B = C,
        $ = M);
    return new Observable(function(F) {
        var N = B;
        if (T)
            return T.schedule(dispatch$4, 0, {
                subscriber: F,
                iterate: E,
                condition: S,
                resultSelector: $,
                state: N
            });
        do {
            if (S) {
                var U = void 0;
                try {
                    U = S(N)
                } catch (Z) {
                    F.error(Z);
                    return
                }
                if (!U) {
                    F.complete();
                    break
                }
            }
            var H = void 0;
            try {
                H = $(N)
            } catch (Z) {
                F.error(Z);
                return
            }
            if (F.next(H),
            F.closed)
                break;
            try {
                N = E(N)
            } catch (Z) {
                F.error(Z);
                return
            }
        } while (!0)
    }
    )
}
function dispatch$4(C) {
    var S = C.subscriber
      , E = C.condition;
    if (!S.closed) {
        if (C.needIterate)
            try {
                C.state = C.iterate(C.state)
            } catch ($) {
                S.error($);
                return
            }
        else
            C.needIterate = !0;
        if (E) {
            var M = void 0;
            try {
                M = E(C.state)
            } catch ($) {
                S.error($);
                return
            }
            if (!M) {
                S.complete();
                return
            }
            if (S.closed)
                return
        }
        var T;
        try {
            T = C.resultSelector(C.state)
        } catch ($) {
            S.error($);
            return
        }
        if (!S.closed && (S.next(T),
        !S.closed))
            return this.schedule(C)
    }
}
function iif(C, S, E) {
    return S === void 0 && (S = EMPTY),
    E === void 0 && (E = EMPTY),
    defer(function() {
        return C() ? S : E
    })
}
function isNumeric(C) {
    return !isArray(C) && C - parseFloat(C) + 1 >= 0
}
function interval(C, S) {
    return C === void 0 && (C = 0),
    S === void 0 && (S = async),
    (!isNumeric(C) || C < 0) && (C = 0),
    (!S || typeof S.schedule != "function") && (S = async),
    new Observable(function(E) {
        return E.add(S.schedule(dispatch$3, C, {
            subscriber: E,
            counter: 0,
            period: C
        })),
        E
    }
    )
}
function dispatch$3(C) {
    var S = C.subscriber
      , E = C.counter
      , M = C.period;
    S.next(E),
    this.schedule({
        subscriber: S,
        counter: E + 1,
        period: M
    }, M)
}
function merge() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    var E = Number.POSITIVE_INFINITY
      , M = null
      , T = C[C.length - 1];
    return isScheduler(T) ? (M = C.pop(),
    C.length > 1 && typeof C[C.length - 1] == "number" && (E = C.pop())) : typeof T == "number" && (E = C.pop()),
    M === null && C.length === 1 && C[0]instanceof Observable ? C[0] : mergeAll(E)(fromArray(C, M))
}
var NEVER = new Observable(noop);
function never() {
    return NEVER
}
function onErrorResumeNext() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    if (C.length === 0)
        return EMPTY;
    var E = C[0]
      , M = C.slice(1);
    return C.length === 1 && isArray(E) ? onErrorResumeNext.apply(void 0, E) : new Observable(function(T) {
        var $ = function() {
            return T.add(onErrorResumeNext.apply(void 0, M).subscribe(T))
        };
        return from(E).subscribe({
            next: function(B) {
                T.next(B)
            },
            error: $,
            complete: $
        })
    }
    )
}
function pairs(C, S) {
    return S ? new Observable(function(E) {
        var M = Object.keys(C)
          , T = new Subscription;
        return T.add(S.schedule(dispatch$2, 0, {
            keys: M,
            index: 0,
            subscriber: E,
            subscription: T,
            obj: C
        })),
        T
    }
    ) : new Observable(function(E) {
        for (var M = Object.keys(C), T = 0; T < M.length && !E.closed; T++) {
            var $ = M[T];
            C.hasOwnProperty($) && E.next([$, C[$]])
        }
        E.complete()
    }
    )
}
function dispatch$2(C) {
    var S = C.keys
      , E = C.index
      , M = C.subscriber
      , T = C.subscription
      , $ = C.obj;
    if (!M.closed)
        if (E < S.length) {
            var B = S[E];
            M.next([B, $[B]]),
            T.add(this.schedule({
                keys: S,
                index: E + 1,
                subscriber: M,
                subscription: T,
                obj: $
            }))
        } else
            M.complete()
}
function not(C, S) {
    function E() {
        return !E.pred.apply(E.thisArg, arguments)
    }
    return E.pred = C,
    E.thisArg = S,
    E
}
function filter(C, S) {
    return function(M) {
        return M.lift(new FilterOperator(C,S))
    }
}
var FilterOperator = function() {
    function C(S, E) {
        this.predicate = S,
        this.thisArg = E
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new FilterSubscriber(S,this.predicate,this.thisArg))
    }
    ,
    C
}()
  , FilterSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this, E) || this;
        return $.predicate = M,
        $.thisArg = T,
        $.count = 0,
        $
    }
    return S.prototype._next = function(E) {
        var M;
        try {
            M = this.predicate.call(this.thisArg, E, this.count++)
        } catch (T) {
            this.destination.error(T);
            return
        }
        M && this.destination.next(E)
    }
    ,
    S
}(Subscriber);
function partition(C, S, E) {
    return [filter(S, E)(new Observable(subscribeTo(C))), filter(not(S, E))(new Observable(subscribeTo(C)))]
}
function race() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    if (C.length === 1)
        if (isArray(C[0]))
            C = C[0];
        else
            return C[0];
    return fromArray(C, void 0).lift(new RaceOperator)
}
var RaceOperator = function() {
    function C() {}
    return C.prototype.call = function(S, E) {
        return E.subscribe(new RaceSubscriber(S))
    }
    ,
    C
}()
  , RaceSubscriber = function(C) {
    __extends$1(S, C);
    function S(E) {
        var M = C.call(this, E) || this;
        return M.hasFirst = !1,
        M.observables = [],
        M.subscriptions = [],
        M
    }
    return S.prototype._next = function(E) {
        this.observables.push(E)
    }
    ,
    S.prototype._complete = function() {
        var E = this.observables
          , M = E.length;
        if (M === 0)
            this.destination.complete();
        else {
            for (var T = 0; T < M && !this.hasFirst; T++) {
                var $ = E[T]
                  , B = subscribeToResult(this, $, void 0, T);
                this.subscriptions && this.subscriptions.push(B),
                this.add(B)
            }
            this.observables = null
        }
    }
    ,
    S.prototype.notifyNext = function(E, M, T) {
        if (!this.hasFirst) {
            this.hasFirst = !0;
            for (var $ = 0; $ < this.subscriptions.length; $++)
                if ($ !== T) {
                    var B = this.subscriptions[$];
                    B.unsubscribe(),
                    this.remove(B)
                }
            this.subscriptions = null
        }
        this.destination.next(M)
    }
    ,
    S
}(OuterSubscriber);
function range(C, S, E) {
    return C === void 0 && (C = 0),
    new Observable(function(M) {
        S === void 0 && (S = C,
        C = 0);
        var T = 0
          , $ = C;
        if (E)
            return E.schedule(dispatch$1, 0, {
                index: T,
                count: S,
                start: C,
                subscriber: M
            });
        do {
            if (T++ >= S) {
                M.complete();
                break
            }
            if (M.next($++),
            M.closed)
                break
        } while (!0)
    }
    )
}
function dispatch$1(C) {
    var S = C.start
      , E = C.index
      , M = C.count
      , T = C.subscriber;
    if (E >= M) {
        T.complete();
        return
    }
    T.next(S),
    !T.closed && (C.index = E + 1,
    C.start = S + 1,
    this.schedule(C))
}
function timer(C, S, E) {
    C === void 0 && (C = 0);
    var M = -1;
    return isNumeric(S) ? M = Number(S) < 1 && 1 || Number(S) : isScheduler(S) && (E = S),
    isScheduler(E) || (E = async),
    new Observable(function(T) {
        var $ = isNumeric(C) ? C : +C - E.now();
        return E.schedule(dispatch, $, {
            index: 0,
            period: M,
            subscriber: T
        })
    }
    )
}
function dispatch(C) {
    var S = C.index
      , E = C.period
      , M = C.subscriber;
    if (M.next(S),
    !M.closed) {
        if (E === -1)
            return M.complete();
        C.index = S + 1,
        this.schedule(C, E)
    }
}
function using(C, S) {
    return new Observable(function(E) {
        var M;
        try {
            M = C()
        } catch (O) {
            E.error(O);
            return
        }
        var T;
        try {
            T = S(M)
        } catch (O) {
            E.error(O);
            return
        }
        var $ = T ? from(T) : EMPTY
          , B = $.subscribe(E);
        return function() {
            B.unsubscribe(),
            M && M.unsubscribe()
        }
    }
    )
}
function zip() {
    for (var C = [], S = 0; S < arguments.length; S++)
        C[S] = arguments[S];
    var E = C[C.length - 1];
    return typeof E == "function" && C.pop(),
    fromArray(C, void 0).lift(new ZipOperator(E))
}
var ZipOperator = function() {
    function C(S) {
        this.resultSelector = S
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new ZipSubscriber(S,this.resultSelector))
    }
    ,
    C
}()
  , ZipSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this, E) || this;
        return $.resultSelector = M,
        $.iterators = [],
        $.active = 0,
        $.resultSelector = typeof M == "function" ? M : void 0,
        $
    }
    return S.prototype._next = function(E) {
        var M = this.iterators;
        isArray(E) ? M.push(new StaticArrayIterator(E)) : typeof E[iterator] == "function" ? M.push(new StaticIterator(E[iterator]())) : M.push(new ZipBufferIterator(this.destination,this,E))
    }
    ,
    S.prototype._complete = function() {
        var E = this.iterators
          , M = E.length;
        if (this.unsubscribe(),
        M === 0) {
            this.destination.complete();
            return
        }
        this.active = M;
        for (var T = 0; T < M; T++) {
            var $ = E[T];
            if ($.stillUnsubscribed) {
                var B = this.destination;
                B.add($.subscribe())
            } else
                this.active--
        }
    }
    ,
    S.prototype.notifyInactive = function() {
        this.active--,
        this.active === 0 && this.destination.complete()
    }
    ,
    S.prototype.checkIterators = function() {
        for (var E = this.iterators, M = E.length, T = this.destination, $ = 0; $ < M; $++) {
            var B = E[$];
            if (typeof B.hasValue == "function" && !B.hasValue())
                return
        }
        for (var O = !1, F = [], $ = 0; $ < M; $++) {
            var B = E[$]
              , N = B.next();
            if (B.hasCompleted() && (O = !0),
            N.done) {
                T.complete();
                return
            }
            F.push(N.value)
        }
        this.resultSelector ? this._tryresultSelector(F) : T.next(F),
        O && T.complete()
    }
    ,
    S.prototype._tryresultSelector = function(E) {
        var M;
        try {
            M = this.resultSelector.apply(this, E)
        } catch (T) {
            this.destination.error(T);
            return
        }
        this.destination.next(M)
    }
    ,
    S
}(Subscriber)
  , StaticIterator = function() {
    function C(S) {
        this.iterator = S,
        this.nextResult = S.next()
    }
    return C.prototype.hasValue = function() {
        return !0
    }
    ,
    C.prototype.next = function() {
        var S = this.nextResult;
        return this.nextResult = this.iterator.next(),
        S
    }
    ,
    C.prototype.hasCompleted = function() {
        var S = this.nextResult;
        return !!(S && S.done)
    }
    ,
    C
}()
  , StaticArrayIterator = function() {
    function C(S) {
        this.array = S,
        this.index = 0,
        this.length = 0,
        this.length = S.length
    }
    return C.prototype[iterator] = function() {
        return this
    }
    ,
    C.prototype.next = function(S) {
        var E = this.index++
          , M = this.array;
        return E < this.length ? {
            value: M[E],
            done: !1
        } : {
            value: null,
            done: !0
        }
    }
    ,
    C.prototype.hasValue = function() {
        return this.array.length > this.index
    }
    ,
    C.prototype.hasCompleted = function() {
        return this.array.length === this.index
    }
    ,
    C
}()
  , ZipBufferIterator = function(C) {
    __extends$1(S, C);
    function S(E, M, T) {
        var $ = C.call(this, E) || this;
        return $.parent = M,
        $.observable = T,
        $.stillUnsubscribed = !0,
        $.buffer = [],
        $.isComplete = !1,
        $
    }
    return S.prototype[iterator] = function() {
        return this
    }
    ,
    S.prototype.next = function() {
        var E = this.buffer;
        return E.length === 0 && this.isComplete ? {
            value: null,
            done: !0
        } : {
            value: E.shift(),
            done: !1
        }
    }
    ,
    S.prototype.hasValue = function() {
        return this.buffer.length > 0
    }
    ,
    S.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete
    }
    ,
    S.prototype.notifyComplete = function() {
        this.buffer.length > 0 ? (this.isComplete = !0,
        this.parent.notifyInactive()) : this.destination.complete()
    }
    ,
    S.prototype.notifyNext = function(E) {
        this.buffer.push(E),
        this.parent.checkIterators()
    }
    ,
    S.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this))
    }
    ,
    S
}(SimpleOuterSubscriber);
const _esm5 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ArgumentOutOfRangeError,
    AsyncSubject,
    BehaviorSubject,
    ConnectableObservable,
    EMPTY,
    EmptyError,
    GroupedObservable,
    NEVER,
    Notification,
    get NotificationKind() {
        return NotificationKind
    },
    ObjectUnsubscribedError,
    Observable,
    ReplaySubject,
    Scheduler,
    Subject,
    Subscriber,
    Subscription,
    TimeoutError,
    UnsubscriptionError,
    VirtualAction,
    VirtualTimeScheduler,
    animationFrame,
    animationFrameScheduler,
    asap,
    asapScheduler,
    async,
    asyncScheduler,
    bindCallback,
    bindNodeCallback,
    combineLatest,
    concat,
    config,
    defer,
    empty,
    forkJoin,
    from,
    fromEvent,
    fromEventPattern,
    generate,
    identity,
    iif,
    interval,
    isObservable,
    merge,
    never,
    noop,
    observable,
    of,
    onErrorResumeNext,
    pairs,
    partition,
    pipe,
    queue,
    queueScheduler,
    race,
    range,
    scheduled,
    throwError,
    timer,
    using,
    zip
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$1 = getAugmentedNamespace(_esm5)
  , require$$2 = getAugmentedNamespace(libEs);
Object.defineProperty(sendAPDU$1, "__esModule", {
    value: !0
});
var sendAPDU_2 = sendAPDU$1.sendAPDU = void 0
  , _rxjs$1 = require$$1
  , _logs$1 = require$$2;
const TagId$1 = 5;
function chunkBuffer(C, S) {
    const E = [];
    for (let M = 0, T = S(0); M < C.length; M += T,
    T = S(M))
        E.push(C.slice(M, M + T));
    return E
}
const sendAPDU = (C,S,E)=>{
    const M = chunkBuffer(S, T=>E - (T === 0 ? 5 : 3)).map((T,$)=>{
        const B = Buffer.alloc($ === 0 ? 5 : 3);
        return B.writeUInt8(TagId$1, 0),
        B.writeUInt16BE($, 1),
        $ === 0 && B.writeUInt16BE(S.length, 3),
        Buffer.concat([B, T])
    }
    );
    return _rxjs$1.Observable.create(T=>{
        let $ = !1;
        async function B() {
            for (const F of M) {
                if ($)
                    return;
                await C(F)
            }
        }
        return B().then(()=>{
            $ = !0,
            T.complete()
        }
        , F=>{
            $ = !0,
            (0,
            _logs$1.log)("ble-error", "sendAPDU failure " + String(F)),
            T.error(F)
        }
        ),
        ()=>{
            $ || ((0,
            _logs$1.log)("ble-verbose", "sendAPDU interruption"),
            $ = !0)
        }
    }
    )
}
;
sendAPDU_2 = sendAPDU$1.sendAPDU = sendAPDU;
var receiveAPDU$1 = {};
Object.defineProperty(receiveAPDU$1, "__esModule", {
    value: !0
});
var receiveAPDU_2 = receiveAPDU$1.receiveAPDU = void 0
  , _errors = require$$0
  , _rxjs = require$$1
  , _logs = require$$2;
const TagId = 5
  , receiveAPDU = C=>_rxjs.Observable.create(S=>{
    let E = 0
      , M = 0
      , T = Buffer.alloc(0);
    const $ = C.subscribe({
        complete: ()=>{
            S.error(new _errors.DisconnectedDevice),
            $.unsubscribe()
        }
        ,
        error: B=>{
            (0,
            _logs.log)("ble-error", "in receiveAPDU " + String(B)),
            S.error(B),
            $.unsubscribe()
        }
        ,
        next: B=>{
            const O = B.readUInt8(0)
              , F = B.readUInt16BE(1);
            let N = B.slice(3);
            if (O !== TagId) {
                S.error(new _errors.TransportError("Invalid tag " + O.toString(16),"InvalidTag"));
                return
            }
            if (E !== F) {
                S.error(new _errors.TransportError("BLE: Invalid sequence number. discontinued chunk. Received " + F + " but expected " + E,"InvalidSequence"));
                return
            }
            if (F === 0 && (M = N.readUInt16BE(0),
            N = N.slice(2)),
            E++,
            T = Buffer.concat([T, N]),
            T.length > M) {
                S.error(new _errors.TransportError("BLE: received too much data. discontinued chunk. Received " + T.length + " but expected " + M,"BLETooMuchData"));
                return
            }
            T.length === M && (S.next(T),
            S.complete(),
            $.unsubscribe())
        }
    });
    return ()=>{
        $.unsubscribe()
    }
}
);
receiveAPDU_2 = receiveAPDU$1.receiveAPDU = receiveAPDU;
function defaultIfEmpty(C) {
    return C === void 0 && (C = null),
    function(S) {
        return S.lift(new DefaultIfEmptyOperator(C))
    }
}
var DefaultIfEmptyOperator = function() {
    function C(S) {
        this.defaultValue = S
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new DefaultIfEmptySubscriber(S,this.defaultValue))
    }
    ,
    C
}()
  , DefaultIfEmptySubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.defaultValue = M,
        T.isEmpty = !0,
        T
    }
    return S.prototype._next = function(E) {
        this.isEmpty = !1,
        this.destination.next(E)
    }
    ,
    S.prototype._complete = function() {
        this.isEmpty && this.destination.next(this.defaultValue),
        this.destination.complete()
    }
    ,
    S
}(Subscriber);
function throwIfEmpty(C) {
    return C === void 0 && (C = defaultErrorFactory),
    function(S) {
        return S.lift(new ThrowIfEmptyOperator(C))
    }
}
var ThrowIfEmptyOperator = function() {
    function C(S) {
        this.errorFactory = S
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new ThrowIfEmptySubscriber(S,this.errorFactory))
    }
    ,
    C
}()
  , ThrowIfEmptySubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.errorFactory = M,
        T.hasValue = !1,
        T
    }
    return S.prototype._next = function(E) {
        this.hasValue = !0,
        this.destination.next(E)
    }
    ,
    S.prototype._complete = function() {
        if (this.hasValue)
            return this.destination.complete();
        var E = void 0;
        try {
            E = this.errorFactory()
        } catch (M) {
            E = M
        }
        this.destination.error(E)
    }
    ,
    S
}(Subscriber);
function defaultErrorFactory() {
    return new EmptyError
}
function take(C) {
    return function(S) {
        return C === 0 ? empty() : S.lift(new TakeOperator(C))
    }
}
var TakeOperator = function() {
    function C(S) {
        if (this.total = S,
        this.total < 0)
            throw new ArgumentOutOfRangeError
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new TakeSubscriber(S,this.total))
    }
    ,
    C
}()
  , TakeSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M) {
        var T = C.call(this, E) || this;
        return T.total = M,
        T.count = 0,
        T
    }
    return S.prototype._next = function(E) {
        var M = this.total
          , T = ++this.count;
        T <= M && (this.destination.next(E),
        T === M && (this.destination.complete(),
        this.unsubscribe()))
    }
    ,
    S
}(Subscriber);
function first(C, S) {
    var E = arguments.length >= 2;
    return function(M) {
        return M.pipe(C ? filter(function(T, $) {
            return C(T, $, M)
        }) : identity, take(1), E ? defaultIfEmpty(S) : throwIfEmpty(function() {
            return new EmptyError
        }))
    }
}
function ignoreElements() {
    return function(S) {
        return S.lift(new IgnoreElementsOperator)
    }
}
var IgnoreElementsOperator = function() {
    function C() {}
    return C.prototype.call = function(S, E) {
        return E.subscribe(new IgnoreElementsSubscriber(S))
    }
    ,
    C
}()
  , IgnoreElementsSubscriber = function(C) {
    __extends$1(S, C);
    function S() {
        return C !== null && C.apply(this, arguments) || this
    }
    return S.prototype._next = function(E) {}
    ,
    S
}(Subscriber);
function multicast(C, S) {
    return function(M) {
        var T;
        if (typeof C == "function" ? T = C : T = function() {
            return C
        }
        ,
        typeof S == "function")
            return M.lift(new MulticastOperator(T,S));
        var $ = Object.create(M, connectableObservableDescriptor);
        return $.source = M,
        $.subjectFactory = T,
        $
    }
}
var MulticastOperator = function() {
    function C(S, E) {
        this.subjectFactory = S,
        this.selector = E
    }
    return C.prototype.call = function(S, E) {
        var M = this.selector
          , T = this.subjectFactory()
          , $ = M(T).subscribe(S);
        return $.add(E.subscribe(T)),
        $
    }
    ,
    C
}();
function shareSubjectFactory() {
    return new Subject
}
function share() {
    return function(C) {
        return refCount()(multicast(shareSubjectFactory)(C))
    }
}
function tap(C, S, E) {
    return function(T) {
        return T.lift(new DoOperator(C,S,E))
    }
}
var DoOperator = function() {
    function C(S, E, M) {
        this.nextOrObserver = S,
        this.error = E,
        this.complete = M
    }
    return C.prototype.call = function(S, E) {
        return E.subscribe(new TapSubscriber(S,this.nextOrObserver,this.error,this.complete))
    }
    ,
    C
}()
  , TapSubscriber = function(C) {
    __extends$1(S, C);
    function S(E, M, T, $) {
        var B = C.call(this, E) || this;
        return B._tapNext = noop,
        B._tapError = noop,
        B._tapComplete = noop,
        B._tapError = T || noop,
        B._tapComplete = $ || noop,
        isFunction(M) ? (B._context = B,
        B._tapNext = M) : M && (B._context = M,
        B._tapNext = M.next || noop,
        B._tapError = M.error || noop,
        B._tapComplete = M.complete || noop),
        B
    }
    return S.prototype._next = function(E) {
        try {
            this._tapNext.call(this._context, E)
        } catch (M) {
            this.destination.error(M);
            return
        }
        this.destination.next(E)
    }
    ,
    S.prototype._error = function(E) {
        try {
            this._tapError.call(this._context, E)
        } catch (M) {
            this.destination.error(M);
            return
        }
        this.destination.error(E)
    }
    ,
    S.prototype._complete = function() {
        try {
            this._tapComplete.call(this._context)
        } catch (E) {
            this.destination.error(E);
            return
        }
        return this.destination.complete()
    }
    ,
    S
}(Subscriber);
const monitorCharacteristic = C=>Observable.create(S=>{
    log("ble-verbose", "start monitor " + C.uuid);
    function E(M) {
        const T = M.target;
        T.value && S.next(Buffer.from(T.value.buffer))
    }
    return C.startNotifications().then(()=>{
        C.addEventListener("characteristicvaluechanged", E)
    }
    ),
    ()=>{
        log("ble-verbose", "end monitor " + C.uuid),
        C.stopNotifications()
    }
}
)
  , requiresBluetooth = ()=>{
    const {bluetooth: C} = navigator;
    if (typeof C > "u")
        throw new Error("web bluetooth not supported");
    return C
}
  , availability = ()=>Observable.create(C=>{
    const S = requiresBluetooth()
      , E = T=>{
        C.next(T.value)
    }
    ;
    S.addEventListener("availabilitychanged", E);
    let M = !1;
    return S.getAvailability().then(T=>{
        M || C.next(T)
    }
    ),
    ()=>{
        M = !0,
        S.removeEventListener("availabilitychanged", E)
    }
}
)
  , transportsCache = {}
  , requestDeviceParam = ()=>({
    filters: getBluetoothServiceUuids().map(C=>({
        services: [C]
    }))
})
  , retrieveService = async C=>{
    if (!C.gatt)
        throw new Error("bluetooth gatt not found");
    const [S] = await C.gatt.getPrimaryServices();
    if (!S)
        throw new Error("bluetooth service not found");
    const E = getInfosForServiceUuid(S.uuid);
    if (!E)
        throw new Error("bluetooth service infos not found");
    return [S, E]
}
;
async function open(C, S) {
    let E;
    if (typeof C == "string") {
        if (transportsCache[C])
            return log("ble-verbose", "Transport in cache, using that."),
            transportsCache[C];
        E = await requiresBluetooth().requestDevice(requestDeviceParam())
    } else
        E = C;
    E.gatt.connected || (log("ble-verbose", "not connected. connecting..."),
    await E.gatt.connect());
    const [M,T] = await retrieveService(E)
      , {deviceModel: $, writeUuid: B, notifyUuid: O} = T
      , [F,N] = await Promise.all([M.getCharacteristic(B), M.getCharacteristic(O)])
      , U = monitorCharacteristic(N).pipe(tap(oe=>{
        log("ble-frame", "<= " + oe.toString("hex"))
    }
    ), share())
      , H = U.subscribe()
      , Z = new BluetoothTransport$1(E,F,U,$);
    if (!E.gatt.connected)
        throw new DisconnectedDevice;
    transportsCache[Z.id] = Z;
    const J = oe=>{
        console.log("onDisconnect!", oe),
        delete transportsCache[Z.id],
        Z.notYetDisconnected = !1,
        H.unsubscribe(),
        E.removeEventListener("gattserverdisconnected", J),
        log("ble-verbose", `BleTransport(${Z.id}) disconnected`),
        Z.emit("disconnect", oe)
    }
    ;
    E.addEventListener("gattserverdisconnected", J);
    let ie = Date.now();
    try {
        await Z.inferMTU()
    } finally {
        Date.now() - ie < 1e3 && (S = !1),
        S && (await E.gatt.disconnect(),
        await new Promise(ae=>setTimeout(ae, 4e3)))
    }
    return S ? open(E, !1) : Z
}
let BluetoothTransport$1 = class extends Transport {
    static listen(S) {
        log("ble-verbose", "listen...");
        let E;
        requiresBluetooth().requestDevice(requestDeviceParam()).then(async $=>{
            E || (S.next({
                type: "add",
                descriptor: $
            }),
            S.complete())
        }
        , $=>{
            S.error(new TransportOpenUserCancelled($.message))
        }
        );
        function T() {
            E = !0
        }
        return {
            unsubscribe: T
        }
    }
    static async open(S) {
        return open(S, !0)
    }
    constructor(S, E, M, T) {
        super(),
        this.id = void 0,
        this.device = void 0,
        this.mtuSize = 20,
        this.writeCharacteristic = void 0,
        this.notifyObservable = void 0,
        this.notYetDisconnected = !0,
        this.deviceModel = void 0,
        this.exchange = $=>this.exchangeAtomicImpl(async()=>{
            try {
                const B = $.toString("hex");
                log("apdu", `=> ${B}`);
                const O = await merge(this.notifyObservable.pipe(receiveAPDU_2), sendAPDU_2(this.write, $, this.mtuSize)).toPromise()
                  , F = O.toString("hex");
                return log("apdu", `<= ${F}`),
                O
            } catch (B) {
                throw log("ble-error", "exchange got " + String(B)),
                this.notYetDisconnected && this.device.gatt.disconnect(),
                B
            }
        }
        ),
        this.write = async $=>{
            log("ble-frame", "=> " + $.toString("hex")),
            await this.writeCharacteristic.writeValue($)
        }
        ,
        this.id = S.id,
        this.device = S,
        this.writeCharacteristic = E,
        this.notifyObservable = M,
        this.deviceModel = T,
        log("ble-verbose", `BleTransport(${String(this.id)}) new instance`)
    }
    async inferMTU() {
        let S = 23;
        if (await this.exchangeAtomicImpl(async()=>{
            try {
                S = await merge(this.notifyObservable.pipe(first(E=>E.readUInt8(0) === 8), map(E=>E.readUInt8(5))), defer(()=>from(this.write(Buffer.from([8, 0, 0, 0, 0])))).pipe(ignoreElements())).toPromise() + 3
            } catch (E) {
                throw log("ble-error", "inferMTU got " + String(E)),
                this.device.gatt.disconnect(),
                E
            }
        }
        ),
        S > 23) {
            const E = S - 3;
            log("ble-verbose", `BleTransport(${String(this.id)}) mtu set to ${String(E)}`),
            this.mtuSize = E
        }
        return this.mtuSize
    }
    setScrambleKey() {}
    async close() {
        this.exchangeBusyPromise && await this.exchangeBusyPromise
    }
}
;
BluetoothTransport$1.isSupported = ()=>Promise.resolve().then(requiresBluetooth).then(()=>!0, ()=>!1);
BluetoothTransport$1.observeAvailability = C=>availability.subscribe(C);
BluetoothTransport$1.list = ()=>Promise.resolve([]);
BluetoothTransport$1.disconnect = async C=>{
    log("ble-verbose", `user disconnect(${C})`);
    const S = transportsCache[C];
    S && S.device.gatt.disconnect()
}
;
const TransportWebBLE = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: BluetoothTransport$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$14 = getAugmentedNamespace(TransportWebBLE);
var dns = {}
  , Dns$3 = {};
const {parseAddress: parseAddress$2} = NftUtils
  , {AdnlAddress, StorageBagId, BN: BN$1, sha256, bytesToHex: bytesToHex$1, bytesToBase64} = utils$1
  , {Cell: Cell$2} = boc$1
  , DNS_CATEGORY_NEXT_RESOLVER$1 = "dns_next_resolver"
  , DNS_CATEGORY_WALLET$1 = "wallet"
  , DNS_CATEGORY_SITE$1 = "site"
  , DNS_CATEGORY_STORAGE$1 = "storage"
  , categoryToBN$1 = async C=>{
    if (!C)
        return new BN$1(0);
    const S = new TextEncoder().encode(C)
      , E = new Uint8Array(await sha256(S));
    return new BN$1(bytesToHex$1(E),16)
}
  , createSmartContractAddressRecord$1 = C=>{
    const S = new Cell$2;
    return S.bits.writeUint(40915, 16),
    S.bits.writeAddress(C),
    S.bits.writeUint(0, 8),
    S
}
  , createAdnlAddressRecord$1 = C=>{
    const S = new Cell$2;
    return S.bits.writeUint(44289, 16),
    S.bits.writeBytes(C.bytes),
    S.bits.writeUint(0, 8),
    S
}
  , createStorageBagIdRecord$1 = C=>{
    const S = new Cell$2;
    return S.bits.writeUint(29811, 16),
    S.bits.writeBytes(C.bytes),
    S
}
  , createNextResolverRecord$1 = C=>{
    const S = new Cell$2;
    return S.bits.writeUint(47763, 16),
    S.bits.writeAddress(C),
    S
}
  , parseSmartContractAddressImpl = (C,S,E)=>{
    if (C.bits.array[0] !== S || C.bits.array[1] !== E)
        throw new Error("Invalid dns record value prefix");
    return C.bits.array = C.bits.array.slice(2),
    parseAddress$2(C)
}
  , parseSmartContractAddressRecord$1 = C=>parseSmartContractAddressImpl(C, 159, 211)
  , parseNextResolverRecord$1 = C=>parseSmartContractAddressImpl(C, 186, 147)
  , parseAdnlAddressRecord$1 = C=>{
    if (C.bits.array[0] !== 173 || C.bits.array[1] !== 1)
        throw new Error("Invalid dns record value prefix");
    const S = C.bits.array.slice(2, 34);
    return new AdnlAddress(S)
}
  , parseStorageBagIdRecord$1 = C=>{
    if (C.bits.array[0] !== 116 || C.bits.array[1] !== 115)
        throw new Error("Invalid dns record value prefix");
    const S = C.bits.array.slice(2, 34);
    return new StorageBagId(S)
}
  , parseSiteRecord$1 = C=>C ? C.bits.array[0] === 173 || C.bits.array[1] === 1 ? parseAdnlAddressRecord$1(C) : parseStorageBagIdRecord$1(C) : null
  , dnsResolveImpl = async(C,S,E,M,T)=>{
    const $ = E.length * 8
      , B = new Cell$2;
    B.bits.writeBytes(E);
    const O = await categoryToBN$1(M)
      , F = await C.call2(S, "dnsresolve", [["tvm.Slice", bytesToBase64(await B.toBoc(!1))], ["num", O.toString()]]);
    if (F.length !== 2)
        throw new Error("Invalid dnsresolve response");
    const N = F[0].toNumber();
    let U = F[1];
    if (U instanceof Array && U.length === 0 && (U = null),
    U && !U.bits)
        throw new Error("Invalid dnsresolve response");
    if (N === 0)
        return null;
    if (N % 8 !== 0)
        throw new Error("domain split not at a component boundary");
    if (N > $)
        throw new Error("invalid response " + N + "/" + $);
    if (N === $)
        return M === DNS_CATEGORY_NEXT_RESOLVER$1 ? U ? parseNextResolverRecord$1(U) : null : M === DNS_CATEGORY_WALLET$1 ? U ? parseSmartContractAddressRecord$1(U) : null : M === DNS_CATEGORY_SITE$1 ? U ? parseSiteRecord$1(U) : null : M === DNS_CATEGORY_STORAGE$1 ? U ? parseStorageBagIdRecord$1(U) : null : U;
    if (U) {
        const H = parseNextResolverRecord$1(U);
        return T ? M === DNS_CATEGORY_NEXT_RESOLVER$1 ? H : null : await dnsResolveImpl(C, H.toString(), E.slice(N / 8), M, !1)
    } else
        return null
}
  , domainToBytes = C=>{
    if (!C || !C.length)
        throw new Error("empty domain");
    if (C === ".")
        return new Uint8Array([0]);
    C = C.toLowerCase();
    for (let M = 0; M < C.length; M++)
        if (C.charCodeAt(M) <= 32)
            throw new Error("bytes in range 0..32 are not allowed in domain names");
    for (let M = 0; M < C.length; M++) {
        const T = C.substring(M, M + 1);
        for (let $ = 127; $ <= 159; $++)
            if (T === String.fromCharCode($))
                throw new Error("bytes in range 127..159 are not allowed in domain names")
    }
    const S = C.split(".");
    S.forEach(M=>{
        if (!M.length)
            throw new Error("domain name cannot have an empty component")
    }
    );
    let E = S.reverse().join("\0") + "\0";
    return E.length < 126 && (E = "\0" + E),
    new TextEncoder().encode(E)
}
  , dnsResolve$3 = async(C,S,E,M,T)=>{
    const $ = domainToBytes(E);
    return dnsResolveImpl(C, S, $, M, T)
}
;
var DnsUtils = {
    DNS_CATEGORY_NEXT_RESOLVER: DNS_CATEGORY_NEXT_RESOLVER$1,
    DNS_CATEGORY_SITE: DNS_CATEGORY_SITE$1,
    DNS_CATEGORY_WALLET: DNS_CATEGORY_WALLET$1,
    DNS_CATEGORY_STORAGE: DNS_CATEGORY_STORAGE$1,
    categoryToBN: categoryToBN$1,
    domainToBytes,
    createSmartContractAddressRecord: createSmartContractAddressRecord$1,
    createAdnlAddressRecord: createAdnlAddressRecord$1,
    createNextResolverRecord: createNextResolverRecord$1,
    parseSmartContractAddressRecord: parseSmartContractAddressRecord$1,
    parseAdnlAddressRecord: parseAdnlAddressRecord$1,
    parseStorageBagIdRecord: parseStorageBagIdRecord$1,
    parseSiteRecord: parseSiteRecord$1,
    parseNextResolverRecord: parseNextResolverRecord$1,
    createStorageBagIdRecord: createStorageBagIdRecord$1,
    dnsResolve: dnsResolve$3
};
const {Address: Address$2, bytesToHex} = utils$1
  , {DNS_CATEGORY_NEXT_RESOLVER, DNS_CATEGORY_SITE, DNS_CATEGORY_WALLET, DNS_CATEGORY_STORAGE, createSmartContractAddressRecord, createAdnlAddressRecord, createStorageBagIdRecord, createNextResolverRecord, parseSmartContractAddressRecord, parseAdnlAddressRecord, parseStorageBagIdRecord, parseSiteRecord, parseNextResolverRecord, dnsResolve: dnsResolve$2} = DnsUtils;
let Dns$2 = class {
    constructor(S) {
        this.provider = S
    }
    async getRootDnsAddress() {
        const E = (await this.provider.getConfigParam(4)).bits.array;
        if (E.length !== 256 / 8)
            throw new Error("Invalid ConfigParam 4 length " + E.length);
        const M = bytesToHex(E);
        return new Address$2("-1:" + M)
    }
    async resolve(S, E, M) {
        const T = await this.getRootDnsAddress();
        return dnsResolve$2(this.provider, T.toString(), S, E, M)
    }
    getWalletAddress(S) {
        return this.resolve(S, DNS_CATEGORY_WALLET)
    }
    getSiteAddress(S) {
        return this.resolve(S, DNS_CATEGORY_SITE)
    }
}
;
Dns$2.resolve = dnsResolve$2;
Dns$2.createSmartContractAddressRecord = createSmartContractAddressRecord;
Dns$2.createAdnlAddressRecord = createAdnlAddressRecord;
Dns$2.createStorageBagIdRecord = createStorageBagIdRecord;
Dns$2.createNextResolverRecord = createNextResolverRecord;
Dns$2.parseNextResolverRecord = parseNextResolverRecord;
Dns$2.parseAdnlAddressRecord = parseAdnlAddressRecord;
Dns$2.parseStorageBagIdRecord = parseStorageBagIdRecord;
Dns$2.parseSiteRecord = parseSiteRecord;
Dns$2.parseSmartContractAddressRecord = parseSmartContractAddressRecord;
Dns$2.DNS_CATEGORY_NEXT_RESOLVER = DNS_CATEGORY_NEXT_RESOLVER;
Dns$2.DNS_CATEGORY_WALLET = DNS_CATEGORY_WALLET;
Dns$2.DNS_CATEGORY_SITE = DNS_CATEGORY_SITE;
Dns$2.DNS_CATEGORY_STORAGE = DNS_CATEGORY_STORAGE;
Dns$3.default = Dns$2;
const {Contract: Contract$2} = contract
  , {Cell: Cell$1} = boc$1
  , {parseAddress: parseAddress$1} = NftUtils
  , {dnsResolve: dnsResolve$1} = DnsUtils
  , {parseOffchainUriCell} = NftUtils;
let DnsCollection$2 = class extends Contract$2 {
    constructor(S, E) {
        if (E.wc = 0,
        E.code = E.code,
        super(S, E),
        !E.collectionContent && !E.address)
            throw new Error("required collectionContent cell");
        this.methods.getCollectionData = this.getCollectionData.bind(this),
        this.methods.getNftItemAddressByIndex = this.getNftItemAddressByIndex.bind(this),
        this.methods.getNftItemContent = this.getNftItemContent.bind(this),
        this.methods.resolve = this.resolve.bind(this)
    }
    createDataCell() {
        const S = new Cell$1;
        return S.refs[0] = this.options.collectionContent,
        S.refs[1] = Cell$1.oneFromBoc(this.options.dnsItemCodeHex),
        S
    }
    async getCollectionData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_collection_data")
          , M = E[0].toNumber()
          , T = E[1];
        return {
            collectionContentUri: parseOffchainUriCell(T),
            collectionContent: T,
            ownerAddress: null,
            nextItemIndex: M
        }
    }
    async getNftItemContent(S) {
        return await S.getData()
    }
    async getNftItemAddressByIndex(S) {
        const E = await this.getAddress()
          , M = await this.provider.call2(E.toString(), "get_nft_address_by_index", [["num", S.toString()]]);
        return parseAddress$1(M)
    }
    async resolve(S, E, M) {
        const T = await this.getAddress();
        return dnsResolve$1(this.provider, T.toString(), S, E, M)
    }
}
;
var DnsCollection_1 = {
    DnsCollection: DnsCollection$2
};
const {Contract: Contract$1} = contract
  , {Cell} = boc$1
  , {Address: Address$1, BN} = utils$1
  , {parseAddress} = NftUtils
  , {dnsResolve, categoryToBN} = DnsUtils;
let DnsItem$2 = class extends Contract$1 {
    constructor(S, E) {
        E.wc = 0,
        E.code = E.code,
        super(S, E),
        this.methods.getData = this.getData.bind(this),
        this.methods.getDomain = this.getDomain.bind(this),
        this.methods.getAuctionInfo = this.getAuctionInfo.bind(this),
        this.methods.getLastFillUpTime = this.getLastFillUpTime.bind(this),
        this.methods.resolve = this.resolve.bind(this)
    }
    createDataCell() {
        const S = new Cell;
        return S.bits.writeUint(this.options.index, 256),
        S.bits.writeAddress(this.options.collectionAddress),
        S
    }
    async getData() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_nft_data")
          , M = E[0].toNumber() === -1
          , T = E[1]
          , $ = parseAddress(E[2])
          , B = M ? parseAddress(E[3]) : null
          , O = E[4];
        return {
            isInitialized: M,
            index: T,
            collectionAddress: $,
            ownerAddress: B,
            contentCell: O
        }
    }
    async createTransferBody(S) {
        const E = new Cell;
        return E.bits.writeUint(1607220500, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E.bits.writeAddress(S.newOwnerAddress),
        E.bits.writeAddress(S.responseAddress),
        E.bits.writeBit(!1),
        E.bits.writeCoins(S.forwardAmount || new BN(0)),
        E.bits.writeBit(!1),
        S.forwardPayload && E.bits.writeBytes(S.forwardPayload),
        E
    }
    createGetStaticDataBody(S) {
        const E = new Cell;
        return E.bits.writeUint(801842850, 32),
        E.bits.writeUint(S.queryId || 0, 64),
        E
    }
    async getDomain() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_domain");
        return new TextDecoder().decode(E.bits.array.buffer)
    }
    async getAuctionInfo() {
        const S = await this.getAddress()
          , E = await this.provider.call2(S.toString(), "get_auction_info")
          , M = parseAddress(E[0])
          , T = E[1]
          , $ = E[2].toNumber();
        return {
            maxBidAddress: M,
            maxBidAmount: T,
            auctionEndTime: $
        }
    }
    async getLastFillUpTime() {
        const S = await this.getAddress();
        return (await this.provider.call2(S.toString(), "get_last_fill_up_time")).toNumber()
    }
    async resolve(S, E, M) {
        const T = await this.getAddress();
        return dnsResolve(this.provider, T.toString(), S, E, M)
    }
}
;
DnsItem$2.createChangeContentEntryBody = async C=>{
    const S = new Cell;
    return S.bits.writeUint(1320284409, 32),
    S.bits.writeUint(C.queryId || 0, 64),
    S.bits.writeUint(await categoryToBN(C.category), 256),
    C.value && (S.refs[0] = C.value),
    S
}
;
var DnsItem_1 = {
    DnsItem: DnsItem$2
};
const Dns$1 = Dns$3.default
  , {DnsCollection: DnsCollection$1} = DnsCollection_1
  , {DnsItem: DnsItem$1} = DnsItem_1;
dns.default = {
    Dns: Dns$1,
    DnsCollection: DnsCollection$1,
    DnsItem: DnsItem$1
};
const utils = utils$1
  , Address = utils.Address
  , boc = boc$1
  , AppTon = AppTon_1
  , HttpProvider = providers.default
  , {Contract} = contract
  , Wallets = wallet.default
  , LockupWallets = lockup.default
  , NFT = nft.default
  , JETTON = ft.default
  , {BlockSubscription, InMemoryBlockStorage} = blockSubscription
  , {SubscriptionContract} = subscription
  , {Payments, PaymentChannel} = payments
  , TransportWebUSB = require$$12.default
  , TransportWebHID = require$$13.default
  , BluetoothTransport = require$$14.default
  , {Dns, DnsCollection, DnsItem} = dns.default
  , version = "0.0.64";
class TonWeb {
    constructor(S) {
        this.version = version,
        this.utils = utils,
        this.Address = Address,
        this.boc = boc,
        this.Contract = Contract,
        this.BlockSubscription = BlockSubscription,
        this.InMemoryBlockStorage = InMemoryBlockStorage,
        this.provider = S || new HttpProvider,
        this.dns = new Dns(this.provider),
        this.wallet = new Wallets(this.provider),
        this.payments = new Payments(this.provider),
        this.lockupWallet = LockupWallets
    }
    async getTransactions(S, E=20, M=void 0, T=void 0, $=void 0) {
        return this.provider.getTransactions(S.toString(), E, M, T, $)
    }
    async getBalance(S) {
        return this.provider.getBalance(S.toString())
    }
    async sendBoc(S) {
        return this.provider.sendBoc(utils.bytesToBase64(S))
    }
    async call(S, E, M=[]) {
        return this.provider.call(S.toString(), E, M)
    }
}
TonWeb.version = version;
TonWeb.utils = utils;
TonWeb.Address = Address;
TonWeb.boc = boc;
TonWeb.HttpProvider = HttpProvider;
TonWeb.Contract = Contract;
TonWeb.Wallets = Wallets;
TonWeb.LockupWallets = LockupWallets;
TonWeb.SubscriptionContract = SubscriptionContract;
TonWeb.BlockSubscription = BlockSubscription;
TonWeb.InMemoryBlockStorage = InMemoryBlockStorage;
TonWeb.ledger = {
    TransportWebUSB,
    TransportWebHID,
    BluetoothTransport,
    AppTon
};
TonWeb.token = {
    nft: NFT,
    ft: JETTON,
    jetton: JETTON
};
TonWeb.dns = Dns;
TonWeb.dns.DnsCollection = DnsCollection;
TonWeb.dns.DnsItem = DnsItem;
TonWeb.payments = Payments;
TonWeb.payments.PaymentChannel = PaymentChannel;
var src = TonWeb;
const TonWeb$1 = getDefaultExportFromCjs$1(src);
function isMobile() {
    return window.matchMedia("(max-width: 900px)").matches || /Android|Mobi|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent)
}
function openLink(C, S="_blank") {
    const E = document.createElement("a");
    E.href = C,
    E.target = S,
    E.rel = "noopener noreferrer",
    document.body.appendChild(E),
    E.click(),
    document.body.removeChild(E)
}
class Sender {
    constructor(S) {
        jt(this, "address");
        jt(this, "connector");
        this.connector = S.connector,
        this.address = S.account ? dist$4.Address.parse(S.account.address) : void 0
    }
    async send(S) {
        var $, B, O;
        console.log(S);
        const E = {
            code: ($ = S.init) == null ? void 0 : $.code,
            data: (B = S.init) == null ? void 0 : B.data
        }
          , M = dist$4.beginCell().store(dist$4.storeStateInit(E)).endCell()
          , T = TonWeb$1.utils.bytesToBase64(await M.toBoc());
        this.connector.sendTransaction({
            messages: [{
                address: S.to.toString(),
                amount: S.value.toString(),
                payload: (O = S.body) == null ? void 0 : O.toBoc().toString("base64"),
                stateInit: T
            }],
            validUntil: Date.now() + 5 * 60 * 1e3
        })
    }
    async sendTransaction(S, E) {
        try {
            "universalLink"in E && !E.embedded && isMobile() && openLink(addReturnStrategy(E.universalLink, "none"), "_blank");
            const M = await this.connector.sendTransaction(S);
            return staticMethods.success({
                message: "Successful transaction",
                description: "You transaction was successfully sent. Please wait until the transaction is included to the TON blockchain.",
                duration: 5
            }),
            console.log(`Send tx result: ${JSON.stringify(M)}`),
            M
        } catch (M) {
            let T = "Send transaction error"
              , $ = "";
            throw typeof M == "object" && M instanceof UserRejectsError && (T = "You rejected the transaction",
            $ = "Please try again and confirm transaction in your wallet."),
            staticMethods.error({
                message: T,
                description: $
            }),
            console.log(M),
            M
        }
    }
}
function addReturnStrategy(C, S) {
    const E = new URL(C);
    return E.searchParams.append("ret", S),
    E.toString()
}
const useDeploy = ()=>{
    const {configStore: C} = useStores()
      , [S] = useTonConnectUI()
      , {isConnected: E, connect: M} = useConnectWallet()
      , {wrapPromise: T} = useStatusState()
      , $ = useTonAddress();
    return {
        deploy: reactExports.useCallback(T(async()=>{
            if (!E || $ === "") {
                await M();
                return
            }
            const O = await getClient()
              , F = await TonPotato.fromInit(9n)
              , N = O.open(F)
              , U = new Sender(S);
            await N.send(U, {
                value: dist$4.toNano(.1)
            }, {
                $$type: "Deploy",
                queryId: 0n
            }),
            await waitTx(dist$4.Address.parse($))
        }
        ), [E, M, S, $, C.config])
    }
}
;
function storeDeploy(C) {
    return S=>{
        let E = S;
        E.storeUint(2490013878, 32),
        E.storeUint(C.queryId, 64)
    }
}
function storeWithdraw(C) {
    return S=>{
        let E = S;
        E.storeUint(195467089, 32),
        E.storeCoins(C.amount)
    }
}
async function PotatoReceive_init() {
    const C = dist$4.Cell.fromBase64("te6ccgECGAEABA0AART/APSkE/S88sgLAQIBYgIDAtTQAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxa2zzy4ILI+EMBzH8BygBZWSDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFssHye1UEgQCASALDATW7aLt+wGSMH/gcCHXScIflTAg1wsf3iDAACLXScEhsJJbf+AgghALppdRuo8xMNMfAYIQC6aXUbry4IH6AAExWds8+CdvEIIImJaAoRO2CPhCf1iAQhAjbW1t2zwBf+AgghCUapi2uuMCwAAICQUGAVAw0x8BghCUapi2uvLggdM/ATHIAYIQr/kPV1jLH8s/yfhCAXBt2zx/BwLmj235ASCC8FmJN67a8JYiqNB0qw+qAIBfjnG+YFYt4ZSEnWYBmRIrupQwf9sx4ILwUJK13OBxWlfdlp9ftab5MCWgsC6rMpRwyis2XKDX6Tq6jxvbPPhCf/gnbxCCCJiWgKGAQhAjbW1t2zx/2zHgkTDicAgJATptbSJus5lbIG7y0IBvIgGRMuIQJHADBIBCUCPbPAkAEvhCUiDHBfLghAHKyHEBygFQBwHKAHABygJQBSDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFlAD+gJwAcpoI26zkX+TJG6z4pczMwFwAcoA4w0hbrOcfwHKAAEgbvLQgAHMlTFwAcoA4skB+wAKAJh/AcoAyHABygBwAcoAJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4iRus51/AcoABCBu8tCAUATMljQDcAHKAOJwAcoAAn8BygACyVjMAhG+KO7Z5tnjYQwSDQIBIA4PAAIhAgEgEBECAUgWFwIRttgbZ5tnjYQwEhMAubd6ME4LnYerpZXPY9CdhzrJUKNs0E4TusalpWyPlmRadeW/vixHME4ECrgDcAzscpnLB1XI5LZYcE4TsunLVmnZbmdB0s2yjN0UkE4IGc6tPOK/OkoWA6wtxMj2UAGA7UTQ1AH4Y9IAAY4l+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiAHTB1lsEuAw+CjXCwqDCbry4InbPBQBDvgnbxB52zwVAAb4QnMA2iDBASHCTbHy0IbIIsEAmIAtAcsHAqMC3n9wbwAEjhsEeqkMIMAAUjCws5twM6YwFG+MBKQEA5Ew4gTkAbOXAoAub4wCpN6OEAN6qQymMBNvjAOkIsAAEDTmMyKlA5pTEm+BAcsHAqUC5GwhydAAEbCvu1E0NIAAYAB1sm7jQ1aXBmczovL1FtVHBnOVpFbURpYWFDU1llWkhYaXRXSEFueVB3enBUeFRDVjRZRzdXV0tReHaCA=")
      , S = dist$4.Cell.fromBase64("te6cckECGgEABBcAAQHAAQEFoLy5AgEU/wD0pBP0vPLICwMCAWIQBAIBIA4FAgEgCQYCAUgIBwB1sm7jQ1aXBmczovL1FtVHBnOVpFbURpYWFDU1llWkhYaXRXSEFueVB3enBUeFRDVjRZRzdXV0tReHaCAAEbCvu1E0NIAAYAIBIAsKALm3ejBOC52Hq6WVz2PQnYc6yVCjbNBOE7rGpaVsj5ZkWnXlv74sRzBOBAq4A3AM7HKZywdVyOS2WHBOE7Lpy1Zp2W5nQdLNsozdFJBOCBnOrTzivzpKFgOsLcTI9lACEbbYG2ebZ42EMBgMAQ74J28Qeds8DQDaIMEBIcJNsfLQhsgiwQCYgC0BywcCowLef3BvAASOGwR6qQwgwABSMLCzm3AzpjAUb4wEpAQDkTDiBOQBs5cCgC5vjAKk3o4QA3qpDKYwE2+MA6QiwAAQNOYzIqUDmlMSb4EBywcCpQLkbCHJ0AIRviju2ebZ42EMGA8AAiEC1NAB0NMDAXGwowH6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIVFBTA28E+GEC+GLbPFrbPPLggsj4QwHMfwHKAFlZINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WywfJ7VQYEQTW7aLt+wGSMH/gcCHXScIflTAg1wsf3iDAACLXScEhsJJbf+AgghALppdRuo8xMNMfAYIQC6aXUbry4IH6AAExWds8+CdvEIIImJaAoRO2CPhCf1iAQhAjbW1t2zwBf+AgghCUapi2uuMCwAAXFRMSAuaPbfkBIILwWYk3rtrwliKo0HSrD6oAgF+Ocb5gVi3hlISdZgGZEiu6lDB/2zHggvBQkrXc4HFaV92Wn1+1pvkwJaCwLqsylHDKKzZcoNfpOrqPG9s8+EJ/+CdvEIIImJaAoYBCECNtbW3bPH/bMeCRMOJwFxUBUDDTHwGCEJRqmLa68uCB0z8BMcgBghCv+Q9XWMsfyz/J+EIBcG3bPH8UATptbSJus5lbIG7y0IBvIgGRMuIQJHADBIBCUCPbPBUByshxAcoBUAcBygBwAcoCUAUg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIzxZQA/oCcAHKaCNus5F/kyRus+KXMzMBcAHKAOMNIW6znH8BygABIG7y0IABzJUxcAHKAOLJAfsAFgCYfwHKAMhwAcoAcAHKACRus51/AcoABCBu8tCAUATMljQDcAHKAOIkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDicAHKAAJ/AcoAAslYzAAS+EJSIMcF8uCEAYDtRNDUAfhj0gABjiX6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIAdMHWWwS4DD4KNcLCoMJuvLgids8GQAG+EJziNDmgQ==");
    let E = dist$4.beginCell();
    E.storeRef(S),
    E.storeUint(0, 1);
    const M = E.endCell();
    return {
        code: C,
        data: M
    }
}
const PotatoReceive_errors = {
    2: {
        message: "Stack undeflow"
    },
    3: {
        message: "Stack overflow"
    },
    4: {
        message: "Integer overflow"
    },
    5: {
        message: "Integer out of expected range"
    },
    6: {
        message: "Invalid opcode"
    },
    7: {
        message: "Type check error"
    },
    8: {
        message: "Cell overflow"
    },
    9: {
        message: "Cell underflow"
    },
    10: {
        message: "Dictionary error"
    },
    13: {
        message: "Out of gas error"
    },
    32: {
        message: "Method ID not found"
    },
    34: {
        message: "Action is invalid or not supported"
    },
    37: {
        message: "Not enough TON"
    },
    38: {
        message: "Not enough extra-currencies"
    },
    128: {
        message: "Null reference exception"
    },
    129: {
        message: "Invalid serialization prefix"
    },
    130: {
        message: "Invalid incoming message"
    },
    131: {
        message: "Constraints error"
    },
    132: {
        message: "Access denied"
    },
    133: {
        message: "Contract stopped"
    },
    134: {
        message: "Invalid argument"
    },
    135: {
        message: "Code of a contract was not found"
    },
    136: {
        message: "Invalid address"
    },
    137: {
        message: "Masterchain support is not enabled for this contract"
    }
}
  , PotatoReceive_types = [{
    name: "StateInit",
    header: null,
    fields: [{
        name: "code",
        type: {
            kind: "simple",
            type: "cell",
            optional: !1
        }
    }, {
        name: "data",
        type: {
            kind: "simple",
            type: "cell",
            optional: !1
        }
    }]
}, {
    name: "Context",
    header: null,
    fields: [{
        name: "bounced",
        type: {
            kind: "simple",
            type: "bool",
            optional: !1
        }
    }, {
        name: "sender",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }, {
        name: "value",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "raw",
        type: {
            kind: "simple",
            type: "slice",
            optional: !1
        }
    }]
}, {
    name: "SendParameters",
    header: null,
    fields: [{
        name: "bounce",
        type: {
            kind: "simple",
            type: "bool",
            optional: !1
        }
    }, {
        name: "to",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }, {
        name: "value",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "mode",
        type: {
            kind: "simple",
            type: "int",
            optional: !1,
            format: 257
        }
    }, {
        name: "body",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }, {
        name: "code",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }, {
        name: "data",
        type: {
            kind: "simple",
            type: "cell",
            optional: !0
        }
    }]
}, {
    name: "Deploy",
    header: 2490013878,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }]
}, {
    name: "DeployOk",
    header: 2952335191,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }]
}, {
    name: "FactoryDeploy",
    header: 1829761339,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "cashback",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "ChangeOwner",
    header: 2174598809,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "newOwner",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "ChangeOwnerOk",
    header: 846932810,
    fields: [{
        name: "queryId",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: 64
        }
    }, {
        name: "newOwner",
        type: {
            kind: "simple",
            type: "address",
            optional: !1
        }
    }]
}, {
    name: "Withdraw",
    header: 195467089,
    fields: [{
        name: "amount",
        type: {
            kind: "simple",
            type: "uint",
            optional: !1,
            format: "coins"
        }
    }]
}]
  , PotatoReceive_getters = [{
    name: "balance",
    arguments: [],
    returnType: {
        kind: "simple",
        type: "string",
        optional: !1
    }
}, {
    name: "owner",
    arguments: [],
    returnType: {
        kind: "simple",
        type: "address",
        optional: !1
    }
}]
  , PotatoReceive_receivers = [{
    receiver: "internal",
    message: {
        kind: "empty"
    }
}, {
    receiver: "internal",
    message: {
        kind: "text",
        text: "mint"
    }
}, {
    receiver: "internal",
    message: {
        kind: "text",
        text: "withdraw all"
    }
}, {
    receiver: "internal",
    message: {
        kind: "typed",
        type: "Withdraw"
    }
}, {
    receiver: "internal",
    message: {
        kind: "typed",
        type: "Deploy"
    }
}];
class PotatoReceive {
    constructor(S, E) {
        jt(this, "address");
        jt(this, "init");
        jt(this, "abi", {
            types: PotatoReceive_types,
            getters: PotatoReceive_getters,
            receivers: PotatoReceive_receivers,
            errors: PotatoReceive_errors
        });
        this.address = S,
        this.init = E
    }
    static async init() {
        return await PotatoReceive_init()
    }
    static async fromInit() {
        const S = await PotatoReceive_init()
          , E = dist$4.contractAddress(0, S);
        return new PotatoReceive(E,S)
    }
    static fromAddress(S) {
        return new PotatoReceive(S)
    }
    async send(S, E, M, T) {
        let $ = null;
        if (T === null && ($ = new dist$4.Cell),
        T === "mint" && ($ = dist$4.beginCell().storeUint(0, 32).storeStringTail(T).endCell()),
        T === "withdraw all" && ($ = dist$4.beginCell().storeUint(0, 32).storeStringTail(T).endCell()),
        T && typeof T == "object" && !(T instanceof dist$4.Slice) && T.$$type === "Withdraw" && ($ = dist$4.beginCell().store(storeWithdraw(T)).endCell()),
        T && typeof T == "object" && !(T instanceof dist$4.Slice) && T.$$type === "Deploy" && ($ = dist$4.beginCell().store(storeDeploy(T)).endCell()),
        $ === null)
            throw new Error("Invalid message type");
        await S.internal(E, {
            ...M,
            body: $
        })
    }
    async getBalance(S) {
        let E = new dist$4.TupleBuilder;
        return (await S.get("balance", E.build())).stack.readString()
    }
    async getOwner(S) {
        let E = new dist$4.TupleBuilder;
        return (await S.get("owner", E.build())).stack.readAddress()
    }
}
const useWithdraw = ()=>{
    const {configStore: C} = useStores()
      , [S] = useTonConnectUI()
      , {isConnected: E, connect: M} = useConnectWallet()
      , {wrapPromise: T} = useStatusState()
      , $ = useTonAddress();
    return {
        withdraw: reactExports.useCallback(T(async({all: O})=>{
            if (!E || $ === "") {
                await M();
                return
            }
            const F = await getClient()
              , N = PotatoReceive.fromAddress(dist$4.Address.parse("EQBg_6NAPwh63Pm2Ynurj3p629DET-SP8bKfY75SuuwvOjBS"))
              , U = F.open(N)
              , H = new Sender(S);
            O ? await U.send(H, {
                value: dist$4.toNano(.1)
            }, "withdraw all") : await U.send(H, {
                value: dist$4.toNano(.1)
            }, {
                $$type: "Withdraw",
                amount: dist$4.toNano(7e3)
            }),
            await waitTx(dist$4.Address.parse($))
        }
        ), [E, M, S, $, C.config])
    }
}
  , DevPage = ()=>{
    const {deploy: C} = useDeploy()
      , {withdraw: S} = useWithdraw()
      , {isConnected: E, connect: M} = useConnectWallet()
      , T = useTonAddress()
      , {buy: $} = useBuy()
      , {create: B} = useCreateOrder();
    return E ? jsxRuntimeExports.jsxs("div", {
        children: [jsxRuntimeExports.jsx("button", {
            onClick: ()=>{
                C()
            }
            ,
            children: "Deploy"
        }), jsxRuntimeExports.jsx("button", {
            onClick: ()=>{
                S({
                    all: !1
                })
            }
            ,
            children: "Withdraw 100"
        }), jsxRuntimeExports.jsx("button", {
            onClick: ()=>{
                S({
                    all: !0
                })
            }
            ,
            children: "Withdraw All"
        }), jsxRuntimeExports.jsx("button", {
            onClick: ()=>{
                $({
                    id: 0,
                    price: 1,
                    seller: dist$4.Address.parse("UQA1a8DK1Yc-QCDa_KzkDqCDPFx85CkeQPxTavYG7FVQ5mHx")
                })
            }
            ,
            children: "Buy"
        }), jsxRuntimeExports.jsx(CreatOrderButton, {}), jsxRuntimeExports.jsx("button", {
            onClick: ()=>{
                B({
                    order: {
                        seller_address: T,
                        price: 10,
                        amount: 100
                    }
                })
            }
            ,
            children: "Create Order"
        })]
    }) : jsxRuntimeExports.jsx("div", {
        children: jsxRuntimeExports.jsx("button", {
            onClick: M,
            children: "Connect"
        })
    })
}
  , BackendTokenContext = reactExports.createContext({
    token: null,
    setToken: ()=>{}
})
  , BackendTokenProvider = C=>{
    const [S,E] = reactExports.useState(null);
    return jsxRuntimeExports.jsx(BackendTokenContext.Provider, {
        value: {
            token: S,
            setToken: E
        },
        children: C.children
    })
}
  , useActivatedStore = (C,...S)=>{
    const E = reactExports.useRef(!1)
      , M = useStores();
    return reactExports.useEffect(()=>{
        const T = M[C];
        if (!(!S.every($=>$ !== void 0) || T.isActivated))
            return E.current = !0,
            T.activate(...S),
            ()=>{
                E.current && (E.current = !1,
                T.deactivate())
            }
    }
    , S),
    {
        [C]: M[C]
    }
}
  , ConfigProvider = observer(({children: C})=>{
    const {configStore: S} = useActivatedStore("configStore");
    return reactExports.useEffect(()=>{
        setInterval(()=>{
            S.reload()
        }
        , 3e4)
    }
    , [S]),
    C
}
)
  , CurrencyProvider = observer(({children: C})=>(useActivatedStore("tokenCurrencyStore"),
C))
  , LanguageProvider = ()=>{
    const {i18n: C} = useTranslation();
    return reactExports.useEffect(()=>{
        const S = localStorage.getItem("language");
        C.changeLanguage(S ?? "en").catch(E=>{
            console.log(E)
        }
        )
    }
    , []),
    reactExports.useEffect(()=>{
        localStorage.setItem("language", C.language)
    }
    , [C.language]),
    null
}
  , TonConnectUiProvider = observer(({children: C})=>jsxRuntimeExports.jsx(TonConnectUIProvider$1, {
    manifestUrl: "https://tonpotato.online/tonconnect-manifest.json",
    children: C
}))
  , TonUserProvider = observer(({children: C})=>{
    const S = useTonAddress();
    return useActivatedStore("tonUserStore", S),
    C
}
)
  , payloadTTL = 5 * 60 * 1e3;
function useBackendAuth() {
    const {setToken: C} = reactExports.useContext(BackendTokenContext)
      , S = useIsConnectionRestored()
      , E = useTonWallet()
      , [M] = useTonConnectUI()
      , T = reactExports.useRef();
    reactExports.useEffect(()=>{
        var B;
        if (!S || !C)
            return;
        if (clearInterval(T.current),
        !E) {
            localStorage.removeItem(authKey),
            C(null);
            const O = async()=>{
                M.setConnectRequestParameters({
                    state: "loading"
                });
                const F = await api.v1TonPayloadList().then(N=>N.data);
                F ? M.setConnectRequestParameters({
                    state: "ready",
                    value: F
                }) : M.setConnectRequestParameters(null)
            }
            ;
            O(),
            setInterval(O, payloadTTL);
            return
        }
        const $ = localStorage.getItem(authKey);
        if ($) {
            C($);
            return
        }
        (B = E.connectItems) != null && B.tonProof && !("error"in E.connectItems.tonProof) ? (console.log({
            proof: E.connectItems.tonProof.proof,
            account: E.account
        }),
        api.v1TonVerifyCreate({
            proof: E.connectItems.tonProof.proof,
            account: E.account
        }).then(O=>{
            const {token: F} = O.data;
            F ? (C(F),
            localStorage.setItem(authKey, F)) : M.disconnect()
        }
        )) : M.disconnect()
    }
    , [E, S, C])
}
const UserProvider = observer(({children: C})=>{
    var M, T, $;
    const S = useTonAddress();
    useBackendAuth();
    const E = A$1();
    return useActivatedStore("userStore", {
        address: S,
        name: (M = E == null ? void 0 : E.user) == null ? void 0 : M.firstName,
        username: ((T = E == null ? void 0 : E.user) == null ? void 0 : T.username) ?? "",
        referral_code: (E == null ? void 0 : E.startParam) ?? "",
        avatar: (($ = E == null ? void 0 : E.user) == null ? void 0 : $.photoUrl) ?? ""
    }),
    C
}
)
  , DialogProvider = observer(()=>{
    const {dialogStore: C} = useStores();
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: C.instances.map(({id: S, props: E, open: M, Component: T})=>reactExports.createElement(T, {
            ...E,
            key: S,
            open: M,
            id: S,
            onClose: ()=>C.closeById(S)
        }))
    })
}
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics = function(C, S) {
    return extendStatics = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(E, M) {
        E.__proto__ = M
    }
    || function(E, M) {
        for (var T in M)
            M.hasOwnProperty(T) && (E[T] = M[T])
    }
    ,
    extendStatics(C, S)
};
function __extends(C, S) {
    extendStatics(C, S);
    function E() {
        this.constructor = C
    }
    C.prototype = S === null ? Object.create(S) : (E.prototype = S.prototype,
    new E)
}
var __assign = function() {
    return __assign = Object.assign || function(S) {
        for (var E, M = 1, T = arguments.length; M < T; M++) {
            E = arguments[M];
            for (var $ in E)
                Object.prototype.hasOwnProperty.call(E, $) && (S[$] = E[$])
        }
        return S
    }
    ,
    __assign.apply(this, arguments)
};
function throttle(C, S, E, M) {
    var T, $ = !1, B = 0;
    function O() {
        T && clearTimeout(T)
    }
    function F() {
        O(),
        $ = !0
    }
    typeof S != "boolean" && (M = E,
    E = S,
    S = void 0);
    function N() {
        var U = this
          , H = Date.now() - B
          , Z = arguments;
        if ($)
            return;
        function J() {
            B = Date.now(),
            E.apply(U, Z)
        }
        function ie() {
            T = void 0
        }
        M && !T && J(),
        O(),
        M === void 0 && H > C ? J() : S !== !0 && (T = setTimeout(M ? ie : J, M === void 0 ? C - H : C))
    }
    return N.cancel = F,
    N
}
var ThresholdUnits = {
    Pixel: "Pixel",
    Percent: "Percent"
}
  , defaultThreshold = {
    unit: ThresholdUnits.Percent,
    value: .8
};
function parseThreshold(C) {
    return typeof C == "number" ? {
        unit: ThresholdUnits.Percent,
        value: C * 100
    } : typeof C == "string" ? C.match(/^(\d*(\.\d+)?)px$/) ? {
        unit: ThresholdUnits.Pixel,
        value: parseFloat(C)
    } : C.match(/^(\d*(\.\d+)?)%$/) ? {
        unit: ThresholdUnits.Percent,
        value: parseFloat(C)
    } : (console.warn('scrollThreshold format is invalid. Valid formats: "120px", "50%"...'),
    defaultThreshold) : (console.warn("scrollThreshold should be string or number"),
    defaultThreshold)
}
var InfiniteScroll = function(C) {
    __extends(S, C);
    function S(E) {
        var M = C.call(this, E) || this;
        return M.lastScrollTop = 0,
        M.actionTriggered = !1,
        M.startY = 0,
        M.currentY = 0,
        M.dragging = !1,
        M.maxPullDownDistance = 0,
        M.getScrollableTarget = function() {
            return M.props.scrollableTarget instanceof HTMLElement ? M.props.scrollableTarget : typeof M.props.scrollableTarget == "string" ? document.getElementById(M.props.scrollableTarget) : (M.props.scrollableTarget === null && console.warn(`You are trying to pass scrollableTarget but it is null. This might
        happen because the element may not have been added to DOM yet.
        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.
      `),
            null)
        }
        ,
        M.onStart = function(T) {
            M.lastScrollTop || (M.dragging = !0,
            T instanceof MouseEvent ? M.startY = T.pageY : T instanceof TouchEvent && (M.startY = T.touches[0].pageY),
            M.currentY = M.startY,
            M._infScroll && (M._infScroll.style.willChange = "transform",
            M._infScroll.style.transition = "transform 0.2s cubic-bezier(0,0,0.31,1)"))
        }
        ,
        M.onMove = function(T) {
            M.dragging && (T instanceof MouseEvent ? M.currentY = T.pageY : T instanceof TouchEvent && (M.currentY = T.touches[0].pageY),
            !(M.currentY < M.startY) && (M.currentY - M.startY >= Number(M.props.pullDownToRefreshThreshold) && M.setState({
                pullToRefreshThresholdBreached: !0
            }),
            !(M.currentY - M.startY > M.maxPullDownDistance * 1.5) && M._infScroll && (M._infScroll.style.overflow = "visible",
            M._infScroll.style.transform = "translate3d(0px, " + (M.currentY - M.startY) + "px, 0px)")))
        }
        ,
        M.onEnd = function() {
            M.startY = 0,
            M.currentY = 0,
            M.dragging = !1,
            M.state.pullToRefreshThresholdBreached && (M.props.refreshFunction && M.props.refreshFunction(),
            M.setState({
                pullToRefreshThresholdBreached: !1
            })),
            requestAnimationFrame(function() {
                M._infScroll && (M._infScroll.style.overflow = "auto",
                M._infScroll.style.transform = "none",
                M._infScroll.style.willChange = "unset")
            })
        }
        ,
        M.onScrollListener = function(T) {
            typeof M.props.onScroll == "function" && setTimeout(function() {
                return M.props.onScroll && M.props.onScroll(T)
            }, 0);
            var $ = M.props.height || M._scrollableNode ? T.target : document.documentElement.scrollTop ? document.documentElement : document.body;
            if (!M.actionTriggered) {
                var B = M.props.inverse ? M.isElementAtTop($, M.props.scrollThreshold) : M.isElementAtBottom($, M.props.scrollThreshold);
                B && M.props.hasMore && (M.actionTriggered = !0,
                M.setState({
                    showLoader: !0
                }),
                M.props.next && M.props.next()),
                M.lastScrollTop = $.scrollTop
            }
        }
        ,
        M.state = {
            showLoader: !1,
            pullToRefreshThresholdBreached: !1,
            prevDataLength: E.dataLength
        },
        M.throttledOnScrollListener = throttle(150, M.onScrollListener).bind(M),
        M.onStart = M.onStart.bind(M),
        M.onMove = M.onMove.bind(M),
        M.onEnd = M.onEnd.bind(M),
        M
    }
    return S.prototype.componentDidMount = function() {
        if (typeof this.props.dataLength > "u")
            throw new Error('mandatory prop "dataLength" is missing. The prop is needed when loading more content. Check README.md for usage');
        if (this._scrollableNode = this.getScrollableTarget(),
        this.el = this.props.height ? this._infScroll : this._scrollableNode || window,
        this.el && this.el.addEventListener("scroll", this.throttledOnScrollListener),
        typeof this.props.initialScrollY == "number" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY && this.el.scrollTo(0, this.props.initialScrollY),
        this.props.pullDownToRefresh && this.el && (this.el.addEventListener("touchstart", this.onStart),
        this.el.addEventListener("touchmove", this.onMove),
        this.el.addEventListener("touchend", this.onEnd),
        this.el.addEventListener("mousedown", this.onStart),
        this.el.addEventListener("mousemove", this.onMove),
        this.el.addEventListener("mouseup", this.onEnd),
        this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0,
        this.forceUpdate(),
        typeof this.props.refreshFunction != "function"))
            throw new Error(`Mandatory prop "refreshFunction" missing.
          Pull Down To Refresh functionality will not work
          as expected. Check README.md for usage'`)
    }
    ,
    S.prototype.componentWillUnmount = function() {
        this.el && (this.el.removeEventListener("scroll", this.throttledOnScrollListener),
        this.props.pullDownToRefresh && (this.el.removeEventListener("touchstart", this.onStart),
        this.el.removeEventListener("touchmove", this.onMove),
        this.el.removeEventListener("touchend", this.onEnd),
        this.el.removeEventListener("mousedown", this.onStart),
        this.el.removeEventListener("mousemove", this.onMove),
        this.el.removeEventListener("mouseup", this.onEnd)))
    }
    ,
    S.prototype.componentDidUpdate = function(E) {
        this.props.dataLength !== E.dataLength && (this.actionTriggered = !1,
        this.setState({
            showLoader: !1
        }))
    }
    ,
    S.getDerivedStateFromProps = function(E, M) {
        var T = E.dataLength !== M.prevDataLength;
        return T ? __assign(__assign({}, M), {
            prevDataLength: E.dataLength
        }) : null
    }
    ,
    S.prototype.isElementAtTop = function(E, M) {
        M === void 0 && (M = .8);
        var T = E === document.body || E === document.documentElement ? window.screen.availHeight : E.clientHeight
          , $ = parseThreshold(M);
        return $.unit === ThresholdUnits.Pixel ? E.scrollTop <= $.value + T - E.scrollHeight + 1 : E.scrollTop <= $.value / 100 + T - E.scrollHeight + 1
    }
    ,
    S.prototype.isElementAtBottom = function(E, M) {
        M === void 0 && (M = .8);
        var T = E === document.body || E === document.documentElement ? window.screen.availHeight : E.clientHeight
          , $ = parseThreshold(M);
        return $.unit === ThresholdUnits.Pixel ? E.scrollTop + T >= E.scrollHeight - $.value : E.scrollTop + T >= $.value / 100 * E.scrollHeight
    }
    ,
    S.prototype.render = function() {
        var E = this
          , M = __assign({
            height: this.props.height || "auto",
            overflow: "auto",
            WebkitOverflowScrolling: "touch"
        }, this.props.style)
          , T = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length)
          , $ = this.props.pullDownToRefresh && this.props.height ? {
            overflow: "auto"
        } : {};
        return React$1.createElement("div", {
            style: $,
            className: "infinite-scroll-component__outerdiv"
        }, React$1.createElement("div", {
            className: "infinite-scroll-component " + (this.props.className || ""),
            ref: function(B) {
                return E._infScroll = B
            },
            style: M
        }, this.props.pullDownToRefresh && React$1.createElement("div", {
            style: {
                position: "relative"
            },
            ref: function(B) {
                return E._pullDown = B
            }
        }, React$1.createElement("div", {
            style: {
                position: "absolute",
                left: 0,
                right: 0,
                top: -1 * this.maxPullDownDistance
            }
        }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)), this.props.children, !this.state.showLoader && !T && this.props.hasMore && this.props.loader, this.state.showLoader && this.props.hasMore && this.props.loader, !this.props.hasMore && this.props.endMessage))
    }
    ,
    S
}(reactExports.Component);
const Clock = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAABICAMAAAB1EdO8AAAAAXNSR0IArs4c6QAAAEtQTFRFAAAAaWlpj4+PcnJyfX19ampqjo6Oj4+Pa2tra2trj4+Pa2tr////7u7u5OTk2trazMzMubm5rKysnp6ej4+PiYmJfHx8cnJya2trNus7SQAAAAx0Uk5TABwkNlaNjqSk3eHvq/18oAAAAs5JREFUeNqdl1uyqyAURFHxRUBRt5ue/0hvILmhCOUhsv6SKle6G/mIuKSR/TTPADDPUy87cZOuf+CLeZLiZ5rk+cTS/CaYEHDHbhejn5jVbuQQ8JJiAnjctuov1p1/kshQgeLzqYVCHVmMkAqW5JM5AKBvLg0zAE4esQ5gm3zDPsiFo/OG3SQ/isCSBrl0dA+/ok44ENh1wgbg0YmMxhsWnUIIkE5ZODrSHdjosiJgOOmSG8oKbVzm6JPRygq9OKBP3igAmy4o8k1lWuPQ9xR6Bx6xypQPUVYYRqzSALD6rkKvAJoY4tD3FZqAKYYwNYoYYwJI1yg0/V9jBtY6xQo83u8E6zqFdkD36rHXKjagjz1uK2KTDnC6UhGaNH4KqlccgBQ9sNUrdqD3a9p6hQWmsGa9YgFmrzAlxamvMF4BQJcUOIy+AEBRESV1igMf2NYpNqAgAZDMmXPCc93GvE9k0ddsnEi2L8nqFQ6w+g/MgT/aWMAJzu56JknbLF9jsVccuoBlRPavUz/FmV728tFQctm9QiG5JOVJjnRNp4TicNvLLIyASe86KzEmTYqTuOREGDhHMVBsUmRdjP7qQYOQxADpKghgkqKlM8SowAA4qRVCVcc4ACYlhBhqY9gQYnwqOiIG2NyuwQATSfFEEQHYK2q40/cITUKVTd9iQwgxCk9LoYpb9A2Wl4FaERiJyAHO3BvCUQjxiXG6bNKS4YwhwhphDl5+bOEAnDGEh4Lj1023/wbVRoWkdxccplhix6tFeCciw8fBtnBZ+WMYRIIiD6MQZCUAYPIokdK+Ha74JzPMEIfIHSfDw3tmWTeHGMEbMjrviBI42uwaOpnF7odDgM/MkOUIEoeMKMgMuSNa8uczQ8bwURCdT40LIuccx+fT08yRioooKf6kHalAjFApGV8rlCXqosIQBUVkblFDJ27SymFUQaTUOMjr3/8HCdjlGF1GjIEAAAAASUVORK5CYII="
  , CloseButtonImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADkAAAA5CAMAAAC7xnO3AAAAAXNSR0IArs4c6QAAAC1QTFRFR3BMbTQecjUhYSwcfDwlgD4nXS4dXS0chEAphEApXS4dhUEpcTcjYzAeXS4da/lTHwAAAAt0Uk5TABAgM2B/hsLK4OW+A5fpAAABK0lEQVR42q3XOW7DQBAF0eY2FMXl/sf1iDBQILpdcKCfFl7CoAeMr2xY2tpGrVOZpvf1Wavh+FuHGkJr2LcONYRmCE0QKvA6oUBoARkUCBUIBSYKLCnw6DuhAaRCged+74ACU12fKdNcd+pMSjRB6DtiJSWaIbRLUqLATCMa6UnZzqARE7CidT3v79dITwrMe4/Rt+wlNbh1KNShUoVODTpV6NShU4dOHTp16NShU4cxbioXhU4VOlXo1KCvVa/VIYA70jK8/kHPCwo0yuWCpidAxgl36NShU4dOBQpdIuYMncpbxox2KQd5ERrR7JILjZgEyvVfecsqKPRTh9dfUOgcAU0QWkJohtAMoQkKBUKBQoFQoFAgFCgUCM0w020u49bTC/jcfFd+O34Aga1lcV0j5nsAAAAASUVORK5CYII="
  , SmallGlare = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAoCAMAAABevo0zAAAAAXNSR0IArs4c6QAAAAxQTFRFR3BM////////////Bp/QCgAAAAR0Uk5TADMoFaU+dxIAAABwSURBVHja7dPBDYBADANBn7f/nhES4gEIOOIfmQJWziMaYepgBzvYwQ7+NsiIQsIjxmjlWE8bUufucLKXOds6IDIvNdK6RHFeaqR1AxfmRUZaz2Zf7Rku5ApJNANPrKsnjT6xi7eecWwaVMVW9avYArzvCpsTe579AAAAAElFTkSuQmCC"
  , ButtonGlare$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAAoAgMAAAA59S9EAAAAAXNSR0IArs4c6QAAAAxQTFRF////R3BM////////nZ+uvQAAAAR0Uk5TMwANHh6scvsAAADDSURBVHja7dKxDcIwEEBRSwyQVZgApvguwgZQZJqM4AKxQqR4GYpQRaIiQjGisYhkYXxOh/8AT747q1KpVCr9R81q0qRYC3ug4GBVfpsrKECP2VTVAgqALpPagbdoMlf1aVGP8vkMSwvdSedr8ZbvZCX3GyBgoZ+S+4UtaGzaoyYIWJKn7Q0hS7C1aoCIBf1P1NRC3ELHtdlLEQtqF11U2ErVnIEkC3Q/Br+BgWQLODq7hOYzILOA+uLu2zdTudtXCHgBmx/cCDiKJ1EAAAAASUVORK5CYII=";
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
    constructor(S) {
        super(`Invalid DateTime: ${S.toMessage()}`)
    }
}
class InvalidIntervalError extends LuxonError {
    constructor(S) {
        super(`Invalid Interval: ${S.toMessage()}`)
    }
}
class InvalidDurationError extends LuxonError {
    constructor(S) {
        super(`Invalid Duration: ${S.toMessage()}`)
    }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
    constructor(S) {
        super(`Invalid unit ${S}`)
    }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
    constructor() {
        super("Zone is an abstract class")
    }
}
const n = "numeric"
  , s = "short"
  , l = "long"
  , DATE_SHORT = {
    year: n,
    month: n,
    day: n
}
  , DATE_MED = {
    year: n,
    month: s,
    day: n
}
  , DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
}
  , DATE_FULL = {
    year: n,
    month: l,
    day: n
}
  , DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
}
  , TIME_SIMPLE = {
    hour: n,
    minute: n
}
  , TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
}
  , TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
}
  , TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
}
  , TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
}
  , TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
}
  , TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
}
  , TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
}
  , DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
}
  , DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
}
  , DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
}
  , DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
}
  , DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
}
  , DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
}
  , DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
}
  , DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
}
  , DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
};
class Zone {
    get type() {
        throw new ZoneIsAbstractError
    }
    get name() {
        throw new ZoneIsAbstractError
    }
    get ianaName() {
        return this.name
    }
    get isUniversal() {
        throw new ZoneIsAbstractError
    }
    offsetName(S, E) {
        throw new ZoneIsAbstractError
    }
    formatOffset(S, E) {
        throw new ZoneIsAbstractError
    }
    offset(S) {
        throw new ZoneIsAbstractError
    }
    equals(S) {
        throw new ZoneIsAbstractError
    }
    get isValid() {
        throw new ZoneIsAbstractError
    }
}
let singleton$1 = null;
class SystemZone extends Zone {
    static get instance() {
        return singleton$1 === null && (singleton$1 = new SystemZone),
        singleton$1
    }
    get type() {
        return "system"
    }
    get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone
    }
    get isUniversal() {
        return !1
    }
    offsetName(S, {format: E, locale: M}) {
        return parseZoneInfo(S, E, M)
    }
    formatOffset(S, E) {
        return formatOffset(this.offset(S), E)
    }
    offset(S) {
        return -new Date(S).getTimezoneOffset()
    }
    equals(S) {
        return S.type === "system"
    }
    get isValid() {
        return !0
    }
}
let dtfCache = {};
function makeDTF(C) {
    return dtfCache[C] || (dtfCache[C] = new Intl.DateTimeFormat("en-US",{
        hour12: !1,
        timeZone: C,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
    })),
    dtfCache[C]
}
const typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
};
function hackyOffset(C, S) {
    const E = C.format(S).replace(/\u200E/g, "")
      , M = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(E)
      , [,T,$,B,O,F,N,U] = M;
    return [B, T, $, O, F, N, U]
}
function partsOffset(C, S) {
    const E = C.formatToParts(S)
      , M = [];
    for (let T = 0; T < E.length; T++) {
        const {type: $, value: B} = E[T]
          , O = typeToPos[$];
        $ === "era" ? M[O] = B : isUndefined(O) || (M[O] = parseInt(B, 10))
    }
    return M
}
let ianaZoneCache = {};
class IANAZone extends Zone {
    static create(S) {
        return ianaZoneCache[S] || (ianaZoneCache[S] = new IANAZone(S)),
        ianaZoneCache[S]
    }
    static resetCache() {
        ianaZoneCache = {},
        dtfCache = {}
    }
    static isValidSpecifier(S) {
        return this.isValidZone(S)
    }
    static isValidZone(S) {
        if (!S)
            return !1;
        try {
            return new Intl.DateTimeFormat("en-US",{
                timeZone: S
            }).format(),
            !0
        } catch {
            return !1
        }
    }
    constructor(S) {
        super(),
        this.zoneName = S,
        this.valid = IANAZone.isValidZone(S)
    }
    get type() {
        return "iana"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName(S, {format: E, locale: M}) {
        return parseZoneInfo(S, E, M, this.name)
    }
    formatOffset(S, E) {
        return formatOffset(this.offset(S), E)
    }
    offset(S) {
        const E = new Date(S);
        if (isNaN(E))
            return NaN;
        const M = makeDTF(this.name);
        let[T,$,B,O,F,N,U] = M.formatToParts ? partsOffset(M, E) : hackyOffset(M, E);
        O === "BC" && (T = -Math.abs(T) + 1);
        const Z = objToLocalTS({
            year: T,
            month: $,
            day: B,
            hour: F === 24 ? 0 : F,
            minute: N,
            second: U,
            millisecond: 0
        });
        let J = +E;
        const ie = J % 1e3;
        return J -= ie >= 0 ? ie : 1e3 + ie,
        (Z - J) / (60 * 1e3)
    }
    equals(S) {
        return S.type === "iana" && S.name === this.name
    }
    get isValid() {
        return this.valid
    }
}
let intlLFCache = {};
function getCachedLF(C, S={}) {
    const E = JSON.stringify([C, S]);
    let M = intlLFCache[E];
    return M || (M = new Intl.ListFormat(C,S),
    intlLFCache[E] = M),
    M
}
let intlDTCache = {};
function getCachedDTF(C, S={}) {
    const E = JSON.stringify([C, S]);
    let M = intlDTCache[E];
    return M || (M = new Intl.DateTimeFormat(C,S),
    intlDTCache[E] = M),
    M
}
let intlNumCache = {};
function getCachedINF(C, S={}) {
    const E = JSON.stringify([C, S]);
    let M = intlNumCache[E];
    return M || (M = new Intl.NumberFormat(C,S),
    intlNumCache[E] = M),
    M
}
let intlRelCache = {};
function getCachedRTF(C, S={}) {
    const {base: E, ...M} = S
      , T = JSON.stringify([C, M]);
    let $ = intlRelCache[T];
    return $ || ($ = new Intl.RelativeTimeFormat(C,S),
    intlRelCache[T] = $),
    $
}
let sysLocaleCache = null;
function systemLocale() {
    return sysLocaleCache || (sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale,
    sysLocaleCache)
}
let weekInfoCache = {};
function getCachedWeekInfo(C) {
    let S = weekInfoCache[C];
    if (!S) {
        const E = new Intl.Locale(C);
        S = "getWeekInfo"in E ? E.getWeekInfo() : E.weekInfo,
        weekInfoCache[C] = S
    }
    return S
}
function parseLocaleString(C) {
    const S = C.indexOf("-x-");
    S !== -1 && (C = C.substring(0, S));
    const E = C.indexOf("-u-");
    if (E === -1)
        return [C];
    {
        let M, T;
        try {
            M = getCachedDTF(C).resolvedOptions(),
            T = C
        } catch {
            const F = C.substring(0, E);
            M = getCachedDTF(F).resolvedOptions(),
            T = F
        }
        const {numberingSystem: $, calendar: B} = M;
        return [T, $, B]
    }
}
function intlConfigString(C, S, E) {
    return (E || S) && (C.includes("-u-") || (C += "-u"),
    E && (C += `-ca-${E}`),
    S && (C += `-nu-${S}`)),
    C
}
function mapMonths(C) {
    const S = [];
    for (let E = 1; E <= 12; E++) {
        const M = DateTime.utc(2009, E, 1);
        S.push(C(M))
    }
    return S
}
function mapWeekdays(C) {
    const S = [];
    for (let E = 1; E <= 7; E++) {
        const M = DateTime.utc(2016, 11, 13 + E);
        S.push(C(M))
    }
    return S
}
function listStuff(C, S, E, M) {
    const T = C.listingMode();
    return T === "error" ? null : T === "en" ? E(S) : M(S)
}
function supportsFastNumbers(C) {
    return C.numberingSystem && C.numberingSystem !== "latn" ? !1 : C.numberingSystem === "latn" || !C.locale || C.locale.startsWith("en") || new Intl.DateTimeFormat(C.intl).resolvedOptions().numberingSystem === "latn"
}
class PolyNumberFormatter {
    constructor(S, E, M) {
        this.padTo = M.padTo || 0,
        this.floor = M.floor || !1;
        const {padTo: T, floor: $, ...B} = M;
        if (!E || Object.keys(B).length > 0) {
            const O = {
                useGrouping: !1,
                ...M
            };
            M.padTo > 0 && (O.minimumIntegerDigits = M.padTo),
            this.inf = getCachedINF(S, O)
        }
    }
    format(S) {
        if (this.inf) {
            const E = this.floor ? Math.floor(S) : S;
            return this.inf.format(E)
        } else {
            const E = this.floor ? Math.floor(S) : roundTo(S, 3);
            return padStart(E, this.padTo)
        }
    }
}
class PolyDateFormatter {
    constructor(S, E, M) {
        this.opts = M,
        this.originalZone = void 0;
        let T;
        if (this.opts.timeZone)
            this.dt = S;
        else if (S.zone.type === "fixed") {
            const B = -1 * (S.offset / 60)
              , O = B >= 0 ? `Etc/GMT+${B}` : `Etc/GMT${B}`;
            S.offset !== 0 && IANAZone.create(O).valid ? (T = O,
            this.dt = S) : (T = "UTC",
            this.dt = S.offset === 0 ? S : S.setZone("UTC").plus({
                minutes: S.offset
            }),
            this.originalZone = S.zone)
        } else
            S.zone.type === "system" ? this.dt = S : S.zone.type === "iana" ? (this.dt = S,
            T = S.zone.name) : (T = "UTC",
            this.dt = S.setZone("UTC").plus({
                minutes: S.offset
            }),
            this.originalZone = S.zone);
        const $ = {
            ...this.opts
        };
        $.timeZone = $.timeZone || T,
        this.dtf = getCachedDTF(E, $)
    }
    format() {
        return this.originalZone ? this.formatToParts().map(({value: S})=>S).join("") : this.dtf.format(this.dt.toJSDate())
    }
    formatToParts() {
        const S = this.dtf.formatToParts(this.dt.toJSDate());
        return this.originalZone ? S.map(E=>{
            if (E.type === "timeZoneName") {
                const M = this.originalZone.offsetName(this.dt.ts, {
                    locale: this.dt.locale,
                    format: this.opts.timeZoneName
                });
                return {
                    ...E,
                    value: M
                }
            } else
                return E
        }
        ) : S
    }
    resolvedOptions() {
        return this.dtf.resolvedOptions()
    }
}
class PolyRelFormatter {
    constructor(S, E, M) {
        this.opts = {
            style: "long",
            ...M
        },
        !E && hasRelative() && (this.rtf = getCachedRTF(S, M))
    }
    format(S, E) {
        return this.rtf ? this.rtf.format(S, E) : formatRelativeTime(E, S, this.opts.numeric, this.opts.style !== "long")
    }
    formatToParts(S, E) {
        return this.rtf ? this.rtf.formatToParts(S, E) : []
    }
}
const fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
};
class Locale {
    static fromOpts(S) {
        return Locale.create(S.locale, S.numberingSystem, S.outputCalendar, S.weekSettings, S.defaultToEN)
    }
    static create(S, E, M, T, $=!1) {
        const B = S || Settings.defaultLocale
          , O = B || ($ ? "en-US" : systemLocale())
          , F = E || Settings.defaultNumberingSystem
          , N = M || Settings.defaultOutputCalendar
          , U = validateWeekSettings(T) || Settings.defaultWeekSettings;
        return new Locale(O,F,N,U,B)
    }
    static resetCache() {
        sysLocaleCache = null,
        intlDTCache = {},
        intlNumCache = {},
        intlRelCache = {}
    }
    static fromObject({locale: S, numberingSystem: E, outputCalendar: M, weekSettings: T}={}) {
        return Locale.create(S, E, M, T)
    }
    constructor(S, E, M, T, $) {
        const [B,O,F] = parseLocaleString(S);
        this.locale = B,
        this.numberingSystem = E || O || null,
        this.outputCalendar = M || F || null,
        this.weekSettings = T,
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar),
        this.weekdaysCache = {
            format: {},
            standalone: {}
        },
        this.monthsCache = {
            format: {},
            standalone: {}
        },
        this.meridiemCache = null,
        this.eraCache = {},
        this.specifiedLocale = $,
        this.fastNumbersCached = null
    }
    get fastNumbers() {
        return this.fastNumbersCached == null && (this.fastNumbersCached = supportsFastNumbers(this)),
        this.fastNumbersCached
    }
    listingMode() {
        const S = this.isEnglish()
          , E = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return S && E ? "en" : "intl"
    }
    clone(S) {
        return !S || Object.getOwnPropertyNames(S).length === 0 ? this : Locale.create(S.locale || this.specifiedLocale, S.numberingSystem || this.numberingSystem, S.outputCalendar || this.outputCalendar, validateWeekSettings(S.weekSettings) || this.weekSettings, S.defaultToEN || !1)
    }
    redefaultToEN(S={}) {
        return this.clone({
            ...S,
            defaultToEN: !0
        })
    }
    redefaultToSystem(S={}) {
        return this.clone({
            ...S,
            defaultToEN: !1
        })
    }
    months(S, E=!1) {
        return listStuff(this, S, months, ()=>{
            const M = E ? {
                month: S,
                day: "numeric"
            } : {
                month: S
            }
              , T = E ? "format" : "standalone";
            return this.monthsCache[T][S] || (this.monthsCache[T][S] = mapMonths($=>this.extract($, M, "month"))),
            this.monthsCache[T][S]
        }
        )
    }
    weekdays(S, E=!1) {
        return listStuff(this, S, weekdays, ()=>{
            const M = E ? {
                weekday: S,
                year: "numeric",
                month: "long",
                day: "numeric"
            } : {
                weekday: S
            }
              , T = E ? "format" : "standalone";
            return this.weekdaysCache[T][S] || (this.weekdaysCache[T][S] = mapWeekdays($=>this.extract($, M, "weekday"))),
            this.weekdaysCache[T][S]
        }
        )
    }
    meridiems() {
        return listStuff(this, void 0, ()=>meridiems, ()=>{
            if (!this.meridiemCache) {
                const S = {
                    hour: "numeric",
                    hourCycle: "h12"
                };
                this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(E=>this.extract(E, S, "dayperiod"))
            }
            return this.meridiemCache
        }
        )
    }
    eras(S) {
        return listStuff(this, S, eras, ()=>{
            const E = {
                era: S
            };
            return this.eraCache[S] || (this.eraCache[S] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(M=>this.extract(M, E, "era"))),
            this.eraCache[S]
        }
        )
    }
    extract(S, E, M) {
        const T = this.dtFormatter(S, E)
          , $ = T.formatToParts()
          , B = $.find(O=>O.type.toLowerCase() === M);
        return B ? B.value : null
    }
    numberFormatter(S={}) {
        return new PolyNumberFormatter(this.intl,S.forceSimple || this.fastNumbers,S)
    }
    dtFormatter(S, E={}) {
        return new PolyDateFormatter(S,this.intl,E)
    }
    relFormatter(S={}) {
        return new PolyRelFormatter(this.intl,this.isEnglish(),S)
    }
    listFormatter(S={}) {
        return getCachedLF(this.intl, S)
    }
    isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    }
    getWeekSettings() {
        return this.weekSettings ? this.weekSettings : hasLocaleWeekInfo() ? getCachedWeekInfo(this.locale) : fallbackWeekSettings
    }
    getStartOfWeek() {
        return this.getWeekSettings().firstDay
    }
    getMinDaysInFirstWeek() {
        return this.getWeekSettings().minimalDays
    }
    getWeekendDays() {
        return this.getWeekSettings().weekend
    }
    equals(S) {
        return this.locale === S.locale && this.numberingSystem === S.numberingSystem && this.outputCalendar === S.outputCalendar
    }
}
let singleton = null;
class FixedOffsetZone extends Zone {
    static get utcInstance() {
        return singleton === null && (singleton = new FixedOffsetZone(0)),
        singleton
    }
    static instance(S) {
        return S === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(S)
    }
    static parseSpecifier(S) {
        if (S) {
            const E = S.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
            if (E)
                return new FixedOffsetZone(signedOffset(E[1], E[2]))
        }
        return null
    }
    constructor(S) {
        super(),
        this.fixed = S
    }
    get type() {
        return "fixed"
    }
    get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`
    }
    get ianaName() {
        return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${formatOffset(-this.fixed, "narrow")}`
    }
    offsetName() {
        return this.name
    }
    formatOffset(S, E) {
        return formatOffset(this.fixed, E)
    }
    get isUniversal() {
        return !0
    }
    offset() {
        return this.fixed
    }
    equals(S) {
        return S.type === "fixed" && S.fixed === this.fixed
    }
    get isValid() {
        return !0
    }
}
class InvalidZone extends Zone {
    constructor(S) {
        super(),
        this.zoneName = S
    }
    get type() {
        return "invalid"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName() {
        return null
    }
    formatOffset() {
        return ""
    }
    offset() {
        return NaN
    }
    equals() {
        return !1
    }
    get isValid() {
        return !1
    }
}
function normalizeZone(C, S) {
    if (isUndefined(C) || C === null)
        return S;
    if (C instanceof Zone)
        return C;
    if (isString(C)) {
        const E = C.toLowerCase();
        return E === "default" ? S : E === "local" || E === "system" ? SystemZone.instance : E === "utc" || E === "gmt" ? FixedOffsetZone.utcInstance : FixedOffsetZone.parseSpecifier(E) || IANAZone.create(C)
    } else
        return isNumber(C) ? FixedOffsetZone.instance(C) : typeof C == "object" && "offset"in C && typeof C.offset == "function" ? C : new InvalidZone(C)
}
let now = ()=>Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid, defaultWeekSettings = null;
class Settings {
    static get now() {
        return now
    }
    static set now(S) {
        now = S
    }
    static set defaultZone(S) {
        defaultZone = S
    }
    static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance)
    }
    static get defaultLocale() {
        return defaultLocale
    }
    static set defaultLocale(S) {
        defaultLocale = S
    }
    static get defaultNumberingSystem() {
        return defaultNumberingSystem
    }
    static set defaultNumberingSystem(S) {
        defaultNumberingSystem = S
    }
    static get defaultOutputCalendar() {
        return defaultOutputCalendar
    }
    static set defaultOutputCalendar(S) {
        defaultOutputCalendar = S
    }
    static get defaultWeekSettings() {
        return defaultWeekSettings
    }
    static set defaultWeekSettings(S) {
        defaultWeekSettings = validateWeekSettings(S)
    }
    static get twoDigitCutoffYear() {
        return twoDigitCutoffYear
    }
    static set twoDigitCutoffYear(S) {
        twoDigitCutoffYear = S % 100
    }
    static get throwOnInvalid() {
        return throwOnInvalid
    }
    static set throwOnInvalid(S) {
        throwOnInvalid = S
    }
    static resetCaches() {
        Locale.resetCache(),
        IANAZone.resetCache()
    }
}
class Invalid {
    constructor(S, E) {
        this.reason = S,
        this.explanation = E
    }
    toMessage() {
        return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason
    }
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
  , leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(C, S) {
    return new Invalid("unit out of range",`you specified ${S} (of type ${typeof S}) as a ${C}, which is invalid`)
}
function dayOfWeek(C, S, E) {
    const M = new Date(Date.UTC(C, S - 1, E));
    C < 100 && C >= 0 && M.setUTCFullYear(M.getUTCFullYear() - 1900);
    const T = M.getUTCDay();
    return T === 0 ? 7 : T
}
function computeOrdinal(C, S, E) {
    return E + (isLeapYear(C) ? leapLadder : nonLeapLadder)[S - 1]
}
function uncomputeOrdinal(C, S) {
    const E = isLeapYear(C) ? leapLadder : nonLeapLadder
      , M = E.findIndex($=>$ < S)
      , T = S - E[M];
    return {
        month: M + 1,
        day: T
    }
}
function isoWeekdayToLocal(C, S) {
    return (C - S + 7) % 7 + 1
}
function gregorianToWeek(C, S=4, E=1) {
    const {year: M, month: T, day: $} = C
      , B = computeOrdinal(M, T, $)
      , O = isoWeekdayToLocal(dayOfWeek(M, T, $), E);
    let F = Math.floor((B - O + 14 - S) / 7), N;
    return F < 1 ? (N = M - 1,
    F = weeksInWeekYear(N, S, E)) : F > weeksInWeekYear(M, S, E) ? (N = M + 1,
    F = 1) : N = M,
    {
        weekYear: N,
        weekNumber: F,
        weekday: O,
        ...timeObject(C)
    }
}
function weekToGregorian(C, S=4, E=1) {
    const {weekYear: M, weekNumber: T, weekday: $} = C
      , B = isoWeekdayToLocal(dayOfWeek(M, 1, S), E)
      , O = daysInYear(M);
    let F = T * 7 + $ - B - 7 + S, N;
    F < 1 ? (N = M - 1,
    F += daysInYear(N)) : F > O ? (N = M + 1,
    F -= daysInYear(M)) : N = M;
    const {month: U, day: H} = uncomputeOrdinal(N, F);
    return {
        year: N,
        month: U,
        day: H,
        ...timeObject(C)
    }
}
function gregorianToOrdinal(C) {
    const {year: S, month: E, day: M} = C
      , T = computeOrdinal(S, E, M);
    return {
        year: S,
        ordinal: T,
        ...timeObject(C)
    }
}
function ordinalToGregorian(C) {
    const {year: S, ordinal: E} = C
      , {month: M, day: T} = uncomputeOrdinal(S, E);
    return {
        year: S,
        month: M,
        day: T,
        ...timeObject(C)
    }
}
function usesLocalWeekValues(C, S) {
    if (!isUndefined(C.localWeekday) || !isUndefined(C.localWeekNumber) || !isUndefined(C.localWeekYear)) {
        if (!isUndefined(C.weekday) || !isUndefined(C.weekNumber) || !isUndefined(C.weekYear))
            throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
        return isUndefined(C.localWeekday) || (C.weekday = C.localWeekday),
        isUndefined(C.localWeekNumber) || (C.weekNumber = C.localWeekNumber),
        isUndefined(C.localWeekYear) || (C.weekYear = C.localWeekYear),
        delete C.localWeekday,
        delete C.localWeekNumber,
        delete C.localWeekYear,
        {
            minDaysInFirstWeek: S.getMinDaysInFirstWeek(),
            startOfWeek: S.getStartOfWeek()
        }
    } else
        return {
            minDaysInFirstWeek: 4,
            startOfWeek: 1
        }
}
function hasInvalidWeekData(C, S=4, E=1) {
    const M = isInteger(C.weekYear)
      , T = integerBetween(C.weekNumber, 1, weeksInWeekYear(C.weekYear, S, E))
      , $ = integerBetween(C.weekday, 1, 7);
    return M ? T ? $ ? !1 : unitOutOfRange("weekday", C.weekday) : unitOutOfRange("week", C.weekNumber) : unitOutOfRange("weekYear", C.weekYear)
}
function hasInvalidOrdinalData(C) {
    const S = isInteger(C.year)
      , E = integerBetween(C.ordinal, 1, daysInYear(C.year));
    return S ? E ? !1 : unitOutOfRange("ordinal", C.ordinal) : unitOutOfRange("year", C.year)
}
function hasInvalidGregorianData(C) {
    const S = isInteger(C.year)
      , E = integerBetween(C.month, 1, 12)
      , M = integerBetween(C.day, 1, daysInMonth(C.year, C.month));
    return S ? E ? M ? !1 : unitOutOfRange("day", C.day) : unitOutOfRange("month", C.month) : unitOutOfRange("year", C.year)
}
function hasInvalidTimeData(C) {
    const {hour: S, minute: E, second: M, millisecond: T} = C
      , $ = integerBetween(S, 0, 23) || S === 24 && E === 0 && M === 0 && T === 0
      , B = integerBetween(E, 0, 59)
      , O = integerBetween(M, 0, 59)
      , F = integerBetween(T, 0, 999);
    return $ ? B ? O ? F ? !1 : unitOutOfRange("millisecond", T) : unitOutOfRange("second", M) : unitOutOfRange("minute", E) : unitOutOfRange("hour", S)
}
function isUndefined(C) {
    return typeof C > "u"
}
function isNumber(C) {
    return typeof C == "number"
}
function isInteger(C) {
    return typeof C == "number" && C % 1 === 0
}
function isString(C) {
    return typeof C == "string"
}
function isDate(C) {
    return Object.prototype.toString.call(C) === "[object Date]"
}
function hasRelative() {
    try {
        return typeof Intl < "u" && !!Intl.RelativeTimeFormat
    } catch {
        return !1
    }
}
function hasLocaleWeekInfo() {
    try {
        return typeof Intl < "u" && !!Intl.Locale && ("weekInfo"in Intl.Locale.prototype || "getWeekInfo"in Intl.Locale.prototype)
    } catch {
        return !1
    }
}
function maybeArray(C) {
    return Array.isArray(C) ? C : [C]
}
function bestBy(C, S, E) {
    if (C.length !== 0)
        return C.reduce((M,T)=>{
            const $ = [S(T), T];
            return M && E(M[0], $[0]) === M[0] ? M : $
        }
        , null)[1]
}
function pick(C, S) {
    return S.reduce((E,M)=>(E[M] = C[M],
    E), {})
}
function hasOwnProperty(C, S) {
    return Object.prototype.hasOwnProperty.call(C, S)
}
function validateWeekSettings(C) {
    if (C == null)
        return null;
    if (typeof C != "object")
        throw new InvalidArgumentError("Week settings must be an object");
    if (!integerBetween(C.firstDay, 1, 7) || !integerBetween(C.minimalDays, 1, 7) || !Array.isArray(C.weekend) || C.weekend.some(S=>!integerBetween(S, 1, 7)))
        throw new InvalidArgumentError("Invalid week settings");
    return {
        firstDay: C.firstDay,
        minimalDays: C.minimalDays,
        weekend: Array.from(C.weekend)
    }
}
function integerBetween(C, S, E) {
    return isInteger(C) && C >= S && C <= E
}
function floorMod(C, S) {
    return C - S * Math.floor(C / S)
}
function padStart(C, S=2) {
    const E = C < 0;
    let M;
    return E ? M = "-" + ("" + -C).padStart(S, "0") : M = ("" + C).padStart(S, "0"),
    M
}
function parseInteger(C) {
    if (!(isUndefined(C) || C === null || C === ""))
        return parseInt(C, 10)
}
function parseFloating(C) {
    if (!(isUndefined(C) || C === null || C === ""))
        return parseFloat(C)
}
function parseMillis(C) {
    if (!(isUndefined(C) || C === null || C === "")) {
        const S = parseFloat("0." + C) * 1e3;
        return Math.floor(S)
    }
}
function roundTo(C, S, E=!1) {
    const M = 10 ** S;
    return (E ? Math.trunc : Math.round)(C * M) / M
}
function isLeapYear(C) {
    return C % 4 === 0 && (C % 100 !== 0 || C % 400 === 0)
}
function daysInYear(C) {
    return isLeapYear(C) ? 366 : 365
}
function daysInMonth(C, S) {
    const E = floorMod(S - 1, 12) + 1
      , M = C + (S - E) / 12;
    return E === 2 ? isLeapYear(M) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][E - 1]
}
function objToLocalTS(C) {
    let S = Date.UTC(C.year, C.month - 1, C.day, C.hour, C.minute, C.second, C.millisecond);
    return C.year < 100 && C.year >= 0 && (S = new Date(S),
    S.setUTCFullYear(C.year, C.month - 1, C.day)),
    +S
}
function firstWeekOffset(C, S, E) {
    return -isoWeekdayToLocal(dayOfWeek(C, 1, S), E) + S - 1
}
function weeksInWeekYear(C, S=4, E=1) {
    const M = firstWeekOffset(C, S, E)
      , T = firstWeekOffset(C + 1, S, E);
    return (daysInYear(C) - M + T) / 7
}
function untruncateYear(C) {
    return C > 99 ? C : C > Settings.twoDigitCutoffYear ? 1900 + C : 2e3 + C
}
function parseZoneInfo(C, S, E, M=null) {
    const T = new Date(C)
      , $ = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
    };
    M && ($.timeZone = M);
    const B = {
        timeZoneName: S,
        ...$
    }
      , O = new Intl.DateTimeFormat(E,B).formatToParts(T).find(F=>F.type.toLowerCase() === "timezonename");
    return O ? O.value : null
}
function signedOffset(C, S) {
    let E = parseInt(C, 10);
    Number.isNaN(E) && (E = 0);
    const M = parseInt(S, 10) || 0
      , T = E < 0 || Object.is(E, -0) ? -M : M;
    return E * 60 + T
}
function asNumber(C) {
    const S = Number(C);
    if (typeof C == "boolean" || C === "" || Number.isNaN(S))
        throw new InvalidArgumentError(`Invalid unit value ${C}`);
    return S
}
function normalizeObject(C, S) {
    const E = {};
    for (const M in C)
        if (hasOwnProperty(C, M)) {
            const T = C[M];
            if (T == null)
                continue;
            E[S(M)] = asNumber(T)
        }
    return E
}
function formatOffset(C, S) {
    const E = Math.trunc(Math.abs(C / 60))
      , M = Math.trunc(Math.abs(C % 60))
      , T = C >= 0 ? "+" : "-";
    switch (S) {
    case "short":
        return `${T}${padStart(E, 2)}:${padStart(M, 2)}`;
    case "narrow":
        return `${T}${E}${M > 0 ? `:${M}` : ""}`;
    case "techie":
        return `${T}${padStart(E, 2)}${padStart(M, 2)}`;
    default:
        throw new RangeError(`Value format ${S} is out of range for property format`)
    }
}
function timeObject(C) {
    return pick(C, ["hour", "minute", "second", "millisecond"])
}
const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  , monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  , monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(C) {
    switch (C) {
    case "narrow":
        return [...monthsNarrow];
    case "short":
        return [...monthsShort];
    case "long":
        return [...monthsLong];
    case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
        return null
    }
}
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
  , weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
  , weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(C) {
    switch (C) {
    case "narrow":
        return [...weekdaysNarrow];
    case "short":
        return [...weekdaysShort];
    case "long":
        return [...weekdaysLong];
    case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
    default:
        return null
    }
}
const meridiems = ["AM", "PM"]
  , erasLong = ["Before Christ", "Anno Domini"]
  , erasShort = ["BC", "AD"]
  , erasNarrow = ["B", "A"];
function eras(C) {
    switch (C) {
    case "narrow":
        return [...erasNarrow];
    case "short":
        return [...erasShort];
    case "long":
        return [...erasLong];
    default:
        return null
    }
}
function meridiemForDateTime(C) {
    return meridiems[C.hour < 12 ? 0 : 1]
}
function weekdayForDateTime(C, S) {
    return weekdays(S)[C.weekday - 1]
}
function monthForDateTime(C, S) {
    return months(S)[C.month - 1]
}
function eraForDateTime(C, S) {
    return eras(S)[C.year < 0 ? 0 : 1]
}
function formatRelativeTime(C, S, E="always", M=!1) {
    const T = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
    }
      , $ = ["hours", "minutes", "seconds"].indexOf(C) === -1;
    if (E === "auto" && $) {
        const H = C === "days";
        switch (S) {
        case 1:
            return H ? "tomorrow" : `next ${T[C][0]}`;
        case -1:
            return H ? "yesterday" : `last ${T[C][0]}`;
        case 0:
            return H ? "today" : `this ${T[C][0]}`
        }
    }
    const B = Object.is(S, -0) || S < 0
      , O = Math.abs(S)
      , F = O === 1
      , N = T[C]
      , U = M ? F ? N[1] : N[2] || N[1] : F ? T[C][0] : C;
    return B ? `${O} ${U} ago` : `in ${O} ${U}`
}
function stringifyTokens(C, S) {
    let E = "";
    for (const M of C)
        M.literal ? E += M.val : E += S(M.val);
    return E
}
const macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
    static create(S, E={}) {
        return new Formatter(S,E)
    }
    static parseFormat(S) {
        let E = null
          , M = ""
          , T = !1;
        const $ = [];
        for (let B = 0; B < S.length; B++) {
            const O = S.charAt(B);
            O === "'" ? (M.length > 0 && $.push({
                literal: T || /^\s+$/.test(M),
                val: M
            }),
            E = null,
            M = "",
            T = !T) : T || O === E ? M += O : (M.length > 0 && $.push({
                literal: /^\s+$/.test(M),
                val: M
            }),
            M = O,
            E = O)
        }
        return M.length > 0 && $.push({
            literal: T || /^\s+$/.test(M),
            val: M
        }),
        $
    }
    static macroTokenToFormatOpts(S) {
        return macroTokenToFormatOpts[S]
    }
    constructor(S, E) {
        this.opts = E,
        this.loc = S,
        this.systemLoc = null
    }
    formatWithSystemDefault(S, E) {
        return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()),
        this.systemLoc.dtFormatter(S, {
            ...this.opts,
            ...E
        }).format()
    }
    dtFormatter(S, E={}) {
        return this.loc.dtFormatter(S, {
            ...this.opts,
            ...E
        })
    }
    formatDateTime(S, E) {
        return this.dtFormatter(S, E).format()
    }
    formatDateTimeParts(S, E) {
        return this.dtFormatter(S, E).formatToParts()
    }
    formatInterval(S, E) {
        return this.dtFormatter(S.start, E).dtf.formatRange(S.start.toJSDate(), S.end.toJSDate())
    }
    resolvedOptions(S, E) {
        return this.dtFormatter(S, E).resolvedOptions()
    }
    num(S, E=0) {
        if (this.opts.forceSimple)
            return padStart(S, E);
        const M = {
            ...this.opts
        };
        return E > 0 && (M.padTo = E),
        this.loc.numberFormatter(M).format(S)
    }
    formatDateTimeFromString(S, E) {
        const M = this.loc.listingMode() === "en"
          , T = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory"
          , $ = (J,ie)=>this.loc.extract(S, J, ie)
          , B = J=>S.isOffsetFixed && S.offset === 0 && J.allowZ ? "Z" : S.isValid ? S.zone.formatOffset(S.ts, J.format) : ""
          , O = ()=>M ? meridiemForDateTime(S) : $({
            hour: "numeric",
            hourCycle: "h12"
        }, "dayperiod")
          , F = (J,ie)=>M ? monthForDateTime(S, J) : $(ie ? {
            month: J
        } : {
            month: J,
            day: "numeric"
        }, "month")
          , N = (J,ie)=>M ? weekdayForDateTime(S, J) : $(ie ? {
            weekday: J
        } : {
            weekday: J,
            month: "long",
            day: "numeric"
        }, "weekday")
          , U = J=>{
            const ie = Formatter.macroTokenToFormatOpts(J);
            return ie ? this.formatWithSystemDefault(S, ie) : J
        }
          , H = J=>M ? eraForDateTime(S, J) : $({
            era: J
        }, "era")
          , Z = J=>{
            switch (J) {
            case "S":
                return this.num(S.millisecond);
            case "u":
            case "SSS":
                return this.num(S.millisecond, 3);
            case "s":
                return this.num(S.second);
            case "ss":
                return this.num(S.second, 2);
            case "uu":
                return this.num(Math.floor(S.millisecond / 10), 2);
            case "uuu":
                return this.num(Math.floor(S.millisecond / 100));
            case "m":
                return this.num(S.minute);
            case "mm":
                return this.num(S.minute, 2);
            case "h":
                return this.num(S.hour % 12 === 0 ? 12 : S.hour % 12);
            case "hh":
                return this.num(S.hour % 12 === 0 ? 12 : S.hour % 12, 2);
            case "H":
                return this.num(S.hour);
            case "HH":
                return this.num(S.hour, 2);
            case "Z":
                return B({
                    format: "narrow",
                    allowZ: this.opts.allowZ
                });
            case "ZZ":
                return B({
                    format: "short",
                    allowZ: this.opts.allowZ
                });
            case "ZZZ":
                return B({
                    format: "techie",
                    allowZ: this.opts.allowZ
                });
            case "ZZZZ":
                return S.zone.offsetName(S.ts, {
                    format: "short",
                    locale: this.loc.locale
                });
            case "ZZZZZ":
                return S.zone.offsetName(S.ts, {
                    format: "long",
                    locale: this.loc.locale
                });
            case "z":
                return S.zoneName;
            case "a":
                return O();
            case "d":
                return T ? $({
                    day: "numeric"
                }, "day") : this.num(S.day);
            case "dd":
                return T ? $({
                    day: "2-digit"
                }, "day") : this.num(S.day, 2);
            case "c":
                return this.num(S.weekday);
            case "ccc":
                return N("short", !0);
            case "cccc":
                return N("long", !0);
            case "ccccc":
                return N("narrow", !0);
            case "E":
                return this.num(S.weekday);
            case "EEE":
                return N("short", !1);
            case "EEEE":
                return N("long", !1);
            case "EEEEE":
                return N("narrow", !1);
            case "L":
                return T ? $({
                    month: "numeric",
                    day: "numeric"
                }, "month") : this.num(S.month);
            case "LL":
                return T ? $({
                    month: "2-digit",
                    day: "numeric"
                }, "month") : this.num(S.month, 2);
            case "LLL":
                return F("short", !0);
            case "LLLL":
                return F("long", !0);
            case "LLLLL":
                return F("narrow", !0);
            case "M":
                return T ? $({
                    month: "numeric"
                }, "month") : this.num(S.month);
            case "MM":
                return T ? $({
                    month: "2-digit"
                }, "month") : this.num(S.month, 2);
            case "MMM":
                return F("short", !1);
            case "MMMM":
                return F("long", !1);
            case "MMMMM":
                return F("narrow", !1);
            case "y":
                return T ? $({
                    year: "numeric"
                }, "year") : this.num(S.year);
            case "yy":
                return T ? $({
                    year: "2-digit"
                }, "year") : this.num(S.year.toString().slice(-2), 2);
            case "yyyy":
                return T ? $({
                    year: "numeric"
                }, "year") : this.num(S.year, 4);
            case "yyyyyy":
                return T ? $({
                    year: "numeric"
                }, "year") : this.num(S.year, 6);
            case "G":
                return H("short");
            case "GG":
                return H("long");
            case "GGGGG":
                return H("narrow");
            case "kk":
                return this.num(S.weekYear.toString().slice(-2), 2);
            case "kkkk":
                return this.num(S.weekYear, 4);
            case "W":
                return this.num(S.weekNumber);
            case "WW":
                return this.num(S.weekNumber, 2);
            case "n":
                return this.num(S.localWeekNumber);
            case "nn":
                return this.num(S.localWeekNumber, 2);
            case "ii":
                return this.num(S.localWeekYear.toString().slice(-2), 2);
            case "iiii":
                return this.num(S.localWeekYear, 4);
            case "o":
                return this.num(S.ordinal);
            case "ooo":
                return this.num(S.ordinal, 3);
            case "q":
                return this.num(S.quarter);
            case "qq":
                return this.num(S.quarter, 2);
            case "X":
                return this.num(Math.floor(S.ts / 1e3));
            case "x":
                return this.num(S.ts);
            default:
                return U(J)
            }
        }
        ;
        return stringifyTokens(Formatter.parseFormat(E), Z)
    }
    formatDurationFromString(S, E) {
        const M = F=>{
            switch (F[0]) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
                return "hour";
            case "d":
                return "day";
            case "w":
                return "week";
            case "M":
                return "month";
            case "y":
                return "year";
            default:
                return null
            }
        }
          , T = F=>N=>{
            const U = M(N);
            return U ? this.num(F.get(U), N.length) : N
        }
          , $ = Formatter.parseFormat(E)
          , B = $.reduce((F,{literal: N, val: U})=>N ? F : F.concat(U), [])
          , O = S.shiftTo(...B.map(M).filter(F=>F));
        return stringifyTokens($, T(O))
    }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...C) {
    const S = C.reduce((E,M)=>E + M.source, "");
    return RegExp(`^${S}$`)
}
function combineExtractors(...C) {
    return S=>C.reduce(([E,M,T],$)=>{
        const [B,O,F] = $(S, T);
        return [{
            ...E,
            ...B
        }, O || M, F]
    }
    , [{}, null, 1]).slice(0, 2)
}
function parse(C, ...S) {
    if (C == null)
        return [null, null];
    for (const [E,M] of S) {
        const T = E.exec(C);
        if (T)
            return M(T)
    }
    return [null, null]
}
function simpleParse(...C) {
    return (S,E)=>{
        const M = {};
        let T;
        for (T = 0; T < C.length; T++)
            M[C[T]] = parseInteger(S[E + T]);
        return [M, null, E + T]
    }
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/
  , isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`
  , isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/
  , isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`)
  , isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`)
  , isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/
  , isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/
  , isoOrdinalRegex = /(\d{4})-?(\d{3})/
  , extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay")
  , extractISOOrdinalData = simpleParse("year", "ordinal")
  , sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/
  , sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`)
  , sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(C, S, E) {
    const M = C[S];
    return isUndefined(M) ? E : parseInteger(M)
}
function extractISOYmd(C, S) {
    return [{
        year: int(C, S),
        month: int(C, S + 1, 1),
        day: int(C, S + 2, 1)
    }, null, S + 3]
}
function extractISOTime(C, S) {
    return [{
        hours: int(C, S, 0),
        minutes: int(C, S + 1, 0),
        seconds: int(C, S + 2, 0),
        milliseconds: parseMillis(C[S + 3])
    }, null, S + 4]
}
function extractISOOffset(C, S) {
    const E = !C[S] && !C[S + 1]
      , M = signedOffset(C[S + 1], C[S + 2])
      , T = E ? null : FixedOffsetZone.instance(M);
    return [{}, T, S + 3]
}
function extractIANAZone(C, S) {
    const E = C[S] ? IANAZone.create(C[S]) : null;
    return [{}, E, S + 1]
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`)
  , isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(C) {
    const [S,E,M,T,$,B,O,F,N] = C
      , U = S[0] === "-"
      , H = F && F[0] === "-"
      , Z = (J,ie=!1)=>J !== void 0 && (ie || J && U) ? -J : J;
    return [{
        years: Z(parseFloating(E)),
        months: Z(parseFloating(M)),
        weeks: Z(parseFloating(T)),
        days: Z(parseFloating($)),
        hours: Z(parseFloating(B)),
        minutes: Z(parseFloating(O)),
        seconds: Z(parseFloating(F), F === "-0"),
        milliseconds: Z(parseMillis(N), H)
    }]
}
const obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};
function fromStrings(C, S, E, M, T, $, B) {
    const O = {
        year: S.length === 2 ? untruncateYear(parseInteger(S)) : parseInteger(S),
        month: monthsShort.indexOf(E) + 1,
        day: parseInteger(M),
        hour: parseInteger(T),
        minute: parseInteger($)
    };
    return B && (O.second = parseInteger(B)),
    C && (O.weekday = C.length > 3 ? weekdaysLong.indexOf(C) + 1 : weekdaysShort.indexOf(C) + 1),
    O
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(C) {
    const [,S,E,M,T,$,B,O,F,N,U,H] = C
      , Z = fromStrings(S, T, M, E, $, B, O);
    let J;
    return F ? J = obsOffsets[F] : N ? J = 0 : J = signedOffset(U, H),
    [Z, new FixedOffsetZone(J)]
}
function preprocessRFC2822(C) {
    return C.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/
  , rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/
  , ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(C) {
    const [,S,E,M,T,$,B,O] = C;
    return [fromStrings(S, T, M, E, $, B, O), FixedOffsetZone.utcInstance]
}
function extractASCII(C) {
    const [,S,E,M,T,$,B,O] = C;
    return [fromStrings(S, O, E, M, T, $, B), FixedOffsetZone.utcInstance]
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex)
  , isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex)
  , isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex)
  , isoTimeCombinedRegex = combineRegexes(isoTimeRegex)
  , extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone)
  , extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone)
  , extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone)
  , extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(C) {
    return parse(C, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset])
}
function parseRFC2822Date(C) {
    return parse(preprocessRFC2822(C), [rfc2822, extractRFC2822])
}
function parseHTTPDate(C) {
    return parse(C, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII])
}
function parseISODuration(C) {
    return parse(C, [isoDuration, extractISODuration])
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(C) {
    return parse(C, [isoTimeOnly, extractISOTimeOnly])
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex)
  , sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex)
  , extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(C) {
    return parse(C, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone])
}
const INVALID$2 = "Invalid Duration"
  , lowOrderMatrix = {
    weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
    },
    minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
    },
    seconds: {
        milliseconds: 1e3
    }
}
  , casualMatrix = {
    years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
}
  , daysInYearAccurate = 146097 / 400
  , daysInMonthAccurate = 146097 / 4800
  , accurateMatrix = {
    years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
    },
    quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
}
  , orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"]
  , reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(C, S, E=!1) {
    const M = {
        values: E ? S.values : {
            ...C.values,
            ...S.values || {}
        },
        loc: C.loc.clone(S.loc),
        conversionAccuracy: S.conversionAccuracy || C.conversionAccuracy,
        matrix: S.matrix || C.matrix
    };
    return new Duration(M)
}
function durationToMillis(C, S) {
    let E = S.milliseconds ?? 0;
    for (const M of reverseUnits.slice(1))
        S[M] && (E += S[M] * C[M].milliseconds);
    return E
}
function normalizeValues(C, S) {
    const E = durationToMillis(C, S) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((M,T)=>{
        if (isUndefined(S[T]))
            return M;
        if (M) {
            const $ = S[M] * E
              , B = C[T][M]
              , O = Math.floor($ / B);
            S[T] += O * E,
            S[M] -= O * B * E
        }
        return T
    }
    , null),
    orderedUnits$1.reduce((M,T)=>{
        if (isUndefined(S[T]))
            return M;
        if (M) {
            const $ = S[M] % 1;
            S[M] -= $,
            S[T] += $ * C[M][T]
        }
        return T
    }
    , null)
}
function removeZeroes(C) {
    const S = {};
    for (const [E,M] of Object.entries(C))
        M !== 0 && (S[E] = M);
    return S
}
class Duration {
    constructor(S) {
        const E = S.conversionAccuracy === "longterm" || !1;
        let M = E ? accurateMatrix : casualMatrix;
        S.matrix && (M = S.matrix),
        this.values = S.values,
        this.loc = S.loc || Locale.create(),
        this.conversionAccuracy = E ? "longterm" : "casual",
        this.invalid = S.invalid || null,
        this.matrix = M,
        this.isLuxonDuration = !0
    }
    static fromMillis(S, E) {
        return Duration.fromObject({
            milliseconds: S
        }, E)
    }
    static fromObject(S, E={}) {
        if (S == null || typeof S != "object")
            throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${S === null ? "null" : typeof S}`);
        return new Duration({
            values: normalizeObject(S, Duration.normalizeUnit),
            loc: Locale.fromObject(E),
            conversionAccuracy: E.conversionAccuracy,
            matrix: E.matrix
        })
    }
    static fromDurationLike(S) {
        if (isNumber(S))
            return Duration.fromMillis(S);
        if (Duration.isDuration(S))
            return S;
        if (typeof S == "object")
            return Duration.fromObject(S);
        throw new InvalidArgumentError(`Unknown duration argument ${S} of type ${typeof S}`)
    }
    static fromISO(S, E) {
        const [M] = parseISODuration(S);
        return M ? Duration.fromObject(M, E) : Duration.invalid("unparsable", `the input "${S}" can't be parsed as ISO 8601`)
    }
    static fromISOTime(S, E) {
        const [M] = parseISOTimeOnly(S);
        return M ? Duration.fromObject(M, E) : Duration.invalid("unparsable", `the input "${S}" can't be parsed as ISO 8601`)
    }
    static invalid(S, E=null) {
        if (!S)
            throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        const M = S instanceof Invalid ? S : new Invalid(S,E);
        if (Settings.throwOnInvalid)
            throw new InvalidDurationError(M);
        return new Duration({
            invalid: M
        })
    }
    static normalizeUnit(S) {
        const E = {
            year: "years",
            years: "years",
            quarter: "quarters",
            quarters: "quarters",
            month: "months",
            months: "months",
            week: "weeks",
            weeks: "weeks",
            day: "days",
            days: "days",
            hour: "hours",
            hours: "hours",
            minute: "minutes",
            minutes: "minutes",
            second: "seconds",
            seconds: "seconds",
            millisecond: "milliseconds",
            milliseconds: "milliseconds"
        }[S && S.toLowerCase()];
        if (!E)
            throw new InvalidUnitError(S);
        return E
    }
    static isDuration(S) {
        return S && S.isLuxonDuration || !1
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    toFormat(S, E={}) {
        const M = {
            ...E,
            floor: E.round !== !1 && E.floor !== !1
        };
        return this.isValid ? Formatter.create(this.loc, M).formatDurationFromString(this, S) : INVALID$2
    }
    toHuman(S={}) {
        if (!this.isValid)
            return INVALID$2;
        const E = orderedUnits$1.map(M=>{
            const T = this.values[M];
            return isUndefined(T) ? null : this.loc.numberFormatter({
                style: "unit",
                unitDisplay: "long",
                ...S,
                unit: M.slice(0, -1)
            }).format(T)
        }
        ).filter(M=>M);
        return this.loc.listFormatter({
            type: "conjunction",
            style: S.listStyle || "narrow",
            ...S
        }).format(E)
    }
    toObject() {
        return this.isValid ? {
            ...this.values
        } : {}
    }
    toISO() {
        if (!this.isValid)
            return null;
        let S = "P";
        return this.years !== 0 && (S += this.years + "Y"),
        (this.months !== 0 || this.quarters !== 0) && (S += this.months + this.quarters * 3 + "M"),
        this.weeks !== 0 && (S += this.weeks + "W"),
        this.days !== 0 && (S += this.days + "D"),
        (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (S += "T"),
        this.hours !== 0 && (S += this.hours + "H"),
        this.minutes !== 0 && (S += this.minutes + "M"),
        (this.seconds !== 0 || this.milliseconds !== 0) && (S += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S"),
        S === "P" && (S += "T0S"),
        S
    }
    toISOTime(S={}) {
        if (!this.isValid)
            return null;
        const E = this.toMillis();
        return E < 0 || E >= 864e5 ? null : (S = {
            suppressMilliseconds: !1,
            suppressSeconds: !1,
            includePrefix: !1,
            format: "extended",
            ...S,
            includeOffset: !1
        },
        DateTime.fromMillis(E, {
            zone: "UTC"
        }).toISOTime(S))
    }
    toJSON() {
        return this.toISO()
    }
    toString() {
        return this.toISO()
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`
    }
    toMillis() {
        return this.isValid ? durationToMillis(this.matrix, this.values) : NaN
    }
    valueOf() {
        return this.toMillis()
    }
    plus(S) {
        if (!this.isValid)
            return this;
        const E = Duration.fromDurationLike(S)
          , M = {};
        for (const T of orderedUnits$1)
            (hasOwnProperty(E.values, T) || hasOwnProperty(this.values, T)) && (M[T] = E.get(T) + this.get(T));
        return clone$1(this, {
            values: M
        }, !0)
    }
    minus(S) {
        if (!this.isValid)
            return this;
        const E = Duration.fromDurationLike(S);
        return this.plus(E.negate())
    }
    mapUnits(S) {
        if (!this.isValid)
            return this;
        const E = {};
        for (const M of Object.keys(this.values))
            E[M] = asNumber(S(this.values[M], M));
        return clone$1(this, {
            values: E
        }, !0)
    }
    get(S) {
        return this[Duration.normalizeUnit(S)]
    }
    set(S) {
        if (!this.isValid)
            return this;
        const E = {
            ...this.values,
            ...normalizeObject(S, Duration.normalizeUnit)
        };
        return clone$1(this, {
            values: E
        })
    }
    reconfigure({locale: S, numberingSystem: E, conversionAccuracy: M, matrix: T}={}) {
        const B = {
            loc: this.loc.clone({
                locale: S,
                numberingSystem: E
            }),
            matrix: T,
            conversionAccuracy: M
        };
        return clone$1(this, B)
    }
    as(S) {
        return this.isValid ? this.shiftTo(S).get(S) : NaN
    }
    normalize() {
        if (!this.isValid)
            return this;
        const S = this.toObject();
        return normalizeValues(this.matrix, S),
        clone$1(this, {
            values: S
        }, !0)
    }
    rescale() {
        if (!this.isValid)
            return this;
        const S = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, {
            values: S
        }, !0)
    }
    shiftTo(...S) {
        if (!this.isValid)
            return this;
        if (S.length === 0)
            return this;
        S = S.map(B=>Duration.normalizeUnit(B));
        const E = {}
          , M = {}
          , T = this.toObject();
        let $;
        for (const B of orderedUnits$1)
            if (S.indexOf(B) >= 0) {
                $ = B;
                let O = 0;
                for (const N in M)
                    O += this.matrix[N][B] * M[N],
                    M[N] = 0;
                isNumber(T[B]) && (O += T[B]);
                const F = Math.trunc(O);
                E[B] = F,
                M[B] = (O * 1e3 - F * 1e3) / 1e3
            } else
                isNumber(T[B]) && (M[B] = T[B]);
        for (const B in M)
            M[B] !== 0 && (E[$] += B === $ ? M[B] : M[B] / this.matrix[$][B]);
        return normalizeValues(this.matrix, E),
        clone$1(this, {
            values: E
        }, !0)
    }
    shiftToAll() {
        return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this
    }
    negate() {
        if (!this.isValid)
            return this;
        const S = {};
        for (const E of Object.keys(this.values))
            S[E] = this.values[E] === 0 ? 0 : -this.values[E];
        return clone$1(this, {
            values: S
        }, !0)
    }
    get years() {
        return this.isValid ? this.values.years || 0 : NaN
    }
    get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN
    }
    get months() {
        return this.isValid ? this.values.months || 0 : NaN
    }
    get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN
    }
    get days() {
        return this.isValid ? this.values.days || 0 : NaN
    }
    get hours() {
        return this.isValid ? this.values.hours || 0 : NaN
    }
    get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN
    }
    get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN
    }
    get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    equals(S) {
        if (!this.isValid || !S.isValid || !this.loc.equals(S.loc))
            return !1;
        function E(M, T) {
            return M === void 0 || M === 0 ? T === void 0 || T === 0 : M === T
        }
        for (const M of orderedUnits$1)
            if (!E(this.values[M], S.values[M]))
                return !1;
        return !0
    }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(C, S) {
    return !C || !C.isValid ? Interval.invalid("missing or invalid start") : !S || !S.isValid ? Interval.invalid("missing or invalid end") : S < C ? Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${C.toISO()} and end=${S.toISO()}`) : null
}
class Interval {
    constructor(S) {
        this.s = S.start,
        this.e = S.end,
        this.invalid = S.invalid || null,
        this.isLuxonInterval = !0
    }
    static invalid(S, E=null) {
        if (!S)
            throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        const M = S instanceof Invalid ? S : new Invalid(S,E);
        if (Settings.throwOnInvalid)
            throw new InvalidIntervalError(M);
        return new Interval({
            invalid: M
        })
    }
    static fromDateTimes(S, E) {
        const M = friendlyDateTime(S)
          , T = friendlyDateTime(E)
          , $ = validateStartEnd(M, T);
        return $ ?? new Interval({
            start: M,
            end: T
        })
    }
    static after(S, E) {
        const M = Duration.fromDurationLike(E)
          , T = friendlyDateTime(S);
        return Interval.fromDateTimes(T, T.plus(M))
    }
    static before(S, E) {
        const M = Duration.fromDurationLike(E)
          , T = friendlyDateTime(S);
        return Interval.fromDateTimes(T.minus(M), T)
    }
    static fromISO(S, E) {
        const [M,T] = (S || "").split("/", 2);
        if (M && T) {
            let $, B;
            try {
                $ = DateTime.fromISO(M, E),
                B = $.isValid
            } catch {
                B = !1
            }
            let O, F;
            try {
                O = DateTime.fromISO(T, E),
                F = O.isValid
            } catch {
                F = !1
            }
            if (B && F)
                return Interval.fromDateTimes($, O);
            if (B) {
                const N = Duration.fromISO(T, E);
                if (N.isValid)
                    return Interval.after($, N)
            } else if (F) {
                const N = Duration.fromISO(M, E);
                if (N.isValid)
                    return Interval.before(O, N)
            }
        }
        return Interval.invalid("unparsable", `the input "${S}" can't be parsed as ISO 8601`)
    }
    static isInterval(S) {
        return S && S.isLuxonInterval || !1
    }
    get start() {
        return this.isValid ? this.s : null
    }
    get end() {
        return this.isValid ? this.e : null
    }
    get isValid() {
        return this.invalidReason === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    length(S="milliseconds") {
        return this.isValid ? this.toDuration(S).get(S) : NaN
    }
    count(S="milliseconds", E) {
        if (!this.isValid)
            return NaN;
        const M = this.start.startOf(S, E);
        let T;
        return E != null && E.useLocaleWeeks ? T = this.end.reconfigure({
            locale: M.locale
        }) : T = this.end,
        T = T.startOf(S, E),
        Math.floor(T.diff(M, S).get(S)) + (T.valueOf() !== this.end.valueOf())
    }
    hasSame(S) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, S) : !1
    }
    isEmpty() {
        return this.s.valueOf() === this.e.valueOf()
    }
    isAfter(S) {
        return this.isValid ? this.s > S : !1
    }
    isBefore(S) {
        return this.isValid ? this.e <= S : !1
    }
    contains(S) {
        return this.isValid ? this.s <= S && this.e > S : !1
    }
    set({start: S, end: E}={}) {
        return this.isValid ? Interval.fromDateTimes(S || this.s, E || this.e) : this
    }
    splitAt(...S) {
        if (!this.isValid)
            return [];
        const E = S.map(friendlyDateTime).filter(B=>this.contains(B)).sort((B,O)=>B.toMillis() - O.toMillis())
          , M = [];
        let {s: T} = this
          , $ = 0;
        for (; T < this.e; ) {
            const B = E[$] || this.e
              , O = +B > +this.e ? this.e : B;
            M.push(Interval.fromDateTimes(T, O)),
            T = O,
            $ += 1
        }
        return M
    }
    splitBy(S) {
        const E = Duration.fromDurationLike(S);
        if (!this.isValid || !E.isValid || E.as("milliseconds") === 0)
            return [];
        let {s: M} = this, T = 1, $;
        const B = [];
        for (; M < this.e; ) {
            const O = this.start.plus(E.mapUnits(F=>F * T));
            $ = +O > +this.e ? this.e : O,
            B.push(Interval.fromDateTimes(M, $)),
            M = $,
            T += 1
        }
        return B
    }
    divideEqually(S) {
        return this.isValid ? this.splitBy(this.length() / S).slice(0, S) : []
    }
    overlaps(S) {
        return this.e > S.s && this.s < S.e
    }
    abutsStart(S) {
        return this.isValid ? +this.e == +S.s : !1
    }
    abutsEnd(S) {
        return this.isValid ? +S.e == +this.s : !1
    }
    engulfs(S) {
        return this.isValid ? this.s <= S.s && this.e >= S.e : !1
    }
    equals(S) {
        return !this.isValid || !S.isValid ? !1 : this.s.equals(S.s) && this.e.equals(S.e)
    }
    intersection(S) {
        if (!this.isValid)
            return this;
        const E = this.s > S.s ? this.s : S.s
          , M = this.e < S.e ? this.e : S.e;
        return E >= M ? null : Interval.fromDateTimes(E, M)
    }
    union(S) {
        if (!this.isValid)
            return this;
        const E = this.s < S.s ? this.s : S.s
          , M = this.e > S.e ? this.e : S.e;
        return Interval.fromDateTimes(E, M)
    }
    static merge(S) {
        const [E,M] = S.sort((T,$)=>T.s - $.s).reduce(([T,$],B)=>$ ? $.overlaps(B) || $.abutsStart(B) ? [T, $.union(B)] : [T.concat([$]), B] : [T, B], [[], null]);
        return M && E.push(M),
        E
    }
    static xor(S) {
        let E = null
          , M = 0;
        const T = []
          , $ = S.map(F=>[{
            time: F.s,
            type: "s"
        }, {
            time: F.e,
            type: "e"
        }])
          , B = Array.prototype.concat(...$)
          , O = B.sort((F,N)=>F.time - N.time);
        for (const F of O)
            M += F.type === "s" ? 1 : -1,
            M === 1 ? E = F.time : (E && +E != +F.time && T.push(Interval.fromDateTimes(E, F.time)),
            E = null);
        return Interval.merge(T)
    }
    difference(...S) {
        return Interval.xor([this].concat(S)).map(E=>this.intersection(E)).filter(E=>E && !E.isEmpty())
    }
    toString() {
        return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : INVALID$1
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`
    }
    toLocaleString(S=DATE_SHORT, E={}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(E), S).formatInterval(this) : INVALID$1
    }
    toISO(S) {
        return this.isValid ? `${this.s.toISO(S)}/${this.e.toISO(S)}` : INVALID$1
    }
    toISODate() {
        return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : INVALID$1
    }
    toISOTime(S) {
        return this.isValid ? `${this.s.toISOTime(S)}/${this.e.toISOTime(S)}` : INVALID$1
    }
    toFormat(S, {separator: E="  "}={}) {
        return this.isValid ? `${this.s.toFormat(S)}${E}${this.e.toFormat(S)}` : INVALID$1
    }
    toDuration(S, E) {
        return this.isValid ? this.e.diff(this.s, S, E) : Duration.invalid(this.invalidReason)
    }
    mapEndpoints(S) {
        return Interval.fromDateTimes(S(this.s), S(this.e))
    }
}
class Info {
    static hasDST(S=Settings.defaultZone) {
        const E = DateTime.now().setZone(S).set({
            month: 12
        });
        return !S.isUniversal && E.offset !== E.set({
            month: 6
        }).offset
    }
    static isValidIANAZone(S) {
        return IANAZone.isValidZone(S)
    }
    static normalizeZone(S) {
        return normalizeZone(S, Settings.defaultZone)
    }
    static getStartOfWeek({locale: S=null, locObj: E=null}={}) {
        return (E || Locale.create(S)).getStartOfWeek()
    }
    static getMinimumDaysInFirstWeek({locale: S=null, locObj: E=null}={}) {
        return (E || Locale.create(S)).getMinDaysInFirstWeek()
    }
    static getWeekendWeekdays({locale: S=null, locObj: E=null}={}) {
        return (E || Locale.create(S)).getWeekendDays().slice()
    }
    static months(S="long", {locale: E=null, numberingSystem: M=null, locObj: T=null, outputCalendar: $="gregory"}={}) {
        return (T || Locale.create(E, M, $)).months(S)
    }
    static monthsFormat(S="long", {locale: E=null, numberingSystem: M=null, locObj: T=null, outputCalendar: $="gregory"}={}) {
        return (T || Locale.create(E, M, $)).months(S, !0)
    }
    static weekdays(S="long", {locale: E=null, numberingSystem: M=null, locObj: T=null}={}) {
        return (T || Locale.create(E, M, null)).weekdays(S)
    }
    static weekdaysFormat(S="long", {locale: E=null, numberingSystem: M=null, locObj: T=null}={}) {
        return (T || Locale.create(E, M, null)).weekdays(S, !0)
    }
    static meridiems({locale: S=null}={}) {
        return Locale.create(S).meridiems()
    }
    static eras(S="short", {locale: E=null}={}) {
        return Locale.create(E, null, "gregory").eras(S)
    }
    static features() {
        return {
            relative: hasRelative(),
            localeWeek: hasLocaleWeekInfo()
        }
    }
}
function dayDiff(C, S) {
    const E = T=>T.toUTC(0, {
        keepLocalTime: !0
    }).startOf("day").valueOf()
      , M = E(S) - E(C);
    return Math.floor(Duration.fromMillis(M).as("days"))
}
function highOrderDiffs(C, S, E) {
    const M = [["years", (F,N)=>N.year - F.year], ["quarters", (F,N)=>N.quarter - F.quarter + (N.year - F.year) * 4], ["months", (F,N)=>N.month - F.month + (N.year - F.year) * 12], ["weeks", (F,N)=>{
        const U = dayDiff(F, N);
        return (U - U % 7) / 7
    }
    ], ["days", dayDiff]]
      , T = {}
      , $ = C;
    let B, O;
    for (const [F,N] of M)
        E.indexOf(F) >= 0 && (B = F,
        T[F] = N(C, S),
        O = $.plus(T),
        O > S ? (T[F]--,
        C = $.plus(T),
        C > S && (O = C,
        T[F]--,
        C = $.plus(T))) : C = O);
    return [C, T, O, B]
}
function diff(C, S, E, M) {
    let[T,$,B,O] = highOrderDiffs(C, S, E);
    const F = S - T
      , N = E.filter(H=>["hours", "minutes", "seconds", "milliseconds"].indexOf(H) >= 0);
    N.length === 0 && (B < S && (B = T.plus({
        [O]: 1
    })),
    B !== T && ($[O] = ($[O] || 0) + F / (B - T)));
    const U = Duration.fromObject($, M);
    return N.length > 0 ? Duration.fromMillis(F, M).shiftTo(...N).plus(U) : U
}
const numberingSystems = {
    arab: "[-]",
    arabext: "[-]",
    bali: "[-]",
    beng: "[-]",
    deva: "[-]",
    fullwide: "[-]",
    gujr: "[-]",
    hanidec: "[|||||||||]",
    khmr: "[-]",
    knda: "[-]",
    laoo: "[-]",
    limb: "[-]",
    mlym: "[-]",
    mong: "[-]",
    mymr: "[-]",
    orya: "[-]",
    tamldec: "[-]",
    telu: "[-]",
    thai: "[-]",
    tibt: "[-]",
    latn: "\\d"
}
  , numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
}
  , hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(C) {
    let S = parseInt(C, 10);
    if (isNaN(S)) {
        S = "";
        for (let E = 0; E < C.length; E++) {
            const M = C.charCodeAt(E);
            if (C[E].search(numberingSystems.hanidec) !== -1)
                S += hanidecChars.indexOf(C[E]);
            else
                for (const T in numberingSystemsUTF16) {
                    const [$,B] = numberingSystemsUTF16[T];
                    M >= $ && M <= B && (S += M - $)
                }
        }
        return parseInt(S, 10)
    } else
        return S
}
function digitRegex({numberingSystem: C}, S="") {
    return new RegExp(`${numberingSystems[C || "latn"]}${S}`)
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(C, S=E=>E) {
    return {
        regex: C,
        deser: ([E])=>S(parseDigits(E))
    }
}
const NBSP = ""
  , spaceOrNBSP = `[ ${NBSP}]`
  , spaceOrNBSPRegExp = new RegExp(spaceOrNBSP,"g");
function fixListRegex(C) {
    return C.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP)
}
function stripInsensitivities(C) {
    return C.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase()
}
function oneOf(C, S) {
    return C === null ? null : {
        regex: RegExp(C.map(fixListRegex).join("|")),
        deser: ([E])=>C.findIndex(M=>stripInsensitivities(E) === stripInsensitivities(M)) + S
    }
}
function offset(C, S) {
    return {
        regex: C,
        deser: ([,E,M])=>signedOffset(E, M),
        groups: S
    }
}
function simple(C) {
    return {
        regex: C,
        deser: ([S])=>S
    }
}
function escapeToken(C) {
    return C.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
}
function unitForToken(C, S) {
    const E = digitRegex(S)
      , M = digitRegex(S, "{2}")
      , T = digitRegex(S, "{3}")
      , $ = digitRegex(S, "{4}")
      , B = digitRegex(S, "{6}")
      , O = digitRegex(S, "{1,2}")
      , F = digitRegex(S, "{1,3}")
      , N = digitRegex(S, "{1,6}")
      , U = digitRegex(S, "{1,9}")
      , H = digitRegex(S, "{2,4}")
      , Z = digitRegex(S, "{4,6}")
      , J = ae=>({
        regex: RegExp(escapeToken(ae.val)),
        deser: ([se])=>se,
        literal: !0
    })
      , oe = (ae=>{
        if (C.literal)
            return J(ae);
        switch (ae.val) {
        case "G":
            return oneOf(S.eras("short"), 0);
        case "GG":
            return oneOf(S.eras("long"), 0);
        case "y":
            return intUnit(N);
        case "yy":
            return intUnit(H, untruncateYear);
        case "yyyy":
            return intUnit($);
        case "yyyyy":
            return intUnit(Z);
        case "yyyyyy":
            return intUnit(B);
        case "M":
            return intUnit(O);
        case "MM":
            return intUnit(M);
        case "MMM":
            return oneOf(S.months("short", !0), 1);
        case "MMMM":
            return oneOf(S.months("long", !0), 1);
        case "L":
            return intUnit(O);
        case "LL":
            return intUnit(M);
        case "LLL":
            return oneOf(S.months("short", !1), 1);
        case "LLLL":
            return oneOf(S.months("long", !1), 1);
        case "d":
            return intUnit(O);
        case "dd":
            return intUnit(M);
        case "o":
            return intUnit(F);
        case "ooo":
            return intUnit(T);
        case "HH":
            return intUnit(M);
        case "H":
            return intUnit(O);
        case "hh":
            return intUnit(M);
        case "h":
            return intUnit(O);
        case "mm":
            return intUnit(M);
        case "m":
            return intUnit(O);
        case "q":
            return intUnit(O);
        case "qq":
            return intUnit(M);
        case "s":
            return intUnit(O);
        case "ss":
            return intUnit(M);
        case "S":
            return intUnit(F);
        case "SSS":
            return intUnit(T);
        case "u":
            return simple(U);
        case "uu":
            return simple(O);
        case "uuu":
            return intUnit(E);
        case "a":
            return oneOf(S.meridiems(), 0);
        case "kkkk":
            return intUnit($);
        case "kk":
            return intUnit(H, untruncateYear);
        case "W":
            return intUnit(O);
        case "WW":
            return intUnit(M);
        case "E":
        case "c":
            return intUnit(E);
        case "EEE":
            return oneOf(S.weekdays("short", !1), 1);
        case "EEEE":
            return oneOf(S.weekdays("long", !1), 1);
        case "ccc":
            return oneOf(S.weekdays("short", !0), 1);
        case "cccc":
            return oneOf(S.weekdays("long", !0), 1);
        case "Z":
        case "ZZ":
            return offset(new RegExp(`([+-]${O.source})(?::(${M.source}))?`), 2);
        case "ZZZ":
            return offset(new RegExp(`([+-]${O.source})(${M.source})?`), 2);
        case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
            return simple(/[^\S\n\r]/);
        default:
            return J(ae)
        }
    }
    )(C) || {
        invalidReason: MISSING_FTP
    };
    return oe.token = C,
    oe
}
const partTypeStyleToTokenVal = {
    year: {
        "2-digit": "yy",
        numeric: "yyyyy"
    },
    month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
    },
    day: {
        numeric: "d",
        "2-digit": "dd"
    },
    weekday: {
        short: "EEE",
        long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
        numeric: "h",
        "2-digit": "hh"
    },
    hour24: {
        numeric: "H",
        "2-digit": "HH"
    },
    minute: {
        numeric: "m",
        "2-digit": "mm"
    },
    second: {
        numeric: "s",
        "2-digit": "ss"
    },
    timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
    }
};
function tokenForPart(C, S, E) {
    const {type: M, value: T} = C;
    if (M === "literal") {
        const F = /^\s+$/.test(T);
        return {
            literal: !F,
            val: F ? " " : T
        }
    }
    const $ = S[M];
    let B = M;
    M === "hour" && (S.hour12 != null ? B = S.hour12 ? "hour12" : "hour24" : S.hourCycle != null ? S.hourCycle === "h11" || S.hourCycle === "h12" ? B = "hour12" : B = "hour24" : B = E.hour12 ? "hour12" : "hour24");
    let O = partTypeStyleToTokenVal[B];
    if (typeof O == "object" && (O = O[$]),
    O)
        return {
            literal: !1,
            val: O
        }
}
function buildRegex(C) {
    return [`^${C.map(E=>E.regex).reduce((E,M)=>`${E}(${M.source})`, "")}$`, C]
}
function match(C, S, E) {
    const M = C.match(S);
    if (M) {
        const T = {};
        let $ = 1;
        for (const B in E)
            if (hasOwnProperty(E, B)) {
                const O = E[B]
                  , F = O.groups ? O.groups + 1 : 1;
                !O.literal && O.token && (T[O.token.val[0]] = O.deser(M.slice($, $ + F))),
                $ += F
            }
        return [M, T]
    } else
        return [M, {}]
}
function dateTimeFromMatches(C) {
    const S = $=>{
        switch ($) {
        case "S":
            return "millisecond";
        case "s":
            return "second";
        case "m":
            return "minute";
        case "h":
        case "H":
            return "hour";
        case "d":
            return "day";
        case "o":
            return "ordinal";
        case "L":
        case "M":
            return "month";
        case "y":
            return "year";
        case "E":
        case "c":
            return "weekday";
        case "W":
            return "weekNumber";
        case "k":
            return "weekYear";
        case "q":
            return "quarter";
        default:
            return null
        }
    }
    ;
    let E = null, M;
    return isUndefined(C.z) || (E = IANAZone.create(C.z)),
    isUndefined(C.Z) || (E || (E = new FixedOffsetZone(C.Z)),
    M = C.Z),
    isUndefined(C.q) || (C.M = (C.q - 1) * 3 + 1),
    isUndefined(C.h) || (C.h < 12 && C.a === 1 ? C.h += 12 : C.h === 12 && C.a === 0 && (C.h = 0)),
    C.G === 0 && C.y && (C.y = -C.y),
    isUndefined(C.u) || (C.S = parseMillis(C.u)),
    [Object.keys(C).reduce(($,B)=>{
        const O = S(B);
        return O && ($[O] = C[B]),
        $
    }
    , {}), E, M]
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
    return dummyDateTimeCache || (dummyDateTimeCache = DateTime.fromMillis(1555555555555)),
    dummyDateTimeCache
}
function maybeExpandMacroToken(C, S) {
    if (C.literal)
        return C;
    const E = Formatter.macroTokenToFormatOpts(C.val)
      , M = formatOptsToTokens(E, S);
    return M == null || M.includes(void 0) ? C : M
}
function expandMacroTokens(C, S) {
    return Array.prototype.concat(...C.map(E=>maybeExpandMacroToken(E, S)))
}
function explainFromTokens(C, S, E) {
    const M = expandMacroTokens(Formatter.parseFormat(E), C)
      , T = M.map(B=>unitForToken(B, C))
      , $ = T.find(B=>B.invalidReason);
    if ($)
        return {
            input: S,
            tokens: M,
            invalidReason: $.invalidReason
        };
    {
        const [B,O] = buildRegex(T)
          , F = RegExp(B, "i")
          , [N,U] = match(S, F, O)
          , [H,Z,J] = U ? dateTimeFromMatches(U) : [null, null, void 0];
        if (hasOwnProperty(U, "a") && hasOwnProperty(U, "H"))
            throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        return {
            input: S,
            tokens: M,
            regex: F,
            rawMatches: N,
            matches: U,
            result: H,
            zone: Z,
            specificOffset: J
        }
    }
}
function parseFromTokens(C, S, E) {
    const {result: M, zone: T, specificOffset: $, invalidReason: B} = explainFromTokens(C, S, E);
    return [M, T, $, B]
}
function formatOptsToTokens(C, S) {
    if (!C)
        return null;
    const M = Formatter.create(S, C).dtFormatter(getDummyDateTime())
      , T = M.formatToParts()
      , $ = M.resolvedOptions();
    return T.map(B=>tokenForPart(B, C, $))
}
const INVALID = "Invalid DateTime"
  , MAX_DATE = 864e13;
function unsupportedZone(C) {
    return new Invalid("unsupported zone",`the zone "${C.name}" is not supported`)
}
function possiblyCachedWeekData(C) {
    return C.weekData === null && (C.weekData = gregorianToWeek(C.c)),
    C.weekData
}
function possiblyCachedLocalWeekData(C) {
    return C.localWeekData === null && (C.localWeekData = gregorianToWeek(C.c, C.loc.getMinDaysInFirstWeek(), C.loc.getStartOfWeek())),
    C.localWeekData
}
function clone(C, S) {
    const E = {
        ts: C.ts,
        zone: C.zone,
        c: C.c,
        o: C.o,
        loc: C.loc,
        invalid: C.invalid
    };
    return new DateTime({
        ...E,
        ...S,
        old: E
    })
}
function fixOffset(C, S, E) {
    let M = C - S * 60 * 1e3;
    const T = E.offset(M);
    if (S === T)
        return [M, S];
    M -= (T - S) * 60 * 1e3;
    const $ = E.offset(M);
    return T === $ ? [M, T] : [C - Math.min(T, $) * 60 * 1e3, Math.max(T, $)]
}
function tsToObj(C, S) {
    C += S * 60 * 1e3;
    const E = new Date(C);
    return {
        year: E.getUTCFullYear(),
        month: E.getUTCMonth() + 1,
        day: E.getUTCDate(),
        hour: E.getUTCHours(),
        minute: E.getUTCMinutes(),
        second: E.getUTCSeconds(),
        millisecond: E.getUTCMilliseconds()
    }
}
function objToTS(C, S, E) {
    return fixOffset(objToLocalTS(C), S, E)
}
function adjustTime(C, S) {
    const E = C.o
      , M = C.c.year + Math.trunc(S.years)
      , T = C.c.month + Math.trunc(S.months) + Math.trunc(S.quarters) * 3
      , $ = {
        ...C.c,
        year: M,
        month: T,
        day: Math.min(C.c.day, daysInMonth(M, T)) + Math.trunc(S.days) + Math.trunc(S.weeks) * 7
    }
      , B = Duration.fromObject({
        years: S.years - Math.trunc(S.years),
        quarters: S.quarters - Math.trunc(S.quarters),
        months: S.months - Math.trunc(S.months),
        weeks: S.weeks - Math.trunc(S.weeks),
        days: S.days - Math.trunc(S.days),
        hours: S.hours,
        minutes: S.minutes,
        seconds: S.seconds,
        milliseconds: S.milliseconds
    }).as("milliseconds")
      , O = objToLocalTS($);
    let[F,N] = fixOffset(O, E, C.zone);
    return B !== 0 && (F += B,
    N = C.zone.offset(F)),
    {
        ts: F,
        o: N
    }
}
function parseDataToDateTime(C, S, E, M, T, $) {
    const {setZone: B, zone: O} = E;
    if (C && Object.keys(C).length !== 0 || S) {
        const F = S || O
          , N = DateTime.fromObject(C, {
            ...E,
            zone: F,
            specificOffset: $
        });
        return B ? N : N.setZone(O)
    } else
        return DateTime.invalid(new Invalid("unparsable",`the input "${T}" can't be parsed as ${M}`))
}
function toTechFormat(C, S, E=!0) {
    return C.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ: E,
        forceSimple: !0
    }).formatDateTimeFromString(C, S) : null
}
function toISODate(C, S) {
    const E = C.c.year > 9999 || C.c.year < 0;
    let M = "";
    return E && C.c.year >= 0 && (M += "+"),
    M += padStart(C.c.year, E ? 6 : 4),
    S ? (M += "-",
    M += padStart(C.c.month),
    M += "-",
    M += padStart(C.c.day)) : (M += padStart(C.c.month),
    M += padStart(C.c.day)),
    M
}
function toISOTime(C, S, E, M, T, $) {
    let B = padStart(C.c.hour);
    return S ? (B += ":",
    B += padStart(C.c.minute),
    (C.c.millisecond !== 0 || C.c.second !== 0 || !E) && (B += ":")) : B += padStart(C.c.minute),
    (C.c.millisecond !== 0 || C.c.second !== 0 || !E) && (B += padStart(C.c.second),
    (C.c.millisecond !== 0 || !M) && (B += ".",
    B += padStart(C.c.millisecond, 3))),
    T && (C.isOffsetFixed && C.offset === 0 && !$ ? B += "Z" : C.o < 0 ? (B += "-",
    B += padStart(Math.trunc(-C.o / 60)),
    B += ":",
    B += padStart(Math.trunc(-C.o % 60))) : (B += "+",
    B += padStart(Math.trunc(C.o / 60)),
    B += ":",
    B += padStart(Math.trunc(C.o % 60)))),
    $ && (B += "[" + C.zone.ianaName + "]"),
    B
}
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"]
  , orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"]
  , orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(C) {
    const S = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
    }[C.toLowerCase()];
    if (!S)
        throw new InvalidUnitError(C);
    return S
}
function normalizeUnitWithLocalWeeks(C) {
    switch (C.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
        return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
        return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
        return "localWeekYear";
    default:
        return normalizeUnit(C)
    }
}
function quickDT(C, S) {
    const E = normalizeZone(S.zone, Settings.defaultZone)
      , M = Locale.fromObject(S)
      , T = Settings.now();
    let $, B;
    if (isUndefined(C.year))
        $ = T;
    else {
        for (const N of orderedUnits)
            isUndefined(C[N]) && (C[N] = defaultUnitValues[N]);
        const O = hasInvalidGregorianData(C) || hasInvalidTimeData(C);
        if (O)
            return DateTime.invalid(O);
        const F = E.offset(T);
        [$,B] = objToTS(C, F, E)
    }
    return new DateTime({
        ts: $,
        zone: E,
        loc: M,
        o: B
    })
}
function diffRelative(C, S, E) {
    const M = isUndefined(E.round) ? !0 : E.round
      , T = (B,O)=>(B = roundTo(B, M || E.calendary ? 0 : 2, !0),
    S.loc.clone(E).relFormatter(E).format(B, O))
      , $ = B=>E.calendary ? S.hasSame(C, B) ? 0 : S.startOf(B).diff(C.startOf(B), B).get(B) : S.diff(C, B).get(B);
    if (E.unit)
        return T($(E.unit), E.unit);
    for (const B of E.units) {
        const O = $(B);
        if (Math.abs(O) >= 1)
            return T(O, B)
    }
    return T(C > S ? -0 : 0, E.units[E.units.length - 1])
}
function lastOpts(C) {
    let S = {}, E;
    return C.length > 0 && typeof C[C.length - 1] == "object" ? (S = C[C.length - 1],
    E = Array.from(C).slice(0, C.length - 1)) : E = Array.from(C),
    [S, E]
}
class DateTime {
    constructor(S) {
        const E = S.zone || Settings.defaultZone;
        let M = S.invalid || (Number.isNaN(S.ts) ? new Invalid("invalid input") : null) || (E.isValid ? null : unsupportedZone(E));
        this.ts = isUndefined(S.ts) ? Settings.now() : S.ts;
        let T = null
          , $ = null;
        if (!M)
            if (S.old && S.old.ts === this.ts && S.old.zone.equals(E))
                [T,$] = [S.old.c, S.old.o];
            else {
                const O = E.offset(this.ts);
                T = tsToObj(this.ts, O),
                M = Number.isNaN(T.year) ? new Invalid("invalid input") : null,
                T = M ? null : T,
                $ = M ? null : O
            }
        this._zone = E,
        this.loc = S.loc || Locale.create(),
        this.invalid = M,
        this.weekData = null,
        this.localWeekData = null,
        this.c = T,
        this.o = $,
        this.isLuxonDateTime = !0
    }
    static now() {
        return new DateTime({})
    }
    static local() {
        const [S,E] = lastOpts(arguments)
          , [M,T,$,B,O,F,N] = E;
        return quickDT({
            year: M,
            month: T,
            day: $,
            hour: B,
            minute: O,
            second: F,
            millisecond: N
        }, S)
    }
    static utc() {
        const [S,E] = lastOpts(arguments)
          , [M,T,$,B,O,F,N] = E;
        return S.zone = FixedOffsetZone.utcInstance,
        quickDT({
            year: M,
            month: T,
            day: $,
            hour: B,
            minute: O,
            second: F,
            millisecond: N
        }, S)
    }
    static fromJSDate(S, E={}) {
        const M = isDate(S) ? S.valueOf() : NaN;
        if (Number.isNaN(M))
            return DateTime.invalid("invalid input");
        const T = normalizeZone(E.zone, Settings.defaultZone);
        return T.isValid ? new DateTime({
            ts: M,
            zone: T,
            loc: Locale.fromObject(E)
        }) : DateTime.invalid(unsupportedZone(T))
    }
    static fromMillis(S, E={}) {
        if (isNumber(S))
            return S < -MAX_DATE || S > MAX_DATE ? DateTime.invalid("Timestamp out of range") : new DateTime({
                ts: S,
                zone: normalizeZone(E.zone, Settings.defaultZone),
                loc: Locale.fromObject(E)
            });
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof S} with value ${S}`)
    }
    static fromSeconds(S, E={}) {
        if (isNumber(S))
            return new DateTime({
                ts: S * 1e3,
                zone: normalizeZone(E.zone, Settings.defaultZone),
                loc: Locale.fromObject(E)
            });
        throw new InvalidArgumentError("fromSeconds requires a numerical input")
    }
    static fromObject(S, E={}) {
        S = S || {};
        const M = normalizeZone(E.zone, Settings.defaultZone);
        if (!M.isValid)
            return DateTime.invalid(unsupportedZone(M));
        const T = Locale.fromObject(E)
          , $ = normalizeObject(S, normalizeUnitWithLocalWeeks)
          , {minDaysInFirstWeek: B, startOfWeek: O} = usesLocalWeekValues($, T)
          , F = Settings.now()
          , N = isUndefined(E.specificOffset) ? M.offset(F) : E.specificOffset
          , U = !isUndefined($.ordinal)
          , H = !isUndefined($.year)
          , Z = !isUndefined($.month) || !isUndefined($.day)
          , J = H || Z
          , ie = $.weekYear || $.weekNumber;
        if ((J || U) && ie)
            throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (Z && U)
            throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        const oe = ie || $.weekday && !J;
        let ae, se, le = tsToObj(F, N);
        oe ? (ae = orderedWeekUnits,
        se = defaultWeekUnitValues,
        le = gregorianToWeek(le, B, O)) : U ? (ae = orderedOrdinalUnits,
        se = defaultOrdinalUnitValues,
        le = gregorianToOrdinal(le)) : (ae = orderedUnits,
        se = defaultUnitValues);
        let de = !1;
        for (const ue of ae) {
            const V = $[ue];
            isUndefined(V) ? de ? $[ue] = se[ue] : $[ue] = le[ue] : de = !0
        }
        const fe = oe ? hasInvalidWeekData($, B, O) : U ? hasInvalidOrdinalData($) : hasInvalidGregorianData($)
          , pe = fe || hasInvalidTimeData($);
        if (pe)
            return DateTime.invalid(pe);
        const ge = oe ? weekToGregorian($, B, O) : U ? ordinalToGregorian($) : $
          , [we,Ae] = objToTS(ge, N, M)
          , Se = new DateTime({
            ts: we,
            zone: M,
            o: Ae,
            loc: T
        });
        return $.weekday && J && S.weekday !== Se.weekday ? DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${$.weekday} and a date of ${Se.toISO()}`) : Se
    }
    static fromISO(S, E={}) {
        const [M,T] = parseISODate(S);
        return parseDataToDateTime(M, T, E, "ISO 8601", S)
    }
    static fromRFC2822(S, E={}) {
        const [M,T] = parseRFC2822Date(S);
        return parseDataToDateTime(M, T, E, "RFC 2822", S)
    }
    static fromHTTP(S, E={}) {
        const [M,T] = parseHTTPDate(S);
        return parseDataToDateTime(M, T, E, "HTTP", E)
    }
    static fromFormat(S, E, M={}) {
        if (isUndefined(S) || isUndefined(E))
            throw new InvalidArgumentError("fromFormat requires an input string and a format");
        const {locale: T=null, numberingSystem: $=null} = M
          , B = Locale.fromOpts({
            locale: T,
            numberingSystem: $,
            defaultToEN: !0
        })
          , [O,F,N,U] = parseFromTokens(B, S, E);
        return U ? DateTime.invalid(U) : parseDataToDateTime(O, F, M, `format ${E}`, S, N)
    }
    static fromString(S, E, M={}) {
        return DateTime.fromFormat(S, E, M)
    }
    static fromSQL(S, E={}) {
        const [M,T] = parseSQL(S);
        return parseDataToDateTime(M, T, E, "SQL", S)
    }
    static invalid(S, E=null) {
        if (!S)
            throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        const M = S instanceof Invalid ? S : new Invalid(S,E);
        if (Settings.throwOnInvalid)
            throw new InvalidDateTimeError(M);
        return new DateTime({
            invalid: M
        })
    }
    static isDateTime(S) {
        return S && S.isLuxonDateTime || !1
    }
    static parseFormatForOpts(S, E={}) {
        const M = formatOptsToTokens(S, Locale.fromObject(E));
        return M ? M.map(T=>T ? T.val : null).join("") : null
    }
    static expandFormat(S, E={}) {
        return expandMacroTokens(Formatter.parseFormat(S), Locale.fromObject(E)).map(T=>T.val).join("")
    }
    get(S) {
        return this[S]
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null
    }
    get zone() {
        return this._zone
    }
    get zoneName() {
        return this.isValid ? this.zone.name : null
    }
    get year() {
        return this.isValid ? this.c.year : NaN
    }
    get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN
    }
    get month() {
        return this.isValid ? this.c.month : NaN
    }
    get day() {
        return this.isValid ? this.c.day : NaN
    }
    get hour() {
        return this.isValid ? this.c.hour : NaN
    }
    get minute() {
        return this.isValid ? this.c.minute : NaN
    }
    get second() {
        return this.isValid ? this.c.second : NaN
    }
    get millisecond() {
        return this.isValid ? this.c.millisecond : NaN
    }
    get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN
    }
    get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN
    }
    get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN
    }
    get isWeekend() {
        return this.isValid && this.loc.getWeekendDays().includes(this.weekday)
    }
    get localWeekday() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN
    }
    get localWeekNumber() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN
    }
    get localWeekYear() {
        return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN
    }
    get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN
    }
    get monthShort() {
        return this.isValid ? Info.months("short", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get monthLong() {
        return this.isValid ? Info.months("long", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get weekdayShort() {
        return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get weekdayLong() {
        return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get offset() {
        return this.isValid ? +this.o : NaN
    }
    get offsetNameShort() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
        }) : null
    }
    get offsetNameLong() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
        }) : null
    }
    get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null
    }
    get isInDST() {
        return this.isOffsetFixed ? !1 : this.offset > this.set({
            month: 1,
            day: 1
        }).offset || this.offset > this.set({
            month: 5
        }).offset
    }
    getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed)
            return [this];
        const S = 864e5
          , E = 6e4
          , M = objToLocalTS(this.c)
          , T = this.zone.offset(M - S)
          , $ = this.zone.offset(M + S)
          , B = this.zone.offset(M - T * E)
          , O = this.zone.offset(M - $ * E);
        if (B === O)
            return [this];
        const F = M - B * E
          , N = M - O * E
          , U = tsToObj(F, B)
          , H = tsToObj(N, O);
        return U.hour === H.hour && U.minute === H.minute && U.second === H.second && U.millisecond === H.millisecond ? [clone(this, {
            ts: F
        }), clone(this, {
            ts: N
        })] : [this]
    }
    get isInLeapYear() {
        return isLeapYear(this.year)
    }
    get daysInMonth() {
        return daysInMonth(this.year, this.month)
    }
    get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN
    }
    get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN
    }
    get weeksInLocalWeekYear() {
        return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN
    }
    resolvedLocaleOptions(S={}) {
        const {locale: E, numberingSystem: M, calendar: T} = Formatter.create(this.loc.clone(S), S).resolvedOptions(this);
        return {
            locale: E,
            numberingSystem: M,
            outputCalendar: T
        }
    }
    toUTC(S=0, E={}) {
        return this.setZone(FixedOffsetZone.instance(S), E)
    }
    toLocal() {
        return this.setZone(Settings.defaultZone)
    }
    setZone(S, {keepLocalTime: E=!1, keepCalendarTime: M=!1}={}) {
        if (S = normalizeZone(S, Settings.defaultZone),
        S.equals(this.zone))
            return this;
        if (S.isValid) {
            let T = this.ts;
            if (E || M) {
                const $ = S.offset(this.ts)
                  , B = this.toObject();
                [T] = objToTS(B, $, S)
            }
            return clone(this, {
                ts: T,
                zone: S
            })
        } else
            return DateTime.invalid(unsupportedZone(S))
    }
    reconfigure({locale: S, numberingSystem: E, outputCalendar: M}={}) {
        const T = this.loc.clone({
            locale: S,
            numberingSystem: E,
            outputCalendar: M
        });
        return clone(this, {
            loc: T
        })
    }
    setLocale(S) {
        return this.reconfigure({
            locale: S
        })
    }
    set(S) {
        if (!this.isValid)
            return this;
        const E = normalizeObject(S, normalizeUnitWithLocalWeeks)
          , {minDaysInFirstWeek: M, startOfWeek: T} = usesLocalWeekValues(E, this.loc)
          , $ = !isUndefined(E.weekYear) || !isUndefined(E.weekNumber) || !isUndefined(E.weekday)
          , B = !isUndefined(E.ordinal)
          , O = !isUndefined(E.year)
          , F = !isUndefined(E.month) || !isUndefined(E.day)
          , N = O || F
          , U = E.weekYear || E.weekNumber;
        if ((N || B) && U)
            throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (F && B)
            throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        let H;
        $ ? H = weekToGregorian({
            ...gregorianToWeek(this.c, M, T),
            ...E
        }, M, T) : isUndefined(E.ordinal) ? (H = {
            ...this.toObject(),
            ...E
        },
        isUndefined(E.day) && (H.day = Math.min(daysInMonth(H.year, H.month), H.day))) : H = ordinalToGregorian({
            ...gregorianToOrdinal(this.c),
            ...E
        });
        const [Z,J] = objToTS(H, this.o, this.zone);
        return clone(this, {
            ts: Z,
            o: J
        })
    }
    plus(S) {
        if (!this.isValid)
            return this;
        const E = Duration.fromDurationLike(S);
        return clone(this, adjustTime(this, E))
    }
    minus(S) {
        if (!this.isValid)
            return this;
        const E = Duration.fromDurationLike(S).negate();
        return clone(this, adjustTime(this, E))
    }
    startOf(S, {useLocaleWeeks: E=!1}={}) {
        if (!this.isValid)
            return this;
        const M = {}
          , T = Duration.normalizeUnit(S);
        switch (T) {
        case "years":
            M.month = 1;
        case "quarters":
        case "months":
            M.day = 1;
        case "weeks":
        case "days":
            M.hour = 0;
        case "hours":
            M.minute = 0;
        case "minutes":
            M.second = 0;
        case "seconds":
            M.millisecond = 0;
            break
        }
        if (T === "weeks")
            if (E) {
                const $ = this.loc.getStartOfWeek()
                  , {weekday: B} = this;
                B < $ && (M.weekNumber = this.weekNumber - 1),
                M.weekday = $
            } else
                M.weekday = 1;
        if (T === "quarters") {
            const $ = Math.ceil(this.month / 3);
            M.month = ($ - 1) * 3 + 1
        }
        return this.set(M)
    }
    endOf(S, E) {
        return this.isValid ? this.plus({
            [S]: 1
        }).startOf(S, E).minus(1) : this
    }
    toFormat(S, E={}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(E)).formatDateTimeFromString(this, S) : INVALID
    }
    toLocaleString(S=DATE_SHORT, E={}) {
        return this.isValid ? Formatter.create(this.loc.clone(E), S).formatDateTime(this) : INVALID
    }
    toLocaleParts(S={}) {
        return this.isValid ? Formatter.create(this.loc.clone(S), S).formatDateTimeParts(this) : []
    }
    toISO({format: S="extended", suppressSeconds: E=!1, suppressMilliseconds: M=!1, includeOffset: T=!0, extendedZone: $=!1}={}) {
        if (!this.isValid)
            return null;
        const B = S === "extended";
        let O = toISODate(this, B);
        return O += "T",
        O += toISOTime(this, B, E, M, T, $),
        O
    }
    toISODate({format: S="extended"}={}) {
        return this.isValid ? toISODate(this, S === "extended") : null
    }
    toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c")
    }
    toISOTime({suppressMilliseconds: S=!1, suppressSeconds: E=!1, includeOffset: M=!0, includePrefix: T=!1, extendedZone: $=!1, format: B="extended"}={}) {
        return this.isValid ? (T ? "T" : "") + toISOTime(this, B === "extended", E, S, M, $) : null
    }
    toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1)
    }
    toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'")
    }
    toSQLDate() {
        return this.isValid ? toISODate(this, !0) : null
    }
    toSQLTime({includeOffset: S=!0, includeZone: E=!1, includeOffsetSpace: M=!0}={}) {
        let T = "HH:mm:ss.SSS";
        return (E || S) && (M && (T += " "),
        E ? T += "z" : S && (T += "ZZ")),
        toTechFormat(this, T, !0)
    }
    toSQL(S={}) {
        return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(S)}` : null
    }
    toString() {
        return this.isValid ? this.toISO() : INVALID
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`
    }
    valueOf() {
        return this.toMillis()
    }
    toMillis() {
        return this.isValid ? this.ts : NaN
    }
    toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN
    }
    toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN
    }
    toJSON() {
        return this.toISO()
    }
    toBSON() {
        return this.toJSDate()
    }
    toObject(S={}) {
        if (!this.isValid)
            return {};
        const E = {
            ...this.c
        };
        return S.includeConfig && (E.outputCalendar = this.outputCalendar,
        E.numberingSystem = this.loc.numberingSystem,
        E.locale = this.loc.locale),
        E
    }
    toJSDate() {
        return new Date(this.isValid ? this.ts : NaN)
    }
    diff(S, E="milliseconds", M={}) {
        if (!this.isValid || !S.isValid)
            return Duration.invalid("created by diffing an invalid DateTime");
        const T = {
            locale: this.locale,
            numberingSystem: this.numberingSystem,
            ...M
        }
          , $ = maybeArray(E).map(Duration.normalizeUnit)
          , B = S.valueOf() > this.valueOf()
          , O = B ? this : S
          , F = B ? S : this
          , N = diff(O, F, $, T);
        return B ? N.negate() : N
    }
    diffNow(S="milliseconds", E={}) {
        return this.diff(DateTime.now(), S, E)
    }
    until(S) {
        return this.isValid ? Interval.fromDateTimes(this, S) : this
    }
    hasSame(S, E, M) {
        if (!this.isValid)
            return !1;
        const T = S.valueOf()
          , $ = this.setZone(S.zone, {
            keepLocalTime: !0
        });
        return $.startOf(E, M) <= T && T <= $.endOf(E, M)
    }
    equals(S) {
        return this.isValid && S.isValid && this.valueOf() === S.valueOf() && this.zone.equals(S.zone) && this.loc.equals(S.loc)
    }
    toRelative(S={}) {
        if (!this.isValid)
            return null;
        const E = S.base || DateTime.fromObject({}, {
            zone: this.zone
        })
          , M = S.padding ? this < E ? -S.padding : S.padding : 0;
        let T = ["years", "months", "days", "hours", "minutes", "seconds"]
          , $ = S.unit;
        return Array.isArray(S.unit) && (T = S.unit,
        $ = void 0),
        diffRelative(E, this.plus(M), {
            ...S,
            numeric: "always",
            units: T,
            unit: $
        })
    }
    toRelativeCalendar(S={}) {
        return this.isValid ? diffRelative(S.base || DateTime.fromObject({}, {
            zone: this.zone
        }), this, {
            ...S,
            numeric: "auto",
            units: ["years", "months", "days"],
            calendary: !0
        }) : null
    }
    static min(...S) {
        if (!S.every(DateTime.isDateTime))
            throw new InvalidArgumentError("min requires all arguments be DateTimes");
        return bestBy(S, E=>E.valueOf(), Math.min)
    }
    static max(...S) {
        if (!S.every(DateTime.isDateTime))
            throw new InvalidArgumentError("max requires all arguments be DateTimes");
        return bestBy(S, E=>E.valueOf(), Math.max)
    }
    static fromFormatExplain(S, E, M={}) {
        const {locale: T=null, numberingSystem: $=null} = M
          , B = Locale.fromOpts({
            locale: T,
            numberingSystem: $,
            defaultToEN: !0
        });
        return explainFromTokens(B, S, E)
    }
    static fromStringExplain(S, E, M={}) {
        return DateTime.fromFormatExplain(S, E, M)
    }
    static get DATE_SHORT() {
        return DATE_SHORT
    }
    static get DATE_MED() {
        return DATE_MED
    }
    static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY
    }
    static get DATE_FULL() {
        return DATE_FULL
    }
    static get DATE_HUGE() {
        return DATE_HUGE
    }
    static get TIME_SIMPLE() {
        return TIME_SIMPLE
    }
    static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS
    }
    static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET
    }
    static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET
    }
    static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE
    }
    static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET
    }
    static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET
    }
    static get DATETIME_SHORT() {
        return DATETIME_SHORT
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS
    }
    static get DATETIME_MED() {
        return DATETIME_MED
    }
    static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY
    }
    static get DATETIME_FULL() {
        return DATETIME_FULL
    }
    static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS
    }
    static get DATETIME_HUGE() {
        return DATETIME_HUGE
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS
    }
}
function friendlyDateTime(C) {
    if (DateTime.isDateTime(C))
        return C;
    if (C && C.valueOf && isNumber(C.valueOf()))
        return DateTime.fromJSDate(C);
    if (C && typeof C == "object")
        return DateTime.fromObject(C);
    throw new InvalidArgumentError(`Unknown datetime argument: ${C}, of type ${typeof C}`)
}
const BlueCoinImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAAXNSR0IArs4c6QAAAKVQTFRFAAAAABAwAAswAAsyAAwzAAwyAAwyAAwyAAwzAA0yAA0yj+H/htr+fNL+Zcr/ZMn/S838Yr78PsP7UbH8LrX7U5nvOZ/7Jaf8GZj8N4rlJI78FYn9EYL9FXv4M2vjFXjYDnP6DWr1CWP5EGO8ClruHFLcBk/5B0vqClKdBkLgCTvUBDzCBDawBz2ABCjTAy+cAxzNAieIAiJwARteARZOABFBAA0zr8+m+AAAAAt0Uk5TABAgMENoh6K/2+9YEfMGAAAIQUlEQVR42q1aiXLiOhBcEo44S7jBGGzwARgZMDf//2lPI0tqGccBNq/ZpLZSle6Z7hnZhvx5FpX3Wr1hWdbtdvu0rI96rVr587+hUq1btyKsxv8iUql9fN5K0aj9kr5aV+zn3Tqaz+eu63rzKFrvTrqPt1/Qf2Qkp3XkuRz0DYjWZ9nG2y/oiR2895ivL5D4J/rrLnJ/RiS8smqvRlsX9FT8Q8x3QuKlJqqfoH+M6VwYVX+x/F2e3gsWMWNJkjAWLwI3j/FaNPH+HP8bbdUlMskXLD3kkeRFps4OTTy2J19+kIDdRLrwDQU7ujyXRI3cj1B8nJqcjBvEnVKSzJCwnd0zNtXJnrlBD24UDNtMibG9p6Ow+pD/5GlzNH0Mxw34LOVGoQc7IZtqD/h3+tcTFSjYC1ikB+ZBYUkK1ef4F2mevlwi9VXSA5txhc/38nzBz0z66WQ0mpRKxIbChF1KZ6lq8HvSHmHwqPWX8NUv0/DTQAU98NiVK5Tt11n/Rla+T1UJ+kxiVKagfbQH4aZk4yw5n+CPXY7J118DzTKJ2NcxrPYI+i5gzQ97XNT/cxexJ03qBaszN6nyTQBr6b/gl7aO/hbQnXyv4GYYDFYUQ71o0M6cHzUYMOiRhBeoFqarLS/3PW8QAohN/onyvptXKg6UH4ZogUz6yE0QV4zk3hwIaii60ng+tbMf0w7CMJRF2T1/tbnLuaEn1E+RLxwaClXnq5A2yifIQerZq9Ux18IbJojp+TQjTlLGaC+G+YGamPxoYdALVyyXQoMShkGpq9CWoaaePPsggbS9UEPFPBEp1L9pQBgkC0HEsxjHX3Kfth8CHjziKXxWvm0ABsEhHyfsrJm3qTsBPzxarVZXEXOxARiEiBNXw8nRN1vtdtuUUHPkrejAaOhT+oQGMEFwCD/q58tvtzjarb5fDEF4pJc4QgO6WizBwSvyd4e8fMEuREZSwkcIqwv3SJ5CV6OBoOgQK/IP00PiEL2SIJ8QQo9COMrLc11HzJCAGfEyv9ZYvGWfIiB60hEKgSGwzUKAQz4SyDkkNadtze8cDixOhQTVL60SLmHVaNcsmiE4hAZyEbOM/yvHH4YLsfSzLidvi38jU8DLBrVizhBtKnNLlmByzx9KicTRLgWY0w4JnMVp0dAXGkRsXsq6yR3/TPGThFicIW+ArJqYi6BSRgRBiUOLHH+T88chIKIYtgnCI092AAG+xp6MAA5hJJsHP8efgB8SM96AFPANgT2dd+/6SpDkZ6iJJRjx/+PCswgBGQU6yGWwJYGqzjhFBPklGGF9k0Na4A+8fisbIw9TpAQaNEQ7ZPzdEvR/4g8m/W5bRMyxMAQCJVBXQ+TlzqGpGkmm+Zv9e35v1KfK6UUaDtMCPS2AKfWRsbkEmv+rnx5S05hRVyyA4BandhLro6LTiVexFsCUssISDPXB7wh+GEOlZ+zSoNkBp2lnEMcy5A/qQAnE90vQVOW3aH21McScsWv/u7MD0wLjzog62EuBCAJYghxaLVpfaYy6BGhu0hqKfJDxJOYKXKAGAf/udgj4kvxkTEtmqowRx+hwRiNO/IHOmCw68SsOQoYARQw0v9rEv+QTw4Ha5beusyR2UT8i6MQc4rBDyK5hUdfg53yzpdOV5VL5oO87ywMB+cg9HhF/zI/rP9gDN8UUNWEPFUzGaJAESXFjEvUEHavp0nscE8QFB5vMtMAI5WeQ8y6IOWAMsWP34NCC+De0Bvl7llQtAcoX/CieRGAMlQ7gpBvEBHFa02l6cfWcmkvQNB2RHRSNAXBLwR1iXOAsblsq+nrgqrvSPvgBkioaA6CBCXeI+Jm88cJtF5Nz+gV71EzyV5kxgK8iHjHGW9hmTwhYBPKIyYibZIv8IvxgDOCqiJfiTZ+TiABjxJGKlPtyOCV5iTEPG4gvt9ubunOc6jkKuIA5nCXGlPGjAbbRz1CfOgRPeOQR9bPGAC4aIEiHZAgnV7fgh2xG1T9nDKCe86kBQnKTDsEjQnJgITssZ7NnjYFBagechCVc4EhrnKHySXOkBikNeRuGMa/x251ekhA/4xG/m0/5Y20SC2MY8zQ/Ek4YvfYUsUIVz2hkUhguYpT+Ej8ZlAiLxNONxgePWbXgpSwEXuJ3B2TQhiw6UgNAjVpQOftp/Co/AlhyfsZF8JgvY0YKpLD4R/7OfJNwdpacMEJ4t2sNheQFfs/gdzbJhiR4wp/ZDqAFMkkreIuXygc/0XMRvN9lpEAmaQXXf6V88CdC4oS3NQGLK+xsKLjB0+WDP+vgmDMIu0AxmAp+8DT9dED5Smzx9ngh5ysUHhgVwBzaL+LfZh1sEUAeFQsKD9oIZPGwpxdtt7L+K94yLZokFOypm4PnGyq+7+vaUf5osxUvDuJHAAWTSGGAJnIAsUlv9zq9+ZZAAtuLCLgMDRK4nscDNAGU0XdG2zw/joiSGK6XaACJB/Tk/l4pbK/gL1cgiZ39WGIs6OdELxX24C/Fm+zhuiaJcanGhLMT/X6/3+4l/xGfcT3sgStcSII0pkVn7B5PtuNEe4Lq4Pzs56X1TIFjFw0EbNsej6fjyXg8tu1Bj9Bx5sSdNUACxyt9qIz5f07hfNnNncGgRy8TvPbj8bg/Sgn+uty4/bWnP+q1lMT5fDmfduuIy9jUi+PMo/Uxw55eGc6vfpz81rhJibPASXydBI6ne/7TDeU/jZqVSUgFIge/lBAKx3/9SB8SsgXFb9KfzjeBj+pr3JBQGnAIEsT+C3pI6Djg0/lyuUlY9cqf3+C9oTRMgB3F/0Lj+z9tsRo1HAu/F6nWGx+WRUKWZTVe+tOf/wC91HCgQL5d9wAAAABJRU5ErkJggg=="
  , PotatoTokenImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAAXNSR0IArs4c6QAAAIRQTFRFR3BMQBAARxAARxMARxMARhMARxMARxMARhMA/fqm/fmV/vVv//U9/uw3/eU0/uMe/Nov+dgc9c0V88YS8L8Q7bcO67AM56oK558F4JwE3pUC7IkE25AB2YsBt44P0H0B2XECxmwBoHYMuWMAsVsAplAAiVYGmEEAijYAcSMAWh8ARxQA80lk8wAAAAl0Uk5TABAjRWuavNzvQ3wnRgAACHpJREFUeNqtmmtjskgMhde7W+uFO6IWEVGB////NgmZOQ4r29duD7Qfn5ycZFBr//qJRuPpbLZYLNu2Xcxn0/Ffv6nRdLZoe5pPf48+b19qMf1VenO7fCWBv91u/f3XrfmdEuPpUkD15cvbsryt59EP3V+3rsT/mcWkM39juOLpFjwr7ErMxj91L/jmwnTRZi3arLmGKJISy+mPsp+J+UTh60/ShvyvtQrzfc/7aqSJ0dv86RL4NdFZXkDyN9oG833f9y6YxJvp1B3+02hDdLo84ZOogJSIGlR4w37z5eKJGoi24t8WIHXDnr5n/+IJHny6t+Q/8ATP2vlWl3cqTNh+0sd3wW93BOfbRKQKvv68wtTYXzt8raHxiDwCp1FXINg3tK7jP1pOTV/Iq9UHaWXhat8mdDgcQqKTpIfF6Fv+gviRsb/6WwXzlr/jBuLDIY2ogNw8h9l34yV+zfEAL1qtVeBTA1wgjcPAiHdp8i3/pvGsPhSODgQO/6SIGjD4MIh5DKNv+BeJR+xDH2rerKfyKRbbQBjSvUdI3/GtfSSEdHi+wmdwh+eLhJDe5DN7jXzUPhcAn5VRSPOh/Rnkfzj2h/Ci5Drcwgx8BYO/cZaHxXQf4RtFeT3UwpT2B/xB/4IX94qXS+lRlOQVWujzG2/Qv8UrHeEI2/DT9HAq6peLNF62TTA437XFawG4R0BRnEqBG86CO2B+/vT5H5/Ae6CriPlkPyF+RgVKzmhgwDhfsA88053dSQ5prPiQ+Em6T7NjgYycAdTbrfdJemFf8CIdrcYTH9I0Vjz73+/TfUYdcEb/OmFNuN1u0IBr38Ej/ZT4EfzvU+7gVEpGYzcgHoC31QZgX+TsvTNd4sfEFr7YJ1GBsmzw0tY7AevP3vIgnRcHN45jck837c9eLynw6A2BA/K8DfPXK3GPdNzNdA9WJOZZzFZRAR7CwmlAXoHNi+5q9al4pA/3wGv4MmDmcxEtwM8j94h5W4/gwrfPzTXsu/4tXfFRggYyKWCmjAl73lb4RkQftA/zCIilBfJSpoyjNqYJM9/iN0aeuu/Twe8k8Sg+y/LyWl5rXiM0sKcJg2/yF7xc/81PhK14LkAVtAAa8IDH9igf+D5dfsVwLxWKK+lhCqABFOgEPPiv/MeJ8rWBY3mliHAQqIGaGlC64uH/tX3Qn/md8ivrZgtMZYW0AfAV7w+5RwHXf3aShNABH2JuAHRR376VmAddBiDZq455aQvgEHsbTFefzYaOJ0NyyvNTIqNFAQnI4o/Z8SQJVdfaFJi3beT5Cse7hqC/mlFeFOeiKDLCw34cEx4VmF8Qnm5eUx3xgxPaSAfgKx78M+PP53ORKZ7psQZk8MdjnpfCvzZcQEeMBgSvfDf8U8H4AytW/xoQ8BnzpYGqqriAJhT4npuPF8C+lojJP+G1gMBFLp4CyguiU4U7P4s0IZ8KgM7vTJzZijJq4GALGHwi4auEXxSl+JcCY03I93fg04V4oBPnowoZL/yE+LDP+eQFwbkEbenS7JDvG7z432G2gT24JzSQgr9HPKy84AY6mbeny7ahhICn++VjM0OBwPBjY9/yqcK1Et31GEza9qYFGC634t2Dm9gRp4HQyX8K++ofDTxkxhjBLgqlAZKLtw+289nwIy3g8k+nglUhoXbUjSDhAnEYeDuWNADhsZboGQhCoZPM6lg+GrjfzQgWbev7Prum3zphni3isaJI0jggvhSIlZ/ngj8Sn1XdH/eKroc5Zm1b06ndhEFgOui5f37wRFQ4Irw0IOFw7s/+y+rxuOuI27G+WHIHvi0g+YMPeqzSfPZd+HS8n/jSAAf0kIR0iYLA33n8S+TQwQfc8vVoUTrCL+m6Ery68gSennQXYXsaUPAKLxcqqH+V8AVflhw/4aWBhX21pHR2VhH4Gr8LV/4zHnyCy6UNsGYogAZc/+Dz5fJPwld8ydnQrQ2MXxXwsTlKB17pDp+VM11EeLlNAygQ9hpw0od7FccP+znj5YfR0kAtDaAAUf3OfyDogeVRpTi7li8diHvWAw1IgQstvmb0HH92PsTOclp+ZtxL/EbXDq8BLZ4/OIUksr8LBK7a05Mnhfv+eMEvDF+kAbWTpwJ1yOKEnsORJ1uE+JWvdBMPC3wENFO8PCqaUOQH8B/rozMkPJSmPfuW7vIxYdKI2knsbmLz91wgjVz7GdzLdoJfgV+3mLA+ri92tHg/JR2Eli1/IXDtg361/IfwNSCs0Y2w4OvRTYkfWbzaR/qv+A8asAQ06v+FyMFbRWY3sfxIB3TlP7p8Gny0xJTbL+Ddk2vwPftKZ34JPueDAUBzyUjk0BF+/9EDvPp/yKV8DAAZtcnrxyZ2B/aRDvh8q38cYWdRb71XlH44sA+48hUv+TsnwNmjJktMhUSuAXwheIm+k0mH8fXQNwcTbiFNE9g39MzlI3t1T+dX6MyXfMDvj7kt9qRU0fKZQugZ0i9cfGXGq/E38A/hLy1tc3Q+6eb50bUvySAbUlUJnNNn/oB/LFK9F2VSIj+fz8AfKXueZgV8JdNFPMPfoCGkG/xnZ5LZTRktpU2OK0uvhG/x4A9ovOAKRNYSx/P5IAV0MclvWRRny5ft0XTU/3wE3MAY2tupo/N1EnxuJnu/nkllR4d9i8f5HR4D6VHkJxmuflrEmb0z/1BeFa90UUtaTgTyfYXmWqiEjb2588tPSnwHr+m38/GffbMoTZSq3pklfJojnFr5b3xNrZNumzv4jFflcZwbfA08aTp667tvKUHW3VOr5xZwUvve9/hoQmuQQK+EXkON4ifvf8OuJdqmpj0XdaEzvvvdKH2JcN7SZNZaNU3NXCWDTZpPRr/9HybQcg7zP9VkOl8OwSn439FoMp3N54tlB17wv/pM3v3nj38AowOnzOKhJbcAAAAASUVORK5CYII="
  , BackgroundImage$4 = "/assets/TradeModalBackground-D0via_es.png"
  , formatFloat = (C,S,E="nearest")=>{
    let M = C.replace(/\s/g, "").split("");
    M.unshift("0");
    const T = M.indexOf(".");
    if (T === -1 || S == null)
        return C;
    const $ = T + S;
    let B = $;
    const O = M[B + 1];
    let F = !1;
    if (E === "nearest") {
        const N = parseInt(O);
        F = !Number.isNaN(N) && N >= 5
    }
    if (E === "up" && (F = M.slice(B + 1).findIndex(U=>{
        const H = Number(U);
        return !Number.isNaN(H) && H > 0
    }
    ) >= 0),
    O && F) {
        let N = 0;
        do {
            const U = M[B];
            if (U && U != ".") {
                const H = parseInt(U) + 1;
                if (!Number.isNaN(H))
                    if (H > 9)
                        M[B] = "0";
                    else {
                        M[B] = `${H}`;
                        break
                    }
            }
            B -= 1,
            N++
        } while (N < 1e4)
    }
    for (M = M.slice(0, $ + 1); M[0] === "0" && M[1] !== "."; )
        M.shift();
    for (; M[M.length - 1] === "0"; )
        M.pop();
    return M[M.length - 1] === "." && M.pop(),
    M.join("")
}
;
function fromDecimals(C, S, E) {
    return formatFloat((parseInt(C.toString()) / Math.pow(10, parseInt((S ?? "9").toString()))).toString(), E)
}
const ButtonGlareImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgwAAAAoCAMAAACl+lI0AAAAAXNSR0IArs4c6QAAAAxQTFRFR3BM////////////Bp/QCgAAAAR0Uk5TABIzJGRZkGUAAADOSURBVHja7ddbboMwFEVRH87859wPkpRKtFWkPCBemxn4Ll+LsUiXhiMQDIJBMAgGwSAYBINgEAyCQTAIBsEgGASDYBAMgkHnaYwkbZ3EzLVNMq5BAcFOoeLjWw38m1Ux3yKggoFBBQNUTFN/NYCFNfC0/IQcj8C+ASwQODoLLh5S/yLAhSXAhR0AxkfX2wrQWuaS0bYB4C4ZNX/9KOfcGu3t/Tf/J5UNjvZgL38Tl/+t5VLXlr5m7m0SF/8MZYMk6aZl/fbr9fsuTWYY+xfxy4Y5onyD8QAAAABJRU5ErkJggg=="
  , MintButtonContainer$1 = re$4("button", {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "calc(100% - 88px)",
    height: "64px",
    overflow: "hidden",
    borderRadius: "14px",
    background: "linear-gradient(97deg, #5DDB22 -3.92%, #29EB82 100%)",
    marginTop: "-40px",
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px 8px 0px 0px #1C8552
  `,
    position: "absolute",
    bottom: "-25px",
    "&::before": {
        content: "",
        backgroundSize: "cover",
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: 1
    },
    "&:disabled": {
        background: "linear-gradient(97deg, #E3E3E3 1.47%, #B0B0B0 100%)",
        boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px 8px 0px 0px #8F8F8F
  `
    }
})
  , ButtonText$5 = re$4("img", {
    width: "44%"
})
  , ButtonGlare$4 = re$4("img", {
    width: "100%",
    position: "absolute",
    top: 0,
    left: 0
})
  , SellButton = observer(({...C})=>{
    const {t: S} = useTranslation();
    return jsxRuntimeExports.jsxs(MintButtonContainer$1, {
        ...C,
        children: [jsxRuntimeExports.jsx(ButtonGlare$4, {
            src: ButtonGlareImage
        }), jsxRuntimeExports.jsx(ButtonText$5, {
            src: S("SellButtonText")
        })]
    })
}
)
  , BackgroundImage$3 = "/assets/MintModalBackground-BWWUzmXn.png"
  , ModalContainer$5 = re$4("form", {
    width: "300px",
    background: `url(${BackgroundImage$3})`,
    backgroundSize: "100% 100%",
    position: "relative",
    padding: "8px",
    minHeight: "160px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
})
  , CloseButton$6 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , ModalText$2 = re$4("p", {
    color: "#FFF",
    textAlign: "center",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "120%"
});
function ErrorOrderContainer({onClose: C, text: S}) {
    const {t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(ModalContainer$5, {
        children: [jsxRuntimeExports.jsx(CloseButton$6, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(ModalText$2, {
            children: E(S)
        })]
    })
}
function ErrorOrderModal({open: C, onClose: S, text: E}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(ErrorOrderContainer, {
            onClose: S,
            text: E
        })
    })
}
const ModalContainer$4 = re$4("form", {
    width: "354px",
    height: "441px",
    background: `url(${BackgroundImage$4})`,
    position: "relative",
    padding: "8px",
    minHeight: "228px",
    backgroundSize: "cover",
    backgroundPosition: "center",
    display: "flex",
    flexDirection: "column",
    alignItems: "center"
})
  , ModalTitle$3 = re$4("img", {
    position: "absolute",
    width: "168px",
    height: "70px",
    left: "-17px",
    top: "-21px"
})
  , CloseButton$5 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , TextContainer$1 = re$4("img", {
    width: "90%",
    marginLeft: "10px",
    marginTop: "30px",
    marginBottom: "20px"
})
  , FieldInputContainer$1 = re$4("div", {
    borderRadius: "8px",
    border: "1px solid #572A24",
    background: "rgba(87, 42, 36, 0.70)",
    boxShadow: "0px 3px 0px 0px #9C4C30",
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "8px",
    padding: "16px",
    flexDirection: "column"
})
  , FieldInputRow = re$4("div", {
    display: "flex",
    width: "100%",
    justifyContent: "space-between"
})
  , InputText = re$4("p", {
    color: "#FFF",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "600",
    letterSpacing: "-0.32px",
    display: "flex",
    gap: "12px",
    "& > span": {
        fontWeight: "400",
        opacity: "0.5"
    }
})
  , TradeModalContainer = observer(({onClose: C})=>{
    var fe, pe, ge;
    const {ordersStore: S, userStore: E, marketStore: M, configStore: T, dialogStore: $} = useStores()
      , {isConnected: B} = useConnectWallet()
      , O = useTonAddress()
      , {t: F} = useTranslation()
      , {control: N, handleSubmit: U, formState: {isValid: H}, watch: Z, setValue: J} = useForm({
        mode: "all",
        defaultValues: {
            potatoAmount: "",
            tonAmount: ""
        }
    })
      , ie = reactExports.useCallback(()=>{
        $.open({
            Component: ErrorOrderModal,
            props: {
                text: "ErrorTimeOrderText"
            }
        })
    }
    , [$])
      , oe = reactExports.useCallback(()=>{
        $.open({
            Component: ErrorOrderModal,
            props: {
                text: "ErrorCountOrderText"
            }
        })
    }
    , [$])
      , ae = Z("potatoAmount")
      , se = Z("tonAmount")
      , le = reactExports.useMemo(()=>{
        var Ae, Se;
        const we = parseFloat(se ?? "0") / parseFloat(ae ?? "0");
        return (S.total ?? 0) < 20 ? we < parseFloat(((Ae = T.config) == null ? void 0 : Ae.min_price_per_potato) ?? "0") : we < parseFloat(((Se = M.config) == null ? void 0 : Se.min_price_per_potato) ?? "0") * .95
    }
    , [ae, se, T.config, M.config])
      , de = reactExports.useCallback(async we=>{
        var Ae, Se;
        if (!(!H || le)) {
            if (DateTime.now().toMillis() - new Date(((Ae = E.user) == null ? void 0 : Ae.last_order_create) ?? "0").getTime() < 60 * 60 * 1e3) {
                ie();
                return
            }
            if (((Se = E.user) == null ? void 0 : Se.orders_in_progress) === 3) {
                oe();
                return
            }
            await api.v1OrdersCreateCreate({
                seller_address: O,
                amount: parseFloat(we.potatoAmount),
                price: parseFloat(we.tonAmount)
            }).then(()=>{
                C == null || C(),
                S.reload(),
                E.reload()
            }
            )
        }
    }
    , [B, O, H, le, E]);
    return jsxRuntimeExports.jsxs(ModalContainer$4, {
        onSubmit: U(de),
        children: [jsxRuntimeExports.jsx(ModalTitle$3, {
            src: F("TradeTitle")
        }), jsxRuntimeExports.jsx(CloseButton$5, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(TextContainer$1, {
            src: F("TradeModalText")
        }), jsxRuntimeExports.jsxs(FieldInputContainer$1, {
            style: {
                borderRadius: "16px 16px 0px 0px",
                boxShadow: "none",
                marginBottom: "1px"
            },
            children: [jsxRuntimeExports.jsxs(FieldInputRow, {
                children: [jsxRuntimeExports.jsx(InputText, {
                    children: "Potato"
                }), jsxRuntimeExports.jsxs(InputText, {
                    children: [jsxRuntimeExports.jsx("span", {
                        children: F("Available")
                    }), jsxRuntimeExports.jsx("p", {
                        style: {
                            opacity: "0.5"
                        },
                        children: (fe = E.user) == null ? void 0 : fe.potato_amount
                    })]
                })]
            }), jsxRuntimeExports.jsxs(FieldInputRow, {
                style: {
                    justifyContent: "center"
                },
                children: [jsxRuntimeExports.jsx("img", {
                    src: PotatoTokenImage,
                    style: {
                        width: "48px",
                        height: "48px"
                    }
                }), jsxRuntimeExports.jsx(Input, {
                    placeholder: "MIN: 100",
                    style: {
                        textAlign: "right",
                        fontFamily: "Rubik",
                        fontSize: "24px",
                        fontStyle: "normal",
                        fontWeight: "400",
                        lineHeight: "24px",
                        letterSpacing: "-0.96px"
                    },
                    controlledInputProps: {
                        name: "potatoAmount",
                        control: N,
                        setValue: J,
                        validateParams: {
                            isOnlyNumbers: !0,
                            isNotNegative: !0,
                            notGreat: Math.floor((((pe = E.user) == null ? void 0 : pe.potato_amount) ?? 0) / 105 * 100).toString(),
                            isNatural: !0
                        },
                        rules: {
                            validate: we=>{
                                if (parseFloat(we) < 100)
                                    return "Not min"
                            }
                        }
                    }
                })]
            })]
        }), jsxRuntimeExports.jsxs(FieldInputContainer$1, {
            style: {
                gap: "20px",
                borderRadius: "0px 0px 16px 16px"
            },
            children: [jsxRuntimeExports.jsxs(FieldInputRow, {
                children: [jsxRuntimeExports.jsx(InputText, {
                    children: "TON/Potato"
                }), jsxRuntimeExports.jsxs(InputText, {
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("span", {
                            children: F("Min")
                        }), jsxRuntimeExports.jsx("p", {
                            style: {
                                opacity: "0.5"
                            },
                            children: (S.total ?? 0) < 20 ? `${.1 * parseFloat(ae || "0")}` : `${formatFloat((parseFloat(((ge = M.config) == null ? void 0 : ge.min_price_per_potato) ?? "0") * .95 * parseFloat(ae || "0")).toString(), 4)}`
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx("span", {
                            children: F("Max")
                        }), jsxRuntimeExports.jsx("p", {
                            style: {
                                opacity: "0.5"
                            },
                            children: formatFloat((parseFloat(ae || "0") * 1e3).toString(), 4)
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsxs(FieldInputRow, {
                style: {
                    justifyContent: "center"
                },
                children: [jsxRuntimeExports.jsx("img", {
                    src: BlueCoinImage,
                    style: {
                        width: "48px",
                        height: "48px"
                    }
                }), jsxRuntimeExports.jsx(Input, {
                    placeholder: "0",
                    style: {
                        textAlign: "right",
                        fontFamily: "Rubik",
                        fontSize: "24px",
                        fontStyle: "normal",
                        fontWeight: "400",
                        lineHeight: "24px",
                        letterSpacing: "-0.96px"
                    },
                    controlledInputProps: {
                        name: "tonAmount",
                        control: N,
                        setValue: J,
                        validateParams: {
                            isOnlyNumbers: !0,
                            isNotNegative: !0
                        },
                        rules: {
                            required: "Amount is required"
                        }
                    }
                })]
            })]
        }), jsxRuntimeExports.jsx(SellButton, {
            type: "submit",
            size: "150px",
            disabled: !H || le
        })]
    })
}
);
function TradeModal({open: C, onClose: S}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(TradeModalContainer, {
            onClose: S
        })
    })
}
const Container$7 = re$4("div", {
    position: "absolute",
    width: "100%",
    zIndex: 1
})
  , HeaderImage = re$4("img", {
    width: "100%",
    position: "relative",
    zIndex: -1
})
  , CloseButton$4 = re$4("button", {
    width: "32px",
    height: "32px",
    position: "absolute",
    zIndex: 100,
    top: "45px",
    right: "30px",
    border: 0,
    background: "transparent"
})
  , ButtonWrapper = re$4("div", {
    display: "flex",
    justifyContent: "space-between",
    gap: "10px",
    alignItems: "center",
    position: "absolute",
    left: "40px",
    top: "65px"
})
  , OrderButton = re$4("button", {
    borderRadius: "9px",
    padding: "8px 16px",
    width: "141px",
    background: "linear-gradient(97deg, #FD810F 0%, #F5ED21 100%)",
    boxShadow: "0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 0px 6px 0px 0px #85681C",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #2A2036",
    position: "relative"
})
  , HistoryButton = re$4("button", {
    width: "40px",
    height: "40px",
    borderRadius: "9px",
    background: "linear-gradient(97deg, #E3E3E3 -5.14%, #B0B0B0 100%)",
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px 6px 0px 0px #8F8F8F
  `,
    position: "relative",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #2A2036"
})
  , ButtonGlare$3 = re$4("img", {
    position: "absolute",
    left: 0,
    top: 0,
    width: "100%",
    zIndex: 1,
    borderRadius: "9px 9px 0px 0px"
})
  , MarketHeader = observer(()=>{
    const {isConnected: C, connect: S} = useConnectWallet()
      , E = useNavigate()
      , {dialogStore: M} = useStores()
      , {i18n: T, t: $} = useTranslation()
      , B = ()=>{
        E("/")
    }
      , O = reactExports.useCallback(()=>{
        if (!C) {
            S();
            return
        }
        M.open({
            Component: TradeModal
        })
    }
    , [C, S]);
    return jsxRuntimeExports.jsxs(Container$7, {
        children: [jsxRuntimeExports.jsx(HeaderImage, {
            src: $("MarketHeaderImage")
        }), jsxRuntimeExports.jsxs(ButtonWrapper, {
            children: [jsxRuntimeExports.jsxs(OrderButton, {
                onClick: O,
                children: [jsxRuntimeExports.jsx(ButtonGlare$3, {
                    src: ButtonGlare$5
                }), jsxRuntimeExports.jsx("img", {
                    src: $("OrderButtonText"),
                    style: {
                        width: T.language === "en" ? "109px" : "74px",
                        height: "24px",
                        zIndex: 100
                    }
                })]
            }), jsxRuntimeExports.jsxs(HistoryButton, {
                children: [jsxRuntimeExports.jsx(ButtonGlare$3, {
                    src: SmallGlare
                }), jsxRuntimeExports.jsx("img", {
                    src: Clock,
                    style: {
                        width: "20px",
                        height: "22px",
                        zIndex: 100
                    }
                })]
            })]
        }), jsxRuntimeExports.jsx(CloseButton$4, {
            onClick: B,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseButtonImage,
                style: {
                    width: "32px",
                    height: "32px"
                }
            })
        })]
    })
}
)
  , BlueCoin$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAMAAAANIilAAAAAAXNSR0IArs4c6QAAAMZQTFRFAAAAABAwAAwwAAsyAAwzAAwyAAwyAAwyAAwzAA0yAA0yAA0zAA0yj+H/fdX/esT3Zsr/ZMn/Rsj8XLn8PLv5Qqf9UJnwJ6n8NKXmLJb8GZnlHZL9QX7oIYzQFYn9EYL9KnfoEXr7D3b2GHrIDnD5LmLgDnLhC2n6DWXwCWP5CVz1DGLFDFfrD1irBk72EUjXB0rmBkLfBkHLCEqWEzfVBTy8BTLaBDWuBzx/BSbSAzCdAxzNAimMAiN4AiFmARlRABJBAA0z9ty3ogAAAA10Uk5TABAgMENqhaa/z9/v7hhYH4gAAATISURBVHjajdaLcppQEAZgk4ooTQwKiAajgWC8BJTjNUgE9v1fqnt2KaWhpvlnamc6/bL/WQ/RxrU0FbWj/QQAra0qzcb3c9NUkWHyLMtBRlOb36QtlHkavr1OKa9vu1R65f/0VkX5/uaRK+OFKfH/Ts13KOt5fQfo3H5hf2hV6nr+wvf+8McMoHXVKgDpa9EzEHHCOUaL4odNwhy0K8NbkIf8v4Iju1hG/h1xgcnjBUD513HbkPHYKC4GFpX9BbaIphR7h9XrtlPYRTmqGvQe60Ne1ypkHo0l6k5r8URAze1N/rl5i617RIvUMbr3XcP5mwdU3bG3AM2qVbizF+NY3K11z/nEvQUVn5xBu6lcK4DSYoEROk7X+lv7VHx1qR5bg90Ug52Psny3oHXuuXK0HeVcnEuntCuey4Mfxg+/+ai07tKfYsz5Cdq/S2tUOiCLMSTZJ8mMeOXo/nK5pFM765RG06bfiwPTz6XWRrQQSTKucneOlkY75noL7epgkfAt4lXPsIMnkj1qjuUvOdTbX+dAC1d4MJbmcr17TMQ9x+XedGPEmFY2Wp954eXggIBzjxnwg2QQxGPoPV3vGRPqTfsuejchrQ4uWtNNtMg+7GeGrhO38NhzPjT3ViGkVfNgXteDoLls5UPJHDXjSX+1vsh9d6j1kQaXrb3SDuLjcnVM9s9oMS5vDPEZFLyZGbcWZJls8Id32SZiiZF8rPd6usUb6/vrA26sSbteJMniT2sjmDpsx2g5UZwMUBsl3oCKNyTkm8l2xG9yzUo+6FWxwHWr8EZv1LHSOihtVFJ3ZPUwAzrzpMDtYl+isq5nst3Zbzt3LUPuC3FA2OmvKziuXk2+VvosCUjiSMnoZSyW8wruFDggrNNI+ae3j1dUVmeGk9EmK75h1nq9xYVpFcytyRtoy7KcwfM+EbwvcxTRW1WcmbFRWN3Yz6weS3oxBjO8Z7QD2pcX0SVRCQs+c5fH4jNQHJO0Md6gjEWAlFqP+kG0/oBm8VYFhEc8VhJ64bIb+vhYLSnc2oqiKMUHQ4GQbpgoWnclY1+UjVly+LF4jiIBnQZdT0wc4z9Ki6hWllMOtk0cfMBl04OBifBuW0wxn8uW8emRehZRRE9kQ4MpxsVDW125Jp3K1iSX5sECca7x784djY7dwKiURVmPyycWQpxla3nobCJHx0G031BZUYH10qa5QZwCf0P4CS9TTHBcHWtl63bU32w3gj4xuHc6oeLRkuB1y6XRivID4wZ49FR8xw63GDoxR4XUIR2svrR84O1WHHK4rXw671jPr9G5W9jtAQen1Y/nFhaf8Gfo/As6KewHaMQ4NxrkjzSbeJ1SnD7aw2F7yO+4dJEmQEaauM+epY+UYveHB2lP9S9DqJ9sqk5xXdf3XZcgxTH7L6cTYrS1r2FtgDy0nWk9THHsCTHb+hdA1Onjv/gEqRmepT2dS1vX2e7Rtp1JVY7sfn8Yns8nqS/Atq5VqbP3F9u0MY7j4KuJ8uUsg/acwV2zDsutIUcfPj0NTdMcDp9ewg8Z0ilA+7ZxNbca65RykWH7QfROaXwZBTmwvqSEiV8ypK2b667K8zxDzUkzlES/k6aKnpLnQNFazcb380NptTt3knXUlnJ1S78AY6GLiiT8BiMAAAAASUVORK5CYII="
  , Grydka = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHkAAAB4CAMAAADheK3eAAAAAXNSR0IArs4c6QAAAKVQTFRFAAAAJSAAKCAAKx4AKh4AKx8ALB4AKx4ALB8AKx8AKx8ALB8Al/UA9K0Pc+0A5aMM8JgGXuIAg80AsK8B5Y0GS9YA2oAFOscAwnwHvGoRKbcAz2ECgIIDq10MKJ0BwkwAV3cAkFkDokQEj0EGEHwBhzsFgDYEDGkBeCwEKFQBQkQBbSkCDVUCYSQBSCsAKzMAVxkATRoBNx4ARBcALB4ANQ0AKQgAQ79x1AAAAAx0Uk5TABAgPF15kKCvw9/vvFkRMgAACKRJREFUeNrFmu12qkgQRaNGjWZiNNeP6I2aiCCKrWCD7/9oU1WQbrAa0DBmzr+7Ftft2VR3E5KH/zy1x0774X9Irfkchp3f59bbzyGk+/t9Q8zu18mP2Pf4+TY63t9287ldV4WfiPvPP4PZ9t7kegdv6eMDpdElLmSG5PvfVGRjbfwHcBF8ZzJ1DE9fB2S3G22YqzcCj5DcvqPoJyR6437/6xRSqDDeZMixecfJAtbhvY8ZOzhZHzG4N7srudEJIV/DfpLpAU1TJgheHBv3mawWcgUUVnlFKIGJvA5rd9suTl99E3gwmSF683yPydKiObg3iWXvn+6yhGmyGJgymkBA9r5Zrd1js93pYjpPrWajhqK7TDQkDabOm32lAYN22XRaJFqMs9zhH+0aAvd5velWE/scUo6YEMNEI/fvu6o8icmLzaZdgUult+vFbIIZjSaLxecORA+z3PFymXKNwcr71kPF0jF4BNxRnLc/r2kwcJfK9QCuSiof4QypVnq7XsdwhR4M3l616CVE3WQCA3qz2dAZUoVd664pC8VFNLA1V1cejRR4Oz2oY/uHaWxj9GY9m3yzB5DeK4qmaNex7DWQP+D8qlq7tSEwfhwWHxAZ82dK3NWHch13xiv3YxwBrP3crOZ7E6OhOLC/0W/vAPbOb6oydabrPvuUOSmvV/CNWMoeb/ggTm/Q+2NH0U5VxpBqqqyP7bBV+yG6s9ko9gKC7AT9dpAfqcrQmK77UNt5Uvvxh49ax5i63eyJDIsMuQn6LQWeARjz8pLaadik3fKo9blJsiewYvd6vUHiGv79Dd5705c0e0y1mzc/atGTx0dSeU/gGWaEZAyRgUtgRAvXtd8BrfN1unHSGh11IAIawZv1ImFPoHYvZieVAUyVdy5m/qrYatKurV1rp588Poi8BzaBAQ1RpVPgo0uh2pqtJu3GZ1pCI5iyWSA4je4RmMjhOfK+2dnabNLKRGv0dq+ij05Cw11OwCcpz2f5zTZN2uMVz7TOMHv+rwiti8doqj1aEHl7kJDoHPkEZpNGtTv1q0VT6FhyCKrhAI7R5BpnywuITcpNk+axSSsWrY6l1W6fzWKG6AFxY5gIEI3KCyatkSvaG2dFL5N45/C4vwgcI7MtYFX8S+VsgelJKxdNcaOzlPJ02GbIu/1sYdkafKGcT9q7nrRy0WQ6OEdSysDDz97ttpDjDrsi2bIcTdbKg4JJe0rX7qitQ0VxfeJK4abjANJGMiZTWylXk5a5f8juZskH/Ha8shsR2GdcyDfZqDyZNCszOC8vQ8HJ8O0YexVp0Tq2lSXnK3emWe7LeGkiw3WE1lnliGZkYnPl1jDLHeIq4WRqM7yoLaSUHuMyMleO/+9C9CuuFWNnDFM+B7bvKa5t6ThAdi0Iq+0IEMVFY8yd+Tqgo0bKQBgae3I/W0vB0DRjQXalgGgsnN+Zbz3EdlIzpksH8rjYSt/ENYs2du7CPqLIJcp1Z0hgX95mFP1uEp3bOfQVmCvvM+XE8lzFLRANu7COdVJk/Y7gJApqj22ozZRzrnS4aJ3VAUGdzNumLrE9V0ctbq1cr+wM2CkTre8xf0JI2Cffu1Y546LoeZ9NtI4dhOYjuvYEZClvVG5rrvwaFokWvsz7UauNZKxVoHyaVW6nRHuFoh3fR7K+xZyM7ELlgfpuKoJEF0208K8ilylX3y1f9EtGdCR9TFBOhguLpnyc2ct92rLSuRC9cs5IFq4oJ8cX6thjvsIS5XQ2FIleWRaShedeRQ58CFPOzhG2ZfHJsiwk0925sjNFK+dPDXS7S0VbGFsK91qyJ4icVT7kysV7sWjMarm6hQyXsdpMeX9aLJq4q+WtZNdjytniLhcN3FvJGJPyVO1y0dYScjPZ1myz8lLRVPjv8G85uZUhw2LQyoueGgg8zBENg3AFuZklQ4qU80OJc2HF/ZBsFSovF93/OblEORdtZURfSa53OJnY+cq5aIoSzcnPdeM7Ek4uUV4impMhTf56FXIQnKyV89rvvLAWzcnuIWQvDZrJkycjFytf5U20mexYzglBrRQZGwvbxlOPk7lyTo65SrSZbMMlTsh/urGpmeDkvCnXZIsX1lkiOXlOnk/nB06WwsZm9FO3UE+1ZuVBkCI7XgF3vIzJjo3c6co1kWXgxrUDGdEnKyRTHpwjPyGvfOllJpq9ULN8KVA0FHZcM1nSFfjhybsdx6wcyfiuD8greqmQVxi5K7jcs6gwfHEzmeLFyiV+cr5yIEMCy5EYN1c0PeELBwqjaErAyKHEKOV+8jrNMSoXZ0okKY5J9JhEC5hGJZpy4GT6HK3cg16RyFHuRSmyD9tlmWhLvTU6GcggOIlnkfJIKWdkKb/JgYeDVi6aInwTWZfQytWkcbKM6HKwwshDKhyLtqbTua25RjKhL5VDtchDNiMjO4LCisxEC/tCNCQAMHtbQewC5ZwswYcil4uGyJAdV/WOQucq52ShyEbRcxCdKUyMTuOBva0wKbeZ8iIycpcG0SIRbf61dC2lPFLKqbbAxU3KC8kk2lai5w4X3arl/xbUrDw4K+VGshatlnCJ6NuV20YyE60mK190ufLAy+ynLiPDHhaLVnulSXSbib5GOUh2tXKXdy4V3WWiS5RLpVwvbjPZU5N1q2iu/JynnJGVaItPNPs9EU/pxqKPMP+CrESzvZKJrqw8Q/Zy90oSXbv5b7EL9tMoQxYkmk00e7F7PbtrYMe1A0WmmA+lKn+51Owa9lPbcpCtyTYTXbRXVlcuErJjOJSk2isrpJG/n/pIzj+UQHTFFBxhNNHzm0RXV25BUbv49K8e8xHmAvOK0/8Oyqn2fUSXH2F+BdEV91PfdCjdIfXWZW1hOP3vEb6figqHUjXlQhW+TXT1xS0qHErV9lN5d9H8dSEGyUlhdvrfW7kMfkk0n7QKh1Kl/ZTtlb+lvMP2yt+r3amwhP8FANK6wSPMAMwAAAAASUVORK5CYII="
  , PotatoToken$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA8CAMAAADi4EJ+AAAAAXNSR0IArs4c6QAAAJxQTFRFR3BMRhMARhMAQBAARxQASBAARxMARhMARxMARxMARRAASBQA8sQS9ckT8L4Q25AB/uk17rkO/eMz6awK3pYDt2EAsFkA7bQN4p0E/fqm6rEMmEIA//A59s4X2YsBwGsA+dcf5acJ/NovbSMAWSIBjTcAznACpE0A/eMe//ZB038B7IcEfCwA7psF/vZv5MQXnHALs4kOhlUG/fiRzSHypwAAAAt0Uk5TAO+lEMMghGffRTCwtaaiAAAEgElEQVR42pXX6XaqShAF4DhrWoiIDJdBRhslEoe8/7vdXUVji55jcnZW1sqfb+2qpkni249ZzIbj+UCIwXg2efunjGbjgUBKRCDjxe/tgmhxvpzSPRJn11KI4eS3VojrhSB/U05n+OnoV7Y8n8BWqyjar6Notd6Tvwox/6l+MoRNQaPDIVobhpGukH0ax/EJ9bOXeDYQZKMDLJo7vU5j8mdM/+KgUZyxjYCJxy2GRgzjFZ/MqXh1oLAGZEva9qCNy1+HXwzKDRd//Yd8AUcdzmPrswFeon0w+ePKojyhmCxrYLaMY6/xlsYSuYrxC/wNSTnosYENszGBkaD8w+oLwhEVq2pFeWeDwtY0lxcxGD3g90Eff0fAzxbatIvH8sn8ET9bYMSybOehfER49dTMlriylKBp6qL/1Kbico+/mPINgWRrtdayM7+pKzHuHfd5v+fTVsXrFVs9ddbYjDPf9z/qRIjR/dK4JNHXrZhtb+Gm8XhlH3xTJ8e70YcCS0fRty7OY4Ss2thqPIsxQjoUw97cuNSH7++vwwqYh+6fNFnL81GNSMfVi/PDUu8Eb9xZjcERUO6WDp7ZrfqSrpQlnnfW0JTi2UyRxHFKcatO00i/T2lvYeZKk8UX60Lo6rUq7t8tLUE9hZEPx3WhdTWKFVZWY1NhmzSndt2ue0HVqpixtnrmwPMCKuZsE5e71bNObzjXC5teLWUdMIYNuuKPj9qBLllPxDVNyTLGzjcsEXAUwwYZoMISuCLNZxavGfPc+hFvpfxEMi4O7I2v8FYmwEqPxTLumnPVywGm2LCIsoQlbBXybRmJY5y2dn2PLUtpxnZGlPCHlElVudVOjNsTj3OF05vVuvEURgjXmLtC2t9NU7GJ89zMgXOyrC3KpiZsBjbClHGSJITDUix47ZORW0aaI5D6bfK8Bq+0ccNbhaUbQu/E/A0ZFAauNeve1UIC/MjY39C6ODBqdsJdWIWFGLaHZsS4IsApY2X5EYMqjNZ6i0eFVFzdDv4urtCc5c1Ca5z5sAg1I/y0UD1vL/l1aTCO2TIO2rDN0MyWseOAhlQ96/SSNSyHaj22uhkWYzuMsfSOqzvdHllLM/tu6CzbdDhh7IaUI1fz3oVpYvFU9W74ctkBW2Bl6wS0w5h7CMpnXprgsUkWwQ0BJQvta+zc4UL/9Z+LjGSLAxvaYoz4bBG2GtPcKkNxMTuLNBicm/vFfTy8+wN2BdX3I9DFfeuy3RXF/T98E1FmsIT1SetiqSwwbEhYaEyvyZmn1vj5tBBYhPDs4V+dzSvrcmDD3ZHwVNP21K9+lhGF9NWL3LdVCPuE1XUTiU8MUG4hGUsgsox3lKKP9UMra2CkljVb9NKLeCtGUFw+Y2Q0B1e/qrewkmYOpZRsK2WBBwuNdCbgCSCdlOzWrT9rVaysGE80eeBilyQE2ULLppGwoLC08WD66uOAKMMOc7YSFpSw+OkDzWwOfwxdZSum3FvqD1OvPVIWxyPG5bCkmUdvv8j7dCweM5+i9rcZLab46Ni68XC6eNX6PxzL+UF217sRAAAAAElFTkSuQmCC"
  , BorderContainer = re$4("div", {
    width: "calc(100% - 40px)",
    height: "250px",
    borderRadius: "16px",
    border: "2px solid #572A24",
    background: "linear-gradient(117deg, rgba(226, 109, 58, 0.50) 0%, rgba(255, 202, 180, 0.50) 100%), url('path-to-image') lightgray 0% 0% / 21.432945132255554px 21.432945132255554px repeat",
    padding: "4px",
    marginTop: "100px",
    marginBottom: "20px"
})
  , InfoContainer = re$4("div", {
    width: "100%",
    height: "100%",
    borderRadius: "12px",
    border: "1px solid rgba(87, 42, 36, 0.30)",
    background: "linear-gradient(122deg, #FFF6F0 0%, #FFD6B9 100%)",
    boxShadow: "0px 0px 6px 3px #9C4C30",
    display: "flex",
    flexDirection: "column",
    justifyContent: "flex-end",
    padding: "8px"
})
  , FieldCountContainer = re$4("div", {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: "12px"
})
  , InfoText = re$4("div", {
    color: "rgba(87, 42, 36, 0.50)",
    textAlign: "center",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "16px",
    letterSpacing: "-0.32px"
})
  , BlockContainer = re$4("div", {
    display: "grid",
    gridGap: "8px",
    gridTemplateRows: "auto auto",
    gridTemplateColumns: "auto auto"
})
  , InfoBlock = re$4("div", {
    width: "100%"
})
  , NumberContainer = re$4("div", {
    borderRadius: "6px",
    background: "rgba(156, 76, 48, 0.20)",
    padding: "3px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "4px",
    width: "100%"
})
  , NumberText = re$4("p", {
    color: "#FFF",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "0.7px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "20px",
    letterSpacing: "-0.8px",
    maxWidth: "80px",
    overflow: "hidden",
    textOverflow: "ellipsis",
    textAlign: "right"
})
  , FieldsNumberText = re$4("div", {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "32px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "32px",
    letterSpacing: "-1.28px",
    display: "flex",
    gap: "8px"
})
  , MarketInfoBlock = observer(()=>{
    var M, T, $, B, O;
    const {marketStore: C} = useActivatedStore("marketStore")
      , {configStore: S} = useStores()
      , {t: E} = useTranslation();
    return jsxRuntimeExports.jsx(BorderContainer, {
        children: jsxRuntimeExports.jsxs(InfoContainer, {
            children: [jsxRuntimeExports.jsxs(FieldCountContainer, {
                children: [jsxRuntimeExports.jsx(InfoText, {
                    style: {
                        fontSize: "20px"
                    },
                    children: E("FieldsCount")
                }), jsxRuntimeExports.jsxs(FieldsNumberText, {
                    children: [" ", (M = S.config) == null ? void 0 : M.fields_amount, jsxRuntimeExports.jsx("img", {
                        src: Grydka,
                        style: {
                            width: "40px",
                            height: "40px"
                        }
                    })]
                })]
            }), jsxRuntimeExports.jsxs(BlockContainer, {
                children: [jsxRuntimeExports.jsxs(InfoBlock, {
                    children: [jsxRuntimeExports.jsx(InfoText, {
                        children: E("SupplyPotato")
                    }), jsxRuntimeExports.jsxs(NumberContainer, {
                        children: [jsxRuntimeExports.jsx(NumberText, {
                            children: (T = C.config) == null ? void 0 : T.total_potatoes
                        }), jsxRuntimeExports.jsx("img", {
                            src: PotatoToken$2,
                            style: {
                                width: "20px",
                                height: "20px"
                            }
                        })]
                    })]
                }), jsxRuntimeExports.jsxs(InfoBlock, {
                    children: [jsxRuntimeExports.jsx(InfoText, {
                        children: E("AveragePrice")
                    }), jsxRuntimeExports.jsxs(NumberContainer, {
                        children: [jsxRuntimeExports.jsx(NumberText, {
                            children: formatFloat(((($ = C.config) == null ? void 0 : $.avg_price) ?? 0).toString(), 4)
                        }), jsxRuntimeExports.jsx("img", {
                            src: BlueCoin$1,
                            style: {
                                width: "20px",
                                height: "20px"
                            }
                        })]
                    })]
                }), jsxRuntimeExports.jsxs(InfoBlock, {
                    children: [jsxRuntimeExports.jsx(InfoText, {
                        children: E("ListedPotato")
                    }), jsxRuntimeExports.jsxs(NumberContainer, {
                        children: [jsxRuntimeExports.jsx(NumberText, {
                            children: (B = C.config) == null ? void 0 : B.listed_potatoes
                        }), jsxRuntimeExports.jsx("img", {
                            src: PotatoToken$2,
                            style: {
                                width: "20px",
                                height: "20px"
                            }
                        })]
                    })]
                }), jsxRuntimeExports.jsxs(InfoBlock, {
                    children: [jsxRuntimeExports.jsx(InfoText, {
                        children: E("DailyVolume")
                    }), jsxRuntimeExports.jsxs(NumberContainer, {
                        children: [jsxRuntimeExports.jsx(NumberText, {
                            children: (O = C.config) == null ? void 0 : O.volume
                        }), jsxRuntimeExports.jsx("img", {
                            src: BlueCoin$1,
                            style: {
                                width: "20px",
                                height: "20px"
                            }
                        })]
                    })]
                })]
            })]
        })
    })
}
)
  , AscImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAMAAABiM0N1AAAAAXNSR0IArs4c6QAAAE5QTFRFbTUoR3BMZzAjajMnazMnm0wwZTEnlUgvjEMsgT4rZjEjfDwrczgoXi0iNBkQZjEnRyIaTyUfXC0l////7+zr2c/Ns56bjG5pakE8Vyok8L6EcAAAABN0Uk5TwAAVS3OAg4aPnKOms7PA0t7t7xjGz+wAAAJQSURBVHja7djRkqIwFATQFqIhyZXrCCPk/390DVBmpMoOsFu1L9PP8XDpRKsMTq9UtXGCzRFn6ip/Gi/GCPbHVBlamOkZjT1vjm2cIFOYHQ+EjGzHAuBnCYsjzflQrCwSZoePw4eaJczO+S+SpAkyEDqPdc4W3s4kqALYukbjM9qwJUD1hAwCW/RUxiHGu6MvZ04oDHSPQ991/RDvZJWFVKghxEEcuyljBFkmqGHg6It9z9B3jKQmlxiQBRqHbskQldXtILBsoL5b0o/RsZIAsKYf3SsPNhLAIIljGiiPJMcguwyUR4qWQsWtz32DQ+Wm8xFgUHnryREoQ+GtaXoEOJSbfuv7vheSVdPkCFCoyQOt+7YU4k3zI5AhvvXkCFCID5T6VgKxLxk/AhxaNU2OAIdCHDuSPFIJQhqIjYSNkP4rSOLAoCHKRsjF+P3Z6ePmjvwtjo/+A/MY481vhK7tLZJ8tVsh37a3r4/MrSXQKm0hdivkuePPBNohXff8HvnrR8afCbQrv9CPWMFbxB6EAlYJ/xtyWMUdLXvd0eFda/AWe3z7A2loF2RXAzFIM8T7dmwdtABZIU0TiPTtShDU0iWyZSCrgFe3ZST+NKceFxW+KMxbz5vUC2qFo5IFiv+eoTUqaChIITTcCaoVTkaRJB7uQC/p77qq0GfyNCGkgaYLBNUQgmsOMW5yzHylcVWEMFl2D2KfSgr0ekpQlg4lOdUCJUmPOpqcGVokHBtncfLVmKpCZA8iAlU11fqy7qL7s76sW6j64rED8Zef14d/ANp7k+2x8AjJAAAAAElFTkSuQmCC"
  , CloseFilterDropdown = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAA2CAMAAAC2heqoAAAAAXNSR0IArs4c6QAAADxQTFRFR3BMCAMDSyIbAAAAViojAAAAFgoIAAAAEggGVikjMRcTQR8aVyojUSchUSYh////4NjX0MPCYzgzVyoktHm+fQAAAA90Uk5TAA8iSGZwgICQnLLO3+/v+UcUBgAAAUBJREFUeNp11luugzAMRVEnUB59EEjmP9fLtRpZ6sn2X9S1Jfggrv1Pmvd9NhoV+d1qbe8sTEQ/1auUq0Ih4j6d5Z4TChF+0kK9i2Rzu0qJAr3P1WbbaylSiO9Tdw+kEB+BP5IU4uOR/KWxyPKjmS2HFOiPJVleNy3Ib+tk0zoqyHswLMDfQV7Hxdiv2ewxLsb+YWZpXIx9MizIYwEeCvRQoIcCPRTosWCvxfb5DT5beCm+XorupVjcS7GEx+8XvijwVLDngv15QkG+VijIHwcU5LcNCvJ0l7CHAj0V7LmA+wRuH/PrfuBT0qJvIPhepJANxPeVbiD1WvRHSv7S4qWQDaQ+ihCL+QbyPwbio+giNlCrtYWXIoQH9zxfr+caXgsXt/cgBu+rmOxn8VTEBmIvIs7gRfgZPYg8TRlsiMn9H8gRWB9y4kglAAAAAElFTkSuQmCC"
  , DescImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGwAAABsCAMAAAC4uKf/AAAAAXNSR0IArs4c6QAAAEtQTFRFbTUoR3BMZjAiajMnm0wwlUgubTQkikMrgD4rXSwefDwrcjcoQR8TNBkQZjEnRCEZVCgh////7unp2c7NvaupoomGf11ZaD86Vyokhf0dfAAAABF0Uk5TvwAUWYCGjY6do6a0tcHS2u0tBFCgAAADnUlEQVR42u3a3W7jIBQE4GPM/4lJNmlS3v9JFwjao0bZDVPcSit1rut+HTzlyrQ8Rq2rjUxziXZd1fIYepQs7Rb76NFHimnfaPU37E4xe2eMnopxzjO1rE8x5RvlxZmMuXtRCfahFju9a1z7pesjtlKJ17vHy1EWTCw2+gtiWDQCrBlNMMWYhWus/mARtXDNN6wfImLhWjvIhil4hy5Gh26SVcM0EYOPwn8et2rUijn0UNBnXKtGy4oWY2phvBotHjwSTz0OfMoupGSKSDH4FiAqlJwiUqzFo+dYMY+tQ4JU8xWz2OFHIknE9mgpCoYWQ5+M4GnwR4whrD0Mr0PioTlCmOFHjA2KwcXwajhm6EkMiKGzxzeCY46exqEYPnsJwxi+DomHMbyYBMbwKUrMd2L/6zsTjQELwKD8YD/Y92GcTvllTol3wHyXBjw/i3EGwnOYyzm/X8+/Xuby9l67TWGnYhVqJOeipRnMl2JiDWh+Aks5X38N55ozfR4zBbuMY5ecTxPNTnKKAzlPYnCzb3tnbzmnCYxl+QMpa+QJLORSDRhjDhPY4Qj8UxfreJjBtjKR23ixbQ475sFBXqo1hYVtuFq9h6exLef8NjD7VmyzE5gpz7eNjFzCRymGYlJtZP5XKQZjkkOrls+vZi/FJjC7jWzk2taxuUlMh03m/2IdQc9irm/k9ew3B2DA/IFiGGYOMn9w9jimrcwfmz2OyfwvwOwBDJr/TdYxj8lGLsA6AAy4Ivtt73AMvyKvUmwSk8j8sdnjmGzkOjB7AAPmL7MPel/MyPzRSxHH5IrEZy9YEgybv6zDoRgwf3AdgiXB0PnLpbg/JlfkuVs3KYZgULXe7XID1tGwVLBUMWQjpdztWqh2iJtDMEpk9GBC13qOSDFzx5IBqrX31nLaSg7Dz7pq2ZS81sBGartjKdVi9Wh8SqFibDSwEUmdPXKKltYEV5M4PZpYsJVUwaLTwEYkYfwQY2EULSEl/pR2GLdc5JTCQsuaEkVAM6FTDrBqsbVgimq16PU4Z611RgNnWIslVbBeLXoDcMjP+tiK2aVivRpylADlYuzFKtaqpVjjd+ca1d9YxUpC0xrnzc6tusXykRfdte45Y+YdVySxSHWsHaRou4faIQr2lVq6Wx0TjfenuFuCNY2+gGOq76tZgvWV7MwRpZKgnn8Am1qIeF7kWkpqCSblbNo5q/rnR8thPykIJdijZwNNMkTWPvkc+zdP8CCy1SI8xAAAAABJRU5ErkJggg=="
  , FilterArrows = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAoCAMAAAChHKjRAAAAAXNSR0IArs4c6QAAADBQTFRFR3BMAAAANxkUVyclBQIBAgEAAAAAGQsKVyokUygi////9PLy6uXklnp2lnl3VyokRTurdwAAAAp0Uk5TABAcMF13gJW36lovA+AAAAEUSURBVHjazdNbrsMgDARQoLwcSLz/3d66mIyUuf3vfETYOlKEsIMnddGeQuAaeYm+I6/brDo9zDnmCdVX3R/meAdKdR7HUCEDZchKVTJQQGSgCKVtoBKhvg1UJ6Q6rb7sY9zuREh0mFlNU1P1v9/NcXlznTuhrBZvrhRCtYmq7KadG6NSLbtZPyGUGWVCsTxRiYRCzLXk3bRzDIz41X8N+Z7s2s6JUZLnM0kitPbEa98ZQmu+TozOUCFk82Xq/kxVQjTOl3ZCWZeC0UKotqVgGqPiCqZWQrm6gsk3Gn6PWJaCKdGRrD0RexZXc7hJwdP0kxagLDDYmVaDK69hsDPVkCsLDHbG7wEFg52xe0CR8Z2JX+o/y4InKpKiVdkAAAAASUVORK5CYII="
  , CheckMarkImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAwCAMAAABtwnnyAAAAAXNSR0IArs4c6QAAABhQTFRFR3BMVycgVygjWCojViokViokVykjVyokRuYB5gAAAAd0Uk5TAB5GYIDL4Z4bFLIAAACUSURBVHja7dYxEsMwDAPBo2AJ//9xCpf0DMdoUiTXb3/8u9M5V/G2y7Z3Bep2gWpuVIMblL0jZa9IeUXKFSl9SVUFqo69K1H2qUDdLlDNjaq5UXHs5ma17OZmxXJ3s6JOc7N6ds9qdo9qdo9qdl0FThA4QeAEgRMEThA4QeAEgRMEThA4QeAEgRMETryttvf64Y36AIg4FWo0NikSAAAAAElFTkSuQmCC"
  , FilterIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAA7CAMAAAAHBYkxAAAAAXNSR0IArs4c6QAAAFdQTFRFR3BMKRAQPBsWAAAAAAAAAQAAVyojAgEAUigiAAAACQQEEwkHTCQfNhoWVyokUCchUyci////9PLy6OLh1crIwK+ttaKfq5SRoYeEhmZib0lDYjcyVyokzszDLAAAABF0Uk5TAAseL0tfYHR5gIiQmbrG4PKPaNbbAAABmklEQVR42u2VUVuDIBhGP5iGZAromlu+//93BrWNh9406qabnfvjp8ARKVDd6AA/dlrq0SPuvFSLnQcyvqu0ELm8ziHMrxdEulrr7RiuzG91nvbRmsKdKXpeSwEtH4BsZe9bxidJaIdP5lBwxBZOR+1mXcIXLtuekicAyxTuLOt6DjtMJwCdjMApZM6ILGGPBRgFwBQyKyLrrjYB+Ks2lu+0IHLe1U7AKC8ATnleOK/rsjtrAdCJ8b/fAG/E9jfvWFrzttVbMdYO7jeHyw3P1khrP+j5KCfKlAZ7pZWD/WRA9OabdUwWpXT3DiJt9spnA5xSfx0motrBgdj+Wjc0KofDcEoUDrGxkxQOwSlxOAynxOEQ3ASHU69xOAynxOEQlBKFU78BHA7DKVE4dYeLwqk+yhQOZ0IpUTjVmVI49T+FRj1unMeN8w83Ts6EoHAoE2b/xtmycjjNzfNAxm9bjZKEbto2zexdtlyfnvodjZaMMjaJg/OAT4sVMUp+RCevREsFhy+eOUgVyhQWzaoYaBoldeRFbZsfJ70DIafMPP8rxQ0AAAAASUVORK5CYII="
  , FiltersContainer = re$4("div", {
    display: "flex",
    justifyContent: "center",
    gap: "8px",
    width: "100%",
    marginBottom: "20px"
})
  , ButtonGroup = re$4("div", {
    display: "flex",
    borderRadius: "12px",
    padding: "1px",
    border: "1px solid #572A24",
    background: "#9C4C30",
    boxShadow: "0px 4px 0px 0px rgba(0, 0, 0, 0.30) inset"
})
  , DropdownButton = re$4("button", {
    width: "40vw",
    padding: "0px 10px",
    position: "relative",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    borderRadius: "8px",
    border: "1px solid rgba(87, 42, 36, 0.50)",
    background: "rgba(156, 76, 48, 0.50)",
    boxShadow: "0px -3px 0px 0px rgba(87, 42, 36, 0.30) inset",
    "&:hover > ul": {
        display: "block"
    }
})
  , DropdownList = re$4("ul", {
    position: "absolute",
    width: "40vw",
    display: "none",
    listStyle: "none",
    margin: 0,
    backgroundColor: "#FFF",
    borderRadius: "8px",
    boxShadow: "0 4px 8px rgba(0, 0, 0, 0.1)",
    bottom: "-100px",
    left: 0,
    zIndex: "100",
    border: "1px solid rgba(120, 44, 4, 0.50)",
    background: "linear-gradient(0deg, rgba(156, 76, 48, 0.45) 0%, rgba(156, 76, 48, 0.45) 100%), #F9EFE2"
})
  , DropdownItem = re$4("li", {
    padding: "16px",
    background: "linear-gradient(0deg, rgba(156, 76, 48, 0.45) 0%, rgba(156, 76, 48, 0.45) 100%), #F9EFE2",
    borderRadius: "7px 7px 0px 0px",
    cursor: "pointer",
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "500",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    variants: {
        active: {
            true: {
                background: "linear-gradient(0deg, rgba(156, 76, 48, 0.15) 0%, rgba(156, 76, 48, 0.15) 100%), #F9EFE2"
            }
        }
    }
})
  , DropDownText = re$4("p", {
    color: "#FFF",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
})
  , FilterButton = re$4("button", {
    cursor: "pointer",
    border: 0,
    padding: "7px",
    variants: {
        active: {
            true: {
                borderRadius: "10px",
                border: "1px solid #572A24",
                background: `linear-gradient(0deg, rgba(156, 76, 48, 0.30) 0%, rgba(156, 76, 48, 0.30) 100%), 
               linear-gradient(101deg, #FFF5F1 0%, #DAA592 100%)`,
                boxShadow: `0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
              0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset`
            },
            false: {
                backgroundColor: "transparent"
            }
        }
    }
})
  , FilterButtonText = re$4("p", {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    variants: {
        active: {
            true: {
                color: "#FFF",
                textAlign: "center",
                textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
                WebkitTextStrokeWidth: "1px",
                WebkitTextStrokeColor: "#532912",
                fontFamily: "Rubik",
                fontSize: "20px",
                fontStyle: "normal",
                fontWeight: "800",
                lineHeight: "20px",
                letterSpacing: "-0.4px"
            },
            false: {
                color: "#C7775B",
                textShadow: "0px 2px 0px #6E3522",
                WebkitTextStrokeWidth: "1px",
                WebkitTextStrokeColor: "#572A24",
                fontFamily: "Rubik",
                fontSize: "20px",
                fontStyle: "normal",
                fontWeight: "800",
                lineHeight: "20px",
                letterSpacing: "-0.4px"
            }
        }
    }
})
  , SortButton = re$4(FilterButton, {
    width: "40px",
    height: "40px",
    borderRadius: "12px",
    background: "rgba(156, 76, 48, 0.30)",
    display: "flex",
    padding: "4px 10px",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    border: "0"
})
  , FilterModalButton = re$4(SortButton, {
    border: "1px solid rgba(87, 42, 36, 0.50)",
    background: "rgba(156, 76, 48, 0.50)",
    boxShadow: "0px -3px 0px 0px rgba(87, 42, 36, 0.30) inset",
    width: "40px",
    height: "40px"
})
  , Icon = re$4("img", {
    height: "40px",
    width: "40px"
})
  , DropDownValues = {
    price: "Total price",
    price_per_potato: "Price",
    amount: "Amount"
}
  , FilterSystem = observer(({openModalHandler: C})=>{
    const {ordersStore: S} = useStores()
      , {isConnected: E, connect: M} = useConnectWallet()
      , T = useTonAddress()
      , [$,B] = reactExports.useState("all")
      , [O,F] = reactExports.useState("price")
      , [N,U] = reactExports.useState(!1)
      , {t: H} = useTranslation()
      , [Z,J] = reactExports.useState("ASC")
      , ie = ()=>U(!N)
      , oe = se=>{
        se !== "price" && se !== "price_per_potato" && se !== "amount" || (F(se),
        U(!1))
    }
      , ae = se=>{
        se !== "ASC" && se !== "DESC" || J(se)
    }
    ;
    return reactExports.useEffect(()=>{
        S.setDirection(Z)
    }
    , [Z]),
    reactExports.useEffect(()=>{
        S.setSort(O)
    }
    , [O]),
    reactExports.useEffect(()=>{
        $ === "mine" && T ? S.setAddress(T) : S.setAddress(void 0)
    }
    , [$, T]),
    jsxRuntimeExports.jsxs(FiltersContainer, {
        children: [jsxRuntimeExports.jsxs(ButtonGroup, {
            children: [jsxRuntimeExports.jsx(FilterButton, {
                active: $ === "all",
                onClick: ()=>B("all"),
                children: jsxRuntimeExports.jsx(FilterButtonText, {
                    active: $ === "all",
                    children: H("All")
                })
            }), jsxRuntimeExports.jsx(FilterButton, {
                active: $ === "mine",
                onClick: ()=>{
                    if (!E) {
                        M();
                        return
                    }
                    B("mine")
                }
                ,
                children: jsxRuntimeExports.jsx(FilterButtonText, {
                    active: $ === "mine",
                    children: H("Mine")
                })
            })]
        }), jsxRuntimeExports.jsxs(DropdownButton, {
            onClick: ie,
            children: [jsxRuntimeExports.jsx(DropDownText, {
                children: DropDownValues[O]
            }), N && jsxRuntimeExports.jsxs(DropdownList, {
                children: [jsxRuntimeExports.jsxs(DropdownItem, {
                    style: {
                        borderRadius: "7px 7px 0px 0px"
                    },
                    active: O === "price_per_potato",
                    onClick: ()=>oe("price_per_potato"),
                    children: [H("Price"), O === "price_per_potato" && jsxRuntimeExports.jsx("img", {
                        src: CheckMarkImage,
                        style: {
                            width: "16px",
                            height: "16px"
                        }
                    })]
                }), jsxRuntimeExports.jsxs(DropdownItem, {
                    style: {
                        borderRadius: "0px 0px 7px 7px"
                    },
                    active: O === "price",
                    onClick: ()=>oe("price"),
                    children: [H("TotalPrice"), O === "price" && jsxRuntimeExports.jsx("img", {
                        src: CheckMarkImage,
                        style: {
                            width: "16px",
                            height: "16px"
                        }
                    })]
                }), jsxRuntimeExports.jsxs(DropdownItem, {
                    style: {
                        borderRadius: "0px 0px 7px 7px"
                    },
                    active: O === "amount",
                    onClick: ()=>oe("amount"),
                    children: [H("Amount"), O === "amount" && jsxRuntimeExports.jsx("img", {
                        src: CheckMarkImage,
                        style: {
                            width: "16px",
                            height: "16px"
                        }
                    })]
                })]
            }), !N && jsxRuntimeExports.jsx("img", {
                src: FilterArrows,
                style: {
                    width: "16px",
                    height: "16px"
                }
            }), N && jsxRuntimeExports.jsx("img", {
                src: CloseFilterDropdown,
                style: {
                    width: "16px",
                    height: "16px"
                }
            })]
        }), jsxRuntimeExports.jsx(SortButton, {
            onClick: ()=>ae(Z === "ASC" ? "DESC" : "ASC"),
            children: Z === "ASC" ? jsxRuntimeExports.jsx(Icon, {
                src: DescImg
            }) : jsxRuntimeExports.jsx(Icon, {
                src: AscImg
            })
        }), jsxRuntimeExports.jsx(FilterModalButton, {
            onClick: C,
            children: jsxRuntimeExports.jsx(Icon, {
                src: FilterIcon,
                style: {
                    width: "16px",
                    height: "16px"
                }
            })
        })]
    })
}
)
  , Container$6 = re$4("button", {
    width: "calc(100% - 40px)",
    height: "40px",
    borderRadius: "9px",
    background: `
    linear-gradient(to bottom right, #5DDB22 0%, #29EB82 100%)
  `,
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px 6px 0px 0px #1C8552
  `,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #0B3523",
    marginLeft: "20px",
    marginTop: "16px",
    position: "relative"
})
  , ButtonText$4 = re$4("img", {
    width: "61%",
    position: "relative",
    zIndex: 100
})
  , Glare$3 = re$4("img", {
    position: "absolute",
    width: "100%",
    left: 0,
    top: 0,
    zIndex: 10
})
  , BuyButton = ({onClick: C})=>{
    const {t: S, i18n: E} = useTranslation();
    return jsxRuntimeExports.jsxs(Container$6, {
        onClick: C,
        children: [jsxRuntimeExports.jsx(Glare$3, {
            src: ButtonGlare$5
        }), jsxRuntimeExports.jsx(ButtonText$4, {
            src: S("BuyButtonText"),
            style: {
                width: `${E.language === "ch" ? "50px" : "61%"}`
            }
        })]
    })
}
  , Container$5 = re$4("button", {
    width: "calc(100% - 40px)",
    height: "40px",
    borderRadius: "9px",
    background: "linear-gradient(135deg, #C7000C 0%, #FF5C83 100%)",
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px 6px 0px 0px #702025
  `,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #0B3523",
    marginLeft: "20px",
    marginTop: "16px",
    position: "relative"
})
  , ButtonText$3 = re$4("img", {
    width: "77.5%",
    position: "relative",
    zIndex: 100
})
  , Glare$2 = re$4("img", {
    position: "absolute",
    width: "100%",
    left: 0,
    top: 0,
    zIndex: 10
})
  , CancelButton = ({onClick: C})=>{
    const {t: S, i18n: E} = useTranslation();
    return jsxRuntimeExports.jsxs(Container$5, {
        onClick: C,
        children: [jsxRuntimeExports.jsx(Glare$2, {
            src: ButtonGlare$5
        }), jsxRuntimeExports.jsx(ButtonText$3, {
            src: S("CancelButtonText"),
            style: {
                width: `${E.language === "ch" ? "48px" : "77.5%"}`
            }
        })]
    })
}
  , BlueCoin = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABYCAMAAABVnIDyAAAAAXNSR0IArs4c6QAAATtQTFRFR3BMAAofB1f0D3v9AAAAAAAAAAAAAAAAAzOrAAADAAAAE4f9Eob8D3H+AiJyABBGAAAABk/7Dnr7EYb/DG39EIL9ABRJAA4vBkbnARZEEIH+ASFzBDSqAAkhB1D7Bj28FpL+DnrmBkjlBTy+BUHREYP9CXTJEYH+EZT4Cmj6CVajCGanAy+YBV2bAC5JBkPXj+H/CWP5EYL9AxzNZcr/ZMn/BCbSEHj6B0XhDG77Ss38B0voFIn9B0/7Bk3xC1nqf9P+O8D8CzHVDWryXr/+Ay+eBDzDBTfcJKX9B0PXBDi3AiF1AiaEAyqRAh1lG5j9Ioz8QsP6BT/OL5b8QKT+VLL7c87/MLr9QYbrNGvjN7D3ABZWJLD9VZ3wG3C7iN3/EVqkJl3fDmPuH0nZLJ3lI43WDUqPJYDmb7X0tmgihQAAADB0Uk5TAI/9f20SKYD+WEDfmBC7+nibRCBk8N23/5+/6NahzPerraud76/nz/cwiOd0vHDn+Qj0tgAAB1hJREFUeNqll3lb2mgUxcNSI4rVupXW1v7TdTqdkQTyBgiETYltFSKyiopr+/0/wdx3z4KGOkd9XB78ec4996IqkdrYTKc/LW9pmra1/PpDYn1F+R9a2UwDKaBP6fUn0tZfaw9oObHx57gEeHtE6Y0/xkXIAuQTcahxbdsl2240/MTPiTl568uaUMNuGbpU3fRCreWNeeylJa0kYFKGZFqWk16JXLtlgWtJSMssYZmtOvnU1ric5Ygd2twSOOHoGmmabwjwRSSIk0cnmeA9mDJfWMg2dFNjak/S0byGQXE20h6QbQiTjrO7EsEzGU57TCWDm590gPgID9UJz0RQ42m/unfZP51JRPwnWgNt9zEeiUt+fLe6R1WdjTQZsT3IvpixzpzH7Wmne1LV7sxJNlhop7wZ3j8Pr6SBOns+NTuziIiHjn8JAL08mqQPlEjkNWt6UN6dOcC65HX3wuqFkIiGtmqdcsIXmE1Z8rQmZQyvzgUv3E4hm2VTHJTjG6HAtpgfiDb8Gz/FPIREWVBBw+rUtLKn6U0xQHpSsuKRUcfI377ChT0QtzhwyuUNaZAHllefp99sIHrXo6qvHW5PWnRqZWpRGmzoIMKTO3OODc9EUnsS2IZa4is+g4YYoEx8g9h2GPrQW3e/2c0K0cfUIPOm16AtAsslrLY0rp4Hd5nL5fPNjh84hsy7XoMtsTFyCUf8C1bT20o+l8+Bmsg3RDdbLpPM62KCBufxJawjxhNXM7rp93OEBybzpwXZc9tFLHOaViwNyiU0WUOSB4+66mEcoeabBQG03C70LBIjajCwhNeUV+Wzu9HJWo56lAfqkSEK4K5IbNOdDiyhn1cFXjabMWDRhwCkL13RijsukyEmRCVIm7WEXcGr6/UsiCHzNHhTtFKrAXBdUV7zJaxrs5aweyl5rSxVHA/8huTO5woSWCGtbPGOZeI+I2B2gMeRLTAAgeG14wMmlC9ihI1A4qEtvELhhm5mvYrX9WYelPMDX7BOcIbwEsrzOBc8qWGeWEQc6BKg7KQVXMKW4F0OdT3jZQHitIn3EGTzlovjSgWAad6JGTy7a8EbBXjdXhMXQnjDSgD4gQPtYGJ+vn3gxQUMdXtAwuboRdfjDNgudiuVygu2NboEdqir3+fMXm6kG4xXQBAURMzRD0YGPz2n2MEOJbDhX8Iqeyd4hQ4OSjEg7A54eoZ3Mi42/A4bYgmlLvvNK+CRoOzYqOgKnh/qhjyUYgWUkIfS8Cbm9pr4WyAoOQp+vwTWHF4ZOjVPnxuK4xIA/2alSGDPYy/XOzSugEZZtAjy2hve6CB22xrrhALTfA+v2RJKe7nm8Bw4nMaQ+fNRnf3hXQGaHOF1CYgpBjRDf4D0c0wyJyBxUOotE/f/SnHdEgD/TSl/8VsueZfwUsCIACWCgloZ79GwpelmAPiGAxG7FIvHFVHz7H0gqBTiiQGY+ZZS/tFYKwZfQmiD7i436A8alEY7ds1MplR5taSktjSsEn3C7jN7eYp6MGjY4C/TzJTeqwD8yH+LQs0dbM8zumDQsArCIPBKb9QFJfVNY4tjQmKwR/xFBJXShEFQ6RUGxixm0UBap8+cRQQVQtygDTxIrCrKkvqRW7RRZQiw6KAysDB4eAiZn6tJRVlQWeYGHFJJvzqPChoO3C66wAPF1BQGQmZ2LZUssGTQOXmWW7w6BJlvVChZeaaqX/m/PPVs3JBBo3k88C3hgUH1maIoa+qrNieCr4ovaHQhmgOBTzARDCYVUEpVP1p8jFGQsD+rWDw8wcD3YBBGiGtWX37WqOzWH/Pc4q+TE0x8rqqwhQoZYuxrmxPN+XAFD++A8N6rNDEoCRbvLI2lnmuESPJuDw6Iwxg1yDKr221ORPPYk7zxAQVCYNIxy6y+vXcoMRpZQH4eIULDrBLaM4SeSqJWiMDxAynefie8g3cxj0F8LDi0JIJQJA72r3j3/TsmAk8YFLWosdXpBLqWKhTCNCmrVnQvCA/0CvOSxCCvhRMtzSuEUIEIUZbEgb3xO+ARJC6EnLHPIoxx9d7BJqPVdovu3eIixb0DnthBOUVKPL6dOFYkboDbAB5BviN5ZSOyaNDb1dVpBNJyXEg7XQQRh4sxNRBY7CKd4+rxxWTAZhmWMyiCu4v9xf19inxDebJh2Qsjbq+eHV/cDgYTJwC12s7ABd1O97EWifD4ZMOh0GyQZ2dn93cDrMnEcZw2vE0GNRfr7mL/CF4wEJDcnroW5kHopMpNnoGO7y/uxoNBbVDDAtz47mL68wgEPEok9mQhYeKaKk0S5vGP+/vpBWg6vf9JdATIfYp8HhO8BQkJ7g6P8HIbeEDE+nH8A/TzB+MR3I4Htwa8KCLoLSADPEF8TlcvPL8wcc3zQGByokQe7XDaw/2Gm5HM2NuX29s7Oxi4swOsmEyqioOLJM6vtSUlWkvz81I0bqTJVAQnst1wN8knpn06MhnGRQdfe9gchH2KFlLJGd4iaFE+F5ZSqSTmriWTqaWFOWr9D4+hNkvPQtBmAAAAAElFTkSuQmCC"
  , InfoImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVYAAAAkBAMAAAAgHA/OAAAAAXNSR0IArs4c6QAAABtQTFRFR3BMUCUgVygiVykjVikjVyokVykkVyojVyokVInhdwAAAAh0Uk5TABAlVX6yw+B6TIF1AAABNElEQVR42tXSIVfCUByG8ZcxxbjgOVYOFuKCgTg1uEiBES3TRTnHwc1z7D4f2wOiTtT+v7/y1ie8khY9z1vM8H6z6JHUby0cxjz917rFns3frQ6LfNlv7afW9xNZMbkpALa/Wyugu5Mt14eq09YCeE1kTVQA9UmrzVRp8ACUP1oraBNZFK2g67cW4FPZFDmoe60ObmXVJfjv1gJa2ZVD/dVaQSq7htB9ti6hkWVTKI+tK0hl2RB2x1ZHK9ty/EfrEjLZFkOpvRU+kW0Dx057jkbWzfD7iWAu62JIDuPHkv0TZJJGtLIvZy1pxlr2XdFKqpjLvphOimAs+waQaEinEFRkOudNIch51AWNQjBlrRkvCsGIRjlzheCMVjmZQhDTqiJVCIbsVDFWCCK8XECtoDBASK3va1vNgCy25ScAAAAASUVORK5CYII="
  , PotatoToken$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAMAAADZqYNOAAAAAXNSR0IArs4c6QAAAOdQTFRFR3BMGQYAKgkAGQcAFgYAAAAARhMACgMAAAAADgMARxMAHwgAOA8AOhAANQ4AShgAYTEDRRUAXy8DRRUAShYA/fqm/fiN/vZz/vNj//NR//M5/uo1/eQz/eIi+t4r+9Yq+NIa9csX88cT5sga8cMS8b8Q77wQ7rgO67QN3rcT6rAL8KkJ6KsK0bEW5qQH4p4FzKYS4ZkE7JIFxaIT3pYC3JEC54UF2YwBwpMN3YQE04MAz3wByHYB0WUCv2sBnXUNumMAtV8AsloAq1QAjV4Iok0Aj1MCm0YAkz0AhjQAeCoAZCMAUhgA2rCbzgAAABV0Uk5TAA4hPU5gZ3WAjpikp73Nz9/f7+731yMw4wAAAgZJREFUeNpl001PE1EUxvHnec69d4aRtmlKEGiLhY0S4koTdSMxYQffVxe60IQYFsQvQNy50PgSFKW0c+c60xKs8D/LX87mJAf/Z0Wre3DYCrgds97eo9FwONzZ795y193b7G8MR4P+5mjnoMBiLPY2N+oGtQ5GW1v7i6zOw/766upav98fDO7d393ebthdYbv3LVZoIkzVRPj04lUkmtjpXZQJkCMkEgK59uHXXJeHZw2acWbGBGXL3ZczDc9OYwRNJoI1YMqMdzpvHAAtf0ygjG5mYJlqBEpHAMX6GGh4bs14g4rsxAA9/5KukfO8aF6fBeRfqxmSUr4080xmtcIB4QcIGAUW7TI/I4IH5eUqwR4nAq5BFpexpFwA4TxYOWTntEQHEhz78rcpBxFMUiJag3GqzMjGrTR5FybBXEj+NdHpRcALBCEI3kHO5OHfnwsSILFOiyjTBAKc4MmiECTlTvINwd7FimjtfieI4pKABcic6Aw6/pMuDWH7JwlVhDInF5wkB+m0ipHIWv0pICgQ8o6EGaS3U0wqg8ODC7PmhApL0vzGDZYRQlWe3A1e8NlSNgXNSzquMUWAMM/iyUUUwfK861l3NE7ApGqUgfDhaUyVGgGPJhHANGKW5XV32t2Vw8OVXru1lDcZrqLPb5bZ4v/cQE8sZovu9W8P8ySKSIipSteIvyD8gZRRSH34AAAAAElFTkSuQmCC"
  , BackgroundImage$2 = "/assets/ProductCardBackground-DiGBcFAb.png"
  , BlurButton = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAA4CAYAAABQb1WFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHHSURBVHgB7dwxixNBGMfhiWihjSCCjbWVH8VvfoUK2mxrQAKucBaxOGF9525OosYzyl3yL54HXjZswqb7MTsJu1qW5VUDCHKvAYQRJiCOMAFxhAmII0xAHGEC4ggTEEeYgDjCBMQRJiCOMAFxhAmII0xAHGEC4ggTEEeYgDjCBMQRJiCOMAFxhAmII0xAHGEC4ggTEEeYgDjCBMQRJiCOMAFxhAmII0xAHGEC4ggTEEeYgDjCBMQRJiCOMAFxhAmII0xAHGEC4ggTEOd++zcXNZuaTzVfarar1epbAxiWZemH3pbHNQ9rntY8qXl06DUODdNcM9WcCxFwk2pEP/ROzOPUesTqec2LdkCg/hambc37+qJNA/hPI1Y9UOt2QKBuClOP0WsrJOC29ECNOPXV1MuaZ/s+96fN76kucCZKwG3rcar5Wi/P2tUW0W/2halHaWoAd2jc3k1tT5x+DdNGlIBj2YnTT/vYu2HqG93vGsDxvWlXDbq0G6Zp3PcBHM1YNfX/SL69PncdprneXDeAExhxmsf8CNOHBnB6l3vcPUxbqyXg1HZWTRc9TJ8bQI51D9PHBpDjvIfJL3FAknnVAEKMpxA8+A7XdEti1SLiEQAAAABJRU5ErkJggg=="
  , useCancel = ()=>{
    const {isConnected: C} = useConnectWallet()
      , {wrapPromise: S} = useStatusState()
      , {userStore: E} = useStores()
      , M = useTonAddress();
    return {
        cancel: reactExports.useCallback(S(async({onSuccess: $, id: B})=>{
            if (!C || M === "" || !E.user)
                return;
            const O = await api.v1OrdersCancelCreate({
                order_id: B
            });
            $ == null || $(O.data)
        }
        ), [C, M])
    }
}
  , ModalContainer$3 = re$4("div", {
    width: "354px",
    background: `url(${BackgroundImage$3})`,
    position: "relative",
    padding: "8px",
    minHeight: "228px"
})
  , CloseButton$3 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , ModalText$1 = re$4("p", {
    color: "#FFF",
    textAlign: "center",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "120%",
    marginTop: "52px",
    marginBottom: "28px"
})
  , ButtonContainer$1 = re$4("div", {
    display: "flex",
    justifyContent: "space-between",
    width: "calc(100% - 40px)",
    marginLeft: "16px"
})
  , ModalButton$1 = re$4("button", {
    borderRadius: "12px",
    border: "4px solid #FFF",
    background: "linear-gradient(135deg, #465D6A 0%, #757ECF 100%)",
    boxShadow: "0px 8px 0px 0px #242D3A",
    width: "calc((50% - 4px))",
    color: "#FFF",
    fontFamily: "Rubik",
    fontSize: "32px",
    fontStyle: "normal",
    fontWeight: "900",
    lineHeight: "32px",
    textTransform: "uppercase",
    padding: "8px 0",
    position: "relative"
})
  , Blur$1 = re$4("img", {
    width: "100%",
    position: "absolute",
    left: 0,
    top: 0
});
function CancelModalContainer({onClose: C, order: S}) {
    const {id: E, seller_address: M} = S
      , {t: T} = useTranslation()
      , $ = useTonAddress()
      , {userStore: B, ordersStore: O} = useStores()
      , {cancel: F} = useCancel()
      , N = reactExports.useCallback(async()=>{
        M && dist$4.Address.parse(M).toString() === dist$4.Address.parse($).toString() && await F({
            onSuccess: ()=>{
                O.reload(),
                B.reload(),
                C == null || C()
            }
            ,
            id: E.toString()
        })
    }
    , [C, M, E, $]);
    return jsxRuntimeExports.jsxs(ModalContainer$3, {
        children: [jsxRuntimeExports.jsx(CloseButton$3, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(ModalText$1, {
            children: T("cancelModalText")
        }), jsxRuntimeExports.jsxs(ButtonContainer$1, {
            children: [jsxRuntimeExports.jsxs(ModalButton$1, {
                onClick: C,
                children: [jsxRuntimeExports.jsx(Blur$1, {
                    src: BlurButton
                }), T("No")]
            }), jsxRuntimeExports.jsxs(ModalButton$1, {
                style: {
                    background: "linear-gradient(135deg, #C7000C 0%, #FF5C83 100%)"
                },
                onClick: N,
                children: [jsxRuntimeExports.jsx(Blur$1, {
                    src: BlurButton
                }), T("Yes")]
            })]
        })]
    })
}
function CancelModal({open: C, onClose: S, order: E}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(CancelModalContainer, {
            onClose: S,
            order: E
        })
    })
}
const Container$4 = re$4("div", {
    background: `url(${BackgroundImage$2})`,
    backgroundSize: "cover",
    backgroundPosition: "center",
    width: "167px",
    height: "182px"
})
  , SellerInfoContainer = re$4("div", {
    position: "relative",
    borderRadius: "16px 16px 0 0",
    borderTop: "2px solid #572A24",
    borderRight: "2px solid #572A24",
    borderLeft: "2px solid #572A24",
    background: "rgba(87, 42, 36, 0.70)",
    borderBottom: "none",
    height: "56px",
    width: "100%",
    padding: "8px 16px"
})
  , InfoContainerImage = re$4("img", {
    width: "calc(100% + 4px)",
    position: "absolute",
    bottom: "-16px",
    left: "-2px"
})
  , SellerText = re$4("div", {
    overflow: "hidden",
    color: "#FFF",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "16px",
    letterSpacing: "-0.32px",
    display: "flex",
    gap: "4px"
})
  , SellerWallet = re$4("div", {
    overflow: "hidden",
    color: "#FFF",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    lineHeight: "16px",
    letterSpacing: "-0.32px",
    WebkitTextStrokeWidth: "0px",
    fontWeight: "400"
})
  , PotatoPriceText = re$4("span", {
    color: "rgba(255, 255, 255, 0.50)",
    fontFamily: "Rubik",
    fontSize: "16px",
    fontStyle: "normal",
    fontWeight: "500",
    lineHeight: "16px",
    letterSpacing: "-0.64px",
    overflow: "hidden",
    textOverflow: "ellipsis"
})
  , PotatoProfitContainer$1 = re$4("div", {
    borderRadius: "8px",
    border: "1px solid #9C4C30",
    background: "#F9F0E2",
    boxShadow: "0px 6px 0px 0px #9C4C30 inset",
    width: "calc(100% - 16px)",
    marginLeft: "8px",
    marginTop: "8px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column",
    padding: "12px 8px 8px 8px",
    boxSizing: "border-box",
    gap: "8px",
    minHeight: "72px"
})
  , ResourceRow = re$4("div", {
    display: "flex",
    justifyContent: "space-between",
    width: "100%"
})
  , PotatoText = re$4("p", {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    width: "calc(100% - 28px)",
    overflow: "hidden",
    textOverflow: "ellipsis"
})
  , TonText$1 = re$4("p", {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    opacity: .3,
    width: "calc(100% - 28px)",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
})
  , ProductCard = observer(({order: C})=>{
    const {seller_address: S, id: E, price: M, amount: T, price_per_potato: $} = C
      , {ordersStore: B, userStore: O, dialogStore: F} = useStores()
      , {buy: N} = useBuy()
      , U = useTonAddress()
      , H = reactExports.useCallback(()=>{
        F.open({
            Component: ErrorOrderModal,
            props: {
                text: "ErrorCancelText"
            }
        })
    }
    , [F])
      , Z = reactExports.useCallback(()=>{
        F.open({
            Component: CancelModal,
            props: {
                order: C
            }
        })
    }
    , [F, C])
      , J = reactExports.useCallback(async ie=>{
        var oe;
        if (!(!M || !S)) {
            if (ie === "cancel" && DateTime.now().toMillis() - new Date(((oe = O.user) == null ? void 0 : oe.last_order_cancel) ?? "0").getTime() < 60 * 60 * 1e3) {
                H();
                return
            }
            if (S && dist$4.Address.parse(S).toString() === dist$4.Address.parse(U).toString()) {
                Z();
                return
            }
            await N({
                id: E,
                seller: dist$4.Address.parse(S),
                price: M,
                onError: ()=>{
                    B.reload()
                }
            })
        }
    }
    , [N, S, E, M, Z, U]);
    return jsxRuntimeExports.jsxs(Container$4, {
        children: [jsxRuntimeExports.jsxs(SellerInfoContainer, {
            children: [jsxRuntimeExports.jsx(ResourceRow, {
                children: jsxRuntimeExports.jsxs(SellerText, {
                    children: ["Seller:", jsxRuntimeExports.jsx(SellerWallet, {
                        children: S
                    })]
                })
            }), jsxRuntimeExports.jsx(ResourceRow, {
                style: {
                    marginTop: "8px"
                },
                children: M && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(PotatoPriceText, {
                        children: formatFloat(($ ?? 0).toString(), 2, "up")
                    }), jsxRuntimeExports.jsx("img", {
                        src: BlueCoin,
                        style: {
                            width: "14px",
                            height: "16px"
                        }
                    }), jsxRuntimeExports.jsx(PotatoPriceText, {
                        children: "/"
                    }), jsxRuntimeExports.jsx("img", {
                        src: PotatoToken$1,
                        style: {
                            width: "16px",
                            height: "18px"
                        }
                    })]
                })
            }), jsxRuntimeExports.jsx(InfoContainerImage, {
                src: InfoImage
            })]
        }), jsxRuntimeExports.jsx(PotatoProfitContainer$1, {
            children: M && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsxs(ResourceRow, {
                    children: [jsxRuntimeExports.jsx(PotatoText, {
                        children: T
                    }), jsxRuntimeExports.jsx("img", {
                        src: PotatoToken$1,
                        style: {
                            width: "20px",
                            height: "20px"
                        }
                    })]
                }), jsxRuntimeExports.jsxs(ResourceRow, {
                    children: [jsxRuntimeExports.jsx(TonText$1, {
                        children: ` ${formatFloat((M ?? 0).toString(), 4, "up")}`
                    }), jsxRuntimeExports.jsx("img", {
                        src: BlueCoin,
                        style: {
                            width: "20px",
                            height: "22px"
                        }
                    })]
                })]
            })
        }), M && S && U && dist$4.Address.parse(S).toString() !== dist$4.Address.parse(U).toString() && jsxRuntimeExports.jsx(BuyButton, {
            onClick: ()=>J("buy")
        }), M && S && U && dist$4.Address.parse(S).toString() === dist$4.Address.parse(U).toString() && jsxRuntimeExports.jsx(CancelButton, {
            onClick: ()=>J("cancel")
        })]
    })
}
)
  , PotatoToken = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAA6CAMAAADWZboaAAAAAXNSR0IArs4c6QAAAVZQTFRFR3BM8cUXWCggbiYKWycfYjcoWiojWycgXQsDWCokXyccVyoj8scS9MMIgj4JhEoU+M4b8cUN+s0JYxYIqGgEvYEE1aMbVyokdTIPtX4P57MH9MgUViol2JcEtXwM+8wKn2MNklAHWCoj0JwJzZoLWSUfbDsg/fpf/vc2Vyok1YQB/v7N88wP9M8R9tcU99wW9dMS78EK7r4J2YsC14gC3ZMC4ZkD244C8cgN8MQM+d8X7boIjC8BtU0A+rQHu1QB++kc7LYG5aADwmUB+eMa67MFx20B664DvlwA030BkzcB6KcFmT4BplIBokIAzXYB+9IFfyYB/O8qtVwB/PNP11gB/flZ9bwH8LIK++pA/fEhbxsC/vg//vt/+eEs/vhM+cYN/vyW7IcF7JQGrUYA4LYK/v2y4GYC/vpu+Nkh9qgE+pMC/v3ChDQB5XcFtnEC2KcF9MMqZXjk0gAAACd0Uk5TAEch39APSOD+776eXNDaxx2g4en9+zCHznXxeHDyqbbd9GC+1q6BNOSX9gAABV9JREFUeNqV1ulb2lgUBnBsQcR916pPbTvTQhgQ2QKICpIYCCEQNmVRtKAiWpf+/1/mvTcLpClO53xQvvye95x7Lgm2t2pxdml3bnl5eW53e8L2P2p9e84Xj1+TOie19Kd6Ytev+AbNZu3MfVZrdqAb53OzfwLnFGXQPHMPq3PeaDSyc4v/AReXFKVT09HP3jU+X/FB0OzW211v7ysDDaJqD8pBC//4g1A225C2PrwRuasoTbf7/vvdd0qbykH6nlA+gNSsxH5wjJPLyuDMfXn3D+qS0DNIfGjyB4E4pCRFxuROLCsdt/s7HAphxF5CnkEG9oiUMmvffidn99Hs/Z0q0bBRTSL3TiiNftqxym1Fqbkvf1hljcr9ECBqbWHS0q2yN5R3o5k8lf4gJCq6Ou34RfpJJpRZ1iqdgCr9QbhwhmVfFjZ+OVsqzd2eXVUSz/1ug0ofqLfeY9nIJ+e7UbpMTsg859WFp5LsP/d6XYnIeCiTEQmNrm7OjMglH7ZikoAez0G/e4x6SEDGkxk23JVYNvay4HIM1+Lb1/f549KACH0GRJ1DJk5ZVDQaDQufXTvGoHEfri1d6N09mZFChGa7GoUMIpBab0m224124003qBHp0WQgqVPIIIUosSQvMA5tL4kBAO48oB6JSgcC/p5KB/Fg8ESTsZIAOqmdbqIGAkT/eLSqYJt7DSqvm8FQSIIEjHkFQmeonA123EZdjUqs8xzdJprxUCgJSCRCOXmeocM6thK6Q7Mm6Sfr9Pk7CUhJk2GBI9RFQ5Mdq+Qh9/chcbSJIOQJS84HMiJwVZ3OBa+MZita5IFFItR7VI+GwyJXJZSBnDgZaBT3rkUhH1ClDxJLCSWTJwiNcfV6JuwtVavVokqXbj0X9KbDpFGVtPZNMckMxhTq/UxEFEALm4QubsU9nosLOmQrneZ5/nfyFDIs1rsxsVQtynKe0tnbDlGGPBiRCUOyMdBwj/WWhGqxKj+Bkn6NdQBCAg5liMjTU4nAcCSCdjm5KsvlaXLC6Fer8TIbhQT04iJV5Ru50HYy07b114FJWpZilgiVi8X8e4bZsE288i1PpfHTUxkvWV2WcBsgi2XQSdv2a6vS6fb6jfEyE9Ylx+WIRL/klP66bbX86XTgGdJ6EQwJ6BU5jjsCLDytuJgZlaaxlF7AWEoyxpplRJe5HJGFtp1hvthsf99SyUuG9LHHjcRbsrziZJwOQgHRrG+4lMbxdUKV2REppG5SN4D5PCZFvxo1r3N/0KHrhGS1MZGZK6bqVJYxKfPORmblK2nz5Uv4g7rUIyGPUvU6YP5wyk5CUR9feT7NQ1qXIkWpRJUw5lG9nyOy7aShqA+RgHmdwwOK6ZmlXC6VStX7hfzhYXsFoerban0tpK/TlIlIXQoEHh0dEVmecjLkeGmtRf3Wbycih82q8gYQ8itD7qBaH9ey/l++ndZIQ047tXZpxy+s5DNJiY3pElNapB3IiM1kTrQxIfEQinA5MTLsFVVUpR1y9K28vhrBiz57SkaU6IMEh1kXAY3IAoFtZJol9rMaZVEx/ekuprqPjyKgOXLK6TJL2jJslBUEVeLB9/j42IWkiZiSRmKfmBPSVI5Pq95YLCLARXDpBPHx4SFm9KpG2l2QM9bfh+8W5BdRLJVKAorjhIfjB4HAYoFEttVeGfIjwFpf5j/LnAYxJCdC3hTzgGXAKReR02qz1txv858LcpVCDAlXACRuxelkUM5J27hy7NgX5p+e8gVU/vDpqVxu42hW7JiRJE5iyvG1YWfs09PvNzffq+V00gkx44wl0dL05FfGUvaZLwj8k5rc+GrXslz2mZ23+vwXtx42NkV/lEgAAAAASUVORK5CYII="
  , Wrapper = re$4("form", {
    width: "100%"
})
  , PriceInput = re$4("div", {
    width: "100%",
    display: "flex",
    margin: "30px 0px",
    gap: "1px"
})
  , Field = re$4("div", {
    display: "flex",
    width: "100%",
    height: "45px",
    alignItems: "center",
    justifyContent: "center",
    border: "1px solid #572A24",
    background: "rgba(87, 42, 36, 0.70)",
    boxShadow: "0px 3px 0px 0px #9C4C30",
    input: {
        minWidth: "50%",
        height: "100%",
        outline: "none",
        fontSize: "19px",
        borderRadius: "5px",
        textAlign: "center",
        border: 0,
        background: "transparent",
        color: "white"
    }
})
  , Slider = re$4("div", {
    height: "8px",
    position: "relative",
    borderRadius: "8px",
    border: "1px solid #572A24",
    background: "rgba(87, 42, 36, 0.70)",
    ".progress": {
        height: "100%",
        position: "absolute",
        borderRadius: "5px",
        background: "linear-gradient(87deg, #FFF500 6.28%, #F90 93.72%)"
    }
})
  , RangeInput = re$4("div", {
    position: "relative",
    input: {
        position: "absolute",
        width: "100%",
        height: "8px",
        top: "-8px",
        background: "none",
        pointerEvents: "none",
        "-webkit-appearance": "none",
        "-moz-appearance": "none"
    },
    'input[type="range"]': {
        "&::-webkit-slider-thumb": {
            height: "32px",
            width: "32px",
            borderRadius: "50%",
            background: "white",
            pointerEvents: "auto",
            "-webkit-appearance": "none",
            boxShadow: "0 0 6px rgba(0, 0, 0, 0.05)",
            border: "1px solid #572A24"
        },
        "&::-moz-range-thumb": {
            height: "32px",
            width: "32px",
            borderRadius: "50%",
            background: "white",
            pointerEvents: "auto",
            "-moz-appearance": "none",
            border: "8px solid #FFF500",
            boxShadow: "0 0 6px rgba(0, 0, 0, 0.05)"
        }
    }
})
  , DoubleRangeSlider = observer(({setMin: C, setMax: S, min: E, max: M, minValue: T, maxValue: $})=>{
    const O = reactExports.useRef(null)
      , F = reactExports.useRef(null);
    reactExports.useEffect(()=>{
        N(O),
        N(F)
    }
    , [O, F]);
    const N = Z=>{
        const J = document.createElement("span");
        J.innerHTML = Z.current.value,
        J.style.visibility = "hidden",
        J.style.whiteSpace = "nowrap",
        document.body.appendChild(J);
        const ie = J.offsetWidth;
        document.body.removeChild(J),
        Z.current.style.width = `${ie + 2}px`
    }
      , U = Z=>{
        const J = Math.min(Number(Z.target.value), M - 1e3);
        N(O),
        C(J)
    }
      , H = Z=>{
        const J = Math.max(Number(Z.target.value), E + 1e3);
        N(F),
        S(J)
    }
    ;
    return jsxRuntimeExports.jsxs(Wrapper, {
        children: [jsxRuntimeExports.jsxs(PriceInput, {
            children: [jsxRuntimeExports.jsxs(Field, {
                style: {
                    borderRadius: "8px 0px 0px 8px"
                },
                children: [jsxRuntimeExports.jsx("input", {
                    ref: O,
                    type: "number",
                    className: "input-min",
                    value: E,
                    onChange: U
                }), jsxRuntimeExports.jsx("img", {
                    src: PotatoToken,
                    style: {
                        width: "24px",
                        height: "24px"
                    }
                })]
            }), jsxRuntimeExports.jsxs(Field, {
                style: {
                    borderRadius: "0px 8px 8px 0px"
                },
                children: [jsxRuntimeExports.jsx("input", {
                    ref: F,
                    type: "number",
                    className: "input-max",
                    value: M,
                    onChange: H
                }), jsxRuntimeExports.jsx("img", {
                    src: PotatoToken,
                    style: {
                        width: "24px",
                        height: "24px"
                    }
                })]
            })]
        }), jsxRuntimeExports.jsx(Slider, {
            children: jsxRuntimeExports.jsx("div", {
                className: "progress",
                style: {
                    left: `${E / $ * 100}%`,
                    right: `${100 - M / $ * 100}%`
                }
            })
        }), jsxRuntimeExports.jsxs(RangeInput, {
            children: [jsxRuntimeExports.jsx("input", {
                type: "range",
                className: "range-min",
                min: T,
                max: $,
                value: E,
                step: "10",
                onChange: U
            }), jsxRuntimeExports.jsx("input", {
                type: "range",
                className: "range-max",
                min: T,
                max: $,
                value: M,
                step: "10",
                onChange: H
            })]
        })]
    })
}
)
  , BackgroundImage$1 = "/assets/PotatoRangeBackground-CmbbPwHO.png"
  , ButtonGlare$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVYAAAAoCAMAAACSLiK0AAAAAXNSR0IArs4c6QAAAAxQTFRFR3BM////////////Bp/QCgAAAAR0Uk5TABEzJGYfLjwAAACwSURBVHja7dJRCoNAFMXQl7n733OhQrXMhxSfUDVZwiE17IRKAlllldVklVVWk1VWWU1WWWU1WWWV1WSVVVY7XhUkOjQWqHfa9pRAfdK2RbQ2idu36H6I+zuouM2g4jaDitsH2h8kEXTNdRs81T3qSW1T93qe+7q5KmdmTnmPcE6e8j6Gc47FV82b+WbVvHewCOf0M6lnNROn48oAUPYVxbuQpZGRiW9kZIkAUP8G+QInk1eeRR7DpwAAAABJRU5ErkJggg=="
  , Container$3 = re$4("button", {
    width: "160px",
    height: "56px",
    borderRadius: "14px",
    background: `
    linear-gradient(to bottom right, #5DDB22 0%, #29EB82 100%)
  `,
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset,
    0px 6px 0px 0px #1C8552
  `,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #0B3523",
    position: "relative"
})
  , ButtonText$2 = re$4("img", {
    width: "104px",
    position: "relative",
    zIndex: 100
})
  , Glare$1 = re$4("img", {
    position: "absolute",
    width: "100%",
    left: 0,
    top: 0,
    zIndex: 10,
    borderRadius: "14px"
})
  , ApplyButton = ({onClick: C})=>{
    const {t: S, i18n: E} = useTranslation();
    return jsxRuntimeExports.jsxs(Container$3, {
        onClick: C,
        children: [jsxRuntimeExports.jsx(Glare$1, {
            src: ButtonGlare$2
        }), jsxRuntimeExports.jsx(ButtonText$2, {
            src: S("ApplyButtonText"),
            style: {
                width: `${E.language === "ch" && "64px"}`
            }
        })]
    })
}
  , Container$2 = re$4("button", {
    width: "160px",
    height: "56px",
    borderRadius: "14px",
    background: "linear-gradient(135deg, #C7000C 0%, #FF5C83 100%)",
    boxShadow: `
    0px 1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px -1px 0.5px 0.5px rgba(255, 255, 255, 0.50) inset, 
    0px 6px 0px 0px #702025
  `,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "1px solid #0B3523",
    position: "relative"
})
  , ButtonText$1 = re$4("img", {
    width: "108px",
    position: "relative",
    zIndex: 100
})
  , Glare = re$4("img", {
    position: "absolute",
    width: "100%",
    left: 0,
    top: 0,
    zIndex: 10,
    borderRadius: "14px"
})
  , ClearButton = ({onClick: C})=>{
    const {t: S, i18n: E} = useTranslation();
    return jsxRuntimeExports.jsxs(Container$2, {
        onClick: C,
        children: [jsxRuntimeExports.jsx(Glare, {
            src: ButtonGlare$2
        }), jsxRuntimeExports.jsx(ButtonText$1, {
            src: S("ClearButtonText"),
            style: {
                width: `${E.language === "ch" && "64px"}`
            }
        })]
    })
}
  , ModalContainer$2 = re$4("div", {
    background: `url(${BackgroundImage$1})`,
    padding: "8px",
    position: "absolute",
    bottom: 0,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column",
    backgroundSize: "cover",
    width: "100%"
})
  , ModalTitle$2 = re$4("img", {
    width: "188px",
    marginTop: "8px"
})
  , CloseButton$2 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , ModalRow$1 = re$4("div", {
    width: "100%",
    display: "flex",
    justifyContent: "space-evenly",
    marginTop: "40px",
    marginBottom: "20px"
})
  , PotatoRangeModalContainer = observer(({onClose: C})=>{
    var H, Z, J, ie, oe, ae, se, le, de, fe;
    const {t: S, i18n: E} = useTranslation()
      , {ordersStore: M, marketStore: T} = useStores()
      , [$,B] = reactExports.useState((H = M.sortParams.filterParams) != null && H.from ? parseInt((Z = M.sortParams.filterParams) == null ? void 0 : Z.from) : parseInt(((J = T.config) == null ? void 0 : J.min_potato) ?? "0"))
      , [O,F] = reactExports.useState((ie = M.sortParams.filterParams) != null && ie.to ? parseInt((oe = M.sortParams.filterParams) == null ? void 0 : oe.to) : parseInt(((ae = T.config) == null ? void 0 : ae.max_potato) ?? "0"))
      , N = reactExports.useCallback(()=>{
        M.setFromTo({
            from: $.toString(),
            to: O.toString()
        }),
        C && C()
    }
    , [M, $, O]);
    reactExports.useEffect(()=>{
        var pe, ge, we, Ae, Se, ue;
        F((pe = M.sortParams.filterParams) != null && pe.to ? parseInt((ge = M.sortParams.filterParams) == null ? void 0 : ge.to) : parseInt(((we = T.config) == null ? void 0 : we.max_potato) ?? "0")),
        B((Ae = M.sortParams.filterParams) != null && Ae.from ? parseInt((Se = M.sortParams.filterParams) == null ? void 0 : Se.from) : parseInt(((ue = T.config) == null ? void 0 : ue.min_potato) ?? "0"))
    }
    , [(se = T.config) == null ? void 0 : se.min_potato, (le = T.config) == null ? void 0 : le.max_potato]);
    const U = reactExports.useCallback(()=>{
        var pe, ge, we, Ae, Se, ue;
        F((pe = M.sortParams.filterParams) != null && pe.to ? parseInt((ge = M.sortParams.filterParams) == null ? void 0 : ge.to) : parseInt(((we = T.config) == null ? void 0 : we.max_potato) ?? "0")),
        B((Ae = M.sortParams.filterParams) != null && Ae.from ? parseInt((Se = M.sortParams.filterParams) == null ? void 0 : Se.from) : parseInt(((ue = T.config) == null ? void 0 : ue.min_potato) ?? "0")),
        M.setFromTo({
            from: void 0,
            to: void 0
        }),
        C && C()
    }
    , [M]);
    return jsxRuntimeExports.jsxs(ModalContainer$2, {
        children: [jsxRuntimeExports.jsx(ModalTitle$2, {
            src: S("PotatoRangeTitle"),
            style: {
                width: `${E.language === "ch" && "121px"}`
            }
        }), jsxRuntimeExports.jsx(CloseButton$2, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(DoubleRangeSlider, {
            setMin: B,
            setMax: F,
            min: $,
            max: O,
            minValue: parseInt(((de = T.config) == null ? void 0 : de.min_potato) ?? "0"),
            maxValue: parseInt(((fe = T.config) == null ? void 0 : fe.max_potato) ?? "0")
        }), jsxRuntimeExports.jsxs(ModalRow$1, {
            children: [jsxRuntimeExports.jsx(ClearButton, {
                onClick: U
            }), jsxRuntimeExports.jsx(ApplyButton, {
                onClick: N
            })]
        })]
    })
}
);
function RangePotatoModal({open: C, onClose: S}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(PotatoRangeModalContainer, {
            onClose: S
        })
    })
}
const infinite = "_infinite_ttmly_1"
  , classes = {
    infinite
}
  , CardsContainer = re$4("div", {
    display: "grid",
    gridTemplateColumns: "calc((100% / 2) - 8px) calc((100% / 2) - 8px)",
    gridColumnGap: "16px",
    gridRowGap: "36px"
})
  , MarketPage = observer(()=>{
    var T, $;
    const {ordersStore: C} = useActivatedStore("ordersStore")
      , {marketStore: S, dialogStore: E} = useStores();
    reactExports.useEffect(()=>{
        const B = setInterval(()=>{
            C.reload(),
            S.reload()
        }
        , 2e4);
        return ()=>clearInterval(B)
    }
    , []);
    const M = reactExports.useCallback(()=>{
        E.open({
            Component: RangePotatoModal
        })
    }
    , [E]);
    return jsxRuntimeExports.jsxs(InfiniteScroll, {
        pullDownToRefresh: !0,
        dataLength: ((T = C.orders) == null ? void 0 : T.length) ?? 0,
        next: ()=>{
            C.requestMore()
        }
        ,
        hasMore: C.hasMore,
        pullDownToRefreshThreshold: 50,
        loader: jsxRuntimeExports.jsx("div", {}),
        refreshFunction: C.reload,
        className: classes.infinite,
        children: [jsxRuntimeExports.jsx(MarketHeader, {}), jsxRuntimeExports.jsx(MarketInfoBlock, {}), jsxRuntimeExports.jsx(FilterSystem, {
            openModalHandler: M
        }), jsxRuntimeExports.jsx(CardsContainer, {
            children: ($ = C.orders) == null ? void 0 : $.map((B,O)=>jsxRuntimeExports.jsx(ProductCard, {
                order: B
            }, O))
        })]
    })
}
)
  , MintDiamondImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAwCAMAAACPHmKLAAAAAXNSR0IArs4c6QAAAC1QTFRFR3BM////////////////////////////////////////////////////////zV7dAgAAAA50Uk5TABAjQFBgeZCfr7/P3+/pGCZYAAABn0lEQVR42o2W27KFIAhAARPNgP//3DMdU3Nr2XqzacVNnWAN+l3MjrjBR1jtQvwnIdoN/igkh4Bevil8Clc5eipuIZA2A/4NWRjeTmJQOziZfQhy2EBcVNEzpkXk6LZKNqNNllMeVfI0CaBJfwxWazAOBgFxVucJyBnGizWwdC5lQewHPRV0HMqn9vNBOON3wmwLkZf6AMs8os2QyBvlOUpJTMzaYOdodLVvkfgax5jT2IVNzawU7mxFwFxrMcI8HXbchSHNPQOAVF7ZpAkHAYB2iq8xtA7A97mTNQ4ECMXIj3zpcllh1K4WANS7Id1G0snRcO0Iy/WJ7b5Hxg6mHCSUyrnvmZSU+iDRbCvJ7IBiL9Q0sE5Q1RYoAF6nPNk3CEAIYL1N7i13kAnfDO6upTcSb+HXwBdFXDkRDC+K1rVQvX89PCsRIbRygffhWm+3Qz0DXI0qIzwqdFsJx7axnpT9rjc8jIrWvvP0ghjx1dhn8xspNSrPQiBMSS/bcA7JYk8tlIVQlMMG1C//Q3oSwQKKcn/fwRe2kNRMJfLY1D8YeUjHjHaQmQAAAABJRU5ErkJggg=="
  , DiamondPatternImage = "/assets/GrowButtonPattern-DkoCCa7F.png"
  , MintButtonContainer = re$4("button", {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "100%",
    height: "64px",
    position: "relative",
    overflow: "hidden",
    borderRadius: "12px",
    border: "4px solid #FFF",
    background: "linear-gradient(45deg, #FF9900,#FFE55E)",
    boxShadow: "0px 8px 0px 0px #763D09",
    zIndex: 1e3,
    "&::before": {
        content: "",
        backgroundImage: `url(${DiamondPatternImage})`,
        backgroundSize: "cover",
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: 1
    }
})
  , DiamondImage = re$4("img", {
    position: "relative",
    zIndex: 2
})
  , MintButtonText = re$4("h2", {
    color: "#FFF",
    fontFamily: "Rubik",
    fontSize: "32px",
    fontStyle: "normal",
    fontWeight: "900",
    lineHeight: "32px",
    position: "relative",
    zIndex: 2,
    marginLeft: "8px"
})
  , ButtonGlare$1 = re$4("div", {
    width: "48px",
    height: "16px",
    flexShrink: "0",
    borderRadius: "4px 12px 12px 12px",
    borderTop: "4px solid rgba(255, 255, 255, 0.50)",
    position: "absolute",
    top: "4px",
    right: "4px"
})
  , GrowButton = observer(({size: C, ...S})=>{
    const {t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(MintButtonContainer, {
        style: {
            width: `${C}`
        },
        ...S,
        children: [C !== "150px" && jsxRuntimeExports.jsx(DiamondImage, {
            src: MintDiamondImage,
            style: {
                width: "24px",
                height: "24px"
            }
        }), C !== "150px" && jsxRuntimeExports.jsx(MintButtonText, {
            children: E("GrowButtonMain")
        }), C === "150px" && jsxRuntimeExports.jsx(MintButtonText, {
            children: E("GrowButton")
        }), jsxRuntimeExports.jsx(ButtonGlare$1, {})]
    })
}
)
  , RefIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAwCAMAAACPHmKLAAAAAXNSR0IArs4c6QAAACpQTFRFR3BM////////////////////////////////////////////////////iwaSzAAAAA10Uk5TABAgMEZfcICQqMXf7yTBoycAAADxSURBVHjapZVRbsQgDETHkEBi8P2vW1VqRSCLxta+35EFDzAGULv9owkOLnvQBZxuT85wxQ1OnSqaS2RaJcFPMwctY3CbhwuDYoz1MJN5yPM5cxoQFLmBoEjBk+zTiIl0zKgxFAiKFMwcxjgwI1QECIoo6ZU3FSAiTAMQUiEIiijeXLSbVjSoAQlrHCEN3lP31xr8b0h4cZJNxTS6yu4fbRlusnMerE3bE9yoEfTEjHFaWp4Ip8ny0qtIsQ+MqM4aZdfsI9JZQ7ZPfkSbCgDgkf5tsoylSVTNrIjUMexYJG0ZXTxKbb0mHp1qplXwyy76AXSJQNYglm6TAAAAAElFTkSuQmCC"
  , RefButtonContainer = re$4("button", {
    width: "78%",
    height: "64px",
    borderRadius: "12px",
    border: "4px solid #FFF",
    background: "linear-gradient(to right, #4200FF, #A07EFF)",
    boxShadow: "0px 8px 0px 0px #371C85",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    zIndex: 1e3
})
  , ButtonGlare = re$4("div", {
    width: "32px",
    height: "16px",
    flexShrink: "0",
    borderRadius: "4px 12px 12px 12px",
    borderTop: "4px solid rgba(255, 255, 255, 0.50)",
    position: "absolute",
    top: "4px",
    right: "4px"
})
  , ButtonText = re$4("h2", {
    color: "#FFF",
    fontFamily: "Rubik",
    fontSize: "32px",
    fontStyle: "normal",
    fontWeight: "900",
    lineHeight: "100%",
    marginLeft: "8px"
})
  , MarketButton = observer(function C({onClick: S}) {
    const {t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(RefButtonContainer, {
        onClick: S,
        children: [jsxRuntimeExports.jsx(ButtonGlare, {}), jsxRuntimeExports.jsx("img", {
            src: RefIcon,
            style: {
                width: "28px",
                height: "24px"
            }
        }), jsxRuntimeExports.jsx(ButtonText, {
            children: E("Market")
        })]
    })
})
  , Canvas = re$4("canvas", {
    width: "100vw",
    height: "calc(100vh - 100px)",
    position: "absolute",
    bottom: 0,
    left: 0,
    background: "transparent",
    zIndex: 1
})
  , Fireflies = ()=>{
    const C = reactExports.useRef(null);
    return reactExports.useEffect(()=>{
        const S = C.current
          , E = S == null ? void 0 : S.getContext("2d");
        if (S && E) {
            const T = S.width = window.innerWidth
              , $ = S.height = window.innerHeight
              , B = []
              , O = ()=>{
                for (let N = 0; N < 10 && B.length < 100; N++)
                    B.push({
                        x: Math.random() * T,
                        y: Math.random() * $,
                        s: Math.random() * 2,
                        ang: Math.random() * 2 * Math.PI,
                        v: Math.random()
                    })
            }
              , F = ()=>{
                E.clearRect(0, 0, T, $),
                B.forEach((N,U)=>{
                    N.ang += Math.random() * 20 * Math.PI / 180 - 10 * Math.PI / 180,
                    N.x += N.v * Math.cos(N.ang),
                    N.y += N.v * Math.sin(N.ang),
                    E.beginPath(),
                    E.arc(N.x, N.y, N.s, 0, 2 * Math.PI),
                    E.fillStyle = "#fddba3",
                    E.fill(),
                    (N.x < 0 || N.x > T || N.y < 0 || N.y > $) && B.splice(U, 1)
                }
                ),
                O(),
                requestAnimationFrame(F)
            }
            ;
            O(),
            F()
        }
        const M = ()=>{
            S && (S.width = window.innerWidth,
            S.height = window.innerHeight)
        }
        ;
        return window.addEventListener("resize", M),
        ()=>window.removeEventListener("resize", M)
    }
    , []),
    jsxRuntimeExports.jsx(Canvas, {
        ref: C
    })
}
  , DarkBackgroundImage = "/assets/DarkGameMainBackground-CWsjFwx0.png"
  , BackgroundImage = "/assets/GameMainBackground-BWgWWwF_.png"
  , InfoBackground = "/assets/GameMainInfoBackground-CsGMncRo.png"
  , formatDurationToDaysMinutesHours = C=>{
    const S = C.shiftTo("days", "hours", "minutes", "seconds").toObject();
    return S.days && S.hours && (S.hours = S.hours + S.days * 24),
    S.minutes && (S.minutes = Math.ceil(S.minutes)),
    S.seconds && (S.seconds = Math.ceil(S.seconds)),
    S
}
  , Countdown = observer(({date: C, intervalDelay: S, renderer: E, onEnd: M})=>{
    const [T,$] = React$1.useState(C.diffNow());
    return React$1.useEffect(()=>{
        const B = setInterval(()=>{
            C.diffNow().toMillis() < 0 && (M == null || M()),
            $(C.diffNow())
        }
        , S);
        return ()=>clearInterval(B)
    }
    , [S, C, M]),
    E({
        total: T
    })
}
)
  , GryadkaIcon = "/assets/Gryadka-D7o_Kc8Y.svg"
  , ModalContainer$1 = re$4("form", {
    width: "354px",
    background: `url(${BackgroundImage$3})`,
    position: "relative",
    padding: "8px",
    minHeight: "228px"
})
  , ModalTitle$1 = re$4("img", {
    position: "absolute",
    width: "228px",
    height: "70px",
    left: "-17px",
    top: "-21px"
})
  , CloseButton$1 = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , TextContainer = re$4("img", {
    width: "90%",
    marginLeft: "10px",
    marginTop: "26px"
})
  , FieldInputContainer = re$4("div", {
    borderRadius: "8px",
    border: "1px solid #572A24",
    background: "rgba(87, 42, 36, 0.70)",
    boxShadow: "0px 3px 0px 0px #9C4C30",
    width: "100%",
    height: "48px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "8px",
    padding: "0px 8px"
})
  , FieldInputImage = re$4("img", {})
  , ModalRow = re$4("div", {
    width: "100%",
    display: "flex",
    justifyContent: "space-between",
    marginTop: "16px"
})
  , TonNumber = re$4("div", {
    display: "flex",
    justifyContent: "start",
    alignItems: "center",
    width: "50%",
    gap: "8px"
})
  , TonText = re$4("p", {
    color: "#FFF",
    textAlign: "right",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "24px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "24px"
})
  , ExchangeModalContainer = observer(({onClose: C})=>{
    var se, le, de;
    const {configStore: S, userStore: E} = useStores()
      , {isConnected: M} = useConnectWallet()
      , T = useNavigate()
      , $ = useTonAddress()
      , {t: B, i18n: O} = useTranslation()
      , {wrapPromise: F} = useStatusState()
      , {control: N, handleSubmit: U, formState: {isValid: H, errors: Z}, watch: J, setValue: ie} = useForm({
        mode: "all",
        defaultValues: {
            amount: "1"
        }
    })
      , oe = J("amount")
      , ae = reactExports.useCallback(async fe=>{
        var pe, ge, we;
        console.log(Z),
        !(!H || !fe.amount || !((pe = S.config) != null && pe.field_price) || parseInt(fe.amount) * ((ge = S.config) == null ? void 0 : ge.field_price) > (((we = E.user) == null ? void 0 : we.potato_amount) ?? 0)) && await F(async()=>{
            var Ae;
            return api.v1OrdersTradeCreate({
                address: $,
                potato_amount: (parseInt(fe.amount) * (((Ae = S.config) == null ? void 0 : Ae.field_price) ?? 720)).toString()
            }).then(()=>{
                S.reload(),
                E.reload(),
                C == null || C()
            }
            )
        }
        )()
    }
    , [M, $, H, T, E, F, S]);
    return jsxRuntimeExports.jsxs(ModalContainer$1, {
        onSubmit: U(ae),
        children: [jsxRuntimeExports.jsx(ModalTitle$1, {
            src: TitleImage
        }), jsxRuntimeExports.jsx(CloseButton$1, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(TextContainer, {
            src: B("MintModalText"),
            style: {
                width: `${O.language === "ch" ? "196px" : "90%"}`
            }
        }), jsxRuntimeExports.jsxs(FieldInputContainer, {
            children: [jsxRuntimeExports.jsx(FieldInputImage, {
                src: GryadkaIcon
            }), jsxRuntimeExports.jsx(Input, {
                placeholder: "0",
                controlledInputProps: {
                    name: "amount",
                    control: N,
                    setValue: ie,
                    validateParams: {
                        isOnlyNumbers: !0,
                        isNotNegative: !0,
                        isNatural: !0,
                        notGreat: ((((se = E.user) == null ? void 0 : se.potato_amount) ?? 0) / (((le = S.config) == null ? void 0 : le.field_price) ?? 1)).toString(),
                        toFixed: 0
                    },
                    rules: {
                        required: "Amount is required",
                        validate: fe=>{
                            if (parseInt(fe) < 1 || parseInt(fe) > 1e3)
                                return "The amount should be in the range from 0 to 1000";
                            if (parseFloat(fe) % 1 !== 0)
                                return "Integers only"
                        }
                    }
                }
            })]
        }), jsxRuntimeExports.jsxs(ModalRow, {
            children: [jsxRuntimeExports.jsxs(TonNumber, {
                children: [jsxRuntimeExports.jsx(TonText, {
                    children: ` ${(((de = S.config) == null ? void 0 : de.field_price) ?? 0) * parseInt(oe)}`
                }), jsxRuntimeExports.jsx("img", {
                    src: PotatoToken,
                    style: {
                        width: "29px",
                        height: "29px"
                    }
                })]
            }), jsxRuntimeExports.jsx(GrowButton, {
                type: "submit",
                size: "150px"
            })]
        })]
    })
}
);
function ExchangeModal({open: C, onClose: S}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(ExchangeModalContainer, {
            onClose: S
        })
    })
}
const timerBack = "/assets/TimerBack-DxIILm2F.png"
  , WoodBackground = re$4("div", {
    background: `url("${timerBack}")`,
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    position: "relative"
})
  , TimerToStartStyled = re$4("div", {
    height: "93px",
    width: "292px",
    position: "relative"
})
  , WhiteBackgroundText = re$4(Txt, {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "100%"
})
  , TimerText$1 = re$4("div", {
    textAlign: "center",
    paddingTop: "10px",
    color: "#FFF",
    "-webkit-text-stroke-width": "1px",
    "-webkit-text-stroke-color": "#572A24",
    fontFamily: "Rubik",
    fontSize: "48px",
    fontStyle: "normal",
    fontWeight: "700",
    lineHeight: "100%",
    textTransform: "uppercase",
    display: "flex",
    flexDirection: "column"
})
  , WhiteBackground = re$4("div", {
    borderRadius: "16px 16px 0px 0px",
    borderTop: "1px solid #572A24",
    borderRight: "1px solid #572A24",
    borderLeft: "1px solid #572A24",
    background: "#FFF",
    display: "inline-flex",
    padding: "2px 16px 10px 16px",
    justifyContent: "center",
    alignItems: "center",
    left: "73px",
    position: "absolute",
    top: "-20px"
})
  , DownTimerText = re$4(Txt, {
    textAlign: "center",
    color: "#FFF",
    textShadow: "0px 1px 0px rgba(0, 0, 0, 0.50)",
    "-webkit-text-stroke-width": "1px",
    "-webkit-text-stroke-color": "#572A24",
    fontFamily: "Rubik",
    fontSize: "14px !important",
    fontStyle: "normal",
    fontWeight: "500",
    lineHeight: "100%",
    textTransform: "uppercase",
    display: "grid",
    gridTemplateColumns: "1fr 1fr 1fr"
})
  , date = 17141256e5;
observer(()=>{
    const {configStore: C} = useStores()
      , {i18n: S, t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(TimerToStartStyled, {
        children: [jsxRuntimeExports.jsx(WhiteBackground, {
            style: {
                left: S.language === "en" ? "73px" : "90px"
            },
            children: jsxRuntimeExports.jsx(WhiteBackgroundText, {
                children: E("gameStartingIn")
            })
        }), jsxRuntimeExports.jsx(WoodBackground, {
            children: jsxRuntimeExports.jsxs(TimerText$1, {
                children: [jsxRuntimeExports.jsx(Countdown, {
                    intervalDelay: 1e3,
                    date: DateTime.fromMillis(date),
                    renderer: ({total: M})=>{
                        const {hours: T, minutes: $, seconds: B} = formatDurationToDaysMinutesHours(M);
                        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                            children: [T !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: `${T < 10 ? "0" + T : T} : `
                            }), $ !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: `${$ < 10 ? "0" + $ : $} : `
                            }), B !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                children: `${B < 10 ? "0" + B : B}`
                            })]
                        })
                    }
                    ,
                    onEnd: ()=>{
                        C.reload()
                    }
                }), jsxRuntimeExports.jsxs(DownTimerText, {
                    children: [jsxRuntimeExports.jsx("span", {
                        style: {
                            fontSize: S.language === "en" ? "12px" : "20px"
                        },
                        children: E("Hours")
                    }), jsxRuntimeExports.jsx("span", {
                        style: {
                            fontSize: S.language === "en" ? "12px" : "20px"
                        },
                        children: E("Minutes")
                    }), jsxRuntimeExports.jsx("span", {
                        style: {
                            fontSize: S.language === "en" ? "12px" : "20px"
                        },
                        children: E("Seconds")
                    })]
                })]
            })
        })]
    })
}
);
const TutorialChest = "/assets/TutorialChest-CR_IPnHQ.png"
  , TutorialField = "/assets/TutorialField-Acjb8FI9.png"
  , LeftArrow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABoCAMAAAAXUCT1AAAAAXNSR0IArs4c6QAAAPlQTFRFR3BM6LJtMR8K+Lx2/taNBQQCAAAAAAAATTgfAAAA9blp9sN8XTcOuYE+m08G/M2Fwo9Vv45RwY1JoFADkEoEdDsE/c6EsXQy97lXnmAf1J5a6KZPlGw1g0QF97JP/tSN+rNQ9KVFckca/9WN9bVj0aNryJJP97Vop1QE8IEO8okVp1cH9JAc84wY+qo09Z079ZUg9pwm+KItqFsK8YUS+aYw958q/b5Z+bBL/cJc9pgj9qE+96ZC96pH+6859Js4+7VQ734L85g2/LpVql8NtnUw/c+C/cRi4nkM/clx9rBfwWgL8pQrrmwd1HEM4I4tzYQu2ZpMwnkkszyamgAAACh0Uk5TACFc/v4yQUwOIGY4dv7Z4P2BourAlXXj5axZyl+p8sSJ64uYp/vTz8zULBYAAAXMSURBVHja7drZctpMEAVgwASJ1Zh4X5I4sRPb7GY3m0AW2IDX93+Y/0zPaEY/xDcjUFWqfMT9V6e7Jd849Jl/K/vfk8Gbk2g0aDMxfYxGA64aPpxOJ9H9YFGYQH8Fav7oTDuY7/cAyfhph6PRAM3IYYepQM3ATOOkw4KlBna+ppHrSDQREBpLtYjED+9MYAtttTrcfQzonTGZCTVI1IydkMnVgF7ULzmQpHJ0O4iF5uyWTWpwaHzHtqHKrtMAPknmqb2ETqKbN7/ZlJbVtkkFam4YhcmbtgeDAW0VaHiz5vE3y7ItqNYAoRlvHE2A5BmwWFR1w+gPC6GqA0q7hWwWNS9cEgstkdrZ9HjDh1ZbqG2QFHvDTRPf2kB5BqUSr7rZ8Zo/2ogFlkxENt3YxyF5SCZ+SJ9MYi3bNxpOfjxaikVPAyZVLQl024e5c7l18bfthE/afYW2Sw08MNnTtm2g3330TL/NtraTf/kI9ft9ycIEKbr6Rw+ccX+2tZVYvqA+mUK1eg0WbkLFR3g6+aVtnjqv5XIP6v7/LuhcmpTeLZmCBWrbj5N9H0VfyuVyV6qqJrFQySQUpKiK8T5Oknqiae44DjOhqgkfn/d6/Z5Q+9xEvAP2gcaNyIHzOiwPy3zCSX60ECVKI1YkUApQzTfGNIwjx3kBiXShbofxbqImRaL92yZQ1yUWL2pH83hjhnFA0x2Sihv+c3He63Ky55L9ZrMJFuSt6mrhePf1hmv8dDBdhHcF0esiMFXZHkyoLEJtEIqV6hd9GUu03OVk11O1W61ylVw+3gah25pFU47jkClViqviaVQRkPiBVFu1OlqfBjNGZ/Q+Hg/HgvWapPaGVcrygIFOJ0m9ohEHKx1DRcgUbM91q3cetOlVNacbozPCSllVOWARIod3CFxX9Q64NUnoFTUOBLqyVmrbrDBUdkVIvaUD1i4acRCQHlWR3UWlclehpoRW2XzlNfW1ipoGn+77Euq64woCk8XTVKAlS6voF4Pd7lNtXlx4WFn1rlBwVVVV7bU3TeigBq20Vnu+ri8EqvY6LMAsMFOyqitSsi5CmmeUgll7uIYqUZ4FTKgUecBNpTbal2Hd6f58quXvr1kKQiV3XCiSKVi5VfVh6s6OQ7rTParla3Nm1usF/rKCHC6KxaJgxYTlfKksir7lNP94I5l8Pg+UqddiwkQylcd7wcRS3n6HQ7rTjdSAPgsUe4U5LtzccLSoBoyqMJX6koWpkxjQVJ6hI67Wb6AubiiyamXlmPC8Zo/1TNNA9hj6MHLVehFyHaasqlg138V7ekcDlCvdlahgEVVVoGrAxL48aZtYKZK54uhImVS1eLNSdSHW+spN/ZVGriQ6guntuqpS08X7UzoX0o6BpK6gAmUqsfVrqqrmu7TVlyfZU/+OrlieRyzercquCKGCfVWm/h2dUdO5QutCpQhSfZhkT193tAsU7EhEsitrBUto+jTkJzF+vCyyqkJVVbBywNUDmH5isHwFKbcq2Y+qNk+++DNNicoDBjpSVZdUFB3m4tqcuiOFXl15J0wmdS3iRyjU85RfE3ekdkpd7x+WuyJQRdXF7whM36i4XpU52+wH3+ByzoC5HnRPkXnWdv6gqiJu1Ur5JGaG/CdGaARLVSxSu39+cFV1S4vZiX+R0JWqlFqtNofLi4qqQGfm2lAks9SUw3C9ay30Z4l1opGMFyWSh+1X/rnpzv749NQhUc5W1TxD8btH4wewbL7hNaBxcB+VrblleZ7m8/e3t7XM1/Aktbu0ViLZ4yadzYXWWpXa7n31NGUPRaJO9ndonVtVdeESqkw14mzWXAdqxhSoXLVVwUoUl7TmCSv3LONxVdN09ji0npjLIxb7ZYVJVGr6EuhGWcA/zzIZdcMY7yXGuz42HjM+Siq1t3d2tnt0dJTbSa7JU3XJ/TC+AR0XL0vwbnxzKO0XcJCogiFrjdc/DRs6S9z8/KfMz3zmM5/Rz3/ny4MeEUHewgAAAABJRU5ErkJggg=="
  , TutorialPotato = "/assets/TutorialPotato-BxZcH2EC.png"
  , RightArrow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABoCAMAAAAXUCT1AAAAAXNSR0IArs4c6QAAAOpQTFRFR3BMgmM/AAAA6LFvAwIB9bt1AAAAzpFHAAAAAAAAPycL9MJ+vItGYDsQ+Lx3eVAZ88SCg1ATwZRU9qpajVQR769srIJDmFQOoW4i/MuFyZBa9qI+s38397ZxpWUWplsM/c+H+8Z7+b1x/b9b+7pW+7dS9rFq+rJO+K1J9ala0bF696hE465V+akz9qNB+KIs9aA+9Z479Js59psm85c09ZQg8ZIw848b8Ywq8ooXvpZP8YcU1Y8x8YUSvZJL8IIP8H8M7noI1H8bu4Q6wX4k0nENsHwpr3ckrnIgv2gMrWwaq2cVqmEQqFkJCOandwAAACB0Uk5TAAsWISk3OERETGZtcHyEk6Cjq6+0yMrM1dre5+nq6/Q3VX0fAAAF6UlEQVR42u3aW1faWhQFYAIBCRYoLdZ6ai0CchGBcL+IRfHCRfz/f+esNffeJIDnwU2S8+KMPn9jrrXi6Bhp6DP/ZyJfj4NHT66vvwZedDy+vg666xGj19Fg0S9jVs+MQNFvY1Zzga3ViJkbNBfUWuOWZYbGnJvLXC4STFGLYhL5d3xTyOWCWWuY0cSY1ZtCPhfMWk1Gk1yUmhYug1lrjNE0odwUajQgNIPxFgtQzyIBHC/lx/gvBWgQx2RYAmUVJo4pGJRIoFJN+f/GAB0LtEiP76oJ9BxNYUr12H90PAZahFos4nX1Hf2LgIRa9FeNAX0ESibIK/rFhP1FX4AKk9WrK1ZTPqMvAoWJrqRe+va+xiXKA74qSFKE1LOInyjUm2IBplILpEb9QC2BUhiFKVMuY8Qp39BzqECVWr4qE8uLjfiJPgKFCBMpXF5ixD6gP184EyxUkGQiFRrx5X+NOBI9BM2+IFeyqUPSUy5R2fdGbHy7zqcOR+vswaRHqRUu+/t4v+b5YzWfj+q/Mmkm5y8tqDAViZRpxLv3dHT+2G6U8r8NbTRJJD2TekWhSoWLsmdbZb+Q2WrVSvmUNppA0/mkzuo+WavUqqW8u+xRe9Jq2S27qlU1ZiFE8k+dVAeFqNRK1bXZ6C+byFaLB6zxB9rcvDNzSpdVoE5PkJRKhcqKM478solktEW3FNFFs4RivlARmAIFSymX8vmU4TbbNqrqoWkSOYw2KxDdpkqFiv3+Tiam26ZwVUPjX4PIfL6Zb7Nee69no9agVKq1hg2UajJraxywIdGfc+SJzWaztr9SqAhMThuplj5+wHE537lIv04mwaTukm7TVma3S1WPNd4Z5EVVJZKzbUJ1TBwRTHqqpRO9S1LzXcz7hCLORl2m3YAJVDald7UU1bykJMjF4qkp06nv7VM1dRftctWU3iWh6oKfiTTpt1ZRLZ2FOiZUDp2S7lJV1XlHkJ1Op1nDdEXRmhouIklUtT8+X9OpukCeRNEOs629wwVKlJquxnw5Ck2iKGUCUwaqq6fNLXuj0RCkiMb9xpSaXYis+k3FqrLouTmiwYjSV2a/T/M1dO4XuVjIQEN6vV6nsW12mby9HUmSnjaWqlk1KZsu5nxFUqWnBRQhcyDQ2+GmaRdL1a2ahUnPE0CQnA7VFCp6wry7lST9YKk6VZGfMFerxUySiu02VE+QZN7dDTBcMvttvKm6VRMXpMJVqsig12uRiRuikEmZ9tGU0SqWqvWuQgWJrjA7whwMBl2XKdQRqnKqpeMPo0Z8o6ZRlDMDKk2kJ01ZdEpVJYpL0hswkoGoVJhKdfeEOujL2Lgk3QFDXQj09WmzUYeECZIjzaG4JN0LhirN1eti4JgjenbR+yFIvKmREKK7VqivUFekumfroDDv72RTXNLhKszX19WMVFHUbU4FylXxiEvSXyuSvmAT7EwW3e0J834kig7t0vfQwWrigkRkvRrBFIGpUMoU5HDYxvl6oKqsZxjv7hEx+vAwBIrzPVBFspKkZ+kuChPqA7G3VJVC5xvyRM046kyS7iviovcPU5jDPtCDVYwY4nq9njG5vdApTMxXovoJx7fKSvXWdbnunvRDIlDsVDfGlpokkXYKc7somWCnQ7HTk5B3apaLYrqcjYmmyD3QdvU4dJjqXuwpNcV0902pArXV315PzumCzOX+K4rhutBqShvbH3GSV/r8zp8iZYql2ieGV58xsFLKTJkKVbNVS538E/Hy29QfrHRnodMHt/r89PgNPb2IielyqKi759RFLpdvbz+OvP2QkWFzCVOh6CnUZxLfTpOGx98UToHybB0TJIOUPxnLMj00w2KlnK3LJY9AiNmkZVlxz7/CrUWeZZbL5RqeFNk0vEQtSoLFNymDc4lIzPuvuUmpwVPgaSZhKTLsxzfOP0xCZffiNJsGqEh/vvwlMlkkk0knmXMSN336CPd+IKKk1zGCFoEGLCLh98CYaYT8jBHf9cIC9Fc1TTNGj2mGw8bnf+b8zGc+8xmd/AtVl5jnqqy9IgAAAABJRU5ErkJggg=="
  , TutorialContainer = re$4("div", {
    width: "100%",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column",
    padding: "20px"
})
  , TutorialRow = re$4("div", {
    display: "flex",
    width: "100%",
    height: "18vh",
    justifyContent: "space-between",
    alignItems: "center"
})
  , TextBlock = re$4("div", {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column"
})
  , TutorialStepTitle = re$4("p", {
    textAlign: "center",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#265614",
    fontFamily: "Rubik",
    fontSize: "6vmin",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "24px",
    background: "linear-gradient(92deg, #DDFFBF 5.55%, #A6E43F 49.9%, #53FF6E 116.34%)",
    WebkitBackgroundClip: "text",
    WebkitTextFillColor: "transparent",
    filter: "drop-shadow(0px 2px 0px rgba(0, 0, 0, 0.50))"
})
  , TutorialText = re$4("p", {
    color: "#FFF",
    textAlign: "center",
    WebkitTextStrokeColor: "#000",
    fontFamily: "Rubik",
    fontSize: "4vmin",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "120%",
    alignSelf: "stretch",
    filter: "drop-shadow(0px 2px 0px rgba(0, 0, 0, 0.50))"
})
  , TutorialImgContainer = re$4("div", {
    width: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
})
  , LeftArrowImg = re$4("img", {
    marginLeft: "40px",
    width: "58px",
    height: "52px"
})
  , RightArrowImg = re$4("img", {
    marginRight: "40px",
    width: "58px",
    height: "52px"
})
  , CountinueButton = re$4("button", {
    color: "#FFF",
    textAlign: "right",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#000",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "900",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    textTransform: "uppercase",
    background: "transparent",
    border: 0,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    opacity: "0.5",
    marginTop: "40px"
});
function TutorialWrapper({openTutorial: C, setOpenTutorial: S}) {
    const {t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(TutorialContainer, {
        onClick: ()=>S(!C),
        children: [jsxRuntimeExports.jsx(TutorialImgContainer, {
            style: {
                marginBottom: "20px"
            },
            children: jsxRuntimeExports.jsx("img", {
                src: E("HowToPlay"),
                style: {
                    width: "80%"
                }
            })
        }), jsxRuntimeExports.jsxs(TutorialRow, {
            children: [jsxRuntimeExports.jsxs(TextBlock, {
                children: [jsxRuntimeExports.jsx(TutorialStepTitle, {
                    style: {
                        background: "linear-gradient(97deg, #FFC700 -32.23%, #FFE55C 9.74%, #FFFFF1 20.05%, #FFE70E 115.04%)",
                        WebkitBackgroundClip: "text",
                        WebkitTextStrokeColor: "#4D3F11"
                    },
                    children: E("BuyPotato")
                }), jsxRuntimeExports.jsx(TutorialText, {
                    children: E("BuyPotatoText")
                })]
            }), jsxRuntimeExports.jsx("img", {
                src: TutorialPotato,
                style: {
                    width: "160px",
                    marginLeft: "-15px"
                }
            })]
        }), jsxRuntimeExports.jsx(TutorialImgContainer, {
            children: jsxRuntimeExports.jsx(LeftArrowImg, {
                src: LeftArrow
            })
        }), jsxRuntimeExports.jsxs(TutorialRow, {
            children: [jsxRuntimeExports.jsx("img", {
                src: TutorialField,
                style: {
                    width: "160px",
                    marginLeft: "-15px"
                }
            }), jsxRuntimeExports.jsxs(TextBlock, {
                children: [jsxRuntimeExports.jsx(TutorialStepTitle, {
                    children: E("Plant")
                }), jsxRuntimeExports.jsx(TutorialText, {
                    children: E("PlantText")
                })]
            })]
        }), jsxRuntimeExports.jsx(TutorialImgContainer, {
            children: jsxRuntimeExports.jsx(RightArrowImg, {
                src: RightArrow
            })
        }), jsxRuntimeExports.jsxs(TutorialRow, {
            children: [jsxRuntimeExports.jsx("img", {
                src: TutorialChest,
                style: {
                    width: "180px",
                    height: "180px",
                    marginLeft: "-20px"
                }
            }), jsxRuntimeExports.jsxs(TextBlock, {
                children: [jsxRuntimeExports.jsx(TutorialStepTitle, {
                    style: {
                        background: "linear-gradient(96deg, #0091E2 -27.62%, #D3EFFF -22.63%, #0091E2 46.71%, #DEF3FF 63.86%, #188AF5 95.66%, #188AF5 138.7%)",
                        WebkitBackgroundClip: "text",
                        WebkitTextStrokeColor: "#00035C"
                    },
                    children: E("Grow")
                }), jsxRuntimeExports.jsx(TutorialText, {
                    children: E("GrowText")
                })]
            })]
        }), jsxRuntimeExports.jsx(TutorialImgContainer, {
            children: jsxRuntimeExports.jsx(CountinueButton, {
                children: E("TapToContinue")
            })
        })]
    })
}
const Tutorial = observer(function C({openTutorial: S, setOpenTutorial: E}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: S,
        className: classes$8.tutorialPopup,
        onClose: ()=>{
            console.log("close")
        }
        ,
        children: jsxRuntimeExports.jsx(TutorialWrapper, {
            openTutorial: S,
            setOpenTutorial: E
        })
    })
})
  , PotatoIcon = "/assets/PotatoToken-C9YzYepB.svg"
  , BlueCoinIcon = "/assets/BlueCoin-g41qCuwV.svg"
  , Wallet = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABICAMAAABx5AOBAAAAAXNSR0IArs4c6QAAAIdQTFRFR3BM////////Iy06Iy05Iyw5////IS85////////JCw6////naGm////////JC06////UGSAVGaIUWSETV2BZ3SxZHKrXWycWmqYTWJ7YnCmane4WGiTX26hbnm/VmiOUF6HVGKNp67A7/D02NviSVl5v8TXiZSweISir7bJmqG5aHSQQklV0exN+QAAAA90Uk5TAM+fYOaYjxob5s9gP6Bfbp78pgAABGZJREFUeNqdlotyojAUhmmrW9udXQJEQaolJEAI6fs/354LuEGHFv3t0MvM9+U/B3Ea/c/u9/PTm/gxb0/Pf3fRbXa/AF6d590NLu7Mrzn/Ju7O2+6GN7r3R0hCyTApp+KcIMXZdubKwLzpj5RkNCDOgpFmHl/FYNgQ8i5hnmnmSVDBiwQjD8nzsgsMtD+NLBcgnDLrzwWIB0PuLpvc0fkBH/Tn88cKVIBwzJk6YIU/OH8yCW73lwYKbkB8XhqqwAXshDOfMB5GpWlNiok/ny1v4TcWCAZAPs3oNbGZyjK4pHXNc6AAQhX+0gTu+vwLjKJMaiMaZyul6roGwWRwgD5HT3Dtp/OD/WVMV15KJygg6RUMAhW4Ac7wFL3BNbm6/2zADKaXXgRpBo8G5MselxAJSHB8wjxVT+UgjIQLxUwOXZ3yHAWlgJAg4IGj8hTZiE62DXM+nR6CASuU1wLmuQGlt1IaYdtWMCUh7OpuBMyzAb4wiRYWp/dtD+31kEqplOp4D7eCZBKwBIKstMK0rRPCtRJ4MPRTA1rB4SKYaIxMZCYTZKXUoqPavZSptR4qaAGxp5z4uYDpo6Qg20jZ8RhCSovrc4o75DjB4VqQEd83RghknXB4eCot/uoFRSs1jCsAfCbImKeGSCQdrD2FH7IOb0AnKKauO9AgPxcAj4YjDO40xEJn7aXXPf6gPVw4JLBU4EaABRrRtRxaxhQ1XhU+TSUXmAsyDDwQUD5tg8h52HCaBPv9XCCPrfgxpitRQPwhFKTQQLZiTYZJEDTgx+e4TmDOOU6wD0cgPlvZQDhsAHgowKwWNCjY3ykwg+e7oOAuPCBwRBNf15PgIxRUKJBLvAa8HzTHuR4EZPgvqECQLgo6KX0TzpOT4GMmwApLAi+9EWHyM/JBgyr9RsAfDBDTq55FBQk+AgEkrZcETiriPH6eLAuqxQZaKoFRqlbqO4H6oUH/XYNTVdVqcQdK8w7qcQdwF4CfC8CwIMDhKyPCnMv9XAD4qarTJUGnlA8Nhif4DAXYoF5+J+L0muK0c5Yn+PycCaCCEt8Zago+S1QAEgoKFizG2B4cLMBHCc8PG5ChVkasSTNuIBQUBRiqulkl6A7MjwI8tS8gUKFfw5sPnoAFJsJTbTEa9AqB5gkgA84TIeOKImfD8MMUprEl8ZgOdZHHP4MgH0sEOV1ScHL6PEaegtP7KMZvNseQJAQu/9ZiynNZIn7hnYDEUTxghTIfQ0iIjTlQ9ogzzwU0CL5Q1AFBDHOYESwJBBRC+MR3yH2BgCoIxyB3DcmQJTzkhziONnHc8NuD6XljRhlmOuRNHG+i9zj+IoMZLrUn/DDnP/FFGQwSzVccv0fbmAyk6Ox+fv68/ER3hAsDfLyNXmI23Bc+H/ISvW5izHAvP8SU1whnoBL6DtoMeDxNEEWv8RSvG7MCbrQfASqAFR7OFnncwoPZQAE2PM4Hhsd5NjzOs2F79/6Qf1ixYfxa8bJ936yA37cvAf4P5WZlLHxmg4UAAAAASUVORK5CYII="
  , ActiveWallet = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABICAMAAABx5AOBAAAAAXNSR0IArs4c6QAAANJQTFRFR3BM////AHFJ////////AHFJ////QI1vAHJJ////////AHJI////////AHJKZ/kKYvUOVewaDLllXvISWu8WD7lhCLdoQdsuUegeOsowMcM3Fb5aMtE9Odg2R+IoKsxFTuQhEbBaI8dMHMNUELZdG69MStwjJ7lBQNIvjdml4vTpHrpOnOSY8vvzyvHHsOqrG4FdUMRxz+3XhN99UtBKt/uQmeC2k+WGjvhTO75gatheTMuH6/7hHr9woMq7kMGvYeI6a9GZe91uYKeOdeJbgORpwjEl/QAAAA10Uk5TAI+gYCCQnxfh5s9gMErUTrgAAAR4SURBVHjanZdpQ6pAFIbJFq3u0Oo1RMVUFhFEccvK9v7/X7rvOTMJZFyxZyZR4H3OmZlPaQnl/aOTY7GV45Oj/bK2ycEewoU5OtCylPfEjuxly6P6rhynmvgj8+Hs7qwAd7NHafiTrf+o0oUcj+keypyfnZ2dY8pxzp+Y2SEv/OKMDfI09jh/viOz9U4ebM1frdkw0CKOaP3neMiDwTXNteLqOv34/FG2UBbg7ioHyl1cXNwQF4A9iju5C/vUAN6UA4l0lvM37bbDtNtskd1ghIju8wpm1z/DpREPHkUcfUpHmx0M7cKRdkIryMbkAIi/vDhOJCTD6IMlSnFBazjRjvFJb29CxRfhh/MiUgwXLw53AejBsSZAThp5ETreQjC+UATcBCGAEtzQAHzhlfPODcXQ84aCmXpvUSiICQT0UiJAQKYVbeB8YNdCMfEMwSwMzzBiuQxqgcgIOIgo4OqB+PTuUdfAhx8skMYcSkGNTiMtaK9pOS2HZg0bdO+9Cd8wcAaRATwMyEDkOa02kRG02i3gIOvUwKcIPS+gaAwV4pO3KSyBAG8kaKUFSMo8sh6oISu3782Y4rlhTELBjXAPeEG+nwhkHOmPId6kbIRGUdwzJvgJCxPAxE8dLpkWqDx3SAljSNsuv+BbJJiQd2ThYYkUyAhqwJuIMArABJWCqTEN7ukLvuGDYcG9h3xWgDgmrTmqM4bBk/7qWYzpAlsAkEgEnG96Bpqf1reAA2nWFIkA8VrTgGAbYTQ1GmzIChBveo26KMLEaHrNJkUSAeWbDaOYIGw0mhDQTAREAx0UIoCB+S6oFxQMNwVc/78Cv790FTgJGBoZQYOx8gVzN4UFARkaiQA/QN0VOfQRG/clQT8YWw1JtgMrVxC57nIoEsK69YPAsqw8wdJd+iKNa1nfBBbyuYKh7UYC+GN37CsBQGgtUPkcwdy2OTe2XXssBR2LSQREp5Mj6Nu2IGwX438Cd7CtA1t1MOh0sgKu3xnkCGLb7ss9sMe+EoC0oEPkdACW9gDBBBZQyYwgvwMcg505R5872BAMIMihT6vvrxkPuhuCbqfbhSDfkAKVul1KJIIukd8B8F/HiYDz9JcIGHMQiiLEEEi+dWAOYlGEuTkwUwKquqT6pnn7IAoQLvFqF4MFoUZVH0xmcNsX23ntmcpA9WLtiTbZZHrm7Wu8pXw8Rl4xx40n7Z1ufwl6vdtt9Hprg4/ouzYK5RqqNKo9cNv7OUmDUK+arwKMNP0ZF39VZXowZOA7mbtViXm58mkFuqaP+Giqm1xKJ669nx7OuQEI0ALoX4LqJYOn8qKuyX2aCj6wZ13XKvrI5x5W62d/1cxcMDG+WHF9f6RXIFAG//VvYR58lYegpLOB8OcPq+3h1UM/FF95vaSd6tKwM8iDU61cYcOz2JFn5EFZ0w51ZvQkihMizpTo/05dMXp/isMC4fjpneOqAWrh1xxqgHbhl1TKWmL4fR4CGH6dT3r4fZ4NhzvvH+UzitIu1TfirDgtVSoFwpXSaSr+DzvTbjMI+ebeAAAAAElFTkSuQmCC"
  , ModalContainer = re$4("form", {
    width: "354px",
    background: `url(${BackgroundImage$3})`,
    position: "relative",
    padding: "8px",
    minHeight: "228px"
})
  , ModalTitle = re$4("img", {
    position: "absolute",
    width: "313px",
    height: "70px",
    left: "-17px",
    top: "-21px"
})
  , CloseButton = re$4("button", {
    width: "36px",
    height: "40px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: 0,
    background: "transparent",
    position: "absolute",
    right: "20px",
    top: "-20px"
})
  , ModalText = re$4("p", {
    color: "#FFF",
    textAlign: "center",
    textShadow: "0px 2px 0px rgba(0, 0, 0, 0.50)",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "800",
    lineHeight: "120%",
    marginTop: "52px",
    marginBottom: "28px"
})
  , ButtonContainer = re$4("div", {
    display: "flex",
    justifyContent: "space-between",
    width: "calc(100% - 40px)",
    marginLeft: "16px"
})
  , ModalButton = re$4("button", {
    borderRadius: "12px",
    border: "4px solid #FFF",
    background: "linear-gradient(135deg, #465D6A 0%, #757ECF 100%)",
    boxShadow: "0px 8px 0px 0px #242D3A",
    width: "calc((50% - 4px))",
    color: "#FFF",
    fontFamily: "Rubik",
    fontSize: "32px",
    fontStyle: "normal",
    fontWeight: "900",
    lineHeight: "32px",
    textTransform: "uppercase",
    padding: "8px 0",
    position: "relative"
})
  , Blur = re$4("img", {
    width: "100%",
    position: "absolute",
    left: 0,
    top: 0
});
function WalletModalContainer({onClose: C}) {
    const [S] = useTonConnectUI()
      , {t: E} = useTranslation();
    return jsxRuntimeExports.jsxs(ModalContainer, {
        children: [jsxRuntimeExports.jsx(ModalTitle, {
            src: E("WalletModalTitle")
        }), jsxRuntimeExports.jsx(CloseButton, {
            onClick: C,
            children: jsxRuntimeExports.jsx("img", {
                src: CloseImage,
                style: {
                    width: "36px",
                    height: "40px"
                }
            })
        }), jsxRuntimeExports.jsx(ModalText, {
            children: E("WalletModalText")
        }), jsxRuntimeExports.jsxs(ButtonContainer, {
            children: [jsxRuntimeExports.jsxs(ModalButton, {
                onClick: C,
                children: [jsxRuntimeExports.jsx(Blur, {
                    src: BlurButton
                }), E("No")]
            }), jsxRuntimeExports.jsxs(ModalButton, {
                style: {
                    background: "linear-gradient(135deg, #C7000C 0%, #FF5C83 100%)"
                },
                onClick: ()=>{
                    S.disconnect(),
                    C == null || C()
                }
                ,
                children: [jsxRuntimeExports.jsx(Blur, {
                    src: BlurButton
                }), E("Yes")]
            })]
        })]
    })
}
function WalletModal({open: C, onClose: S}) {
    return jsxRuntimeExports.jsx(Modal, {
        isOpen: C,
        className: classes$8.mintPopup,
        onClose: S,
        children: jsxRuntimeExports.jsx(WalletModalContainer, {
            onClose: S
        })
    })
}
const Container$1 = re$4("div", {
    borderRadius: "0px 12px 12px 0px",
    border: "1px solid rgba(0, 0, 0, 0.50)",
    background: "linear-gradient(180deg, rgba(0, 0, 0, 0.50) 0%, rgba(0, 0, 0, 0.25) 100%)",
    display: "inline-flex",
    height: "20px",
    padding: "3px 4px 3px 16px",
    justifyContent: "flex-end",
    alignItems: "center",
    flexShrink: "0",
    position: "relative",
    marginLeft: "10px",
    minWidth: "21%",
    marginTop: "8px"
})
  , IconImage = re$4("object", {
    position: "absolute",
    left: "-18px",
    top: "-4px"
})
  , Text = re$4("p", {
    overflow: "hidden",
    color: "#FFF",
    textAlign: "center",
    textOverflow: "ellipsis",
    textShadow: "0px 0px 1px rgba(75, 62, 50, 0.90), 0px 1px 0px #291605",
    WebkitTextStrokeWidth: "0.5px",
    WebkitTextStrokeColor: "#291605",
    fontFamily: "Rubik",
    fontSize: "14px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "14px",
    letterSpacing: "-0.42px",
    marginLeft: "4px"
})
  , ResourceButton = observer(function C({image: S, value: E}) {
    return jsxRuntimeExports.jsxs(Container$1, {
        children: [jsxRuntimeExports.jsx(IconImage, {
            type: "image/svg+xml",
            data: S
        }), jsxRuntimeExports.jsx(Text, {
            children: E
        })]
    })
})
  , HeaderContainer = re$4("header", {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "flex-start",
    width: "100%",
    zIndex: 999
})
  , WalletButton = re$4("button", {
    border: 0,
    background: "transparent",
    cursor: "pointer"
})
  , LanguageButton = re$4("button", {
    border: 0,
    background: "transparent",
    cursor: "pointer"
})
  , ButtonsContainer = re$4("div", {
    display: "flex",
    flexDirection: "column",
    gap: "10px"
})
  , Header = observer(()=>{
    var U, H;
    const C = useTonAddress()
      , {userStore: S, tonUserStore: E, dialogStore: M} = useStores()
      , {i18n: T, t: $} = useTranslation()
      , {isConnected: B, connect: O} = useConnectWallet()
      , F = reactExports.useCallback(()=>{
        M.open({
            Component: WalletModal
        })
    }
    , [M])
      , N = reactExports.useCallback(()=>{
        T && T.changeLanguage(T.language === "en" ? "ch" : "en").catch(Z=>{
            console.log(Z)
        }
        )
    }
    , [T]);
    return jsxRuntimeExports.jsxs(HeaderContainer, {
        children: [jsxRuntimeExports.jsx(ResourceButton, {
            image: GryadkaIcon,
            value: ((U = S == null ? void 0 : S.user) == null ? void 0 : U.fields_amount) ?? "0"
        }), jsxRuntimeExports.jsx(ResourceButton, {
            image: PotatoIcon,
            value: ((H = S == null ? void 0 : S.user) == null ? void 0 : H.potato_amount) ?? "0"
        }), jsxRuntimeExports.jsx(ResourceButton, {
            image: BlueCoinIcon,
            value: C !== "" ? fromDecimals(E.balance.toString(), 9, 2) : "0"
        }), jsxRuntimeExports.jsxs(ButtonsContainer, {
            children: [!B && jsxRuntimeExports.jsx(WalletButton, {
                onClick: ()=>{
                    O()
                }
                ,
                children: jsxRuntimeExports.jsx("img", {
                    src: Wallet,
                    style: {
                        width: "32px",
                        height: "36px"
                    }
                })
            }), B && jsxRuntimeExports.jsx(WalletButton, {
                onClick: ()=>{
                    F()
                }
                ,
                children: jsxRuntimeExports.jsx("img", {
                    src: ActiveWallet,
                    style: {
                        width: "32px",
                        height: "36px"
                    }
                })
            }), jsxRuntimeExports.jsx(LanguageButton, {
                onClick: ()=>{
                    N()
                }
                ,
                children: jsxRuntimeExports.jsx("img", {
                    src: $("LanguageButton"),
                    style: {
                        width: "32px",
                        height: "36px"
                    }
                })
            })]
        })]
    })
}
)
  , InfoIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACQCAMAAAD3NpNiAAAAAXNSR0IArs4c6QAAAGlQTFRFR3BMIyw5////////IDA6ub/Q////7e7yIyw6Iy05////////////////iJWt////JC06hZKnZnSvYG+ii5i1Y3GpXGyaWGmSVGaKj5q8aHW0a3e5gpGibnnAkpzDTl2CeISdw8jVqrHH5qZ6DwAAAA50Uk5TALwgwxrIf/516ZVfYFBYWodAAAAJuklEQVR42sWY0VbjOBBEwzBnBcxsHMfBjkMA2///kStbUq5b3dbyAimJnBl4uNXVLdmw0/r78uiqb5B7fPnzC8yG/nmsvlWPeDDx1Q/o5ded8OgfE/+L8L9dzgjhT/Wj+vdO8es2wL+rg3+rtcapr6+56lz7el/QaX/K1E/jKDB/4P+qkBtrxWaBDxsbgD16n1bm4TS6CjGJjm9OcLPyr8AD26TzkasPa4T1qAfA7Q041V+xAL8G75UKDzkIftj9h2MMaAB8hfea2eBT+LJ+6Am9z/Bh9f2Eg2DgJeMPOgHg8GX5IXcaoNqfVsqACAjAzt9/2OkzAliIS8cf2H7NmkQEf+35o/psAOBn+DVftSD1YLFwGtcRPKYGaH4oXx4/LKQWgE90TCzwlAC7dxyEX3kAg+An/FWMH3RE+MYRZAQWcRhXHYh0RPx+g09LsOUFIOqPCQR6svCRqH9vZ2AErEYA6fOv5w88MxjQRPCRIni5jcBk05k/qs/pIn8ioP5IJgJ68Hi7hnvip/0qAfMAiPKBGx6SOIluV0XV/xe/Pv6wYwxMIOxlR2GBIbgZyPCM4Hr+odfE72U0Hw8s9NGXDSS8Vb9OwG8+8v7fbh+B7wsGiF9aMK8/6gdtPIM4AKUEtAXYcQUL2NC3Px4ilASAfxRnIKAZgJUFjcdBfv8QgO5AOYHarN+4/tIFyDKvX3LAgF8lA6n+QOcJYF6Ams0BBCrppoFSAObbJ3sm8kH2LJF+OQFuYPg4EC420+9xEOEnFcCWAU/O7z/I4CVaHUHosKFvJkD1MgCOXy56sM/pRvwMoJdtAAuifnX6AzWbRUXnAQC7mADzD144KIsU1PzhoJCAx8PHAvTMRL0Sz4SIha3677c9hOkAIvUCouhDWJiYxfALEyl9z95KYBETwP1H+dCH67AWFhYHwKGnBLaH0JNF/xMeEzYeD2sHxglc2JsJRDgHgJVlf430aQy/bDs3TvXgFR1Y48f4byZQE4DMX/Fn1nVa2MhNdbRAAuBv/EICEY5S9OtfRCJ+GCGjsS46oPjeNCCOYIDm85/Kn6oNjSGENIcYIP5yAhuPAPhL+oSv5Px4hgyA0wFkGVAXAB2g/ivl23LTMEQHSJVfNKB//YZP/NsaYwaw4aNCC/ZbJub6mb6yAyJg/L/cAs+6Dm13Xmn5z+f58/MqUMNn1Lla63TuurZtm6jX5eP1eNn3XzHgCx06DxP4RZ7fOdHvz5vk95vMgcf7L6/j6QsJDJBlAHBsA8idz8nA68JvtAVtIHa+8yi/zQCmqmgATTcDgR/oQW99KYHrOcHB+92FBkDAANGs5LrgAANJx9fjsd82cI14lPAzZzQN+IUBFcFr4AsPxy0D+2tAyvwDnwCQS3wMEEHXiRYQwHwethLozABSB076xE9R+naYui4kEOqHP+/jm2lgP+j5IwFVZVnjORpo1ni/g4WTeRPClhO4OKADyCUZ3kgAfEzA62IZGKz+M4J0QMyA1yfziXoSSDqGteikDezNAUgeuATQ6PnRnT0E3gB06g8RKANDDg8JzHwY2kCwZ/wwGqD6YCEZ6JWBhgnEw7KCAWcYCAGZBpyfQjoQx++GP17elYFOBbDQvULKlWmgm2UaiAnQfb/R5U0ZUOOf8P5r00DXBYdjpXTGwJEJSAFcLgUDOCCBbQMtCeTnUIxAwOPAMgA98bFgzcB5ee7PP98y0IgGQN9OAAuB7VUawjmAlhaoGRDnDwclAww/Hhj0rycw+p8wApQ/r3ICko6ByTTQes62Aego8MstYP5wYD0Mz4UW9LcO5NNXmAGaPy9hwMtOoN1IoAkG9AAUW8D56/IIPoFgoNtsgUsjcJT4pDfbQMe6qU09mMwEGMKtDjCAlG8nMAfNBQi/jU1wRgIdLTA7IKYvJfBmJpDgYSMfMhGYQ4gB+wxQP3rTzwLSlw3AQef0RRSkLolXFQDj7+nzMlvAIxB8WERgPQ3zBKYUAM+fedOAQgLQpYXFgcsMBAdck/oIIJG/lzaQpg94Wl7BQetyAx6u3gkdE+g39CP5byWgLIQp9zs66GWhn1FyOk6hAYGu8g8BmAawoOpvUxcYg01NNGAj/suGAeB4WJkoOCjxuf8ZQNMA5Rv1k8Hn3pXwrjfqV/nbBszjJ010XkyixW8SXwZA9ZdNA/CxEOGo3AY3dar+ixB8bYD5JwEsNMJBM5r4tmtV/XSA8jcMIPArNX7Rh6bP7+WpDeWrG1jOf9C7bUDPXwfeb7+YRu9hGl38a33vv0X5r4X5Tw7KCeABA3E1IYUoLu+FTvq8gcJH74UWMPqIADyfVrSY9Wr4RYz2r/FzAjh43zDQcgAkvgnbK/hAAZ7Kt+8/Sd+egVak3+X9j3A+/Y5wqtf3D3T47xsJlOYPGtqmw18czBu+l04gwPEAnvoBzou/wUX8vDVe17+dAMkj0gcvybH3VgIcQPAz3RzC9ALc2gHgAH4DPtDBI1E+FpQBT6X7MgDyXzsAHxyUXn+wEPCWAdX9vHbaD54E5NsP6fsPGhDWdgJ+ha3OHw6gA88c6McfDSglQPkIuso/4dPxe+XhR/6ULxJ4LyUg2VyB4LP4jyQgAtDxJ7ZtAHjWAGR0H7jAk4BVv22AO0DiW3MEwWcTcMEDdOr/cgKMnwlvVvkX7l/y/0oCaOv86frF8RcPQD1/SBpwVVAjH8C6A5EP3roA4Qt8XEUDV00385cWeAIZ1+8l4q0APiLW7aYq6MOcQPj+S+av/v6JA54/4DMLCTvuTulfEQ4aPPErPhL4tTxORzBG7Gk3VFEN+c8bPvnLGdB4+Bd9AO0ZHHaHKmpSTwB1/cIGb72AyPNHALoD1WF3SGE48hd0/eqDicQXdCQegEIuNd4buBIB0ydmALxI/xX8ZgCwzQmoBm/gkNy4gQgKLwD6BgBvBmCoSjrMBuoKB7wBivYLPHSdf6qf8bPuAHcLfTawRICDDE8C6CjylwOIuIAUnwCCgbrCgfH0a1T3iQC0ev8Pq1R/VUcDhxEHUyMD8B8yApX/UV1+HEBDUwXskAwcKuQ+ZADq7gnbSEBasNs/ujUfA0O11vixPwoHCLLGy/qN3k+jwJxXBrgMfk51IO+eD4vq+/AxcDi7n8S7IWKfdw+HJPeD/Bv0Yfd0uKn+KXwN82k2gKYfw2Pg90FoGL8XP9aS93uXhgANp9F9R+VuOg2JwQjs6ME99OQN/H6+A5gO3CkCOkAEdwqACO4yAVEP9+E/B/rdmvAcGkAT7tCA+ziAf0cH8HHw/KP9h3+XSXxg/kQI9yqfEB5+BE/5hoWnb/bwAH7bw9PD83dU/vzwZND/A3saUzcb/LK5AAAAAElFTkSuQmCC"
  , InfoButtonContainer = re$4("button", {
    border: 0,
    background: "transparent",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    paddingTop: "8px",
    width: "64px",
    height: "72px",
    zIndex: 1e3
})
  , InfoButton = observer(function C({openTutorial: S, setOpenTutorial: E}) {
    return jsxRuntimeExports.jsx(InfoButtonContainer, {
        onClick: ()=>E(!S),
        children: jsxRuntimeExports.jsx("img", {
            src: InfoIcon,
            style: {
                width: "64px",
                height: "72px"
            }
        })
    })
})
  , Container = re$4("div", {
    height: "100%",
    width: "100%",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    flexDirection: "column"
})
  , ScrollingImageContainer = re$4("div", {
    width: "100vw",
    height: "100vh",
    overflow: "hidden",
    position: "relative"
})
  , ButtonRow = re$4("div", {
    width: "100%",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: "8px"
})
  , InfoBlockContainer = re$4("div", {
    width: "calc(100vw - 40px)",
    height: "calc((100vw - 40px)/2.765)",
    background: `url(${InfoBackground})`,
    backgroundSize: "cover",
    backgroundPosition: "center",
    padding: "16px",
    zIndex: 1e3
})
  , InfoBlockTitle = re$4("img", {
    width: "calc((100vw - 40px)/2.689)",
    height: "calc(((100vw - 40px)/2.689)/7.25)"
})
  , TimerContainer = re$4("div", {
    borderRadius: "8px",
    width: "calc((100vw - 40px)/2.173)",
    border: "2px solid #FFF",
    background: "rgba(0, 0, 0, 0.50)",
    boxShadow: "0px 0px 2px 1px rgba(0, 0, 0, 0.15) inset",
    height: "32px",
    position: "relative"
})
  , TimerBackground = re$4("div", {
    height: "calc(100% - 2px)",
    borderRadius: "5px",
    background: `
    linear-gradient(10deg, rgba(255, 255, 255, 0.00) 50.05%, rgba(255, 255, 255, 0.30) 92.49%),
    linear-gradient(180deg, rgba(0, 0, 0, 0.00) 50%, rgba(0, 0, 0, 0.05) 100%),
    linear-gradient(279deg, #FFC700 0%, #FF8A00 100%)
  `,
    boxShadow: "0px 0px 2px 1px rgba(0, 0, 0, 0.15)",
    marginTop: "1px",
    marginLeft: "1px"
})
  , TimerText = re$4("div", {
    color: "#FFF",
    textAlign: "center",
    WebkitTextStrokeWidth: "1px",
    WebkitTextStrokeColor: "#572A24",
    fontFamily: "Rubik",
    fontSize: "20px",
    fontStyle: "normal",
    fontWeight: "700",
    lineHeight: "20px",
    letterSpacing: "-0.4px",
    position: "absolute",
    top: "15%",
    width: "calc((100vw - 40px)/2.173)"
})
  , PotatoProfitContainer = re$4("div", {
    borderRadius: "8px",
    border: "1px solid #9C4C30",
    background: "#F9F0E2",
    boxShadow: "0px 6px 0px 0px #9C4C30 inset",
    width: "calc(100%)",
    height: "48px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
})
  , ProfitText = re$4("div", {
    color: "#572A24",
    fontFamily: "Rubik",
    fontSize: "24px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "24px",
    letterSpacing: "-0.96px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    marginTop: "2px"
})
  , ProfitTextBlock = re$4("div", {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    gap: "8px",
    color: "rgba(87, 42, 36, 0.30)",
    fontFamily: "Rubik",
    fontSize: "24px",
    fontStyle: "normal",
    fontWeight: "600",
    lineHeight: "24px",
    letterSpacing: "-0.96px",
    marginLeft: "8px"
})
  , TitleContainer = re$4("div", {
    display: "flex",
    justifyContent: "space-between",
    marginBottom: "8px",
    alignItems: "center"
})
  , ButtonBlock = re$4("div", {
    width: "100%"
});
function calculateWidth(C) {
    const S = Date.now()
      , E = 3 * 60 * 60 * 1e3
      , T = (C - S) / E * 100;
    return Math.max(0, Math.min(T, 100))
}
const GameMainPage = observer(()=>{
    var ae, se, le, de;
    const {dialogStore: C, userStore: S} = useStores()
      , E = useNavigate()
      , {t: M, i18n: T} = useTranslation()
      , $ = DateTime.local().hour
      , B = Q()
      , [O,F] = reactExports.useState(!1)
      , [N,U] = reactExports.useState(calculateWidth(new Date(((ae = S == null ? void 0 : S.user) == null ? void 0 : ae.last_farm_time) ?? "0").getTime() + 1e3 * 3600 * 3))
      , {isConnected: H, connect: Z} = useConnectWallet()
      , J = reactExports.useCallback(()=>{
        if (!H) {
            Z();
            return
        }
        C.open({
            Component: ExchangeModal
        })
    }
    , [H])
      , ie = ()=>{
        E("/market")
    }
    ;
    reactExports.useEffect(()=>{
        var fe;
        U(calculateWidth(new Date(((fe = S == null ? void 0 : S.user) == null ? void 0 : fe.last_farm_time) ?? "0").getTime() + 1e3 * 3600 * 3))
    }
    , [(se = S == null ? void 0 : S.user) == null ? void 0 : se.last_farm_time]);
    const oe = reactExports.useMemo(()=>{
        var fe, pe, ge;
        return (fe = S.user) != null && fe.last_farm_time ? new Date((pe = S.user) == null ? void 0 : pe.last_farm_time).getTime() < date ? date + 1e3 * 3600 * 3 : new Date((ge = S == null ? void 0 : S.user) == null ? void 0 : ge.last_farm_time).getTime() + 1e3 * 3600 * 3 : 0
    }
    , [S == null ? void 0 : S.user]);
    return jsxRuntimeExports.jsx(ScrollingImageContainer, {
        style: {
            height: B.stableHeight,
            background: `url(${$ >= 20 || $ <= 8 ? DarkBackgroundImage : BackgroundImage})`,
            backgroundSize: "cover",
            backgroundPosition: "center"
        },
        children: jsxRuntimeExports.jsxs(PageLayout, {
            className: classes$8.page,
            children: [jsxRuntimeExports.jsxs(Container, {
                children: [jsxRuntimeExports.jsxs("div", {
                    children: [jsxRuntimeExports.jsx(Header, {}), ($ >= 20 || $ <= 8) && jsxRuntimeExports.jsx(Fireflies, {}), jsxRuntimeExports.jsxs(InfoBlockContainer, {
                        children: [jsxRuntimeExports.jsxs(TitleContainer, {
                            children: [jsxRuntimeExports.jsx(InfoBlockTitle, {
                                src: M("HarvestTitle"),
                                style: {
                                    width: `${T.language === "ch" ? "100px" : "calc((100vw - 40px)/2.689)"}`,
                                    height: `${T.language === "ch" ? "20px" : "calc(((100vw - 40px)/2.689)/7.25)"}`
                                }
                            }), jsxRuntimeExports.jsx(TimerContainer, {
                                children: jsxRuntimeExports.jsx(TimerBackground, {
                                    style: {
                                        width: `calc(${N}% - 2px)`
                                    },
                                    children: jsxRuntimeExports.jsx(TimerText, {
                                        children: ((le = S == null ? void 0 : S.user) == null ? void 0 : le.last_farm_time) && S.user.fields_amount > 0 && jsxRuntimeExports.jsx(Countdown, {
                                            intervalDelay: 1e3,
                                            date: DateTime.fromMillis(oe),
                                            renderer: ({total: fe})=>{
                                                const {hours: pe, minutes: ge, seconds: we} = formatDurationToDaysMinutesHours(fe);
                                                return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                                    children: [pe !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                                        children: `${pe < 10 ? "0" + pe : pe} : `
                                                    }), ge !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                                        children: `${ge < 10 ? "0" + ge : ge} : `
                                                    }), we !== void 0 && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                                                        children: `${we < 10 ? "0" + we : we}`
                                                    })]
                                                })
                                            }
                                            ,
                                            onEnd: ()=>{
                                                S.reload()
                                            }
                                        })
                                    })
                                })
                            })]
                        }), jsxRuntimeExports.jsxs(PotatoProfitContainer, {
                            children: [jsxRuntimeExports.jsx(ProfitText, {
                                children: ((de = S.user) == null ? void 0 : de.income) ?? 0
                            }), jsxRuntimeExports.jsxs(ProfitTextBlock, {
                                children: [jsxRuntimeExports.jsx("img", {
                                    src: PotatoToken,
                                    style: {
                                        width: "24px",
                                        height: "24px"
                                    }
                                }), "/ 3 ", M("Hours")]
                            })]
                        })]
                    })]
                }), jsxRuntimeExports.jsxs(ButtonBlock, {
                    children: [jsxRuntimeExports.jsx(GrowButton, {
                        size: "100%",
                        onClick: ()=>{
                            J()
                        }
                    }), jsxRuntimeExports.jsxs(ButtonRow, {
                        children: [jsxRuntimeExports.jsx(InfoButton, {
                            openTutorial: O,
                            setOpenTutorial: F
                        }), jsxRuntimeExports.jsx(MarketButton, {
                            onClick: ie
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx(Tutorial, {
                openTutorial: O,
                setOpenTutorial: F
            })]
        })
    })
}
)
  , App = observer(function C() {
    return jsxRuntimeExports.jsx(TonConnectUiProvider, {
        children: jsxRuntimeExports.jsx(StoreProvider, {
            children: jsxRuntimeExports.jsx(TonUserProvider, {
                children: jsxRuntimeExports.jsx(ConfigProvider, {
                    children: jsxRuntimeExports.jsx(UserProvider, {
                        children: jsxRuntimeExports.jsx(CurrencyProvider, {
                            children: jsxRuntimeExports.jsx(BackendTokenProvider, {
                                children: jsxRuntimeExports.jsx(React$1.Suspense, {
                                    fallback: jsxRuntimeExports.jsx(Preloader, {}),
                                    children: jsxRuntimeExports.jsxs(BrowserRouter, {
                                        children: [jsxRuntimeExports.jsxs(Routes, {
                                            children: [jsxRuntimeExports.jsx(Route, {
                                                path: "/",
                                                element: jsxRuntimeExports.jsx(GameMainPage, {})
                                            }), jsxRuntimeExports.jsx(Route, {
                                                path: "/market",
                                                element: jsxRuntimeExports.jsx(MarketPage, {})
                                            }), jsxRuntimeExports.jsx(Route, {
                                                path: "devPage8642",
                                                element: jsxRuntimeExports.jsx(DevPage, {})
                                            })]
                                        }), jsxRuntimeExports.jsx(DialogProvider, {}), jsxRuntimeExports.jsx(LanguageProvider, {})]
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    })
});
export {App};
